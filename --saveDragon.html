<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - mesh - batch</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">


</head>

<style>
    body {
        background-color: #fff;
        color: #444;
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
    }

    a {
        color: #08f;
    }
</style>

<body>

    <p>https://codesandbox.io/p/sandbox/three-js-instanced-skinned-mesh-2yfgiu?file=%2Findex.html%3A22%2C1</p>
    <script type="importmap">
		{
			"imports": {
				"three": "./three.module.js",
				"three/addons/": "./jsm/"
			}
		}
	</script>

    <script type="module">
        import * as THREE from 'three';

        import Stats from 'three/addons/stats.module.js';
        import { GUI } from 'three/addons/lil-gui.module.min.js';
        import { GLTFLoader } from 'three/addons/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/OrbitControls.js';
        import { radixSort } from 'three/addons/SortUtils.js';
        import { MeshSurfaceSampler } from 'three/addons/MeshSurfaceSampler.js';
        let meshShowTexture, renderTarget, model, stats, gui, guiStatsEl, mixer, mixer1, sampler, meshSamplerInstanced, pointsSkin;
        let camera, controls, scene, renderer;
        let geometries, mesh, material;
        let saveMat, saveGeo, dataColection
        let renderBufferA, renderBufferB, postFXScene, postFXMesh
        const clock = new THREE.Clock();
        //for skined static
        const bindMatrixSTATIC = new THREE.Matrix4();
        bindMatrixSTATIC.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        const bindMatrixInverseSTATIC = new THREE.Matrix4();
        bindMatrixInverseSTATIC.set(0.1139, 0, 0, 0, 0, 0.1139, 0, 0, 0, 0, 0.1139, 0, 0, 34.1586, 0, 1);

        init();

        initMesh();
        animate();

        const vertFinal = `
            precision highp float;
            precision highp int;
      
            uniform mat4 modelMatrix;
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform mat3 normalMatrix;
            uniform vec3 cameraPosition;
            uniform bool isOrthographic;
            attribute vec3 position;
            attribute vec3 normal;
            attribute vec2 uv;
            attribute vec4 skinIndex;
            attribute vec4 skinWeight;
            out vec4 vPos;
            out vec3 vViewPosition;
            out vec3 vNormal;
            uniform mat4 bindMatrix;
            uniform mat4 bindMatrixInverse;
            uniform highp sampler2D boneTexture;
            mat4 getBoneMatrix( const in float i ) {
                int size = textureSize( boneTexture, 0 ).x;
                int j = int( i ) * 4;
                int x = j % size;
                int y = j / size;
                vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
                vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
                vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
                vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
                return mat4( v1, v2, v3, v4 );
            }
            void main() {
                vec3 objectNormal = vec3( normal );
                mat4 boneMatX = getBoneMatrix( skinIndex.x );
                mat4 boneMatY = getBoneMatrix( skinIndex.y );
                mat4 boneMatZ = getBoneMatrix( skinIndex.z );
                mat4 boneMatW = getBoneMatrix( skinIndex.w );
                vec3 transformedNormal = objectNormal;
                transformedNormal = normalMatrix * transformedNormal;
                vec3 transformed = vec3( position );
                vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
                vec4 skinned = vec4( 0.0 );
                skinned += boneMatX * skinVertex * skinWeight.x;
                skinned += boneMatY * skinVertex * skinWeight.y;
                skinned += boneMatZ * skinVertex * skinWeight.z;
                skinned += boneMatW * skinVertex * skinWeight.w;
                transformed = ( bindMatrixInverse * skinned ).xyz;
                vec4 mvPosition = vec4( transformed, 1.0 );
                mvPosition = modelViewMatrix * mvPosition;
                gl_Position = projectionMatrix * mvPosition;
                vViewPosition = - mvPosition.xyz;
                gl_PointSize = 0.01;
                vec4 dc = modelMatrix * vec4(transformed, 1.0);
                vPos = dc;
            }


        `

        function getSkinnedPoints(skinnedMesh) {
            const points = new THREE.Points(skinnedMesh.geometry, skinnedMesh.material);

            points.skeleton = skinnedMesh.skeleton;
            points.bindMatrix = skinnedMesh.bindMatrix;
            points.bindMatrixInverse = skinnedMesh.bindMatrixInverse;
            points.bindMode = skinnedMesh.bindMode;
            points.drawMode = skinnedMesh.drawMode;
            points.name = skinnedMesh.name;
            points.parent = skinnedMesh.parent;
            points.uuid = skinnedMesh.uuid;
            points.type = skinnedMesh.type;

            points.isSkinnedMesh = true;
            points.bind = skinnedMesh.bind;
            points.clone = skinnedMesh.clone;
            points.initBones = skinnedMesh.initBones;
            points.normalizeSkinWeights = skinnedMesh.normalizeSkinWeights;
            points.pose = skinnedMesh.pose;
            points.updateMatrixWorld = skinnedMesh.updateMatrixWorld;

            return points;
        }

        function showTexture(mat, geo) {
            console.log(mat, geo)
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                  vUv = uv;
                }
            `;

            const fragmentShader = `
                varying vec2 vUv;
                uniform sampler2D renderTex;
                void main() {
                vec4 tex = texture2D(renderTex,vUv);
                    gl_FragColor = vec4(tex.xy,1.,1.);
                }
            `;

            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    renderTex: { value: null }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true
            });
            const geometry = new THREE.PlaneGeometry(200, 200, 200, 200);
            const count = 200
            const customAttribute = new Float32Array(count);

            // Fill the custom attribute with random values
            for (let i = 0; i < count; i++) {
                customAttribute[i] = Math.random();
            }

            geometry.setAttribute('customAttribute', new THREE.Float32BufferAttribute(customAttribute, 1));
            meshShowTexture = new THREE.Mesh(geometry, mat);
            meshShowTexture.position.x = 200
            scene.add(meshShowTexture);
        }





        function initMesh() {

            const loader = new GLTFLoader().setPath("models/");
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('/jsm/draco/');
            loader.setDRACOLoader(dracoLoader);
            loader.load('dragon.gltf', async function (gltf) {

                model = gltf.scene;

                let targetObject = null;
                model.traverse(function (child) {
                    if (child.name === "GLTF_created_0") {
                        targetObject = child.children[1]
                        saveMat = targetObject.material
                        saveGeo = targetObject.geometry
                        showTexture(saveMat, saveGeo)
                        child.children[0].visible = false
                        child.children[2].visible = false
                        targetObject = getSkinnedPoints(child.children[1])
                        targetObject.material.onBeforeCompile = (shader) => {
                            shader.uniforms.bindMatrix = { value: bindMatrixSTATIC };
                            shader.uniforms.bindMatrixInverse = { value: bindMatrixInverseSTATIC };
                            shader.vertexShader = `
                            uniform mat4 bindMatrix; 
                               uniform mat4 bindMatrixInverse; 
                               
                        ` + shader.vertexShader;
                            let token = `#define STANDARD`
                            let insert = `\nvarying vec4 vPos;`
                            shader.vertexShader = shader.vertexShader.replace(token, token + insert);

                            token = `#include <fog_vertex>`;
                            insert = `
                                gl_PointSize  = 0.01;
                                vec4 dc = modelMatrix * vec4(transformed, 1.0);
                                vPos = dc;
                            `;
                            shader.vertexShader = shader.vertexShader.replace(token, token + insert);

                            // remove notuse
                            const tokens = [
                                `#include <morphnormal_vertex>`,
                                `#include <skinnormal_vertex>`,
                                `#include <normal_vertex>`,
                                `#include <morphtarget_vertex>`,
                                `#include <displacementmap_vertex>`,
                                `#include <logdepthbuf_vertex>`,
                                `#include <clipping_planes_vertex>`,
                                `#include <worldpos_vertex>`,
                                `#include <shadowmap_vertex>`,
                                `#include <fog_vertex>`,
                                `#include <uv_vertex>`,
                                `#include <color_vertex>`,
                                `#include <morphinstance_vertex>`,
                                `#include <morphcolor_vertex>`,
                                `#include <batching_vertex>`,
                                `#include <common>`,
                                `#include <batching_pars_vertex>`,
                                `#include <uv_pars_vertex>`,
                                `#include <displacementmap_pars_vertex>`,
                                `#include <color_pars_vertex>`,
                                `#include <fog_pars_vertex>`,
                                `#include <morphtarget_pars_vertex>`,
                                `#include <shadowmap_pars_vertex>`,
                                `#include <logdepthbuf_pars_vertex>`,
                                `#include <clipping_planes_pars_vertex>`,
                                `#include <skinning_pars_vertex>`
                            ];

                            tokens.forEach(token => {
                                shader.vertexShader = shader.vertexShader.replace(token, ``);
                            });


                            token = `#include <normal_pars_vertex>`
                            insert = `
                                uniform highp sampler2D boneTexture;

                                mat4 getBoneMatrix( const in float i ) {

                                    int size = textureSize( boneTexture, 0 ).x;
                                    int j = int( i ) * 4;
                                    int x = j % size;
                                    int y = j / size;
                                    vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
                                    vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
                                    vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
                                    vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );

                                    return mat4( v1, v2, v3, v4 );

                                }
                            `
                            shader.vertexShader = shader.vertexShader.replace(token, token + insert);
                            // shader.vertexShader = vertFinal



                            token = `#define STANDARD`
                            insert = `\nvarying vec4 vPos;`
                            shader.fragmentShader = shader.fragmentShader.replace(token, token + insert);

                            token = '#include <dithering_fragment>'
                            insert = `
                                gl_FragColor = vec4(vec3(0.),1.);
                            `
                            shader.fragmentShader = shader.fragmentShader.replace(token, token + insert);

                            shader.fragmentShader = `
                            void main() {
                            gl_FragColor = vec4(vec3(1.,.5,1.),1.);}
                            `
                            console.log(shader.vertexShader)
                        }


                        child.children[1] = targetObject


                    }
                });


                model.position.set(0, -200, 0)
                model.scale.set(120, 120, 120)
                mixer = new THREE.AnimationMixer(model);
                const action = mixer.clipAction(gltf.animations[0]);
                action.play();
                action.paused = false;
                // mixer.setTime(8.)
                // action.paused = true

                scene.add(model)

            });




        }

        function init() {

            const width = window.innerWidth;
            const height = window.innerHeight;

            // camera

            camera = new THREE.OrthographicCamera(
                -width / 2,
                width / 2,
                height / 2,
                -height / 2,
                0.0001,
                100000,
            )
            camera.position.set(700, 700, 700)
            camera.lookAt(new THREE.Vector3(0, 0, 0))
            // renderer

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(0x222222)
            renderer.setClearAlpha(0)
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            document.body.appendChild(renderer.domElement);

            // scene

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            // scene.add(directionalLight);
            // controls

            controls = new OrbitControls(camera, renderer.domElement);
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;

            // stats

            stats = new Stats();
            document.body.appendChild(stats.dom);

            // listeners

            window.addEventListener('resize', onWindowResize);

        }




        function onWindowResize() {

            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);

        }

        function animate() {

            requestAnimationFrame(animate);


            //controls.update();
            stats.update();

            render();

        }


        function render() {
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);



            renderer.render(scene, camera)



        }

    </script>

</body>

</html>