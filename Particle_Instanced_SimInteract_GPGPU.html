<!DOCTYPE html>
<html lang="en">

<head>
    <title>Particle_SimInteract_GPGPU</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">

</head>
<style>
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
    }

    .note {
        position: fixed;
        top: 50px;
        left: 50%;
        width: 100%;
        height: 100px;
        color: rgb(255, 255, 255);
        font-size: .5rem;
        z-index: 99;
    }
</style>

<body>
    <div class="note">

    </div>
    <div id="canvas"></div>
    <script id="viewDf-vert" type="x-shader/x-vertex">
        varying vec2 vUv;

        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>

    <script id="viewGPGPU_Pos-frag" type="x-shader/x-fragment">
        varying vec2 vUv;
        uniform sampler2D tPos;
        void main() {
            vec4 outColor = texture2D( tPos, vUv );
            if(vUv.x < 0.01 || vUv.y < 0.01 || vUv.x > 0.99 || vUv.y > 0.99 ) {
                outColor.xyz = vec3(1.,0.,0.);
            }
            gl_FragColor =  vec4(outColor.xyz,1.);
        }
    </script>
    <script id="viewGPGPU_Vel-frag" type="x-shader/x-fragment">
        varying vec2 vUv;
        uniform sampler2D tVel;
        void main() {
            vec4 outColor = texture2D( tVel, vUv );
            if(vUv.x < 0.01 || vUv.y < 0.01 || vUv.x > 0.99 || vUv.y > 0.99 ) {
                outColor.xyz = vec3(1.,0.,0.);
            }
            gl_FragColor =  vec4(outColor.xyz ,1.);
        }
    </script>
    <script id="viewGPGPU_Extra-frag" type="x-shader/x-fragment">
        varying vec2 vUv;
        uniform sampler2D tExtra;
        void main() {
            vec4 outColor = texture2D( tExtra, vUv );
            if(vUv.x < 0.01 || vUv.y < 0.01 || vUv.x > 0.99 || vUv.y > 0.99 ) {
                outColor.xyz = vec3(1.,0.,0.);
            }
            gl_FragColor =  vec4(outColor.xyz ,1.);
        }
    </script>

    <script id="frag_Pos_GPGPU" type="x-shader/x-fragment">

        uniform float time;
        uniform float delta;
        uniform sampler2D tNormalFont;
        uniform sampler2D tDepthFont;
        uniform sampler2D tNormalBack;
        uniform sampler2D tDepthBack;
        uniform mat4 shadowMatrix0;
        uniform mat4 shadowMatrix1;
        uniform mat4 projInvert0;
        uniform mat4 projInvert1;
        uniform mat4 viewInvert0;
        uniform mat4 viewInvert1;
    
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;  }

        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;  }
        
        vec4 permute(vec4 x) {  return mod289(((x*34.0)+1.0)*x);  }
        
        vec4 taylorInvSqrt(vec4 r) {  return 1.79284291400159 - 0.85373472095314 * r;}
        
        float snoise(vec3 v) { 
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
        
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 =   v - i + dot(i, C.xxx) ;
        
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
        
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
            vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
        
            i = mod289(i); 
            vec4 p = permute( permute( permute( 
                                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
        
            float n_ = 0.142857142857; // 1.0/7.0
            vec3  ns = n_ * D.wyz - D.xzx;
        
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
        
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
        
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
        
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
        
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
        
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
        
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
        
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
        
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                                                        dot(p2,x2), dot(p3,x3) ) );
        }
        
        vec3 snoiseVec3( vec3 x ){
        
            float s  = snoise(vec3( x ));
            float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));
            float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));
            vec3 c = vec3( s , s1 , s2 );
            return c;
        
        }
        
        vec3 curlNoise( vec3 p ){
            
            const float e = .1;
            vec3 dx = vec3( e   , 0.0 , 0.0 );
            vec3 dy = vec3( 0.0 , e   , 0.0 );
            vec3 dz = vec3( 0.0 , 0.0 , e   );
        
            vec3 p_x0 = snoiseVec3( p - dx );
            vec3 p_x1 = snoiseVec3( p + dx );
            vec3 p_y0 = snoiseVec3( p - dy );
            vec3 p_y1 = snoiseVec3( p + dy );
            vec3 p_z0 = snoiseVec3( p - dz );
            vec3 p_z1 = snoiseVec3( p + dz );
        
            float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
            float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
            float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;
        
            const float divisor = 1.0 / ( 2.0 * e );
            return normalize( vec3( x , y , z ) * divisor );
        
        }
      
        vec2 rotate(vec2 v, float a) {
            float s = sin(a);
            float c = cos(a);
            mat2 m = mat2(c, -s, s, c);
            return m * v;
        }
        
        #define PI 3.141592653
        void main()	{

            vec2 uv = gl_FragCoord.xy / resolution.xy;
            vec4 tmpPos = texture2D( texturePosition, uv );
            vec3 posSelf = tmpPos.xyz;
            vec3 velSelf = texture2D( textureVelocity, uv ).xyz;
            vec3 extraSelf = texture2D( textureExtra, uv ).xyz;
       
            float posOffset    = mix(extraSelf.g, 1.0, .9);
            vec3 acc             = curlNoise(posSelf * posOffset + delta);
      
            float life = tmpPos.w;
   
            float maxYSet = 8.;
            float activeOnYSet = 7.;

            if(posSelf.y > maxYSet) {
                posSelf.y = -maxYSet;
                
            }
         
         
        

      
            if (posSelf.y >= activeOnYSet && posSelf.y < maxYSet) {
                life = 1.0 - ((posSelf.y - activeOnYSet) / 2.0);
               

            } else if (posSelf.y >= maxYSet) {
                life = 0.0;
                posSelf.y = -maxYSet;
            } else if (posSelf.y >= -maxYSet && posSelf.y < -activeOnYSet) {
                life = (posSelf.y + maxYSet) / 2.0;
            }
        
            posSelf   += velSelf * 0.2;
            gl_FragColor = vec4(  posSelf, life  );

        }

    </script>

    <script id="frag_Vel_GPGPU" type="x-shader/x-fragment">

        uniform float time;
        uniform float delta;
        uniform vec2 mouse;
        uniform sampler2D tNormalFont;
        uniform sampler2D tDepthFont;
        uniform sampler2D tNormalBack;
        uniform sampler2D tDepthBack;
        uniform mat4 shadowMatrix0;
        uniform mat4 shadowMatrix1;
        uniform mat4 projInvert0;
        uniform mat4 projInvert1;
        uniform mat4 viewInvert0;
        uniform mat4 viewInvert1;
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;  }

        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;  }
        
        vec4 permute(vec4 x) {  return mod289(((x*34.0)+1.0)*x);  }
        
        vec4 taylorInvSqrt(vec4 r) {  return 1.79284291400159 - 0.85373472095314 * r;}
        
        float snoise(vec3 v) { 
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
        
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 =   v - i + dot(i, C.xxx) ;
        
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
        
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
            vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
        
            i = mod289(i); 
            vec4 p = permute( permute( permute( 
                                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
        
            float n_ = 0.142857142857; // 1.0/7.0
            vec3  ns = n_ * D.wyz - D.xzx;
        
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
        
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
        
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
        
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
        
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
        
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
        
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
        
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
        
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                                                        dot(p2,x2), dot(p3,x3) ) );
        }
        
        vec3 snoiseVec3( vec3 x ){
        
            float s  = snoise(vec3( x ));
            float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));
            float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));
            vec3 c = vec3( s , s1 , s2 );
            return c;
        
        }
        
        vec3 curlNoise( vec3 p ){
            
            const float e = .1;
            vec3 dx = vec3( e   , 0.0 , 0.0 );
            vec3 dy = vec3( 0.0 , e   , 0.0 );
            vec3 dz = vec3( 0.0 , 0.0 , e   );
        
            vec3 p_x0 = snoiseVec3( p - dx );
            vec3 p_x1 = snoiseVec3( p + dx );
            vec3 p_y0 = snoiseVec3( p - dy );
            vec3 p_y1 = snoiseVec3( p + dy );
            vec3 p_z0 = snoiseVec3( p - dz );
            vec3 p_z1 = snoiseVec3( p + dz );
        
            float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
            float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
            float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;
        
            const float divisor = 1.0 / ( 2.0 * e );
            return normalize( vec3( x , y , z ) * divisor );
        
        }
        vec2 rotate(vec2 v, float a) {
            float s = sin(a);
            float c = cos(a);
            mat2 m = mat2(c, -s, s, c);
            return m * v;
        }
        
        #define PI 3.141592653
        void main() {
            
            vec2 uv = gl_FragCoord.xy / resolution.xy;

            vec3 posSelf = texture2D( texturePosition, uv ).xyz;
            vec3 velSelf = texture2D( textureVelocity, uv ).xyz;
            vec3 extraSelf = texture2D( textureExtra, uv ).xyz;

              
            float posOffset      = 0.1;
            vec3 acc             = curlNoise(posSelf * posOffset + delta);
           acc.y 				 += 1.0;
            acc.y 				 *= 0.85;
            float speedOffset    = mix(extraSelf.g, 1.0, .9);
       
        
            //	rotation 
            vec2 dir = normalize(posSelf.xz);
            dir      = rotate(dir, PI * 0.75);
            acc.xz   += dir * 0.5;
        
           
            velSelf                  += acc * .01 * speedOffset;

           
            //rand dir

            vec2 dirRand = normalize(extraSelf.xz);
            dirRand      = rotate(dirRand, PI * 0.75);

            float life = 1.;
            float maxYSet = 8.;
            


            // hit 
            float dHit = distance(mouse * 2.,posSelf.xy);
            vec3 normal = normalize(posSelf); // Normal của mặt phẳng
            vec3 reflectedVel = reflect(velSelf, normal);

            if(dHit < .5) velSelf = reflectedVel;



            float dowSpeed = 1.;
            if(time > 7.2) dowSpeed = .72;
            const float decrease = .96;
            velSelf                  *= decrease;
            velSelf *= dowSpeed;

            gl_FragColor = vec4( velSelf,1.);

        }

    </script>

    <script id="frag_Extra_GPGPU" type="x-shader/x-fragment">
        void main() {
            vec2 uv = gl_FragCoord.xy / resolution.xy;
            vec4 extra = texture2D( textureExtra, uv );
            gl_FragColor =  vec4(extra.rgb ,1.);
        }
    </script>


    <!-- main obj -->
    <script id="frag_point" type="x-shader/x-fragment">
        varying vec3 vPos;
        uniform sampler2D texturePoint;
        varying vec2 vUv;
        varying float life;

        #define uMapSize vec2(1024.0)
        #define FOG_DENSITY 0.001
        #define LIGHT_POS vec3(0.0, 10.0, 0.0)


        float rand(vec4 seed4) {
            float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));
            return fract(sin(dot_product) * 43758.5453);
        }


        float PCFShadow(sampler2D depths, vec2 size, vec4 shadowCoord) {
            float result = 0.0;
            float bias = 0.005;
            vec2 uv = shadowCoord.xy;

            for(int x=-1; x<=1; x++){
                for(int y=-1; y<=1; y++){
                    vec2 off = vec2(x,y) + rand(vec4(gl_FragCoord.xy, float(x), float(y)));
                    off /= size;

                    float d = texture2D(depths, uv + off).r;
                    if(d < shadowCoord.z - bias) {
                        result += 1.0;
                    }

                }
            }
            return 1.0 -result/9.0;

        }

        float fogFactorExp2(const float dist, const float density) {
            const float LOG2 = -1.442695;
            float d = density * dist;
            return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);
        }


        float diffuse(vec3 N, vec3 L) {
            return max(dot(N, normalize(L)), 0.0);
        }


        vec3 diffuse(vec3 N, vec3 L, vec3 C) {
            return diffuse(N, L) * C;
        }
        float sdCircle( vec2 p, float r )
        {
            return length(p) - r;
        }
        void main() {
        
            vec2 uv = gl_PointCoord;
            float cc = sdCircle(vec2(uv.x-.5,uv.y-.5),.2);    
            cc = step(cc,.15);
            uv.y = 1.0 - uv.y;
            
            vec4 colorMap = texture2D(texturePoint, uv);
            if(colorMap.r <= 0.0) {
                discard;
            }
            vec3 N = colorMap.rgb * 2.0 - 1.0;


            float d = diffuse(N, LIGHT_POS);
            vec3 finalColor = mix(vec3(d), vPos.xyz, .5);

            vec4 color = vec4(finalColor, 1.0);


            float fogDistance = gl_FragCoord.z / gl_FragCoord.w;
            float fogAmount = fogFactorExp2(fogDistance - 4.5, FOG_DENSITY);
            const vec4 fogColor = vec4(0.0, 0.0, 0.0, 1.0); // white

            vec4 mixOut = mix(color, fogColor, fogAmount);
            gl_FragColor = color;
            gl_FragColor = vec4(vec3(cc) * colorMap.xyz / 0.92,cc);
        }
    </script>
    <script type="importmap">
		{
			"imports": {
				"three": "./three.module.js",
				"three/addons/": "./jsm/"
			}
		}
	</script>

    <script type="module">
        import * as THREE from 'three';

        import Stats from 'three/addons/stats.module.js';
        import { GUI } from 'three/addons/lil-gui.module.min.js';
        import { OBJLoader } from 'three/addons/OBJLoader.js';
        import { DRACOLoader } from 'three/addons/DRACOLoader.js';
        import { GPUComputationRenderer } from 'three/addons/GPUComputationRenderer.js';
        import { OrbitControls } from 'three/addons/OrbitControls.js';
        import { radixSort } from 'three/addons/SortUtils.js';
        //glsl
        import { curl4Noise } from './glsl/curl4Noise.js'

        //MAIN SCENE
        let renderer, controls, stats, cameraMain, sceneDisplay;
        let matCubeInstanced
        //MONITOR
        let sceneMonitor, camMonitor, points, PointMat;
        let viewFBODepth_Mat, viewFboNormal_Mat, viewGPGPU_Pos, viewGPGPU_Vel, viewGPGPU_Extra
        let loaderObjModel

        //UTILS
        let now, last, delta
        let wView = window.innerWidth
        let hView = window.innerHeight
        let ratioView = window.innerWidth / window.innerHeight
        let marginScissor = 2



        //GPGPU
        let gpuCompute
        let widthTexture = 258
        let velocityVariable, positionVariable, extraVariable
        let positionUniforms, velocityUniforms, extraUniforms


        init();
        let mouseX = 0;
        let mouseY = 0;

        window.addEventListener('mousemove', (event) => {
            mouseX =  (event.clientX / wView) * 2 - 1;
            mouseY =  - (event.clientY / hView) * 2 + 1;
        });

        function init() {
            loaderObjModel = new OBJLoader();

            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(wView, hView);
            renderer.setAnimationLoop(animate);
            const canvasDom = document.getElementById("canvas")
            canvasDom.appendChild(renderer.domElement);

            //

            stats = new Stats();
            document.body.appendChild(stats.dom);

            cameraMain = new THREE.PerspectiveCamera(70, wView / hView, 0.01, 400);
            cameraMain.position.z = 10;


            controls = new OrbitControls(cameraMain, renderer.domElement);
            controls.enableDamping = true;


            sceneDisplay = new THREE.Scene();
            sceneDisplay.background = new THREE.Color(0x000000);
            const ambienLight = new THREE.AmbientLight(0x404040, 5); // soft white light
            sceneDisplay.add(ambienLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(-2,0,1)
            sceneDisplay.add(directionalLight)

            const axesHelper = new THREE.AxesHelper(5);
          //  sceneDisplay.add(axesHelper);
            initViewDisplay()
            initComputeRenderer()

            initInstancedMesh()

            if (wView > 568) initViewMonitor()
            onWindowResize();
            window.addEventListener('resize', onWindowResize);



        }

        function initComputeRenderer() {

            gpuCompute = new GPUComputationRenderer(widthTexture, widthTexture, renderer);

            const dtPosition = gpuCompute.createTexture();
            const dtVelocity = gpuCompute.createTexture();
            const dtExtra = gpuCompute.createTexture();

            fillPosTexture(dtPosition);
            fillVelTexture(dtVelocity);
            fillExtraTexture(dtExtra)

            velocityVariable = gpuCompute.addVariable('textureVelocity', document.getElementById('frag_Vel_GPGPU').textContent, dtVelocity);
            positionVariable = gpuCompute.addVariable('texturePosition', document.getElementById('frag_Pos_GPGPU').textContent, dtPosition);
            extraVariable = gpuCompute.addVariable('textureExtra', document.getElementById('frag_Extra_GPGPU').textContent, dtExtra);

            velocityVariable.wrapS = THREE.RepeatWrapping;
            velocityVariable.wrapT = THREE.RepeatWrapping;
            positionVariable.wrapS = THREE.RepeatWrapping;
            positionVariable.wrapT = THREE.RepeatWrapping;
            extraVariable.wrapS = THREE.RepeatWrapping;
            extraVariable.wrapT = THREE.RepeatWrapping;

            gpuCompute.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable, extraVariable]);
            gpuCompute.setVariableDependencies(positionVariable, [positionVariable, velocityVariable, extraVariable]);
            gpuCompute.setVariableDependencies(extraVariable, [positionVariable, velocityVariable, extraVariable]);

            positionUniforms = positionVariable.material.uniforms;
            velocityUniforms = velocityVariable.material.uniforms;
            extraUniforms = extraVariable.material.uniforms;

            positionUniforms['time'] = { value: 0.0 };
            positionUniforms['delta'] = { value: 0.0 };
            velocityUniforms['time'] = { value: 0.0 };
            velocityUniforms['delta'] = { value: 0.0 };
            extraUniforms['time'] = { value: 0.0 };
            extraUniforms['delta'] = { value: 0.0 };

            //mouse
            positionUniforms['mouse'] = { value: new THREE.Vector2(10000,10000) };
            velocityUniforms['mouse'] = { value: new THREE.Vector2(10000,10000) };

            // for fbo depth
            positionUniforms['tDepthFont'] = { value: null };
            positionUniforms['tNormalFont'] = { value: null };
            velocityUniforms['tDepthFont'] = { value: null };
            velocityUniforms['tNormalFont'] = { value: null };

            positionUniforms['tDepthBack'] = { value: null };
            positionUniforms['tNormalBack'] = { value: null };
            velocityUniforms['tDepthBack'] = { value: null };
            velocityUniforms['tNormalBack'] = { value: null };

            positionUniforms['shadowMatrix0'] = { value: new THREE.Matrix4() };
            positionUniforms['projInvert0'] = { value: new THREE.Matrix4() };
            positionUniforms['viewInvert0'] = { value: new THREE.Matrix4() };
            positionUniforms['shadowMatrix1'] = { value: new THREE.Matrix4() };
            positionUniforms['projInvert1'] = { value: new THREE.Matrix4() };
            positionUniforms['viewInvert1'] = { value: new THREE.Matrix4() };

            velocityUniforms['shadowMatrix0'] = { value: new THREE.Matrix4() };
            velocityUniforms['projInvert0'] = { value: new THREE.Matrix4() };
            velocityUniforms['viewInvert0'] = { value: new THREE.Matrix4() };
            velocityUniforms['shadowMatrix1'] = { value: new THREE.Matrix4() };
            velocityUniforms['projInvert1'] = { value: new THREE.Matrix4() };
            velocityUniforms['viewInvert1'] = { value: new THREE.Matrix4() };




            const error = gpuCompute.init();

            if (error !== null) {

                console.error(error);

            }

        }

        function fillPosTexture(texture) {
            const arrT = texture.image.data;
            for (let k = 0, kl = arrT.length; k < kl; k += 4) {
                const x = Math.random() * 2 - 1;
                const y = Math.random() * 2 - 1;
                const z = Math.random() * 2 - 1;
                let vp = new THREE.Vector3(x, y, z)
                vp.multiplyScalar(0.1)
                arrT[k + 0] = vp.x
                arrT[k + 1] = vp.y
                arrT[k + 2] = vp.z
                arrT[k + 3] = 1
            }
        }

        function fillVelTexture(texture) {
            const arrT = texture.image.data;
            for (let k = 0, kl = arrT.length; k < kl; k += 4) {
                const x = Math.random() * 2 - 1;
                const y = Math.random() * 2 - 1;
                const z = Math.random() * 2 - 1;
                let vv = new THREE.Vector3(x, y, z)

                arrT[k + 0] = vv.x
                arrT[k + 1] = vv.y
                arrT[k + 2] = vv.z
                arrT[k + 3] = 1
            }
        }
        function fillExtraTexture(texture) {
            const arrT = texture.image.data;
            for (let k = 0, kl = arrT.length; k < kl; k += 4) {
                const x = Math.random() * 2 - 1;
                const y = Math.random() * 2 - 1;
                const z = Math.random() * 2 - 1;
                arrT[k + 0] = x
                arrT[k + 1] = y
                arrT[k + 2] = z
                arrT[k + 3] = 1
            }
        }

        function initInstancedMesh() {
            const count = 4500;
            const dummy = new THREE.Object3D();
            const sizeCube = {
                x: 0.05,
                y: .5,
                z: 0.05
            }
            const geometry = new THREE.BoxGeometry(sizeCube.x, sizeCube.y, sizeCube.z);
            const textureCube = new THREE.TextureLoader().load('textures/colorMap.jpg');

            const offsets = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {

                offsets[i * 3 + 0] = Math.random() * 2 - 1; // X
                offsets[i * 3 + 1] = Math.random() * 2 - 1; // Y
                offsets[i * 3 + 2] = Math.random() * 2 - 1; // Z
            }


            geometry.setAttribute('offset', new THREE.InstancedBufferAttribute(offsets, 3));

            // matCubeInstanced = new THREE.ShaderMaterial({
            //     vertexShader: `
            //          attribute vec3 offset;
            //     uniform sampler2D tPos_gpu;
            //     uniform sampler2D tVel_gpu;
            //     uniform vec3 sizeCube;
            //     uniform vec2 tSize;
            //        varying vec3 vColor;
            //     varying vec4 vPos;
            //              varying vec2 vUv;
            //     vec2 rotate(vec2 v, float a) {
            //         float s = sin(a);
            //         float c = cos(a);
            //         mat2 m = mat2(c, s, -s, c);
            //         return m * v;
            //     }

            //     mat4 rotationMatrix(vec3 axis, float angle) {
            //         axis = normalize(axis);
            //         float s = sin(angle);
            //         float c = cos(angle);
            //         float oc = 1.0 - c;
                    
            //         return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
            //                     oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
            //                     oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
            //                     0.0,                                0.0,                                0.0,                                1.0);
            //     }

            //     vec3 rotate(vec3 v, vec3 axis, float angle) {
            //         mat4 m = rotationMatrix(axis, angle);
            //         return (m * vec4(v, 1.0)).xyz;
            //     }
                    
            //     #define axisX vec3(0.0, 1.0, 0.0)
                
            //     void main() {
            //         vec3 pos = position * max(.4,abs(offset.x));
                    

            //         vec2 uvT = vec2(
            //             mod(float(gl_InstanceID), tSize.x) / tSize.x, // Tính chỉ số cột
            //             floor(float(gl_InstanceID) / tSize.x) / tSize.y  // Tính chỉ số hàng
            //         );
            //         vec4 posGpu = texture2D(tPos_gpu, uvT);
            //         vec3 velGpu = texture2D(tVel_gpu, uvT).xyz;

            //         vec3 dir = normalize(velGpu);
            //         vec3 axis = cross(dir, axisX);
            //         float angle = acos(dot(dir, axisX));


                
                
            //         pos = rotate(pos, axis, angle);
            //         pos += posGpu.xyz;
                

            //         gl_Position = projectionMatrix * modelViewMatrix * vec4(pos , 1.0);

            //         vPos = vec4(pos,posGpu.w);
            //         vColor = offset;
            //         vUv = uvT;
            //     }
            // `,

            //     fragmentShader: `
            //          varying vec3 vColor;
            //        varying vec4 vPos;
            //                varying vec2 vUv;
            //           uniform sampler2D texturePoint;
            //     void main() {
            //      vec4 colorMap = texture2D(texturePoint, vUv);
            //         gl_FragColor = vec4(colorMap.xyz,1.);
            //     }
            // `,

            //     uniforms: {
            //         time: {
            //             value: 0
            //         },
            //         texturePoint: {
            //             value: textureCube
            //         },
            //         tPos_gpu: {
            //             value: null
            //         },
            //         tVel_gpu: {
            //             value: null
            //         },
            //         tSize: {
            //             value: new THREE.Vector2(widthTexture, widthTexture)
            //         },
            //         sizeCube: {
            //             value: new THREE.Vector3(sizeCube.x, sizeCube.y, sizeCube.z)
            //         }
            //     }
            // });


            const materialChunk = new THREE.MeshPhongMaterial({
                color: 0x595959,
                specular : 0x2c2a2a,
                shininess: 100,
            });
            materialChunk.onBeforeCompile = (shader) => {
                shader.uniforms.time = { value: 0 };
                shader.uniforms.texturePoint = { value: textureCube };
                shader.uniforms.tPos_gpu = { value: null };
                shader.uniforms.tVel_gpu = { value: null };
                shader.uniforms.tSize = { value: new THREE.Vector2(widthTexture, widthTexture) };
                shader.uniforms.sizeCube = { value: new THREE.Vector3(sizeCube.x, sizeCube.y, sizeCube.z) };

                // Sửa đổi vertex shader
                shader.vertexShader = `
                    attribute vec3 offset;
                    uniform sampler2D tPos_gpu;
                    uniform sampler2D tVel_gpu;
                    uniform vec3 sizeCube;
                    uniform vec2 tSize;
                    varying vec3 vColor;
                    varying vec4 vPos;
                          varying vec2 vUv;
                    vec2 rotate(vec2 v, float a) {
                        float s = sin(a);
                        float c = cos(a);
                        mat2 m = mat2(c, s, -s, c);
                        return m * v;
                    }

                    mat4 rotationMatrix(vec3 axis, float angle) {
                        axis = normalize(axis);
                        float s = sin(angle);
                        float c = cos(angle);
                        float oc = 1.0 - c;
                        
                        return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                                    0.0,                                0.0,                                0.0,                                1.0);
                    }

                    vec3 rotate(vec3 v, vec3 axis, float angle) {
                        mat4 m = rotationMatrix(axis, angle);
                        return (m * vec4(v, 1.0)).xyz;
                    }
                        
                    #define axisX vec3(0.0, 1.0, 0.0)
                    ${shader.vertexShader}  // Giữ nguyên phần vertex shader gốc
                `.replace(
                    `#include <fog_vertex>`,
                    `#include <fog_vertex>
                    vec3 pos = position * abs(offset.x);
                    

                    vec2 uvT = vec2(
                        mod(float(gl_InstanceID), tSize.x) / tSize.x, // Tính chỉ số cột
                        floor(float(gl_InstanceID) / tSize.x) / tSize.y  // Tính chỉ số hàng
                    );
                    vec4 posGpu = texture2D(tPos_gpu, uvT);
                    vec3 velGpu = texture2D(tVel_gpu, uvT).xyz;

                    vec3 dirC = normalize(velGpu);
                    vec3 axis = cross(dirC, axisX);
                    float angle = acos(dot(dirC, axisX));


                
                
                    pos = rotate(pos, axis, angle);
                    pos += posGpu.xyz;
                


                

                 
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);

                    vPos = vec4(pos,posGpu.w);
                    vColor = offset;

                `);
        
                // Sửa đổi fragment shader
                shader.fragmentShader = `
             
                    varying vec3 vColor;
                    varying vec4 vPos;
                    varying vec2 vUv;
                    uniform sampler2D texturePoint;
                    ${shader.fragmentShader} // Giữ nguyên phần fragment shader gốc
                `.replace(
                    `#include <dithering_fragment>`,
                    `#include <dithering_fragment>
                    vec4 colorMap = texture2D(texturePoint, vUv);
                    gl_FragColor = vec4( outgoingLight * 12. + vColor / 5.,1.);
                    

                   `);
                   console.log(shader.vertexShader)
                matCubeInstanced = shader;
            };

            const cubeInstanced = new THREE.InstancedMesh(geometry, materialChunk, count);
            for (let i = 0; i < count; i++) {
                dummy.position.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
                dummy.updateMatrix();
                cubeInstanced.setMatrixAt(i, dummy.matrix);
            }

            sceneDisplay.add(cubeInstanced);
        }

        function initViewDisplay() {

            const gridSize = widthTexture; // Số điểm theo mỗi chiều
            const spacing = 1.0 / (gridSize - 1); // Khoảng cách giữa các điểm

            // Tạo dữ liệu điểm cho lưới
            const vertices = [];
            const extra = [];
            const uvs = [];

            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    // Tính toán tọa độ UV cho điểm
                    const u = x * spacing;
                    const v = y * spacing;

                    let posX = u * 2.0 - 1.0;
                    let posY = v * 2.0 - 1.0;
                    let extraX = Math.random() * 2 - 1
                    let extraY = Math.random() * 2 - 1
                    vertices.push(posX * 2., posY * 2., 0);
                    extra.push(extraX, extraY, 0);
                    uvs.push(u, v);
                }
            }
            const PointGeo = new THREE.BufferGeometry();
            const positionAttribute = new THREE.BufferAttribute(new Float32Array(vertices), 3);
            const extraAttribute = new THREE.BufferAttribute(new Float32Array(extra), 3);
            const uvAttribute = new THREE.BufferAttribute(new Float32Array(uvs), 2);
            PointGeo.setAttribute('position', positionAttribute);
            PointGeo.setAttribute('extra', extraAttribute);
            PointGeo.setAttribute('uv', uvAttribute);


            const vertexShader = `
                precision highp float;
                uniform float time;
                attribute vec3 extra;
                uniform sampler2D depthTexture;
                uniform sampler2D tPos_gpu;
                uniform sampler2D tVel_gpu;
                varying vec3 vPos;
                varying vec2 vUv;
                varying float life;
                void main() {
                    vec4 depthData = texture2D(depthTexture,uv).xyzw;
                    vec4 posGpu = texture2D(tPos_gpu,uv).xyzw;
                    //  float zDepth = mix(0.0, 1.0, (depthData.b)/2. );
                    //  pos.z = zDepth ;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(posGpu.xyz, 1.0);
                 gl_Position = projectionMatrix * modelViewMatrix * vec4(posGpu.xyz, 1.0);
                    vPos = extra;
                    vUv = uv;
                    life = posGpu.w;
                    gl_PointSize  = 2.;
                }
            `;

            const fragmentShader = document.getElementById('frag_point').textContent.trim();
            const texture = new THREE.TextureLoader().load('textures/colorMap.jpg');
            PointMat = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,

                depthWrite: false,

                blendSrcAlpha: 1,
                uniforms: {
                    time: {
                        value: 0
                    },
                    texturePoint: {
                        value: texture
                    },
                    tPos_gpu: {
                        value: null
                    },
                    tVel_gpu: {
                        value: null
                    }
                }
            });

            // Tạo điểm từ geometry và material
            points = new THREE.Points(PointGeo, PointMat);

            const vSphere = new THREE.Mesh(new THREE.SphereGeometry(2, 32, 32), new THREE.MeshNormalMaterial({ wireframe: true, transparent: true, opacity: .1 }))
             sceneDisplay.add(points)

            

        }
    
        function initViewMonitor() {
            sceneMonitor = new THREE.Scene();
            sceneMonitor.background = new THREE.Color(0x000000);
            // set cam ortho
            const aspectRatio = 0.3; // vì đã sisscor
            const vZ = 2.
            camMonitor = new THREE.OrthographicCamera(- ratioView * vZ, ratioView * vZ, 1 * vZ, - 1 * vZ, 0, 1);

            viewGPGPU_Pos = new THREE.ShaderMaterial({
                vertexShader: document.querySelector('#viewDf-vert').textContent.trim(),
                fragmentShader: document.querySelector('#viewGPGPU_Pos-frag').textContent.trim(),
                uniforms: {
                    tPos: { value: null }
                }
            });
            viewGPGPU_Vel = new THREE.ShaderMaterial({
                vertexShader: document.querySelector('#viewDf-vert').textContent.trim(),
                fragmentShader: document.querySelector('#viewGPGPU_Vel-frag').textContent.trim(),
                uniforms: {
                    tVel: { value: null }
                }
            });
            viewGPGPU_Extra = new THREE.ShaderMaterial({
                vertexShader: document.querySelector('#viewDf-vert').textContent.trim(),
                fragmentShader: document.querySelector('#viewGPGPU_Extra-frag').textContent.trim(),
                uniforms: {
                    tExtra: { value: null }
                }
            });

            let vMesh3 = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), viewGPGPU_Pos);
            let vMesh4 = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), viewGPGPU_Vel);
            let vMesh5 = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), viewGPGPU_Extra);

            //pass gpu
            vMesh3.position.set(- ratioView * vZ + .72, ratioView * vZ / 3, 0)
            vMesh4.position.set(- ratioView * vZ + .72, 0, 0)
            vMesh5.position.set(- ratioView * vZ + .72, - ratioView * vZ / 3, 0)
            sceneMonitor.add(vMesh3, vMesh4, vMesh5);

        }

        function onWindowResize() {

            const aspect = wView / hView;
            cameraMain.aspect = aspect;
            cameraMain.updateProjectionMatrix();
            const dpr = renderer.getPixelRatio();
            renderer.setSize(wView, hView);

        }
    
        function renderMain() {
    

            if (viewFboNormal_Mat) {
                //Display
                renderer.setScissorTest(true)

                const leftPer = .2
                const leftWidth = wView * leftPer - marginScissor;
                const leftX = 0;

                renderer.setScissor(0, 0, wView, hView);
                renderer.setScissor(0, 0, wView, hView);
                renderer.clear();
                renderer.render(sceneMonitor, camMonitor);

                // Phần bên phải (70%)
                const rightWidth = wView * (1 - leftPer) - marginScissor;
                const rightX = wView * leftPer + marginScissor;

                renderer.setViewport(0, 0, wView, hView);
                renderer.setScissor(0, 0, wView, hView);
                renderer.render(sceneDisplay, cameraMain);
                renderer.setScissorTest(false);
            } else {
                renderer.clear();
                renderer.setViewport(0, 0, wView, hView);
                renderer.render(sceneDisplay, cameraMain);
            }

        }

        function runGPGPU() {

            if (now && delta && last && now > 1000) {
                positionUniforms['time'].value = now/1000;
                positionUniforms['delta'].value = delta;

                velocityUniforms['time'].value = now/1000;
                velocityUniforms['delta'].value = delta;

                positionUniforms['mouse'].value = new THREE.Vector2(mouseX,mouseY)
                velocityUniforms['mouse'].value = new THREE.Vector2(mouseX,mouseY)

       
                // extraUniforms['time'].value = now;
                // extraUniforms['delta'].value = delta;
            }

            gpuCompute.compute();
            const texturePosOut = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
            const textureVelOut = gpuCompute.getCurrentRenderTarget(velocityVariable).texture;
            const textureExtraOut = gpuCompute.getCurrentRenderTarget(extraVariable).texture;
            if (viewGPGPU_Vel) {
                viewGPGPU_Vel.uniforms.tVel.value = textureVelOut
                viewGPGPU_Pos.uniforms.tPos.value = texturePosOut
            
                viewGPGPU_Extra.uniforms.tExtra.value = textureExtraOut
            }

            PointMat.uniforms.tPos_gpu.value = texturePosOut
            if (matCubeInstanced) {
                matCubeInstanced.uniforms.tPos_gpu.value = texturePosOut
                matCubeInstanced.uniforms.tVel_gpu.value = textureVelOut
            }
        }

   

        function animate() {
            now = performance.now();

            delta = (now - last) / 4200;
            // delta = 1/60 
            if (delta > 1) delta = 1; // safety cap on large deltas
            last = now;
            renderer.autoClear = false;
            runGPGPU()

            renderMain()
   
            controls.update();
            stats.update();
        }

    </script>

</body>

</html>