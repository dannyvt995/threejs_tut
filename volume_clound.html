<!DOCTYPE html>
<html lang="en">

<head>
	<title>volume visual</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

</head>
<style>
	body {
		margin: 0;
		overflow: hidden;
	}
</style>

<body>

	<script type="importmap">
            {
                "imports": {
                    "three": "./three.module.js",
                    "three/addons/": "./jsm/"
                }
            }
		</script>
	
	<script type="module">
		import Stats from 'three/addons/stats.module.js';
		import * as THREE from 'three';
		import { OrbitControls } from 'three/addons/OrbitControls.js';
		import { ImprovedNoise } from 'three/addons/ImprovedNoise.js';
		import { OBJLoader } from 'three/addons/OBJLoader.js';
		import { GUI } from 'three/addons/lil-gui.module.min.js';

		let renderer, scene, camera, stats;
		let mesh, texturedd, dataTexture3D,dataTexture3DSample,materialCube
	
		init();
	
		function init() {

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setAnimationLoop(animate);
			document.body.appendChild(renderer.domElement);

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
			camera.position.set(0, 0, 2);

			new OrbitControls(camera, renderer.domElement);

			// Texture
			stats = new Stats();
			document.body.appendChild(stats.dom);


			const textureSDF =new THREE.TextureLoader().load('/models/eisbar/sdf.png')
			let textureSDFData

			

			const size = 81;
			const radius = 5;
			const data = new Uint8Array(size * size * size);
			let i = 0;
			const center = size / 2; 

			for (let z = 0; z < size; z++) {
				for (let y = 0; y < size; y++) {
					for (let x = 0; x < size; x++) {
						// Tính khoảng cách từ (x, y, z) đến trung tâm của hình cầu
						const dx = x - center;
						const dy = y - center;
						const dz = z - center;
						const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

						// Nếu khoảng cách nhỏ hơn hoặc bằng bán kính, gán giá trị
						// if (distance <= radius) {
						// 	data[i] = 255; // Giá trị trong hình cầu
						// } else {
						// 	data[i] = 0;   // Giá trị ngoài hình cầu
						// }
						data[i] = Math.random() * 255;
						i++;
					}
				}
			}
			dataTexture3DSample  = new THREE.Data3DTexture(data,size,size,size);
			dataTexture3DSample.format = THREE.RedFormat;
			dataTexture3DSample.type = THREE.FloatType;
			dataTexture3DSample.minFilter = THREE.LinearFilter;
			dataTexture3DSample.magFilter = THREE.LinearFilter;
			dataTexture3DSample.unpackAlignment = 1;
			dataTexture3DSample.needsUpdate = true;
			
			const img = new Image();
			img.src = '/models/eisbar/sdf.png';
			img.onload = () => {
				const canvas = document.createElement('canvas');
				const context = canvas.getContext('2d');

				// Set canvas dimensions to match the image
				canvas.width = img.width;
				canvas.height = img.height;
				context.drawImage(img, 0, 0);

				// Get image data
				const imageData = context.getImageData(0, 0, img.width, img.height);
				textureSDFData = imageData.data;

				// Assume 128 layers and a 16x8 grid of layers in the image
				const layers = 128;
				const gridX = 16; // Number of layers in x direction
				const gridY = 8;  // Number of layers in y direction
				const layerWidth = img.width / gridX; // Width of each layer
				const layerHeight = img.height / gridY; // Height of each layer
				const layerSize = layerWidth * layerHeight;

				// Initialize 3D data array
				const textureData = new Float32Array(layers * layerSize);

				// Loop through each pixel and organize data into 3D array
				for (let z = 0; z < layers; z++) {
					const sliceXOffset = (z % gridX) * layerWidth;
					const sliceYOffset = Math.floor(z / gridX) * layerHeight;

					for (let y = 0; y < layerHeight; y++) {
						for (let x = 0; x < layerWidth; x++) {
							const sliceX = sliceXOffset + x;
							const sliceY = sliceYOffset + y;
							const pixelIndex = (sliceY * img.width + sliceX) * 4;
							// Here, we assume the SDF value is stored in the red channel
							const sdfValue = textureSDFData[pixelIndex] / 255; // Normalize to [0, 1]
							textureData[z * layerSize + y * layerWidth + x] = sdfValue;
						}
					}
				}


			
				// Create DataTexture3D from textureData
				dataTexture3D = new THREE.Data3DTexture(textureData, layerWidth, layerHeight, layers);
				dataTexture3D.format = THREE.RedFormat;
				dataTexture3D.type = THREE.FloatType;
				dataTexture3D.minFilter = THREE.LinearFilter;
				dataTexture3D.magFilter = THREE.LinearFilter;
				dataTexture3D.unpackAlignment = 1;
				dataTexture3D.needsUpdate = true;

				console.log(textureSDFData)


			const width = 128;
			const height = 128;

			const data2D = new Float32Array( 4 * width * height );

			for (let y = 0; y < height; y++) {
			for (let x = 0; x < width; x++) {
				const index = (y * width + x) * 4; // Tính toán đúng chỉ số của pixel theo x, y
				data2D[index] = textureSDFData[index] / 255;      // Red
				data2D[index + 1] = textureSDFData[index + 1] / 255;  // Green
				data2D[index + 2] = textureSDFData[index + 2] / 255;  // Blue
				data2D[index + 3] = textureSDFData[index + 3] / 255;  // Alpha
			}
			}


			// used the buffer to create a DataTexture
			const texture = new THREE.DataTexture( data2D, width, height, THREE.RGBAFormat, THREE.FloatType);
			texture.needsUpdate = true;
			const meshLayer = new THREE.Mesh(
				new THREE.PlaneGeometry(2,2),
				new THREE.MeshBasicMaterial({map:texture})
			)
			const showSdfTexture = new THREE.Mesh(
				new THREE.PlaneGeometry(1,1),
				new THREE.MeshBasicMaterial({map:textureSDF})
			)
			showSdfTexture.position.z = .5
			scene.add(meshLayer,showSdfTexture)

				
			};

		

			
			const vertexShader = /* glsl */`
					in vec3 position;

					uniform mat4 modelMatrix;
					uniform mat4 modelViewMatrix;
					uniform mat4 projectionMatrix;
					uniform vec3 cameraPos;
	
					out vec3 vOrigin;
					out vec3 vDirection;

				
					void main() {
						vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

						vOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPos, 1.0 ) ).xyz;
						vDirection = position - vOrigin;

						gl_Position = projectionMatrix * mvPosition;
						
					}
				`;

			const fragmentShader = /* glsl */`
					// Fragment Shader
				precision highp float;
				precision highp sampler3D;

				uniform sampler3D map;
				uniform float threshold;
				uniform float steps;
						
				in vec3 vOrigin;
				in vec3 vDirection;

				out vec4 color;
						
				#define epsilon 0.01

				float sample1(vec3 p) {
					return texture(map, p).r;
				}

				vec3 normal(vec3 coord) {
					float step = 0.01;
					float x = sample1(coord + vec3(-step, 0.0, 0.0)) - sample1(coord + vec3(step, 0.0, 0.0));
					float y = sample1(coord + vec3(0.0, -step, 0.0)) - sample1(coord + vec3(0.0, step, 0.0));
					float z = sample1(coord + vec3(0.0, 0.0, -step)) - sample1(coord + vec3(0.0, 0.0, step));
					return normalize(vec3(x, y, z));
				}

				void main() {
					vec3 rayDir = normalize(vDirection);
					vec3 p = vOrigin;
					float tMin = 0.0;
					float tMax = 100.0;
					float delta = (tMax - tMin) / steps;
					color = vec4(0.0);

					for (float t = tMin; t < tMax; t += delta) {
						p = vOrigin + t * rayDir;
						float d = sample1(p);

						if (d < threshold) {
							vec3 n = normal(p);
							color.rgb =n; 
							color.a = 1.0;
							return;
						}
					}

					color.rgb = vec3(1.0, 0.0, 0.0); 
					color.a = 0.0;


				}
				`;

			const geometry = new THREE.BoxGeometry(1, 1, 1);
			 materialCube = new THREE.RawShaderMaterial({
				glslVersion: THREE.GLSL3,
				uniforms: {
					map: { value: dataTexture3DSample },
					cameraPos: { value: new THREE.Vector3() },
					threshold: { value: 0.6 },
					steps: { value: 200 }
				},
				vertexShader,
				fragmentShader,
				side: 2,

			});

			mesh = new THREE.Mesh(geometry, materialCube);
			// scene.add(mesh);

			//

			const parameters = { threshold: 0.6, steps: 200 };

			function update() {

				materialCube.uniforms.threshold.value = parameters.threshold;
				materialCube.uniforms.steps.value = parameters.steps;

			}

			const gui = new GUI();
			gui.add(parameters, 'threshold', 0, 1, 0.01).onChange(update);
			gui.add(parameters, 'steps', 0, 300, 1).onChange(update);

			window.addEventListener('resize', onWindowResize);

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function animate() {
			stats.update();
			materialCube.uniforms.cameraPos.value.copy(camera.position);

			renderer.render(scene, camera);

		}


	</script>

</body>

</html>


<!-- 

	precision highp float;
					precision highp sampler3D;

					uniform mat4 modelViewMatrix;
					uniform mat4 projectionMatrix;

					in vec3 vOrigin;
					in vec3 vDirection;

					out vec4 color;

					uniform sampler3D map;

					uniform float threshold;
					uniform float steps;

					vec2 hitBox( vec3 orig, vec3 dir ) {
						const vec3 box_min = vec3( - 0.5 );
						const vec3 box_max = vec3( 0.5 );
						vec3 inv_dir = 1.0 / dir;
						vec3 tmin_tmp = ( box_min - orig ) * inv_dir;
						vec3 tmax_tmp = ( box_max - orig ) * inv_dir;
						vec3 tmin = min( tmin_tmp, tmax_tmp );
						vec3 tmax = max( tmin_tmp, tmax_tmp );
						float t0 = max( tmin.x, max( tmin.y, tmin.z ) );
						float t1 = min( tmax.x, min( tmax.y, tmax.z ) );
						return vec2( t0, t1 );
					}

					float sample1( vec3 p ) {
						return texture( map, p ).r;
					}

					#define epsilon .0001

					vec3 normal( vec3 coord ) {
						if ( coord.x < epsilon ) return vec3( 1.0, 0.0, 0.0 );
						if ( coord.y < epsilon ) return vec3( 0.0, 1.0, 0.0 );
						if ( coord.z < epsilon ) return vec3( 0.0, 0.0, 1.0 );
						if ( coord.x > 1.0 - epsilon ) return vec3( - 1.0, 0.0, 0.0 );
						if ( coord.y > 1.0 - epsilon ) return vec3( 0.0, - 1.0, 0.0 );
						if ( coord.z > 1.0 - epsilon ) return vec3( 0.0, 0.0, - 1.0 );

						float step = 0.01;
						float x = sample1( coord + vec3( - step, 0.0, 0.0 ) ) - sample1( coord + vec3( step, 0.0, 0.0 ) );
						float y = sample1( coord + vec3( 0.0, - step, 0.0 ) ) - sample1( coord + vec3( 0.0, step, 0.0 ) );
						float z = sample1( coord + vec3( 0.0, 0.0, - step ) ) - sample1( coord + vec3( 0.0, 0.0, step ) );

						return normalize( vec3( x, y, z ) );
					}

					void main(){

						vec3 rayDir = normalize( vDirection );
						vec2 bounds = hitBox( vOrigin, rayDir );

						if ( bounds.x > bounds.y ) discard;

						bounds.x = max( bounds.x, 0.0 );

						vec3 p = vOrigin + bounds.x * rayDir;
						vec3 inc = 1.0 / abs( rayDir );
						float delta = min( inc.x, min( inc.y, inc.z ) );
						delta /= steps;

						for ( float t = bounds.x; t < bounds.y; t += delta ) {

							float d = sample1( p + 0.5 );

							if ( d > threshold ) {

								color.rgb = normal( p + 0.5 ) * 0.5 + ( p * 1.5 + 0.25 );
								color.a = 1.;
								break;

							}

							p += rayDir * delta;

						}

						if ( color.a == 0.0 ) color.rgb = vec3(1.,0.,0.);
					
					}
-->