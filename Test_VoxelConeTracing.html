<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test_VoxelConeTracing</title>
</head>
<style>
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: black;
    }

    .monitor {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 9999;
    }

    .monitor button {
        padding: 1rem 2rem;
    }
</style>

<body>

</body>
<div id="canvas"></div>
<div class="monitor">
    <button id="stop">stop delta</button>
    <button id="start">start</button>
</div>
<script type="importmap">
        {
            "imports": {
                "three": "./three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>


<script id="frag_Pos_GPGPU" type="x-shader/x-fragment">

        uniform float time;
        uniform float delta;
        uniform float forceMouse;
        uniform sampler2D fuildMap;
        uniform vec2 sizeView;
        uniform bool stopDelta;
        uniform bool start;


        vec2 rotate(vec2 v, float a) {
            float s = sin(a);
            float c = cos(a);
            mat2 m = mat2(c, -s, s, c);
            return m * v;
        }
        


        float rand(float seed) {
            return fract(sin(seed) * 43758.5453123);
        }
        float randomInRange(float seed) {
            return rand(seed) * 0.6 - 0.3;
        }
        #define PI 3.141592653
        void main()	{

            vec2 uv = gl_FragCoord.xy / resolution.xy;
            vec4 tmpPos = texture2D( texturePosition, uv );
            vec3 posSelf = tmpPos.xyz;
            vec3 velSelf = texture2D( textureVelocity, uv ).xyz;
            vec3 extraSelf = texture2D( textureExtra, uv ).xyz;
            

            float life = tmpPos.w;

        
            float decreaseVel = 0.05;
            if(stopDelta) decreaseVel = 0.;
            posSelf   += velSelf * decreaseVel;
           

         
         vec2 uvPos = vec2(
            posSelf.x / sizeView.x + 0.5,
            posSelf.y / sizeView.y + 0.5
         );
         vec2 velFuild = texture2D(fuildMap,uvPos).xy;


   //posSelf += vec3(velFuild,posSelf.z)  * 1.5;
    

        vec3 rr1 =  vec3(randomInRange(sizeView.x),randomInRange(sizeView.y),0.);
    
        vec3 rr2 =  vec3(randomInRange(sizeView.x),-randomInRange(sizeView.y),0.);

         if(posSelf.y > sizeView.y) {

            //posSelf = rr2;
            posSelf.y = -sizeView.y / 2.;

            }else if(posSelf.y < -sizeView.y) {

               // posSelf = rr1;
                posSelf.y *=  -1.;
            }

            if(posSelf.x > sizeView.x) {

                //posSelf = rr2;
                posSelf.x = -sizeView.x / 2.;
                }else if(posSelf.x < -sizeView.y) {

                    //posSelf = rr1;
                    posSelf.x *= -1.;
                }


                if(posSelf.z > sizeView.y) {

                  //  posSelf = rr2;
                  posSelf.z = -sizeView.y / 2.;

                    }else if(posSelf.z < -sizeView.y) {

                      //  posSelf = rr1;
                      posSelf.z *= -1.;

                    }

                
                   
             if(!start) posSelf = tmpPos.xyz;

                    
            gl_FragColor = vec4(  posSelf , 1.  );

        }

    </script>

<script id="frag_Vel_GPGPU" type="x-shader/x-fragment">

        uniform float time;
        uniform float delta;
        uniform vec2 mouse;
        uniform bool stopDelta;
        uniform bool start;
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;  }

        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;  }
        
        vec4 permute(vec4 x) {  return mod289(((x*34.0)+1.0)*x);  }
        
        vec4 taylorInvSqrt(vec4 r) {  return 1.79284291400159 - 0.85373472095314 * r;}
        
        float snoise(vec3 v) { 
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
        
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 =   v - i + dot(i, C.xxx) ;
        
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
        
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
            vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
        
            i = mod289(i); 
            vec4 p = permute( permute( permute( 
                                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
        
            float n_ = 0.142857142857; // 1.0/7.0
            vec3  ns = n_ * D.wyz - D.xzx;
        
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
        
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
        
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
        
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
        
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
        
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
        
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
        
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
        
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                                                        dot(p2,x2), dot(p3,x3) ) );
        }
        
        vec3 snoiseVec3( vec3 x ){
        
            float s  = snoise(vec3( x ));
            float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));
            float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));
            vec3 c = vec3( s , s1 , s2 );
            return c;
        
        }
        
        vec3 curlNoise( vec3 p ){
            
            const float e = .1;
            vec3 dx = vec3( e   , 0.0 , 0.0 );
            vec3 dy = vec3( 0.0 , e   , 0.0 );
            vec3 dz = vec3( 0.0 , 0.0 , e   );
        
            vec3 p_x0 = snoiseVec3( p - dx );
            vec3 p_x1 = snoiseVec3( p + dx );
            vec3 p_y0 = snoiseVec3( p - dy );
            vec3 p_y1 = snoiseVec3( p + dy );
            vec3 p_z0 = snoiseVec3( p - dz );
            vec3 p_z1 = snoiseVec3( p + dz );
        
            float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
            float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
            float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;
        
            const float divisor = 1.0 / ( 2.0 * e );
            return normalize( vec3( x , y , z ) * divisor );
        
        }
        vec2 rotate(vec2 v, float a) {
            float s = sin(a);
            float c = cos(a);
            mat2 m = mat2(c, -s, s, c);
            return m * v;
        }

        float random (vec2 st) {
            return fract(sin(dot(st.xy,
                                 vec2(12.9898,78.233)))*
                43758.5453123);
        }


        #define PI 3.141592653
        void main() {
            
            vec2 uv = gl_FragCoord.xy / resolution.xy;

            vec3 posSelf = texture2D( texturePosition, uv ).xyz;
            vec3 velSelf = texture2D( textureVelocity, uv ).xyz;
            vec3 pvelSelf = velSelf;
            vec3 extraSelf = texture2D( textureExtra, uv ).xyz;

              
            float posOffset    = mix(posSelf.b, 1.0, .1);
            vec3 acc             = curlNoise(posSelf * posOffset + delta * 0.5);
            acc.y 				 += .5 ;
            acc.y 				 *= 0.5;
            
            float speedOffset    = mix(extraSelf.g, 1.0, .9);
       
        
            //	rotation 
            vec2 dir = normalize(posSelf.xz);
            dir      = rotate(dir, PI * 0.62 );
            float rr = 0.4;
            acc.xz   += dir * rr; // > 4 to have tornal
        
           
            velSelf                  += acc * .005 * speedOffset;

            float decrease = .96;
            if(stopDelta) decrease = 0.;
            velSelf                  *= decrease;
            
            if(!start) velSelf = pvelSelf;

                        
            gl_FragColor = vec4( velSelf,1.);

        }

    </script>
<script id="frag_Extra_GPGPU" type="x-shader/x-fragment">
        void main() {
            vec2 uv = gl_FragCoord.xy / resolution.xy;
            vec4 extra = texture2D( textureExtra, uv );
            gl_FragColor =  vec4(extra.rgb ,1.);
        }
    </script>
<script type="module">
    import * as THREE from "three";

    import Renderer from "./fuild/modules_curlNoise/Renderer.js";
    import Simulation from "./fuild/modules_curlNoise/Simulation.js";
    import Mouse from "./fuild/modules_curlNoise/Mouse.js";
    import { calcSizeFitCamPerspective } from './utils/calcSizeFitCamPerspective.js'
    import { GPUComputationRenderer } from 'three/addons/GPUComputationRenderer.js';
    import { OrbitControls } from 'three/addons/OrbitControls.js';
    import Stats from 'three/addons/stats.module.js';
    import { GUI } from 'three/addons/lil-gui.module.min.js';
    import { curl4Noise } from './glsl/curl4Noise.js'

    let controlsMain
    //GPGPU
    let gpuCompute
    let widthTexture = 20
    let velocityVariable, positionVariable, extraVariable
    let positionUniforms, velocityUniforms, extraUniforms

    let now, last, delta
    let wView = window.innerWidth
    let hView = window.innerHeight
    let ratioView = window.innerWidth / window.innerHeight

  
    let texture3dSample, dataArray
    let PointMat;
    let meshCheck
    let meshCheck2
    let stats
    let PointMat2

    let shaderInstancedSample,chunk,instancedMesh,points
    //fbo save
    let sceneFbo, cameraFbo
    let renderTarget2DOut
    let renderTarget2DOutOrigin


    // write 3d
    let computeMaterial, computeMesh, rendertarget3D
    const SIMPLE_VERTEX = `

    varying vec2 vUv;

    void main() {
        vUv = uv;
        gl_Position = vec4(position, 1.0);
    }`;
    const COMPUTE_FRAGMENT = `
    varying vec2 vUv;
    uniform sampler2D sample2DSetter;
    uniform float sizeVol;
    uniform float uZCoord;
    uniform float uLod;
    void main() {
    
     float sliceSize = 1.0 / sqrt(sizeVol); // Tỉ lệ của một lớp trên texture2D
        
        // Tọa độ lớp 2D dựa vào uZCoord
        float zLayer = floor(uZCoord * sizeVol); 
        float col = mod(zLayer, sqrt(sizeVol)); // Cột trong grid 2D
        float row = floor(zLayer / sqrt(sizeVol)); // Hàng trong grid 2D

        // Tọa độ lấy mẫu trong sample2DSetter
        vec2 layerOffset = vec2(col, row) * sliceSize;
        vec2 uvInLayer = vec2(vUv.x,vUv.y) * sliceSize;
        vec2 sampleUV = layerOffset + uvInLayer;

        // Lấy mẫu từ sample2DSetter
        vec3 textureSample = textureLod(sample2DSetter, sampleUV,uLod).xyz;

        gl_FragColor = vec4(textureSample,1.);
    }`;

    const sizeDisplayView = 2
    const parameters = {
            pointSize:2,
            sizeVol: 36, lod: 3,lodOn3D: 0 , uLodOn3D: 0, toggle: false,displaySample:true,displayParticel:false,
            rangeForLight : 1,
            applyChanges: () => {
                localStorage.setItem("sizeVol2D", `${parameters.sizeVol}`);
                window.location.reload(); // Tải lại trang sau khi nhấn nút
            }

        };

    localStorage.setItem("sizeVol2D","16")

    const getLocalPara1 = localStorage.getItem("sizeVol2D")
   
    const sizeVol2D = getLocalPara1 ? Number(getLocalPara1) : parameters.sizeVol
    function initComputeRenderer(renderer) {

        gpuCompute = new GPUComputationRenderer(widthTexture, widthTexture, renderer);

        const dtPosition = gpuCompute.createTexture();
        const dtVelocity = gpuCompute.createTexture();
        const dtExtra = gpuCompute.createTexture();

        fillPosTexture(dtPosition);
        fillVelTexture(dtVelocity);
        fillExtraTexture(dtExtra)

        velocityVariable = gpuCompute.addVariable('textureVelocity', document.getElementById('frag_Vel_GPGPU').textContent, dtVelocity);
        positionVariable = gpuCompute.addVariable('texturePosition', document.getElementById('frag_Pos_GPGPU').textContent, dtPosition);
        extraVariable = gpuCompute.addVariable('textureExtra', document.getElementById('frag_Extra_GPGPU').textContent, dtExtra);

        velocityVariable.wrapS = THREE.RepeatWrapping;
        velocityVariable.wrapT = THREE.RepeatWrapping;
        positionVariable.wrapS = THREE.RepeatWrapping;
        positionVariable.wrapT = THREE.RepeatWrapping;
        extraVariable.wrapS = THREE.RepeatWrapping;
        extraVariable.wrapT = THREE.RepeatWrapping;

        gpuCompute.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable, extraVariable]);
        gpuCompute.setVariableDependencies(positionVariable, [positionVariable, velocityVariable, extraVariable]);
        gpuCompute.setVariableDependencies(extraVariable, [positionVariable, velocityVariable, extraVariable]);

        positionUniforms = positionVariable.material.uniforms;
        velocityUniforms = velocityVariable.material.uniforms;
        extraUniforms = extraVariable.material.uniforms;

        positionUniforms['time'] = { value: 0.0 };
        positionUniforms['sizeView'] = { value: new THREE.Vector2(1, 1) };




        positionUniforms['delta'] = { value: 0.0 };
        velocityUniforms['time'] = { value: 0.0 };
        velocityUniforms['delta'] = { value: 0.0 };
        extraUniforms['time'] = { value: 0.0 };
        extraUniforms['delta'] = { value: 0.0 };
        positionUniforms['fuildMap'] = { value: null }
        velocityUniforms['fuildMap'] = { value: null }

        positionUniforms['start'] = { value: false }
        velocityUniforms['start'] = { value: false };
        positionUniforms['stopDelta'] = { value: false }
        velocityUniforms['stopDelta'] = { value: false };


        positionUniforms['forceMouse'] = { value: 0.0 };
        positionUniforms['projectionMatrix'] = { value: new THREE.Matrix4() };
        positionUniforms['viewMatrix'] = { value: new THREE.Matrix4() };
        const error = gpuCompute.init();

        if (error !== null) {

            console.error(error);

        }

    }

    function fillPosTexture(texture) {
        const arrT = texture.image.data;
        for (let k = 0, kl = arrT.length; k < kl; k += 4) {
            const x = Math.random() * 2 - 1;
            const y = Math.random() * 2 - 1;
            const z = Math.random() * 2 - 1;
            let vp = new THREE.Vector3(x, y, z)
            vp.multiplyScalar(.1)
            arrT[k + 0] = vp.x
            arrT[k + 1] = vp.y
            arrT[k + 2] = vp.z
            arrT[k + 3] = 1
        }
    }

    function fillVelTexture(texture) {
        const arrT = texture.image.data;
        for (let k = 0, kl = arrT.length; k < kl; k += 4) {
            const x = Math.random() * 2 - 1;
            const y = Math.random() * 2 - 1;
            const z = Math.random() * 2 - 1;
            let vv = new THREE.Vector3(x, y, z)

            arrT[k + 0] = vv.x
            arrT[k + 1] = vv.y
            arrT[k + 2] = vv.z
            arrT[k + 3] = 1
        }
    }
    function fillExtraTexture(texture) {
        const arrT = texture.image.data;
        for (let k = 0, kl = arrT.length; k < kl; k += 4) {
            const x = Math.random() * 2 - 1;
            const y = Math.random() * 2 - 1;
            const z = Math.random() * 2 - 1;
            arrT[k + 0] = x
            arrT[k + 1] = y
            arrT[k + 2] = z
            arrT[k + 3] = 1
        }
    }

    Renderer.init();
    Mouse.init();

    const buttonStop = document.getElementById("stop")
    const buttonStart = document.getElementById("start")
    buttonStop.onclick = () => {
        velocityUniforms['stopDelta'].value = !velocityUniforms['stopDelta'].value;
        positionUniforms['stopDelta'].value = !positionUniforms['stopDelta'].value;
    };
    buttonStart.onclick = () => {
        velocityUniforms['start'].value = !velocityUniforms['start'].value;
        positionUniforms['start'].value = !positionUniforms['start'].value;
    };
    initComputeRenderer(Renderer.renderer)

    const width = window.innerWidth
    const height = window.innerHeight
    const scene = new THREE.Scene();
    const sceneGenTexture = new THREE.Scene();

    scene.background = 0x000000
    const light = new THREE.AmbientLight(0x404040); // soft white light
    scene.add(light);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
    directionalLight.position.set(0,0,1)
   // scene.add(directionalLight);
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);
   //sceneGenTexture.add(axesHelper);
    const cameraGenTexture = new THREE.OrthographicCamera(- 2, 2, 2 * (height / width), - 2 * (height / width), 0., 1000);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.00001, 1000); // 

    camera.position.z = 2

    controlsMain = new OrbitControls(camera, Renderer.renderer.domElement);
    //controlsMain.enableRotate = false
    const [widthFit, heightFit] = calcSizeFitCamPerspective(camera)



    const simulation = new Simulation({
        options: {
            iterations_poisson: 1,
            iterations_viscous: 32,
            mouse_force: 10,
            resolution: 0.3,
            cursor_size: 20,
            viscous: 30,
            isBounce: false,
            dt: 0.9,
            isViscous: false,
            BFECC: false
        }
    });

    const textureImg = new THREE.TextureLoader().load('textures/cat.jpg');
    stats = new Stats();
    document.body.appendChild(stats.dom);




    //config shader
    const rangeX = .01
    const sizePointCommon = `
        if(extra.x < ${rangeX}) {
            if(mvPosition.z > 0.) {
                gl_PointSize = 20. ;
            }else{
                gl_PointSize = 20.;
            }
           
        }else{
            gl_PointSize = 15. * (1.-distance(posgpu / 2.,vec3(0.)));
            if(mvPosition.z > 0.) {
                gl_PointSize = 10.  * ( mvPosition.z);
            }else{
                gl_PointSize = 10.;
            }
        }
    
    `
    const fragmentShaderPoint = `
                varying vec3 vExtra;
                varying vec3 vPos;
                varying vec2 vFuild;
                varying vec2 vUv;
       
                void main() {
                   float dist = length(gl_PointCoord - vec2(0.5));
                    if (dist > 0.5) discard;
                   // gl_FragColor = vec4(vec3(1.-dist) * vec3(vUv,1.) * (1.-distance(vPos,vec3(0.))), 1.);
                   if(vExtra.x < ${rangeX}) {
                        gl_FragColor = vec4(vec3(1.-dist) * vec3(1.,0.,0.)  ,1.);
                   }else{
                        gl_FragColor = vec4(vec3(step(.5,1.-dist)  *  vec3(.8))  ,1.);
                   }
                  
                }
            `








    initData3d()
    initFbo()
    initPoint()
    initMeshCheck()

    initGui()
    initCubeSample()

    initUpdate3D()

    function initUpdate3D() {
        
        rendertarget3D = new THREE.WebGL3DRenderTarget(sizeVol2D, sizeVol2D, sizeVol2D);
        rendertarget3D.depthBuffer = false;
        console.log(rendertarget3D.texture)
        rendertarget3D.texture.generateMipmaps = true
        rendertarget3D.texture.minFilter =  THREE.NearestMipmapLinearFilter,
        rendertarget3D.texture.magFilter =  THREE.NearestFilter,

        computeMaterial = new THREE.ShaderMaterial({
      
            vertexShader: SIMPLE_VERTEX,
            fragmentShader: COMPUTE_FRAGMENT,
            uniforms: {
                uZCoord: { value: 0.0 },
                sizeVol: { value: sizeVol2D },
                sample2DSetter: {value:null},
                uLod: {value:parameters.lod},
            },
            depthTest: false,
        });
        computeMaterial.type = "VolumeShaderWrite";
        computeMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), computeMaterial);

    }

    function initCubeSample() {
        const dummy = new THREE.Object3D();

        const countInstanced = sizeVol2D ** 3 
        const spacing = 1 / sizeVol2D;
        const halfSize = (sizeVol2D - 1) / 2;
        const groupBox = new THREE.Group()
        const mr = spacing - 0.01 * 0.0
        let geometry = new THREE.BoxGeometry(mr, mr, mr);
       // geometry = new THREE.SphereGeometry(mr * 0.5, 16, 16);
        console.log(texture3dSample.source.data.data)
      //  shaderInstancedSample.uniforms.uTexture3DSample.value = texture3dSample
        shaderInstancedSample  = new THREE.MeshPhongMaterial({
            color:0x22018f,
            transparent:true,
            
        })
        shaderInstancedSample.onBeforeCompile = (shader) => {
            shader.uniforms.uTexture2D = { value: null };
            shader.uniforms.uSizeVol2D = { value: Math.sqrt(sizeVol2D) };
            shader.uniforms.uLodOn3D = { value: parameters.lodOn3D };
            shader.uniforms.uTexture3DSample = {value:null}
            shader.uniforms.rangeForLight = { value: parameters.rangeForLight };
            
            shader.vertexShader = `
                attribute vec3 randomOffset;
                varying vec3 vRandomOffset;
                attribute vec3 dummyOffset;
                varying vec3 dumOff;
                varying vec3 vPos;
                varying vec2 vUv;
                varying float idd;
                uniform float uSizeVol2D;
                ${shader.vertexShader} 
            `.replace(
                `#include <fog_vertex>`,
                `#include <fog_vertex>
                    vRandomOffset = randomOffset;

                    // Tính toán vị trí của từng instance dựa trên instanceMatrix
                    vPos = position;
                    vUv = uv;
                    idd = float(gl_InstanceID);
                    dumOff = dummyOffset;
                    vec4 modelPosition = instanceMatrix * vec4(dummyOffset  * 0.+ position, 1.0);
                    gl_Position = projectionMatrix * modelViewMatrix * modelPosition;

                `
            )


            shader.fragmentShader = `
                varying vec3 dumOff;
                varying vec3 vRandomOffset;
                varying vec3 vPos;
                varying vec2 vUv;
                varying float idd;
                uniform float uSizeVol2D;
                uniform float uLodOn3D;
                uniform sampler3D uTexture3DSample;
                uniform sampler2D uTexture2D;
                uniform float rangeForLight;
                
                vec2 computeSliceOffsetOrigin(float slice, float slicesPerRow, vec2 sliceSize) {
                        return sliceSize * vec2(mod(slice, slicesPerRow), 
                                        floor(slice / slicesPerRow));
                }

                vec4 sampleAs3DTextureOrigin(
                    sampler2D tex, vec3 texCoord, float size, float numRows, float slicesPerRow,float lod) {
                    float slice   = texCoord.z * size;
                    float sliceZ  = floor(slice);                         // slice we need
                    float zOffset = fract(slice);                         // dist between slices

                    vec2 sliceSize = vec2(1.0 / slicesPerRow,             // u space of 1 slice
                                            1.0 / numRows);                 // v space of 1 slice

                    vec2 slice0Offset = computeSliceOffsetOrigin(sliceZ, slicesPerRow, sliceSize);
                    vec2 slice1Offset = computeSliceOffsetOrigin(sliceZ + 1.0, slicesPerRow, sliceSize);

                    vec2 slicePixelSize = sliceSize / size;               // space of 1 pixel
                    vec2 sliceInnerSize = slicePixelSize * (size - 1.0);  // space of size pixels

                    vec2 uv = slicePixelSize * 0.5 + texCoord.xy * sliceInnerSize;
                
                    vec4 slice0Color = texture2D(tex, slice0Offset + uv);
                    vec4 slice1Color = texture2D(tex, slice1Offset + uv);

                    slice0Color = textureLod(tex, slice0Offset + uv,lod);
                    slice1Color = textureLod(tex, slice1Offset + uv,lod);


                    return mix(slice0Color, slice1Color, zOffset);
                    //return slice0Color;
                }
                ${shader.fragmentShader} 
            `.replace(`#include <dithering_fragment>`,`
                    #include <dithering_fragment>

                        float u_sdfVoxelSize = uSizeVol2D*uSizeVol2D;
                        vec3 voxelTextureCoordOri = vPos  + vec3(.5,.5,.5) * 0. ;
                        vec3 voxelTextureCoord = clamp(voxelTextureCoordOri, vec3(0.5 / u_sdfVoxelSize), vec3(1.0 - 0.5 / u_sdfVoxelSize));
                    
                        float ads = uSizeVol2D;
                    
                        vec4 distanceInfo = sampleAs3DTextureOrigin(uTexture2D,vec3(dumOff.xy,dumOff.z), uSizeVol2D * uSizeVol2D,uSizeVol2D,uSizeVol2D,uLodOn3D);
                
                     //  gl_FragColor += vec4(distanceInfo.xyz * .8, 1.);
                    
                    //   gl_FragColor = vec4(0.);
                        vec3 getValFrom3d = texture(uTexture3DSample,dumOff).rgb;
                        
                       getValFrom3d = textureLod(uTexture3DSample,dumOff ,uLodOn3D).rgb;

                 
                        if(getValFrom3d.x < rangeForLight) {
                            gl_FragColor.xy *=vUv * .5;
                            gl_FragColor.xyz = getValFrom3d;
                            gl_FragColor.z = 0.9;
                         
                        }else{
                            discard;
                        }
                    



                 
                    

            `)
          //  console.log(shader.fragmentShader)
            chunk = shader
        }
       instancedMesh = new THREE.InstancedMesh(geometry, shaderInstancedSample, countInstanced);


        const randomValues = new Float32Array(countInstanced * 3);

        for (let i = 0; i < sizeVol2D ** 3; i++) {
            randomValues[i * 3] = Math.random() < 0.9 ? 0 : 1;
            randomValues[i * 3 + 1] = 0;
            randomValues[i * 3 + 2] = 0;
        }

        instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        instancedMesh.geometry.setAttribute('randomOffset', new THREE.InstancedBufferAttribute(randomValues, 3));

        const dummyOffsetArray = new Float32Array(sizeVol2D ** 3 * 3); // vec3 cho mỗi instance
        let index2 = 0;
        let totalLopp = sizeVol2D
        for (let x2 = 0; x2 < totalLopp; x2++) {
            for (let y2 = 0; y2 < totalLopp; y2++) {
                for (let z2 = 0; z2 < totalLopp; z2++) {
                    // Tạo giá trị ngẫu nhiên cho offset (chỉ ví dụ, bạn có thể đặt giá trị khác)
                    const offsetX = (x2 - halfSize) * spacing;
                    const offsetY = (y2 - halfSize) * spacing
                    const offsetZ = (z2 - halfSize) * spacing
                    let newVal = new THREE.Vector3(offsetX, offsetY, offsetZ)
                    newVal.add(new THREE.Vector3(.5, .5, 1))
                    // Lưu giá trị vào array
                    dummyOffsetArray[index2 * 3] = newVal.x;
                    dummyOffsetArray[index2 * 3 + 1] = newVal.y;
                    dummyOffsetArray[index2 * 3 + 2] = z2/sizeVol2D ;
                  
                    index2++;
                }
            }
        }

        // Tạo BufferAttribute từ array và gán vào instancedMesh
        const dummyOffsetAttribute = new THREE.InstancedBufferAttribute(dummyOffsetArray, 3);
        instancedMesh.geometry.setAttribute('dummyOffset', dummyOffsetAttribute);


        console.log(instancedMesh)



        let index = 0;
        for (let x = 0; x < sizeVol2D; x++) {
            for (let y = 0; y < sizeVol2D; y++) {
                for (let z = 0; z < sizeVol2D; z++) {
                    // Thiết lập vị trí của mỗi cube ở tâm texel
                    dummy.position.set(
                        (x - halfSize) * spacing,
                        (y - halfSize) * spacing,
                        (z - halfSize) * spacing
                    );

                    // Áp dụng biến đổi
                    dummy.updateMatrix();
                    instancedMesh.setMatrixAt(index, dummy.matrix);
                    index++;
                }
            }
        }

        instancedMesh.instanceMatrix.needsUpdate = true;
        const mm = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshBasicMaterial({ color: "red",transparent:true,opacity:.1,wireframe: true })
        )

        instancedMesh.visible = parameters.displaySample
        groupBox.add(instancedMesh, mm);
        groupBox.renderOrder = 5

        scene.add(groupBox)
    }
    
    function initFbo() {
        const dpr = 1.
        let voxelSize = sizeVol2D
        let vv = sizeVol2D * Math.sqrt(sizeVol2D)
        console.log(vv)
        vv *= 8
       vv = sizeVol2D * sizeVol2D * 2 //( 512 ( 16 *  32 ( 32 = 512 / 16 ) )  / Ex:36 > 2592)
       //vv = window.innerHeight,window.innerHeight
       renderTarget2DOut = new THREE.WebGLRenderTarget(/* 1024,1024, */vv,vv, {
     // renderTarget2DOut = new THREE.WebGLRenderTarget(window.innerWidth,window.innerHeight, {
            minFilter: THREE.NearestMipmapLinearFilter,
            magFilter: THREE.NearestMipmapLinearFilter,
            format: THREE.RGBAFormat
        });


        renderTarget2DOutOrigin = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
            minFilter: THREE.NearestFilter,
            magFilter: THREE.NearestFilter,
            format: THREE.RGBAFormat
        });
    }

    function initData3d() {


        dataArray = new Float32Array(sizeVol2D ** 3 * 4);
        let i = 0;

        for (let z = 0; z < sizeVol2D; z++) {
            for (let y = 0; y < sizeVol2D; y++) {
                for (let x = 0; x < sizeVol2D; x++) {
                    dataArray[i] = Math.random();     // Red
                    dataArray[i + 1] = Math.random(); // Green
                    dataArray[i + 2] = Math.random(); // Blue
                    dataArray[i + 3] = 1.0;           // Alpha (để không trong suốt)
                    i += 4; // Tăng lên 4 vì mỗi voxel cần 4 giá trị RGBA
                }
            }
        }


        texture3dSample = new THREE.Data3DTexture(dataArray, sizeVol2D, sizeVol2D, sizeVol2D);
        texture3dSample.format = THREE.RGBAFormat;
        texture3dSample.type = THREE.FloatType;
        texture3dSample.minFilter = THREE.LinearFilter;
        texture3dSample.magFilter = THREE.LinearFilter;
        texture3dSample.needsUpdate = true;
       
    }

    function updateData3dRandom() {
        let i = 0;

        for (let z = 0; z < sizeVol2D; z++) {
            for (let y = 0; y < sizeVol2D; y++) {
                for (let x = 0; x < sizeVol2D; x++) {
                    // Update data with random values between 0 and 255
                    dataArray[i] = Math.floor(Math.random() * 256);
                    i++;
                }
            }
        }
        console.log(dataArray[2])
        // Mark texture for update
        texture3dSample.needsUpdate = true;
    }

    function initGui() {

      

        function update() {
            if (meshCheck) meshCheck.material.uniforms.uLod.value = parameters.lod
            if(computeMaterial) computeMaterial.uniforms.uLod.value = parameters.lod

        }
        function update33() {
            if(chunk) {
                chunk.uniforms.uLodOn3D.value = parameters.lodOn3D
                
            }

        }
        function update2() {
            if (meshCheck2) meshCheck2.material.uniforms.toggle.value = !meshCheck2.material.uniforms.toggle.value
        }

        const gui = new GUI();
        gui.add(parameters, 'sizeVol', 8, 64, 1).name("Enter sizeVol");

        // Thêm nút `applyChanges` để thực hiện hành động
        gui.add(parameters, 'applyChanges').name("Apply Changes");
        gui.add(parameters, 'lod', 0, 8, 0.5).onChange(update);
        gui.add(parameters, 'lodOn3D', 0, 1, 0.01).onChange(update33);
        gui.add(parameters, 'toggle', 0, 1, 1).onChange(update2);

        function displaySample() {
            if(instancedMesh) instancedMesh.visible =  !instancedMesh.visible
        }
        function displayParticel() {
            
            if(points) points.visible =  !points.visible
        }
        gui.add(parameters, 'displaySample').onChange(displaySample);
        gui.add(parameters, 'displayParticel').onChange(displayParticel);
        function update4() {
            if(chunk) {
                chunk.uniforms.rangeForLight.value = parameters.rangeForLight
                
            }
        }

        gui.add(parameters, 'rangeForLight', 0, 1, 0.01).onChange(update4);
        
        
    }
  
    function initMeshCheck() {
       
        const groupDisplay1 = new THREE.Group()
        const groupDisplay2 = new THREE.Group()
        meshCheck = new THREE.Mesh(
            new THREE.PlaneGeometry(4, 4, sizeVol2D, sizeVol2D),
            new THREE.ShaderMaterial({
                //wireframe:true,
                uniforms: {
                    utex: { value: null },
                    uLod: { value: parameters.lod }
                },
                vertexShader: `
                        varying vec2 vUv;

                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                fragmentShader: `
                        varying vec2 vUv;
                        uniform sampler2D utex;
                        uniform float uLod;
                        

                        void main() {
                            vec3 tex = textureLod(utex,vUv,uLod).xyz;
                            if(tex.x < 0.95) {
                                 gl_FragColor = vec4(tex, 1.0);
                            }else{
                                gl_FragColor = vec4(vec3(1.) , 1.0);
                            }
                      
                            //gl_FragColor =  vec4(vec3(1.), 1.0);
                        }
                    `
            })

        )



        groupDisplay1.add(meshCheck)



        meshCheck2 = new THREE.Mesh(
            new THREE.PlaneGeometry(4, 4),
            new THREE.ShaderMaterial({
                //wireframe:true,
                transparent: true,
                //  blending: THREE.AdditiveBlending,
                uniforms: {
                    utex: { value: null },
                    toggle: { value: false }
                },
                vertexShader: `
                        varying vec2 vUv;

                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                fragmentShader: `
                        varying vec2 vUv;
                        uniform sampler2D utex;
                               uniform bool toggle;
                        void main() {
                         vec3  tex = texture2D(utex,vUv).xyz;
                            float activeC = 0.;
                            if(toggle) activeC = .5;
                            gl_FragColor = vec4(tex * vec3(.9,1.,.5),activeC);
                        }
                    `
            })

        )
        //   meshCheck2.position.z = 0.1
        //meshCheck2.position.x = -5

        groupDisplay2.add(meshCheck2)


        const groupGrid = create3DGrid({ size: sizeDisplayView, divisions: (Math.sqrt(sizeVol2D) / 2) * Math.sqrt(sizeVol2D) })

        groupDisplay1.traverse((child) => {
            if (child.isMesh) child.material.depthTest = false;
        });
        groupDisplay2.traverse((child) => {
            if (child.isMesh) child.material.depthTest = false;
        });
        groupGrid.traverse((child) => {
            if (child.isMesh) child.material.depthTest = false;
        });

        groupDisplay1.renderOrder = 5
        groupDisplay2.renderOrder = 7
        groupGrid.renderOrder = 4
        const groupAll = new THREE.Group()
        groupAll.position.x = 4
        groupAll.add(groupDisplay1, groupGrid, groupDisplay2)
        scene.add(groupAll)
    }


   
    function initPoint() {
        const gridSize = widthTexture; // Số điểm theo mỗi chiều
        const spacing = 1.0 / (gridSize - 1); // Khoảng cách giữa các điểm
        let a = Math.random()
        // Tạo dữ liệu điểm cho lưới
        const vertices = [];
        const extra = [];
        const uvs = [];
        const radius = .5;
        let ar = [
            new THREE.Vector3(1., 0.8, 0.2),
            new THREE.Vector3(0.1, 1., 0.6)
        ]
        for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
                // Tính toán tọa độ UV cho điểm
                const u = x * spacing;
                const v = y * spacing;

                //// rando
                // let posX = u * 2.0 - 1.0;
                // let posY = v * 2.0 - 1.0;
                // vertices.push(posX * 2., posY * 2., 0);
                //// sphere

                const theta = u * Math.PI * 2; // Góc xoay quanh trục Y (longitude)
                const phi = v * Math.PI;       // Góc từ trên xuống dưới (latitude)

                // Tính toán tọa độ x, y, z trên bề mặt hình cầu
                let posX = radius * Math.sin(phi) * Math.cos(theta);
                let posY = radius * Math.sin(phi) * Math.sin(theta);
                let posZ = radius * Math.cos(phi);
                vertices.push(posX, posY, posZ);

                let extraX = Math.random()
                let extraY = Math.random()

                // let rand = Math.floor(Math.random())
                // let a = Math.random()
                // let aa = .5
                // if(aa < .5){a = 0}else{a = 1}



                extra.push(extraX, extraY, 0);
                uvs.push(u, v);
            }
        }
        const PointGeo = new THREE.BufferGeometry();
        const positionAttribute = new THREE.BufferAttribute(new Float32Array(vertices), 3);
        const extraAttribute = new THREE.BufferAttribute(new Float32Array(extra), 3);
        const uvAttribute = new THREE.BufferAttribute(new Float32Array(uvs), 2);
        PointGeo.setAttribute('position', positionAttribute);
        PointGeo.setAttribute('extra', extraAttribute);
        PointGeo.setAttribute('uv', uvAttribute);


        const vertexShader = `
                precision highp float;
                uniform float time;
                uniform sampler2D fuildMap;
                uniform sampler2D fuildPress;
                uniform sampler2D tPos_gpu;
                uniform sampler2D tVel_gpu;
                uniform float speedmouse;
                uniform vec2 sizeView;
                uniform vec2 tSize;
                attribute vec3 extra;
                varying vec3 vExtra;
                varying vec2 vUv;
                varying vec3 vPos;
                varying vec2 vFuild;
                ${curl4Noise}
                void main() {
                    vec2 uvT = vec2(
                        mod(float(gl_InstanceID), tSize.x) / tSize.x, // Tính chỉ số cột
                        floor(float(gl_InstanceID) / tSize.x) / tSize.y  // Tính chỉ số hàng
                    );
                 
                     vec3 posgpu = texture2D(tPos_gpu,vec2(uv.x,1.-uv.y)).xyz;
                    vec3 pos = posgpu;
                     vec2 uvPos = vec2(
                        pos.x / sizeView.x + 0.5,
                        pos.y / sizeView.y + 0.5
                     );
                       vec2 velfuild = texture2D(fuildMap,uvPos).xy;
                            // posgpu.xy /= 2.;




                            
                 
                    vUv = uvPos;
                    vPos = posgpu / 2.;
                    vFuild = 1.-velfuild;
                    vExtra = extra;
                      vec4 mvPosition = modelViewMatrix * vec4(posgpu / 2., 1.0);
                      // gl_PointSize = 1.5 * (10.0 / -mvPosition.z);
                            ${sizePointCommon}
                        gl_Position = projectionMatrix * mvPosition;
                        
          

                }
            `;

       

        PointMat = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShaderPoint,
            transparent: true,
          //  blending: THREE.AdditiveBlending,
         depthTest: false, 

            uniforms: {
                
                speedmouse: {
                    value: 0
                },
                time: {
                    value: 0
                },
                fuildMap: {
                    value: simulation.fbos.vel_0.texture
                },
                fuildPress: {
                    value: simulation.fbos.pressure_1.texture
                },
                sizeView: {
                    value: new THREE.Vector2(widthFit, heightFit)
                },
                tPos_gpu: { value: null },
                tVel_gpu: { value: null },
                tSize: { value: new THREE.Vector2(widthTexture, widthTexture) }
            }
        });


        points = new THREE.Points(PointGeo, PointMat);
        
        points.visible = parameters.displayParticel
        

        const groupp = new THREE.Group()
        const mm = new THREE.Mesh(
            new THREE.BoxGeometry(2, 2, 2),
            new THREE.MeshBasicMaterial({ color: "blue",transparent:true,opacity:.1, wireframe: true })
        )

        groupp.position.x = 0
        groupp.add(points, mm)
        groupp.renderOrder = 20

        scene.add(groupp)
    






        initTexture2DBaseSetter(PointGeo,fragmentShaderPoint)
    }



    // problem here
    // slice need fix to get exacly pos
    function initTexture2DBaseSetter(geo,fragmentCommon) {
      //  sceneGenTexture.background = new THREE.Color(0x757575); 
        const vertexShaderSetter = `
                precision highp float;
                uniform float time;
                uniform sampler2D tPos_gpu;
                uniform sampler2D tVel_gpu;
                uniform vec2 sizeView;
                uniform vec3 sizeVolume;

                attribute vec3 extra;
                uniform vec2 tSize;
                varying vec2 vUv;
                varying vec3 vPos;
                varying vec3 vExtra;
                void main() {
                    vec2 uvT = vec2(
                        mod(float(gl_InstanceID), tSize.x) / tSize.x, // Tính chỉ số cột
                        floor(float(gl_InstanceID) / tSize.x) / tSize.y  // Tính chỉ số hàng
                    );
                     vec3 posgpuOri = texture2D(tPos_gpu,uv).xyz;
                     vec3 posgpu = texture2D(tPos_gpu,uv).xyz;
                     //  posgpu = position;
                      //  posgpu += position;
                    float voxelSizeX = 1.0 / sizeVolume.z; // Kích thước voxel theo chiều X
                    float voxelSizeY = 1.0 / sizeVolume.z; // Kích thước voxel theo chiều Y 

                //  posgpu.xy /= 2.;
                // posgpu.xy += 1.25;
          
                // NOTE : FIX SOME MORE ON HERE !!!!!!!!!!
                posgpu.z /= 2.;
                posgpu.z += 0.5;
                /////////////////
                float normalizedZ = mod(posgpu.z  , 1.0);  
                float slice = floor((posgpu.z) * (sizeVolume.x * sizeVolume.y)); 

                float gridSizeX = sizeVolume.x; 
                float gridSizeY = sizeVolume.y; 

             
                float offsetX = mod(slice, gridSizeX);     
                float offsetY = floor(slice / gridSizeX );    
                float margin = 2.;

                posgpu.xy +=  vec2(offsetX,offsetY)* margin;

                // posgpu.z = 0.;
                posgpu.xy /= sizeVolume.x;
                posgpu.xy -= 1.-(1./sizeVolume.x);

                // resize
              
                gl_Position = vec4(posgpu, 1.0);

            
                 
                vUv = uv;
                vec4 mvPosition = vec4(0.);
                   ${sizePointCommon}
            
                vPos = posgpu;
                vExtra = extra;
                }
            `;

        // const fragmentShaderSetter = `

        //         varying vec3 vPos;
        //         varying vec2 vUv;
        //         void main() {

        //         float dist = length(gl_PointCoord - vec2(0.5));
        //             if (dist > 0.5) discard;
        //             gl_FragColor = vec4(vec3(1.-dist) * vec3(vUv,1.) * (1.-distance(vPos,vec3(0.))), 1.0);

        //             // if(vPos.x < 0.01) {
        //             //   gl_FragColor = vec4( vec3(0.,.2,.2) ,1.);
        //             // }else{
        //             //   gl_FragColor = vec4( vec3(0.) ,1.);
        //             // }
                  
        //         }
        //     `

        PointMat2 = new THREE.ShaderMaterial({
            vertexShader: vertexShaderSetter,
            fragmentShader: fragmentCommon,
            transparent: true,
            
            //blending: THREE.MultiplyBlending,

            // blending : THREE.CustomBlending,
            // blendEquation :  THREE.AddEquation,


            uniforms: {
                sizeVolume: {
                    value: new THREE.Vector3(Math.sqrt(sizeVol2D), Math.sqrt(sizeVol2D), sizeVol2D)
                },
                sizeView: {
                    value: new THREE.Vector2(widthFit, heightFit)
                },
                tPos_gpu: { value: null },
                tVel_gpu: { value: null },
                tSize: { value: new THREE.Vector2(Math.sqrt(sizeVol2D) * sizeVol2D, Math.sqrt(sizeVol2D) * sizeVol2D ) }
            }
        });
        let point2s = new THREE.Points(geo, PointMat2);
        const groupPoint = new THREE.Group()
        groupPoint.add(point2s)
      
        sceneGenTexture.add(groupPoint)

    }

    function create3DGrid({ size, divisions }) {
        const gr = new THREE.Group()
        const gridMaterial = new THREE.LineBasicMaterial({ color: "black", transparent: true, opacity: 1.4, side: 1 });
        const gridMaterial2 = new THREE.LineBasicMaterial({ color: "red", transparent: true, opacity: .2, side: 1 });
        const gridGeometry = new THREE.BufferGeometry();
        const gridGeometry2 = new THREE.BufferGeometry();
        const gridVertices = [];
        const gridVertices2 = [];
        // Tạo lưới trên mặt XY
        for (let i = -size; i <= size; i += size / Math.sqrt(sizeVol2D) * 2) {
            // Các đường song song trục X
            gridVertices.push(-size, i, 0, size, i, 0);
            // Các đường song song trục Y
            gridVertices.push(i, -size, 0, i, size, 0);
        }
        gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(gridVertices, 3));

        for (let i = -size; i <= size; i += size / (divisions * divisions/ 2)) {
            // Các đường song song trục X
            gridVertices2.push(-size, i, 0, size, i, 0);
            // Các đường song song trục Y
            gridVertices2.push(i, -size, 0, i, size, 0);
        }
        gridGeometry2.setAttribute('position', new THREE.Float32BufferAttribute(gridVertices2, 3));

        // Tạo LineSegments cho lưới 3D
        const grid = new THREE.LineSegments(gridGeometry, gridMaterial);


        const grid2 = new THREE.LineSegments(gridGeometry2, gridMaterial2);

        gr.add(grid, grid2)
        //const meshHelper = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshBasicMaterial({ depthWrite: false,color: "blue", transparent: true, opacity: .1,side:1 }));
        //  scene.add(meshHelper);
        return gr
    }

    function runGPGPU() {

        positionUniforms['time'].value = now / 1000;
        positionUniforms['delta'].value = delta;

        velocityUniforms['time'].value = now / 1000;
        velocityUniforms['delta'].value = delta;

        positionUniforms['fuildMap'].value = simulation.fbos.vel_0.texture

        gpuCompute.compute();
        const texturePosOut = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
        const textureVelOut = gpuCompute.getCurrentRenderTarget(velocityVariable).texture;



        if (PointMat2) {
            PointMat2.uniforms.tPos_gpu.value = texturePosOut
        }

        if (PointMat) {
            PointMat.uniforms.tPos_gpu.value = texturePosOut
            PointMat.uniforms.tVel_gpu.value = textureVelOut
        }

    }

    function updateTexture3D() {
    

        for ( let i = 0; i < sizeVol2D; i ++ ) {
            
            // Render volume shader to target3d buffer
            computeMesh.material.uniforms.uZCoord.value = i / ( sizeVol2D  );
            Renderer.renderer.setRenderTarget(rendertarget3D, i);
            Renderer.renderer.render(computeMesh, camera);

        }   
       
    }
    Renderer.renderer.setAnimationLoop(animate);
    function animate() {
      
        if(directionalLight) directionalLight.position.copy(controlsMain.object.position)
        stats.update();
        Mouse.update();
        Renderer.update();

        simulation.update()
        runGPGPU()


       if(texture3dSample) updateTexture3D()
      
        Renderer.renderer.autoClear = true
        Renderer.renderer.setClearColor(0xffffff, 1); 
        Renderer.renderer.setRenderTarget(renderTarget2DOut);
        Renderer.renderer.render(sceneGenTexture, cameraGenTexture);
        renderTarget2DOut.textures[0].generateMipmaps = true
        // renderTarget2DOut.textures[0].blending =  THREE.AdditiveBlending
        // renderTarget2DOut.textures[0].transparent =  true
        if (meshCheck && meshCheck.material && meshCheck.material.uniforms.utex) {
            meshCheck.material.uniforms.utex.value = renderTarget2DOut.textures[0]
        }
   
        if(computeMaterial) {
            computeMaterial.uniforms.sample2DSetter.value = renderTarget2DOut.textures[0]
        }
        if(chunk) {
            chunk.uniforms.uTexture3DSample.value = rendertarget3D.texture
            chunk.uniforms.uTexture2D.value = renderTarget2DOut.textures[0]
        }
        Renderer.renderer.setRenderTarget(null);
        Renderer.renderer.setRenderTarget(renderTarget2DOutOrigin);
        Renderer.renderer.render(sceneGenTexture, cameraGenTexture);
        if (meshCheck2 && meshCheck2.material && meshCheck2.material.uniforms.utex) {
            meshCheck2.material.uniforms.utex.value = renderTarget2DOutOrigin.textures[0]
        }


        Renderer.renderer.setClearColor(0x00000, 1); 
        Renderer.renderer.setRenderTarget(null);
        Renderer.renderer.render(scene, camera);

     //   Renderer.renderer.render(sceneGenTexture, cameraGenTexture);
        PointMat.uniforms.time.value = Renderer.time
    
      
     
        // PointMat.uniforms.speedmouse.value = simulation.externalForce.speed
        // positionUniforms['forceMouse'] = { value: simulation.externalForce.speed };

        if (dataArray && texture3dSample) {
            // console.time()
            // updateData3dRandom()
            //console.timeEnd()
        }

    

        //   positionUniforms['projectionMatrix'] = { value: controlsMain.object.projectionMatrix };
        //   positionUniforms['viewMatrix'] = { value: controlsMain.object.matrixWorldInverse};
        //   PointMat.uniforms.externalForce.value = simulation.externalForce.props.output.texture
    }

</script>

</html>







<!-- 





   const vertexShader = `
            attribute vec3 randomOffset;
            varying vec3 vRandomOffset;
              attribute vec3 dummyOffset;
                 varying vec3 dumOff;
            varying vec3 vPos;
            varying vec2 vUv;
            varying float idd;
                 uniform float uSizeVol2D;
            void main() {
                vRandomOffset = randomOffset;

                // Tính toán vị trí của từng instance dựa trên instanceMatrix
                vPos = position;
                vUv = uv;
                idd = float(gl_InstanceID);
                dumOff = dummyOffset;
                vec4 modelPosition = instanceMatrix * vec4(dummyOffset  * 0.+ position, 1.0);
                gl_Position = projectionMatrix * modelViewMatrix * modelPosition;
            }
        `;

        const fragmentShader = `
              
                varying vec3 dumOff;
            varying vec3 vRandomOffset;
            varying vec3 vPos;
            varying vec2 vUv;
            varying float idd;
            uniform float uSizeVol2D;
            uniform float uLodOn3D;
            
            uniform sampler2D uTexture2D;
            vec2 computeSliceOffsetOrigin(float slice, float slicesPerRow, vec2 sliceSize) {
                    return sliceSize * vec2(mod(slice, slicesPerRow), 
									floor(slice / slicesPerRow));
			}

			vec4 sampleAs3DTextureOrigin(
				sampler2D tex, vec3 texCoord, float size, float numRows, float slicesPerRow,float lod) {
				float slice   = texCoord.z * size;
				float sliceZ  = floor(slice);                         // slice we need
				float zOffset = fract(slice);                         // dist between slices

				vec2 sliceSize = vec2(1.0 / slicesPerRow,             // u space of 1 slice
										1.0 / numRows);                 // v space of 1 slice

				vec2 slice0Offset = computeSliceOffsetOrigin(sliceZ, slicesPerRow, sliceSize);
				vec2 slice1Offset = computeSliceOffsetOrigin(sliceZ + 1.0, slicesPerRow, sliceSize);

				vec2 slicePixelSize = sliceSize / size;               // space of 1 pixel
				vec2 sliceInnerSize = slicePixelSize * (size - 1.0);  // space of size pixels

				vec2 uv = slicePixelSize * 0.5 + texCoord.xy * sliceInnerSize;
			
				vec4 slice0Color = texture2D(tex, slice0Offset + uv);
				vec4 slice1Color = texture2D(tex, slice1Offset + uv);

                slice0Color = textureLod(tex, slice0Offset + uv,lod);
                slice1Color = textureLod(tex, slice1Offset + uv,lod);


				return mix(slice0Color, slice1Color, zOffset);
				//return slice0Color;
			}
            void main() {
                // Sử dụng giá trị randomOffset để điều chỉnh màu sắc
                //if(vRandomOffset.x == 0.) discard;
  float u_sdfVoxelSize = uSizeVol2D*uSizeVol2D;
                	vec3 voxelTextureCoordOri = vPos  + vec3(.5,.5,.5) * 0. ;
 			        vec3 voxelTextureCoord = clamp(voxelTextureCoordOri, vec3(0.5 / u_sdfVoxelSize), vec3(1.0 - 0.5 / u_sdfVoxelSize));
                  
                    float ads = uSizeVol2D;
                  
                	vec4 distanceInfo = sampleAs3DTextureOrigin(uTexture2D,vec3(dumOff.xy,dumOff.z * 2.), uSizeVol2D + uSizeVol2D,uSizeVol2D,uSizeVol2D,uLodOn3D);
                if(distanceInfo.x > 0.) {
                    gl_FragColor = vec4(distanceInfo.xyz, 1.);
                   gl_FragColor =  vec4(1.,.3,1., 1.);
                }else{
                    discard;
                }
             //gl_FragColor =  vec4(1.,.3,1., 1.);
                   
               
            }
        `;

        shaderInstancedSample = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            transparent: true,
            side: 0,
            uniforms: {
                uTexture2D: { value: null },
                uSizeVol2D: { value: Math.sqrt(sizeVol2D) },
                uLodOn3D: { value: 0. }
            }
        });
-->