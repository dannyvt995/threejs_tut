<!DOCTYPE html>
<html lang="en">

<head>
    <title>Ribbon_FboPingPong</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">

</head>
<style>
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
    }

    .note {
        position: fixed;
        top: 50px;
        left: 50%;
        width: 100%;
        height: 100px;
        color: rgb(255, 255, 255);
        font-size: .5rem;
        z-index: 99;
    }
</style>

<body>
    <div class="note"></div>
    <div id="canvas"></div>
    <script type="importmap">
		{
			"imports": {
				"three": "./three.module.js",
				"three/addons/": "./jsm/"
			}
		}
	</script>
    <script type="module">
        import * as THREE from 'three';

        import Stats from 'three/addons/stats.module.js';
        import { GUI } from 'three/addons/lil-gui.module.min.js';
        import { OBJLoader } from 'three/addons/OBJLoader.js';
    
        import { OrbitControls } from 'three/addons/OrbitControls.js';
        import { radixSort } from 'three/addons/SortUtils.js';
        //glsl
        import { curl4Noise } from './glsl/curl4Noise.js'

        //MAIN SCENE
        let renderer, controls, stats, cameraMain, sceneDisplay;
        let matCubeInstanced,materialRibbon
        //MONITOR
        let sceneMonitor, camMonitor, points, PointMat;
        let viewFBODepth_Mat, viewFboNormal_Mat, viewGPGPU_Pos, viewGPGPU_Vel, viewGPGPU_Extra
        let loaderObjModel

        //UTILS
        let now, last, delta
        let wView = window.innerWidth
        let hView = window.innerHeight
        let ratioView = window.innerWidth / window.innerHeight
        let marginScissor = 2




        init();

        function init() {
            loaderObjModel = new OBJLoader();

            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(wView, hView);
            renderer.setAnimationLoop(animate);
            const canvasDom = document.getElementById("canvas")
            canvasDom.appendChild(renderer.domElement);

            //

            stats = new Stats();
            document.body.appendChild(stats.dom);

            cameraMain = new THREE.PerspectiveCamera(70, wView / hView, 0.01, 400);
            cameraMain.position.z = 1;


            controls = new OrbitControls(cameraMain, renderer.domElement);
            controls.enableDamping = true;


            sceneDisplay = new THREE.Scene();
            sceneDisplay.background = new THREE.Color(0x000000);
            const ambienLight = new THREE.AmbientLight(0x404040, 5); // soft white light
            sceneDisplay.add(ambienLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(-2,0,1)
            sceneDisplay.add(directionalLight)

            const axesHelper = new THREE.AxesHelper(5);
            sceneDisplay.add(axesHelper);
  
          

            initInstancedMesh()

           
            onWindowResize();
            window.addEventListener('resize', onWindowResize);



        }


        function initInstancedMesh() {
                const numParticles = 5; // Thay thế Config.numParticles nếu cần
                const numSets = 5;       // Thay thế Config.numSets nếu cần

                const positions = [];
                const uvs = [];
                const normals = [];
                const indices = [];

                let count = 0;
                const numSides = 3; // Số mặt của ribbon

                const getPos = (i, j) => {
                const a = ((Math.PI * 2) / numSides) * j;
                const z = Math.cos(a);
                const y = Math.sin(a);
                const r = 0.015; // Bán kính ribbon

                const pos = [i, y * r, z * r];
                const normal = [0, y, z];

                return {
                    pos,
                    normal,
                };
                };

                const addVertex = (i, j) => {
                const { pos, normal } = getPos(i, j);
                positions.push(...pos);
                normals.push(...normal);
                uvs.push(i / numSets, j / numSides);
                };

                const totalSets = numSets * numSets;

                for (let i = 0; i < totalSets - 1; i++) {
                for (let j = 0; j < numSides; j++) {
                    addVertex(i, j);
                    addVertex(i + 1, j);
                    addVertex(i + 1, (j + 1) % numSides);
                    addVertex(i, (j + 1) % numSides);

                    indices.push(count * 4 + 0, count * 4 + 1, count * 4 + 2);
                    indices.push(count * 4 + 0, count * 4 + 2, count * 4 + 3);

                    count++;
                }
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                geometry.setIndex(indices);

                // Instancing attributes
                const uvOffsets = [];
                const extras = [];

                for (let i = 0; i < numParticles; i++) {
                for (let j = 0; j < numParticles; j++) {
                    uvOffsets.push((i + 0.5) / numParticles / numSets, (j + 0.5) / numParticles / numSets);
                    extras.push(Math.random(), Math.random(), Math.random());
                }
                }

                const uvOffsetAttribute = new THREE.InstancedBufferAttribute(new Float32Array(uvOffsets), 2);
                const extrasAttribute = new THREE.InstancedBufferAttribute(new Float32Array(extras), 3);

                geometry.setAttribute('aUVOffset', uvOffsetAttribute);
                geometry.setAttribute('aExtra', extrasAttribute);

               

                // Shader material
                materialRibbon = new THREE.ShaderMaterial({
                vertexShader: `
                    // Vertex Shader (vs)
                     uniform float uTime;
                     uniform float uDelta;
                    uniform float uTotal;
                    uniform float uNumSets;

                    attribute vec2 aUVOffset;
                    attribute vec3 aExtra;

                    varying vec2 vUV;
                    varying vec3 vExtra;

                      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;  }

        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;  }
        
        vec4 permute(vec4 x) {  return mod289(((x*34.0)+1.0)*x);  }
        
        vec4 taylorInvSqrt(vec4 r) {  return 1.79284291400159 - 0.85373472095314 * r;}
        
        float snoise(vec3 v) { 
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
        
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 =   v - i + dot(i, C.xxx) ;
        
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
        
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
            vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
        
            i = mod289(i); 
            vec4 p = permute( permute( permute( 
                                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
        
            float n_ = 0.142857142857; // 1.0/7.0
            vec3  ns = n_ * D.wyz - D.xzx;
        
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
        
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
        
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
        
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
        
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
        
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
        
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
        
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
        
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                                                        dot(p2,x2), dot(p3,x3) ) );
        }
        
        vec3 snoiseVec3( vec3 x ){
        
            float s  = snoise(vec3( x ));
            float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));
            float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));
            vec3 c = vec3( s , s1 , s2 );
            return c;
        
        }
        
        vec3 curlNoise( vec3 p ){
            
            const float e = .1;
            vec3 dx = vec3( e   , 0.0 , 0.0 );
            vec3 dy = vec3( 0.0 , e   , 0.0 );
            vec3 dz = vec3( 0.0 , 0.0 , e   );
        
            vec3 p_x0 = snoiseVec3( p - dx );
            vec3 p_x1 = snoiseVec3( p + dx );
            vec3 p_y0 = snoiseVec3( p - dy );
            vec3 p_y1 = snoiseVec3( p + dy );
            vec3 p_z0 = snoiseVec3( p - dz );
            vec3 p_z1 = snoiseVec3( p + dz );
        
            float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
            float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
            float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;
        
            const float divisor = 1.0 / ( 2.0 * e );
            return normalize( vec3( x , y , z ) * divisor );
        
        }

                    mat4 rotationMatrix(float angle, vec3 axis) {
                        float s = sin(angle);
                        float c = cos(angle);
                        float t = 1.0 - c;

                        vec3 normAxis = normalize(axis);

                        return mat4(
                            t * normAxis.x * normAxis.x + c,     t * normAxis.x * normAxis.y - s * normAxis.z, t * normAxis.x * normAxis.z + s * normAxis.y, 0.0,
                            t * normAxis.x * normAxis.y + s * normAxis.z, t * normAxis.y * normAxis.y + c,     t * normAxis.y * normAxis.z - s * normAxis.x, 0.0,
                            t * normAxis.x * normAxis.z - s * normAxis.y, t * normAxis.y * normAxis.z + s * normAxis.x, t * normAxis.z * normAxis.z + c,     0.0,
                            0.0, 0.0, 0.0, 1.0
                        );
                    }

float rand(float seed) {
    return fract(sin(seed * 12.9898) * 43758.5453);
}


                    void main() {
                        // Đặt UV offset cho mỗi instance
                        vec2 uv = uv * aUVOffset;

                        // Cập nhật UV cho fragment shader
                        vUV = uv;
                        vExtra = aExtra;

                        // Tính toán vị trí cuối cùng của điểm
                        vec3 pos = position;
                        pos.x /= 10.;

                        float idR = (float(gl_InstanceID) + .5)/10.;
                        float yWave = sin(pos.x * 12.0 * 3.14  * idR/ uNumSets + uTime) * 0.1 ; // Sóng cho trục y
                        float xWave = cos(pos.y * 12.0 * 3.14 / uNumSets + uTime) * 0.1; // Sóng cho trục x
                        float zWave = sin(yWave * 12.0 * 3.14  * idR/ uNumSets + uTime) * 0.1; // Sóng cho trục z


pos.x += sin(pos.y * 5. * rand(idR)  / uNumSets + uTime);
pos.z += cos(pos.x * 5. * rand(idR)  / uNumSets + uTime);
pos.y += sin(pos.z * 5. * rand(idR)  / uNumSets + uTime);

vec3 ppp =  curlNoise(pos + uDelta);


                         mat4 rotMatrix = rotationMatrix(10. * idR ,vec3(0.,1.,0.));
                        vec4 rotatedPosition = rotMatrix * vec4(pos, 1.0);

            
                        vec4 modelViewPosition = modelViewMatrix * vec4(rotatedPosition.xyz, 1.0);
                        gl_Position = projectionMatrix * modelViewPosition;
                    }

                `, // vs là shader bạn đã import
                fragmentShader: `
                // Fragment Shader (fs)
                    uniform float uTotal;
                    uniform float uNumSets;

                    varying vec2 vUV;
                    varying vec3 vExtra;

                    void main() {
                        // Tạo màu sắc cơ bản từ UV và giá trị extra
                        vec3 color = vec3(vUV, 1.0);
                        color += vExtra * 0.5; // Thay đổi màu sắc dựa trên giá trị aExtra

                        // Đặt màu sắc của pixel
                        gl_FragColor = vec4(color, 1.0);
                    }

                `, // fs là shader bạn đã import
                uniforms: {
                    uTime: {value: 0.},
                    uDelta: {value: 0.},
                    uTotal: { value: totalSets },
                    uNumSets: { value: numSets },
                },
                side: THREE.DoubleSide,
                wireframe:true
                });

                // Instanced mesh
                const mesh = new THREE.InstancedMesh(geometry, materialRibbon, numParticles * numParticles);

                sceneDisplay.add(mesh);
        }

        function onWindowResize() {

            const aspect = wView / hView;
            cameraMain.aspect = aspect;
            cameraMain.updateProjectionMatrix();
            const dpr = renderer.getPixelRatio();
            renderer.setSize(wView, hView);

        }
    
        function renderMain() {
        
            renderer.setViewport(0, 0, wView, hView);
            renderer.render(sceneDisplay, cameraMain);
          
        }

       
        function animate() {
            now = performance.now();

            delta = (now - last) / 4200;
            // delta = 1/60 
            if (delta > 1) delta = 1; // safety cap on large deltas
            last = now;
            renderer.autoClear = false;
        
            renderMain()
            materialRibbon.uniforms.uTime.value = now/1000
            materialRibbon.uniforms.uDelta.value = delta
            controls.update();
            stats.update();
        }

    </script>

</body>

</html>