<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl2 - volume - cloud</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

</head>
<style>
    body {
        margin: 0;
        overflow: hidden;
    }
</style>

<body>

    <script type="importmap">
            {
                "imports": {
                    "three": "../three.module.js",
                    "three/addons/": "../jsm/"
                }
            }
		</script>

    <script type="module">
        import Stats from 'three/addons/stats.module.js';
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/OrbitControls.js';
        import { ImprovedNoise } from 'three/addons/ImprovedNoise.js';

        import { GUI } from 'three/addons/lil-gui.module.min.js';

        let matPLane, gui
        let time = 0; // Biến lưu trữ thời gian tổng
        let lastTime = performance.now(); // Lưu thời gian khởi đầu

        let renderer, orbitControl
        let sceneMain, cameraMain
        let rt1,rt2

        const textureImg = new THREE.TextureLoader().load('../textures/cat.jpg');
        const ratioView = (16 / 27)

        initRender()
        function initRender() {
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
        }

        initSceneMain()
        function initSceneMain() {
            sceneMain = new THREE.Scene();
            cameraMain = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            cameraMain.position.z = 2;
            orbitControl = new OrbitControls(cameraMain, renderer.domElement)

            const light = new THREE.AmbientLight(0x404040); // soft white light
            sceneMain.add(light);
        }

        initPlane()

        function initPlane() {

            const plane = new THREE.PlaneGeometry(1, 1 * ratioView, 32, 16)

            const vertexShader = /* glsl */`
                varying vec2 vUv;


                void main() {
                
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

                    vUv = uv;
                }
                `;


            const fragmentShader = /* glsl */`
                    uniform sampler2D textureImg;
                    uniform float time;
                    uniform float delta;

                    varying vec2 vUv;

                    void main() {
                        
                        vec4 img =  texture2D(textureImg,vUv);
                        gl_FragColor = img;
                    }
            `;
            matPLane = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: {
                    time: { value: 0 },
                    delta: { value: 0 },
                    textureImg: { value: textureImg }
                },
                wireframe: false,
                side: 2,
                transparent: true,
                blending: THREE.NormalBlending,
            })

            const mesh = new THREE.Mesh(plane, matPLane)
            
            sceneMain.add(mesh)

        }

        function initFbo(){
            const rtParams = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };
            rt1 = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParams);
            rt2 = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParams);
        }






        initGui()

        function initGui() {

            gui = new GUI();
            const params = {
                u_progress: 0.,
            };

            gui.add(params, 'u_progress', 0, 1).name('u_progress').onChange(updateUniforms);

            function updateUniforms() {

                matPLane.uniforms.u_progress.value = params.u_progress;

            }

        }

        function animate() {
            const currentTime = performance.now(); // Lấy thời gian hiện tại
            const delta = (currentTime - lastTime) / 1000; // Tính toán delta (thời gian trôi qua giữa các khung hình) tính bằng giây

            lastTime = currentTime; // Cập nhật lastTime cho khung hình tiếp theo

            time += delta; // Cập nhật giá trị time

            matPLane.uniforms.time.value = time; // Cập nhật uniform time
            matPLane.uniforms.delta.value = delta;
            requestAnimationFrame(animate); // Gọi hàm animate lại

            renderer.render(sceneMain, cameraMain); // Render scene
        }

        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            rt1.setSize(window.innerWidth, window.innerHeight);
            rt2.setSize(window.innerWidth, window.innerHeight);
            cameraMain.aspect = window.innerWidth / window.innerHeight;
            cameraMain.updateProjectionMatrix();
        });

    </script>

</body>

</html>