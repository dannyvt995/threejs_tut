/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "148"
  , MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , TOUCH = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , CullFaceNone = 0
  , CullFaceBack = 1
  , CullFaceFront = 2
  , PCFShadowMap = 1
  , PCFSoftShadowMap = 2
  , VSMShadowMap = 3
  , FrontSide = 0
  , BackSide = 1
  , DoubleSide = 2
  , TwoPassDoubleSide = 3
  , NoBlending = 0
  , NormalBlending = 1
  , AdditiveBlending = 2
  , SubtractiveBlending = 3
  , MultiplyBlending = 4
  , CustomBlending = 5
  , AddEquation = 100
  , SubtractEquation = 101
  , ReverseSubtractEquation = 102
  , MinEquation = 103
  , MaxEquation = 104
  , ZeroFactor = 200
  , OneFactor = 201
  , SrcColorFactor = 202
  , OneMinusSrcColorFactor = 203
  , SrcAlphaFactor = 204
  , OneMinusSrcAlphaFactor = 205
  , DstAlphaFactor = 206
  , OneMinusDstAlphaFactor = 207
  , DstColorFactor = 208
  , OneMinusDstColorFactor = 209
  , SrcAlphaSaturateFactor = 210
  , NeverDepth = 0
  , AlwaysDepth = 1
  , LessDepth = 2
  , LessEqualDepth = 3
  , EqualDepth = 4
  , GreaterEqualDepth = 5
  , GreaterDepth = 6
  , NotEqualDepth = 7
  , MultiplyOperation = 0
  , MixOperation = 1
  , AddOperation = 2
  , NoToneMapping = 0
  , LinearToneMapping = 1
  , ReinhardToneMapping = 2
  , CineonToneMapping = 3
  , ACESFilmicToneMapping = 4
  , CustomToneMapping = 5
  , UVMapping = 300
  , CubeReflectionMapping = 301
  , CubeRefractionMapping = 302
  , EquirectangularReflectionMapping = 303
  , EquirectangularRefractionMapping = 304
  , CubeUVReflectionMapping = 306
  , RepeatWrapping = 1e3
  , ClampToEdgeWrapping = 1001
  , MirroredRepeatWrapping = 1002
  , NearestFilter = 1003
  , NearestMipmapNearestFilter = 1004
  , NearestMipMapNearestFilter = 1004
  , NearestMipmapLinearFilter = 1005
  , NearestMipMapLinearFilter = 1005
  , LinearFilter = 1006
  , LinearMipmapNearestFilter = 1007
  , LinearMipMapNearestFilter = 1007
  , LinearMipmapLinearFilter = 1008
  , LinearMipMapLinearFilter = 1008
  , UnsignedByteType = 1009
  , ByteType = 1010
  , ShortType = 1011
  , UnsignedShortType = 1012
  , IntType = 1013
  , UnsignedIntType = 1014
  , FloatType = 1015
  , HalfFloatType = 1016
  , UnsignedShort4444Type = 1017
  , UnsignedShort5551Type = 1018
  , UnsignedInt248Type = 1020
  , AlphaFormat = 1021
  , RGBFormat = 1022
  , RGBAFormat = 1023
  , LuminanceFormat = 1024
  , LuminanceAlphaFormat = 1025
  , DepthFormat = 1026
  , DepthStencilFormat = 1027
  , RedFormat = 1028
  , RedIntegerFormat = 1029
  , RGFormat = 1030
  , RGIntegerFormat = 1031
  , RGBAIntegerFormat = 1033
  , RGB_S3TC_DXT1_Format = 33776
  , RGBA_S3TC_DXT1_Format = 33777
  , RGBA_S3TC_DXT3_Format = 33778
  , RGBA_S3TC_DXT5_Format = 33779
  , RGB_PVRTC_4BPPV1_Format = 35840
  , RGB_PVRTC_2BPPV1_Format = 35841
  , RGBA_PVRTC_4BPPV1_Format = 35842
  , RGBA_PVRTC_2BPPV1_Format = 35843
  , RGB_ETC1_Format = 36196
  , RGB_ETC2_Format = 37492
  , RGBA_ETC2_EAC_Format = 37496
  , RGBA_ASTC_4x4_Format = 37808
  , RGBA_ASTC_5x4_Format = 37809
  , RGBA_ASTC_5x5_Format = 37810
  , RGBA_ASTC_6x5_Format = 37811
  , RGBA_ASTC_6x6_Format = 37812
  , RGBA_ASTC_8x5_Format = 37813
  , RGBA_ASTC_8x6_Format = 37814
  , RGBA_ASTC_8x8_Format = 37815
  , RGBA_ASTC_10x5_Format = 37816
  , RGBA_ASTC_10x6_Format = 37817
  , RGBA_ASTC_10x8_Format = 37818
  , RGBA_ASTC_10x10_Format = 37819
  , RGBA_ASTC_12x10_Format = 37820
  , RGBA_ASTC_12x12_Format = 37821
  , RGBA_BPTC_Format = 36492
  , LinearEncoding = 3e3
  , sRGBEncoding = 3001
  , BasicDepthPacking = 3200
  , RGBADepthPacking = 3201
  , TangentSpaceNormalMap = 0
  , ObjectSpaceNormalMap = 1
  , SRGBColorSpace = "srgb"
  , LinearSRGBColorSpace = "srgb-linear"
  , KeepStencilOp = 7680
  , AlwaysStencilFunc = 519
  , StaticDrawUsage = 35044
  , DynamicDrawUsage = 35048
  , GLSL3 = "300 es"
  , _SRGBAFormat = 1035;
class EventDispatcher {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const r = this._listeners;
        r[e] === void 0 && (r[e] = []),
        r[e].indexOf(t) === -1 && r[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const r = this._listeners;
        return r[e] !== void 0 && r[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const n = this._listeners[e];
        if (n !== void 0) {
            const o = n.indexOf(t);
            o !== -1 && n.splice(o, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const r = this._listeners[e.type];
        if (r !== void 0) {
            e.target = this;
            const n = r.slice(0);
            for (let o = 0, l = n.length; o < l; o++)
                n[o].call(this, e);
            e.target = null
        }
    }
}
const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180
  , RAD2DEG = 180 / Math.PI;
function generateUUID() {
    const a = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , r = Math.random() * 4294967295 | 0;
    return (_lut[a & 255] + _lut[a >> 8 & 255] + _lut[a >> 16 & 255] + _lut[a >> 24 & 255] + "-" + _lut[e & 255] + _lut[e >> 8 & 255] + "-" + _lut[e >> 16 & 15 | 64] + _lut[e >> 24 & 255] + "-" + _lut[t & 63 | 128] + _lut[t >> 8 & 255] + "-" + _lut[t >> 16 & 255] + _lut[t >> 24 & 255] + _lut[r & 255] + _lut[r >> 8 & 255] + _lut[r >> 16 & 255] + _lut[r >> 24 & 255]).toLowerCase()
}
function clamp$1(a, e, t) {
    return Math.max(e, Math.min(t, a))
}
function euclideanModulo(a, e) {
    return (a % e + e) % e
}
function mapLinear(a, e, t, r, n) {
    return r + (a - e) * (n - r) / (t - e)
}
function inverseLerp(a, e, t) {
    return a !== e ? (t - a) / (e - a) : 0
}
function lerp(a, e, t) {
    return (1 - t) * a + t * e
}
function damp(a, e, t, r) {
    return lerp(a, e, 1 - Math.exp(-t * r))
}
function pingpong(a, e=1) {
    return e - Math.abs(euclideanModulo(a, e * 2) - e)
}
function smoothstep(a, e, t) {
    return a <= e ? 0 : a >= t ? 1 : (a = (a - e) / (t - e),
    a * a * (3 - 2 * a))
}
function smootherstep(a, e, t) {
    return a <= e ? 0 : a >= t ? 1 : (a = (a - e) / (t - e),
    a * a * a * (a * (a * 6 - 15) + 10))
}
function randInt(a, e) {
    return a + Math.floor(Math.random() * (e - a + 1))
}
function randFloat(a, e) {
    return a + Math.random() * (e - a)
}
function randFloatSpread(a) {
    return a * (.5 - Math.random())
}
function seededRandom(a) {
    a !== void 0 && (_seed = a);
    let e = _seed += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function degToRad(a) {
    return a * DEG2RAD
}
function radToDeg(a) {
    return a * RAD2DEG
}
function isPowerOfTwo(a) {
    return (a & a - 1) === 0 && a !== 0
}
function ceilPowerOfTwo(a) {
    return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2))
}
function floorPowerOfTwo(a) {
    return Math.pow(2, Math.floor(Math.log(a) / Math.LN2))
}
function setQuaternionFromProperEuler(a, e, t, r, n) {
    const o = Math.cos
      , l = Math.sin
      , c = o(t / 2)
      , u = l(t / 2)
      , f = o((e + r) / 2)
      , p = l((e + r) / 2)
      , g = o((e - r) / 2)
      , v = l((e - r) / 2)
      , _ = o((r - e) / 2)
      , w = l((r - e) / 2);
    switch (n) {
    case "XYX":
        a.set(c * p, u * g, u * v, c * f);
        break;
    case "YZY":
        a.set(u * v, c * p, u * g, c * f);
        break;
    case "ZXZ":
        a.set(u * g, u * v, c * p, c * f);
        break;
    case "XZX":
        a.set(c * p, u * w, u * _, c * f);
        break;
    case "YXY":
        a.set(u * _, c * p, u * w, c * f);
        break;
    case "ZYZ":
        a.set(u * w, u * _, c * p, c * f);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n)
    }
}
function denormalize(a, e) {
    switch (e.constructor) {
    case Float32Array:
        return a;
    case Uint16Array:
        return a / 65535;
    case Uint8Array:
        return a / 255;
    case Int16Array:
        return Math.max(a / 32767, -1);
    case Int8Array:
        return Math.max(a / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function normalize(a, e) {
    switch (e.constructor) {
    case Float32Array:
        return a;
    case Uint16Array:
        return Math.round(a * 65535);
    case Uint8Array:
        return Math.round(a * 255);
    case Int16Array:
        return Math.round(a * 32767);
    case Int8Array:
        return Math.round(a * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
var MathUtils$1 = Object.freeze({
    __proto__: null,
    DEG2RAD,
    RAD2DEG,
    generateUUID,
    clamp: clamp$1,
    euclideanModulo,
    mapLinear,
    inverseLerp,
    lerp,
    damp,
    pingpong,
    smoothstep,
    smootherstep,
    randInt,
    randFloat,
    randFloatSpread,
    seededRandom,
    degToRad,
    radToDeg,
    isPowerOfTwo,
    ceilPowerOfTwo,
    floorPowerOfTwo,
    setQuaternionFromProperEuler,
    normalize,
    denormalize
});
class Vector2 {
    constructor(e=0, t=0) {
        Vector2.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , r = this.y
          , n = e.elements;
        return this.x = n[0] * t + n[3] * r + n[6],
        this.y = n[1] * t + n[4] * r + n[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , r = this.y - e.y;
        return t * t + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const r = Math.cos(t)
          , n = Math.sin(t)
          , o = this.x - e.x
          , l = this.y - e.y;
        return this.x = o * r - l * n + e.x,
        this.y = o * n + l * r + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class Matrix3 {
    constructor() {
        Matrix3.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }
    set(e, t, r, n, o, l, c, u, f) {
        const p = this.elements;
        return p[0] = e,
        p[1] = n,
        p[2] = c,
        p[3] = t,
        p[4] = o,
        p[5] = u,
        p[6] = r,
        p[7] = l,
        p[8] = f,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , r = e.elements;
        return t[0] = r[0],
        t[1] = r[1],
        t[2] = r[2],
        t[3] = r[3],
        t[4] = r[4],
        t[5] = r[5],
        t[6] = r[6],
        t[7] = r[7],
        t[8] = r[8],
        this
    }
    extractBasis(e, t, r) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        r.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const r = e.elements
          , n = t.elements
          , o = this.elements
          , l = r[0]
          , c = r[3]
          , u = r[6]
          , f = r[1]
          , p = r[4]
          , g = r[7]
          , v = r[2]
          , _ = r[5]
          , w = r[8]
          , S = n[0]
          , b = n[3]
          , C = n[6]
          , R = n[1]
          , T = n[4]
          , M = n[7]
          , P = n[2]
          , I = n[5]
          , k = n[8];
        return o[0] = l * S + c * R + u * P,
        o[3] = l * b + c * T + u * I,
        o[6] = l * C + c * M + u * k,
        o[1] = f * S + p * R + g * P,
        o[4] = f * b + p * T + g * I,
        o[7] = f * C + p * M + g * k,
        o[2] = v * S + _ * R + w * P,
        o[5] = v * b + _ * T + w * I,
        o[8] = v * C + _ * M + w * k,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , r = e[1]
          , n = e[2]
          , o = e[3]
          , l = e[4]
          , c = e[5]
          , u = e[6]
          , f = e[7]
          , p = e[8];
        return t * l * p - t * c * f - r * o * p + r * c * u + n * o * f - n * l * u
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , r = e[1]
          , n = e[2]
          , o = e[3]
          , l = e[4]
          , c = e[5]
          , u = e[6]
          , f = e[7]
          , p = e[8]
          , g = p * l - c * f
          , v = c * u - p * o
          , _ = f * o - l * u
          , w = t * g + r * v + n * _;
        if (w === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const S = 1 / w;
        return e[0] = g * S,
        e[1] = (n * f - p * r) * S,
        e[2] = (c * r - n * l) * S,
        e[3] = v * S,
        e[4] = (p * t - n * u) * S,
        e[5] = (n * o - c * t) * S,
        e[6] = _ * S,
        e[7] = (r * u - f * t) * S,
        e[8] = (l * t - r * o) * S,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, r, n, o, l, c) {
        const u = Math.cos(o)
          , f = Math.sin(o);
        return this.set(r * u, r * f, -r * (u * l + f * c) + l + e, -n * f, n * u, -n * (-f * l + u * c) + c + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(_m3.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(_m3.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(_m3.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(t, -r, 0, r, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , r = e.elements;
        for (let n = 0; n < 9; n++)
            if (t[n] !== r[n])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let r = 0; r < 9; r++)
            this.elements[r] = e[r + t];
        return this
    }
    toArray(e=[], t=0) {
        const r = this.elements;
        return e[t] = r[0],
        e[t + 1] = r[1],
        e[t + 2] = r[2],
        e[t + 3] = r[3],
        e[t + 4] = r[4],
        e[t + 5] = r[5],
        e[t + 6] = r[6],
        e[t + 7] = r[7],
        e[t + 8] = r[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const _m3 = new Matrix3;
function arrayNeedsUint32(a) {
    for (let e = a.length - 1; e >= 0; --e)
        if (a[e] >= 65535)
            return !0;
    return !1
}
function createElementNS(a) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", a)
}
function SRGBToLinear(a) {
    return a < .04045 ? a * .0773993808 : Math.pow(a * .9478672986 + .0521327014, 2.4)
}
function LinearToSRGB(a) {
    return a < .0031308 ? a * 12.92 : 1.055 * Math.pow(a, .41666) - .055
}
const FN = {
    [SRGBColorSpace]: {
        [LinearSRGBColorSpace]: SRGBToLinear
    },
    [LinearSRGBColorSpace]: {
        [SRGBColorSpace]: LinearToSRGB
    }
}
  , ColorManagement = {
    legacyMode: !0,
    get workingColorSpace() {
        return LinearSRGBColorSpace
    },
    set workingColorSpace(a) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
    },
    convert: function(a, e, t) {
        if (this.legacyMode || e === t || !e || !t)
            return a;
        if (FN[e] && FN[e][t] !== void 0) {
            const r = FN[e][t];
            return a.r = r(a.r),
            a.g = r(a.g),
            a.b = r(a.b),
            a
        }
        throw new Error("Unsupported color space conversion.")
    },
    fromWorkingColorSpace: function(a, e) {
        return this.convert(a, this.workingColorSpace, e)
    },
    toWorkingColorSpace: function(a, e) {
        return this.convert(a, e, this.workingColorSpace)
    }
}
  , _colorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , _rgb$1 = {
    r: 0,
    g: 0,
    b: 0
}
  , _hslA = {
    h: 0,
    s: 0,
    l: 0
}
  , _hslB = {
    h: 0,
    s: 0,
    l: 0
};
function hue2rgb(a, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? a + (e - a) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? a + (e - a) * 6 * (2 / 3 - t) : a
}
function toComponents(a, e) {
    return e.r = a.r,
    e.g = a.g,
    e.b = a.b,
    e
}
class Color {
    constructor(e, t, r) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        t === void 0 && r === void 0 ? this.set(e) : this.setRGB(e, t, r)
    }
    set(e) {
        return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e),
        this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=SRGBColorSpace) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        ColorManagement.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, r, n=ColorManagement.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = r,
        ColorManagement.toWorkingColorSpace(this, n),
        this
    }
    setHSL(e, t, r, n=ColorManagement.workingColorSpace) {
        if (e = euclideanModulo(e, 1),
        t = clamp$1(t, 0, 1),
        r = clamp$1(r, 0, 1),
        t === 0)
            this.r = this.g = this.b = r;
        else {
            const o = r <= .5 ? r * (1 + t) : r + t - r * t
              , l = 2 * r - o;
            this.r = hue2rgb(l, o, e + 1 / 3),
            this.g = hue2rgb(l, o, e),
            this.b = hue2rgb(l, o, e - 1 / 3)
        }
        return ColorManagement.toWorkingColorSpace(this, n),
        this
    }
    setStyle(e, t=SRGBColorSpace) {
        function r(o) {
            o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let n;
        if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
            let o;
            const l = n[1]
              , c = n[2];
            switch (l) {
            case "rgb":
            case "rgba":
                if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(c))
                    return this.r = Math.min(255, parseInt(o[1], 10)) / 255,
                    this.g = Math.min(255, parseInt(o[2], 10)) / 255,
                    this.b = Math.min(255, parseInt(o[3], 10)) / 255,
                    ColorManagement.toWorkingColorSpace(this, t),
                    r(o[4]),
                    this;
                if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(c))
                    return this.r = Math.min(100, parseInt(o[1], 10)) / 100,
                    this.g = Math.min(100, parseInt(o[2], 10)) / 100,
                    this.b = Math.min(100, parseInt(o[3], 10)) / 100,
                    ColorManagement.toWorkingColorSpace(this, t),
                    r(o[4]),
                    this;
                break;
            case "hsl":
            case "hsla":
                if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(c)) {
                    const u = parseFloat(o[1]) / 360
                      , f = parseFloat(o[2]) / 100
                      , p = parseFloat(o[3]) / 100;
                    return r(o[4]),
                    this.setHSL(u, f, p, t)
                }
                break
            }
        } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const o = n[1]
              , l = o.length;
            if (l === 3)
                return this.r = parseInt(o.charAt(0) + o.charAt(0), 16) / 255,
                this.g = parseInt(o.charAt(1) + o.charAt(1), 16) / 255,
                this.b = parseInt(o.charAt(2) + o.charAt(2), 16) / 255,
                ColorManagement.toWorkingColorSpace(this, t),
                this;
            if (l === 6)
                return this.r = parseInt(o.charAt(0) + o.charAt(1), 16) / 255,
                this.g = parseInt(o.charAt(2) + o.charAt(3), 16) / 255,
                this.b = parseInt(o.charAt(4) + o.charAt(5), 16) / 255,
                ColorManagement.toWorkingColorSpace(this, t),
                this
        }
        return e && e.length > 0 ? this.setColorName(e, t) : this
    }
    setColorName(e, t=SRGBColorSpace) {
        const r = _colorKeywords[e.toLowerCase()];
        return r !== void 0 ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = SRGBToLinear(e.r),
        this.g = SRGBToLinear(e.g),
        this.b = SRGBToLinear(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = LinearToSRGB(e.r),
        this.g = LinearToSRGB(e.g),
        this.b = LinearToSRGB(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=SRGBColorSpace) {
        return ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb$1), e),
        clamp$1(_rgb$1.r * 255, 0, 255) << 16 ^ clamp$1(_rgb$1.g * 255, 0, 255) << 8 ^ clamp$1(_rgb$1.b * 255, 0, 255) << 0
    }
    getHexString(e=SRGBColorSpace) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=ColorManagement.workingColorSpace) {
        ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb$1), t);
        const r = _rgb$1.r
          , n = _rgb$1.g
          , o = _rgb$1.b
          , l = Math.max(r, n, o)
          , c = Math.min(r, n, o);
        let u, f;
        const p = (c + l) / 2;
        if (c === l)
            u = 0,
            f = 0;
        else {
            const g = l - c;
            switch (f = p <= .5 ? g / (l + c) : g / (2 - l - c),
            l) {
            case r:
                u = (n - o) / g + (n < o ? 6 : 0);
                break;
            case n:
                u = (o - r) / g + 2;
                break;
            case o:
                u = (r - n) / g + 4;
                break
            }
            u /= 6
        }
        return e.h = u,
        e.s = f,
        e.l = p,
        e
    }
    getRGB(e, t=ColorManagement.workingColorSpace) {
        return ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb$1), t),
        e.r = _rgb$1.r,
        e.g = _rgb$1.g,
        e.b = _rgb$1.b,
        e
    }
    getStyle(e=SRGBColorSpace) {
        return ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb$1), e),
        e !== SRGBColorSpace ? `color(${e} ${_rgb$1.r} ${_rgb$1.g} ${_rgb$1.b})` : `rgb(${_rgb$1.r * 255 | 0},${_rgb$1.g * 255 | 0},${_rgb$1.b * 255 | 0})`
    }
    offsetHSL(e, t, r) {
        return this.getHSL(_hslA),
        _hslA.h += e,
        _hslA.s += t,
        _hslA.l += r,
        this.setHSL(_hslA.h, _hslA.s, _hslA.l),
        this
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, r) {
        return this.r = e.r + (t.r - e.r) * r,
        this.g = e.g + (t.g - e.g) * r,
        this.b = e.b + (t.b - e.b) * r,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(_hslA),
        e.getHSL(_hslB);
        const r = lerp(_hslA.h, _hslB.h, t)
          , n = lerp(_hslA.s, _hslB.s, t)
          , o = lerp(_hslA.l, _hslB.l, t);
        return this.setHSL(r, n, o),
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
Color.NAMES = _colorKeywords;
let _canvas;
class ImageUtils {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            _canvas === void 0 && (_canvas = createElementNS("canvas")),
            _canvas.width = e.width,
            _canvas.height = e.height;
            const r = _canvas.getContext("2d");
            e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height),
            t = _canvas
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = createElementNS("canvas");
            t.width = e.width,
            t.height = e.height;
            const r = t.getContext("2d");
            r.drawImage(e, 0, 0, e.width, e.height);
            const n = r.getImageData(0, 0, e.width, e.height)
              , o = n.data;
            for (let l = 0; l < o.length; l++)
                o[l] = SRGBToLinear(o[l] / 255) * 255;
            return r.putImageData(n, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let r = 0; r < t.length; r++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[r] = Math.floor(SRGBToLinear(t[r] / 255) * 255) : t[r] = SRGBToLinear(t[r]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
class Source {
    constructor(e=null) {
        this.isSource = !0,
        this.uuid = generateUUID(),
        this.data = e,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const r = {
            uuid: this.uuid,
            url: ""
        }
          , n = this.data;
        if (n !== null) {
            let o;
            if (Array.isArray(n)) {
                o = [];
                for (let l = 0, c = n.length; l < c; l++)
                    n[l].isDataTexture ? o.push(serializeImage(n[l].image)) : o.push(serializeImage(n[l]))
            } else
                o = serializeImage(n);
            r.url = o
        }
        return t || (e.images[this.uuid] = r),
        r
    }
}
function serializeImage(a) {
    return typeof HTMLImageElement < "u" && a instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && a instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && a instanceof ImageBitmap ? ImageUtils.getDataURL(a) : a.data ? {
        data: Array.from(a.data),
        width: a.width,
        height: a.height,
        type: a.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let textureId = 0;
class Texture extends EventDispatcher {
    constructor(e=Texture.DEFAULT_IMAGE, t=Texture.DEFAULT_MAPPING, r=ClampToEdgeWrapping, n=ClampToEdgeWrapping, o=LinearFilter, l=LinearMipmapLinearFilter, c=RGBAFormat, u=UnsignedByteType, f=Texture.DEFAULT_ANISOTROPY, p=LinearEncoding) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: textureId++
        }),
        this.uuid = generateUUID(),
        this.name = "",
        this.source = new Source(e),
        this.mipmaps = [],
        this.mapping = t,
        this.wrapS = r,
        this.wrapT = n,
        this.magFilter = o,
        this.minFilter = l,
        this.anisotropy = f,
        this.format = c,
        this.internalFormat = null,
        this.type = u,
        this.offset = new Vector2(0,0),
        this.repeat = new Vector2(1,1),
        this.center = new Vector2(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Matrix3,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = p,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.encoding = e.encoding,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const r = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        t || (e.textures[this.uuid] = r),
        r
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== UVMapping)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case RepeatWrapping:
                e.x = e.x - Math.floor(e.x);
                break;
            case ClampToEdgeWrapping:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case RepeatWrapping:
                e.y = e.y - Math.floor(e.y);
                break;
            case ClampToEdgeWrapping:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Vector4 {
    constructor(e=0, t=0, r=0, n=1) {
        Vector4.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = r,
        this.w = n
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, r, n) {
        return this.x = e,
        this.y = t,
        this.z = r,
        this.w = n,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , r = this.y
          , n = this.z
          , o = this.w
          , l = e.elements;
        return this.x = l[0] * t + l[4] * r + l[8] * n + l[12] * o,
        this.y = l[1] * t + l[5] * r + l[9] * n + l[13] * o,
        this.z = l[2] * t + l[6] * r + l[10] * n + l[14] * o,
        this.w = l[3] * t + l[7] * r + l[11] * n + l[15] * o,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, r, n, o;
        const u = e.elements
          , f = u[0]
          , p = u[4]
          , g = u[8]
          , v = u[1]
          , _ = u[5]
          , w = u[9]
          , S = u[2]
          , b = u[6]
          , C = u[10];
        if (Math.abs(p - v) < .01 && Math.abs(g - S) < .01 && Math.abs(w - b) < .01) {
            if (Math.abs(p + v) < .1 && Math.abs(g + S) < .1 && Math.abs(w + b) < .1 && Math.abs(f + _ + C - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const T = (f + 1) / 2
              , M = (_ + 1) / 2
              , P = (C + 1) / 2
              , I = (p + v) / 4
              , k = (g + S) / 4
              , A = (w + b) / 4;
            return T > M && T > P ? T < .01 ? (r = 0,
            n = .707106781,
            o = .707106781) : (r = Math.sqrt(T),
            n = I / r,
            o = k / r) : M > P ? M < .01 ? (r = .707106781,
            n = 0,
            o = .707106781) : (n = Math.sqrt(M),
            r = I / n,
            o = A / n) : P < .01 ? (r = .707106781,
            n = .707106781,
            o = 0) : (o = Math.sqrt(P),
            r = k / o,
            n = A / o),
            this.set(r, n, o, t),
            this
        }
        let R = Math.sqrt((b - w) * (b - w) + (g - S) * (g - S) + (v - p) * (v - p));
        return Math.abs(R) < .001 && (R = 1),
        this.x = (b - w) / R,
        this.y = (g - S) / R,
        this.z = (v - p) / R,
        this.w = Math.acos((f + _ + C - 1) / 2),
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this.z = e.z + (t.z - e.z) * r,
        this.w = e.w + (t.w - e.w) * r,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class WebGLRenderTarget extends EventDispatcher {
    constructor(e=1, t=1, r={}) {
        super(),
        this.isWebGLRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new Vector4(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Vector4(0,0,e,t);
        const n = {
            width: e,
            height: t,
            depth: 1
        };
        this.texture = new Texture(n,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.flipY = !1,
        this.texture.generateMipmaps = r.generateMipmaps !== void 0 ? r.generateMipmaps : !1,
        this.texture.internalFormat = r.internalFormat !== void 0 ? r.internalFormat : null,
        this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : LinearFilter,
        this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0,
        this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !1,
        this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null,
        this.samples = r.samples !== void 0 ? r.samples : 0
    }
    setSize(e, t, r=1) {
        (this.width !== e || this.height !== t || this.depth !== r) && (this.width = e,
        this.height = t,
        this.depth = r,
        this.texture.image.width = e,
        this.texture.image.height = t,
        this.texture.image.depth = r,
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.viewport.copy(e.viewport),
        this.texture = e.texture.clone(),
        this.texture.isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new Source(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class DataArrayTexture extends Texture {
    constructor(e=null, t=1, r=1, n=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: r,
            depth: n
        },
        this.magFilter = NearestFilter,
        this.minFilter = NearestFilter,
        this.wrapR = ClampToEdgeWrapping,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class Data3DTexture extends Texture {
    constructor(e=null, t=1, r=1, n=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: r,
            depth: n
        },
        this.magFilter = NearestFilter,
        this.minFilter = NearestFilter,
        this.wrapR = ClampToEdgeWrapping,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class Quaternion {
    constructor(e=0, t=0, r=0, n=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = r,
        this._w = n
    }
    static slerpFlat(e, t, r, n, o, l, c) {
        let u = r[n + 0]
          , f = r[n + 1]
          , p = r[n + 2]
          , g = r[n + 3];
        const v = o[l + 0]
          , _ = o[l + 1]
          , w = o[l + 2]
          , S = o[l + 3];
        if (c === 0) {
            e[t + 0] = u,
            e[t + 1] = f,
            e[t + 2] = p,
            e[t + 3] = g;
            return
        }
        if (c === 1) {
            e[t + 0] = v,
            e[t + 1] = _,
            e[t + 2] = w,
            e[t + 3] = S;
            return
        }
        if (g !== S || u !== v || f !== _ || p !== w) {
            let b = 1 - c;
            const C = u * v + f * _ + p * w + g * S
              , R = C >= 0 ? 1 : -1
              , T = 1 - C * C;
            if (T > Number.EPSILON) {
                const P = Math.sqrt(T)
                  , I = Math.atan2(P, C * R);
                b = Math.sin(b * I) / P,
                c = Math.sin(c * I) / P
            }
            const M = c * R;
            if (u = u * b + v * M,
            f = f * b + _ * M,
            p = p * b + w * M,
            g = g * b + S * M,
            b === 1 - c) {
                const P = 1 / Math.sqrt(u * u + f * f + p * p + g * g);
                u *= P,
                f *= P,
                p *= P,
                g *= P
            }
        }
        e[t] = u,
        e[t + 1] = f,
        e[t + 2] = p,
        e[t + 3] = g
    }
    static multiplyQuaternionsFlat(e, t, r, n, o, l) {
        const c = r[n]
          , u = r[n + 1]
          , f = r[n + 2]
          , p = r[n + 3]
          , g = o[l]
          , v = o[l + 1]
          , _ = o[l + 2]
          , w = o[l + 3];
        return e[t] = c * w + p * g + u * _ - f * v,
        e[t + 1] = u * w + p * v + f * g - c * _,
        e[t + 2] = f * w + p * _ + c * v - u * g,
        e[t + 3] = p * w - c * g - u * v - f * _,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, r, n) {
        return this._x = e,
        this._y = t,
        this._z = r,
        this._w = n,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t) {
        const r = e._x
          , n = e._y
          , o = e._z
          , l = e._order
          , c = Math.cos
          , u = Math.sin
          , f = c(r / 2)
          , p = c(n / 2)
          , g = c(o / 2)
          , v = u(r / 2)
          , _ = u(n / 2)
          , w = u(o / 2);
        switch (l) {
        case "XYZ":
            this._x = v * p * g + f * _ * w,
            this._y = f * _ * g - v * p * w,
            this._z = f * p * w + v * _ * g,
            this._w = f * p * g - v * _ * w;
            break;
        case "YXZ":
            this._x = v * p * g + f * _ * w,
            this._y = f * _ * g - v * p * w,
            this._z = f * p * w - v * _ * g,
            this._w = f * p * g + v * _ * w;
            break;
        case "ZXY":
            this._x = v * p * g - f * _ * w,
            this._y = f * _ * g + v * p * w,
            this._z = f * p * w + v * _ * g,
            this._w = f * p * g - v * _ * w;
            break;
        case "ZYX":
            this._x = v * p * g - f * _ * w,
            this._y = f * _ * g + v * p * w,
            this._z = f * p * w - v * _ * g,
            this._w = f * p * g + v * _ * w;
            break;
        case "YZX":
            this._x = v * p * g + f * _ * w,
            this._y = f * _ * g + v * p * w,
            this._z = f * p * w - v * _ * g,
            this._w = f * p * g - v * _ * w;
            break;
        case "XZY":
            this._x = v * p * g - f * _ * w,
            this._y = f * _ * g - v * p * w,
            this._z = f * p * w + v * _ * g,
            this._w = f * p * g + v * _ * w;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + l)
        }
        return t !== !1 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const r = t / 2
          , n = Math.sin(r);
        return this._x = e.x * n,
        this._y = e.y * n,
        this._z = e.z * n,
        this._w = Math.cos(r),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , r = t[0]
          , n = t[4]
          , o = t[8]
          , l = t[1]
          , c = t[5]
          , u = t[9]
          , f = t[2]
          , p = t[6]
          , g = t[10]
          , v = r + c + g;
        if (v > 0) {
            const _ = .5 / Math.sqrt(v + 1);
            this._w = .25 / _,
            this._x = (p - u) * _,
            this._y = (o - f) * _,
            this._z = (l - n) * _
        } else if (r > c && r > g) {
            const _ = 2 * Math.sqrt(1 + r - c - g);
            this._w = (p - u) / _,
            this._x = .25 * _,
            this._y = (n + l) / _,
            this._z = (o + f) / _
        } else if (c > g) {
            const _ = 2 * Math.sqrt(1 + c - r - g);
            this._w = (o - f) / _,
            this._x = (n + l) / _,
            this._y = .25 * _,
            this._z = (u + p) / _
        } else {
            const _ = 2 * Math.sqrt(1 + g - r - c);
            this._w = (l - n) / _,
            this._x = (o + f) / _,
            this._y = (u + p) / _,
            this._z = .25 * _
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let r = e.dot(t) + 1;
        return r < Number.EPSILON ? (r = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = r) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = r)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = r),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(clamp$1(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const r = this.angleTo(e);
        if (r === 0)
            return this;
        const n = Math.min(1, t / r);
        return this.slerp(e, n),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const r = e._x
          , n = e._y
          , o = e._z
          , l = e._w
          , c = t._x
          , u = t._y
          , f = t._z
          , p = t._w;
        return this._x = r * p + l * c + n * f - o * u,
        this._y = n * p + l * u + o * c - r * f,
        this._z = o * p + l * f + r * u - n * c,
        this._w = l * p - r * c - n * u - o * f,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const r = this._x
          , n = this._y
          , o = this._z
          , l = this._w;
        let c = l * e._w + r * e._x + n * e._y + o * e._z;
        if (c < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        c = -c) : this.copy(e),
        c >= 1)
            return this._w = l,
            this._x = r,
            this._y = n,
            this._z = o,
            this;
        const u = 1 - c * c;
        if (u <= Number.EPSILON) {
            const _ = 1 - t;
            return this._w = _ * l + t * this._w,
            this._x = _ * r + t * this._x,
            this._y = _ * n + t * this._y,
            this._z = _ * o + t * this._z,
            this.normalize(),
            this._onChangeCallback(),
            this
        }
        const f = Math.sqrt(u)
          , p = Math.atan2(f, c)
          , g = Math.sin((1 - t) * p) / f
          , v = Math.sin(t * p) / f;
        return this._w = l * g + this._w * v,
        this._x = r * g + this._x * v,
        this._y = n * g + this._y * v,
        this._z = o * g + this._z * v,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, r) {
        return this.copy(e).slerp(t, r)
    }
    random() {
        const e = Math.random()
          , t = Math.sqrt(1 - e)
          , r = Math.sqrt(e)
          , n = 2 * Math.PI * Math.random()
          , o = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(n), r * Math.sin(o), r * Math.cos(o), t * Math.sin(n))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class Vector3 {
    constructor(e=0, t=0, r=0) {
        Vector3.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = r
    }
    set(e, t, r) {
        return r === void 0 && (r = this.z),
        this.x = e,
        this.y = t,
        this.z = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(_quaternion$4.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(_quaternion$4.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , r = this.y
          , n = this.z
          , o = e.elements;
        return this.x = o[0] * t + o[3] * r + o[6] * n,
        this.y = o[1] * t + o[4] * r + o[7] * n,
        this.z = o[2] * t + o[5] * r + o[8] * n,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , r = this.y
          , n = this.z
          , o = e.elements
          , l = 1 / (o[3] * t + o[7] * r + o[11] * n + o[15]);
        return this.x = (o[0] * t + o[4] * r + o[8] * n + o[12]) * l,
        this.y = (o[1] * t + o[5] * r + o[9] * n + o[13]) * l,
        this.z = (o[2] * t + o[6] * r + o[10] * n + o[14]) * l,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , r = this.y
          , n = this.z
          , o = e.x
          , l = e.y
          , c = e.z
          , u = e.w
          , f = u * t + l * n - c * r
          , p = u * r + c * t - o * n
          , g = u * n + o * r - l * t
          , v = -o * t - l * r - c * n;
        return this.x = f * u + v * -o + p * -c - g * -l,
        this.y = p * u + v * -l + g * -o - f * -c,
        this.z = g * u + v * -c + f * -l - p * -o,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , r = this.y
          , n = this.z
          , o = e.elements;
        return this.x = o[0] * t + o[4] * r + o[8] * n,
        this.y = o[1] * t + o[5] * r + o[9] * n,
        this.z = o[2] * t + o[6] * r + o[10] * n,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this.z = e.z + (t.z - e.z) * r,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const r = e.x
          , n = e.y
          , o = e.z
          , l = t.x
          , c = t.y
          , u = t.z;
        return this.x = n * u - o * c,
        this.y = o * l - r * u,
        this.z = r * c - n * l,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const r = e.dot(this) / t;
        return this.copy(e).multiplyScalar(r)
    }
    projectOnPlane(e) {
        return _vector$c.copy(this).projectOnVector(e),
        this.sub(_vector$c)
    }
    reflect(e) {
        return this.sub(_vector$c.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const r = this.dot(e) / t;
        return Math.acos(clamp$1(r, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , r = this.y - e.y
          , n = this.z - e.z;
        return t * t + r * r + n * n
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, r) {
        const n = Math.sin(t) * e;
        return this.x = n * Math.sin(r),
        this.y = Math.cos(t) * e,
        this.z = n * Math.cos(r),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, r) {
        return this.x = e * Math.sin(t),
        this.y = r,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , r = this.setFromMatrixColumn(e, 1).length()
          , n = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = r,
        this.z = n,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = (Math.random() - .5) * 2
          , t = Math.random() * Math.PI * 2
          , r = Math.sqrt(1 - e ** 2);
        return this.x = r * Math.cos(t),
        this.y = r * Math.sin(t),
        this.z = e,
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const _vector$c = new Vector3
  , _quaternion$4 = new Quaternion;
class Box3 {
    constructor(e=new Vector3(1 / 0,1 / 0,1 / 0), t=new Vector3(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        let t = 1 / 0
          , r = 1 / 0
          , n = 1 / 0
          , o = -1 / 0
          , l = -1 / 0
          , c = -1 / 0;
        for (let u = 0, f = e.length; u < f; u += 3) {
            const p = e[u]
              , g = e[u + 1]
              , v = e[u + 2];
            p < t && (t = p),
            g < r && (r = g),
            v < n && (n = v),
            p > o && (o = p),
            g > l && (l = g),
            v > c && (c = v)
        }
        return this.min.set(t, r, n),
        this.max.set(o, l, c),
        this
    }
    setFromBufferAttribute(e) {
        let t = 1 / 0
          , r = 1 / 0
          , n = 1 / 0
          , o = -1 / 0
          , l = -1 / 0
          , c = -1 / 0;
        for (let u = 0, f = e.count; u < f; u++) {
            const p = e.getX(u)
              , g = e.getY(u)
              , v = e.getZ(u);
            p < t && (t = p),
            g < r && (r = g),
            v < n && (n = v),
            p > o && (o = p),
            g > l && (l = g),
            v > c && (c = v)
        }
        return this.min.set(t, r, n),
        this.max.set(o, l, c),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, r = e.length; t < r; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const r = _vector$b.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(r),
        this.max.copy(e).add(r),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const r = e.geometry;
        if (r !== void 0)
            if (t && r.attributes != null && r.attributes.position !== void 0) {
                const o = r.attributes.position;
                for (let l = 0, c = o.count; l < c; l++)
                    _vector$b.fromBufferAttribute(o, l).applyMatrix4(e.matrixWorld),
                    this.expandByPoint(_vector$b)
            } else
                r.boundingBox === null && r.computeBoundingBox(),
                _box$3.copy(r.boundingBox),
                _box$3.applyMatrix4(e.matrixWorld),
                this.union(_box$3);
        const n = e.children;
        for (let o = 0, l = n.length; o < l; o++)
            this.expandByObject(n[o], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, _vector$b),
        _vector$b.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, r;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        r = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        r += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        r += e.normal.z * this.min.z),
        t <= -e.constant && r >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(_center),
        _extents.subVectors(this.max, _center),
        _v0$2$1.subVectors(e.a, _center),
        _v1$7.subVectors(e.b, _center),
        _v2$4.subVectors(e.c, _center),
        _f0.subVectors(_v1$7, _v0$2$1),
        _f1.subVectors(_v2$4, _v1$7),
        _f2.subVectors(_v0$2$1, _v2$4);
        let t = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
        return !satForAxes(t, _v0$2$1, _v1$7, _v2$4, _extents) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !satForAxes(t, _v0$2$1, _v1$7, _v2$4, _extents)) ? !1 : (_triangleNormal.crossVectors(_f0, _f1),
        t = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z],
        satForAxes(t, _v0$2$1, _v1$7, _v2$4, _extents))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return _vector$b.copy(e).clamp(this.min, this.max).sub(e).length()
    }
    getBoundingSphere(e) {
        return this.getCenter(e.center),
        e.radius = this.getSize(_vector$b).length() * .5,
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(_points),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const _points = [new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3]
  , _vector$b = new Vector3
  , _box$3 = new Box3
  , _v0$2$1 = new Vector3
  , _v1$7 = new Vector3
  , _v2$4 = new Vector3
  , _f0 = new Vector3
  , _f1 = new Vector3
  , _f2 = new Vector3
  , _center = new Vector3
  , _extents = new Vector3
  , _triangleNormal = new Vector3
  , _testAxis = new Vector3;
function satForAxes(a, e, t, r, n) {
    for (let o = 0, l = a.length - 3; o <= l; o += 3) {
        _testAxis.fromArray(a, o);
        const c = n.x * Math.abs(_testAxis.x) + n.y * Math.abs(_testAxis.y) + n.z * Math.abs(_testAxis.z)
          , u = e.dot(_testAxis)
          , f = t.dot(_testAxis)
          , p = r.dot(_testAxis);
        if (Math.max(-Math.max(u, f, p), Math.min(u, f, p)) > c)
            return !1
    }
    return !0
}
const _box$2 = new Box3
  , _v1$6$1 = new Vector3
  , _v2$3 = new Vector3;
class Sphere {
    constructor(e=new Vector3, t=-1) {
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const r = this.center;
        t !== void 0 ? r.copy(t) : _box$2.setFromPoints(e).getCenter(r);
        let n = 0;
        for (let o = 0, l = e.length; o < l; o++)
            n = Math.max(n, r.distanceToSquared(e[o]));
        return this.radius = Math.sqrt(n),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const r = this.center.distanceToSquared(e);
        return t.copy(e),
        r > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        _v1$6$1.subVectors(e, this.center);
        const t = _v1$6$1.lengthSq();
        if (t > this.radius * this.radius) {
            const r = Math.sqrt(t)
              , n = (r - this.radius) * .5;
            this.center.addScaledVector(_v1$6$1, n / r),
            this.radius += n
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (_v2$3.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(_v1$6$1.copy(e.center).add(_v2$3)),
        this.expandByPoint(_v1$6$1.copy(e.center).sub(_v2$3))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const _vector$a = new Vector3
  , _segCenter = new Vector3
  , _segDir = new Vector3
  , _diff = new Vector3
  , _edge1 = new Vector3
  , _edge2 = new Vector3
  , _normal$1 = new Vector3;
class Ray {
    constructor(e=new Vector3, t=new Vector3(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.direction).multiplyScalar(e).add(this.origin)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, _vector$a)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const r = t.dot(this.direction);
        return r < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(r).add(this.origin)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = _vector$a.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (_vector$a.copy(this.direction).multiplyScalar(t).add(this.origin),
        _vector$a.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, r, n) {
        _segCenter.copy(e).add(t).multiplyScalar(.5),
        _segDir.copy(t).sub(e).normalize(),
        _diff.copy(this.origin).sub(_segCenter);
        const o = e.distanceTo(t) * .5
          , l = -this.direction.dot(_segDir)
          , c = _diff.dot(this.direction)
          , u = -_diff.dot(_segDir)
          , f = _diff.lengthSq()
          , p = Math.abs(1 - l * l);
        let g, v, _, w;
        if (p > 0)
            if (g = l * u - c,
            v = l * c - u,
            w = o * p,
            g >= 0)
                if (v >= -w)
                    if (v <= w) {
                        const S = 1 / p;
                        g *= S,
                        v *= S,
                        _ = g * (g + l * v + 2 * c) + v * (l * g + v + 2 * u) + f
                    } else
                        v = o,
                        g = Math.max(0, -(l * v + c)),
                        _ = -g * g + v * (v + 2 * u) + f;
                else
                    v = -o,
                    g = Math.max(0, -(l * v + c)),
                    _ = -g * g + v * (v + 2 * u) + f;
            else
                v <= -w ? (g = Math.max(0, -(-l * o + c)),
                v = g > 0 ? -o : Math.min(Math.max(-o, -u), o),
                _ = -g * g + v * (v + 2 * u) + f) : v <= w ? (g = 0,
                v = Math.min(Math.max(-o, -u), o),
                _ = v * (v + 2 * u) + f) : (g = Math.max(0, -(l * o + c)),
                v = g > 0 ? o : Math.min(Math.max(-o, -u), o),
                _ = -g * g + v * (v + 2 * u) + f);
        else
            v = l > 0 ? -o : o,
            g = Math.max(0, -(l * v + c)),
            _ = -g * g + v * (v + 2 * u) + f;
        return r && r.copy(this.direction).multiplyScalar(g).add(this.origin),
        n && n.copy(_segDir).multiplyScalar(v).add(_segCenter),
        _
    }
    intersectSphere(e, t) {
        _vector$a.subVectors(e.center, this.origin);
        const r = _vector$a.dot(this.direction)
          , n = _vector$a.dot(_vector$a) - r * r
          , o = e.radius * e.radius;
        if (n > o)
            return null;
        const l = Math.sqrt(o - n)
          , c = r - l
          , u = r + l;
        return c < 0 && u < 0 ? null : c < 0 ? this.at(u, t) : this.at(c, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const r = -(this.origin.dot(e.normal) + e.constant) / t;
        return r >= 0 ? r : null
    }
    intersectPlane(e, t) {
        const r = this.distanceToPlane(e);
        return r === null ? null : this.at(r, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let r, n, o, l, c, u;
        const f = 1 / this.direction.x
          , p = 1 / this.direction.y
          , g = 1 / this.direction.z
          , v = this.origin;
        return f >= 0 ? (r = (e.min.x - v.x) * f,
        n = (e.max.x - v.x) * f) : (r = (e.max.x - v.x) * f,
        n = (e.min.x - v.x) * f),
        p >= 0 ? (o = (e.min.y - v.y) * p,
        l = (e.max.y - v.y) * p) : (o = (e.max.y - v.y) * p,
        l = (e.min.y - v.y) * p),
        r > l || o > n || ((o > r || isNaN(r)) && (r = o),
        (l < n || isNaN(n)) && (n = l),
        g >= 0 ? (c = (e.min.z - v.z) * g,
        u = (e.max.z - v.z) * g) : (c = (e.max.z - v.z) * g,
        u = (e.min.z - v.z) * g),
        r > u || c > n) || ((c > r || r !== r) && (r = c),
        (u < n || n !== n) && (n = u),
        n < 0) ? null : this.at(r >= 0 ? r : n, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, _vector$a) !== null
    }
    intersectTriangle(e, t, r, n, o) {
        _edge1.subVectors(t, e),
        _edge2.subVectors(r, e),
        _normal$1.crossVectors(_edge1, _edge2);
        let l = this.direction.dot(_normal$1), c;
        if (l > 0) {
            if (n)
                return null;
            c = 1
        } else if (l < 0)
            c = -1,
            l = -l;
        else
            return null;
        _diff.subVectors(this.origin, e);
        const u = c * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        if (u < 0)
            return null;
        const f = c * this.direction.dot(_edge1.cross(_diff));
        if (f < 0 || u + f > l)
            return null;
        const p = -c * _diff.dot(_normal$1);
        return p < 0 ? null : this.at(p / l, o)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Matrix4 {
    constructor() {
        Matrix4.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }
    set(e, t, r, n, o, l, c, u, f, p, g, v, _, w, S, b) {
        const C = this.elements;
        return C[0] = e,
        C[4] = t,
        C[8] = r,
        C[12] = n,
        C[1] = o,
        C[5] = l,
        C[9] = c,
        C[13] = u,
        C[2] = f,
        C[6] = p,
        C[10] = g,
        C[14] = v,
        C[3] = _,
        C[7] = w,
        C[11] = S,
        C[15] = b,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new Matrix4().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , r = e.elements;
        return t[0] = r[0],
        t[1] = r[1],
        t[2] = r[2],
        t[3] = r[3],
        t[4] = r[4],
        t[5] = r[5],
        t[6] = r[6],
        t[7] = r[7],
        t[8] = r[8],
        t[9] = r[9],
        t[10] = r[10],
        t[11] = r[11],
        t[12] = r[12],
        t[13] = r[13],
        t[14] = r[14],
        t[15] = r[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , r = e.elements;
        return t[12] = r[12],
        t[13] = r[13],
        t[14] = r[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, r) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        r.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, r) {
        return this.set(e.x, t.x, r.x, 0, e.y, t.y, r.y, 0, e.z, t.z, r.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , r = e.elements
          , n = 1 / _v1$5$1.setFromMatrixColumn(e, 0).length()
          , o = 1 / _v1$5$1.setFromMatrixColumn(e, 1).length()
          , l = 1 / _v1$5$1.setFromMatrixColumn(e, 2).length();
        return t[0] = r[0] * n,
        t[1] = r[1] * n,
        t[2] = r[2] * n,
        t[3] = 0,
        t[4] = r[4] * o,
        t[5] = r[5] * o,
        t[6] = r[6] * o,
        t[7] = 0,
        t[8] = r[8] * l,
        t[9] = r[9] * l,
        t[10] = r[10] * l,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , r = e.x
          , n = e.y
          , o = e.z
          , l = Math.cos(r)
          , c = Math.sin(r)
          , u = Math.cos(n)
          , f = Math.sin(n)
          , p = Math.cos(o)
          , g = Math.sin(o);
        if (e.order === "XYZ") {
            const v = l * p
              , _ = l * g
              , w = c * p
              , S = c * g;
            t[0] = u * p,
            t[4] = -u * g,
            t[8] = f,
            t[1] = _ + w * f,
            t[5] = v - S * f,
            t[9] = -c * u,
            t[2] = S - v * f,
            t[6] = w + _ * f,
            t[10] = l * u
        } else if (e.order === "YXZ") {
            const v = u * p
              , _ = u * g
              , w = f * p
              , S = f * g;
            t[0] = v + S * c,
            t[4] = w * c - _,
            t[8] = l * f,
            t[1] = l * g,
            t[5] = l * p,
            t[9] = -c,
            t[2] = _ * c - w,
            t[6] = S + v * c,
            t[10] = l * u
        } else if (e.order === "ZXY") {
            const v = u * p
              , _ = u * g
              , w = f * p
              , S = f * g;
            t[0] = v - S * c,
            t[4] = -l * g,
            t[8] = w + _ * c,
            t[1] = _ + w * c,
            t[5] = l * p,
            t[9] = S - v * c,
            t[2] = -l * f,
            t[6] = c,
            t[10] = l * u
        } else if (e.order === "ZYX") {
            const v = l * p
              , _ = l * g
              , w = c * p
              , S = c * g;
            t[0] = u * p,
            t[4] = w * f - _,
            t[8] = v * f + S,
            t[1] = u * g,
            t[5] = S * f + v,
            t[9] = _ * f - w,
            t[2] = -f,
            t[6] = c * u,
            t[10] = l * u
        } else if (e.order === "YZX") {
            const v = l * u
              , _ = l * f
              , w = c * u
              , S = c * f;
            t[0] = u * p,
            t[4] = S - v * g,
            t[8] = w * g + _,
            t[1] = g,
            t[5] = l * p,
            t[9] = -c * p,
            t[2] = -f * p,
            t[6] = _ * g + w,
            t[10] = v - S * g
        } else if (e.order === "XZY") {
            const v = l * u
              , _ = l * f
              , w = c * u
              , S = c * f;
            t[0] = u * p,
            t[4] = -g,
            t[8] = f * p,
            t[1] = v * g + S,
            t[5] = l * p,
            t[9] = _ * g - w,
            t[2] = w * g - _,
            t[6] = c * p,
            t[10] = S * g + v
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(_zero, e, _one)
    }
    lookAt(e, t, r) {
        const n = this.elements;
        return _z.subVectors(e, t),
        _z.lengthSq() === 0 && (_z.z = 1),
        _z.normalize(),
        _x.crossVectors(r, _z),
        _x.lengthSq() === 0 && (Math.abs(r.z) === 1 ? _z.x += 1e-4 : _z.z += 1e-4,
        _z.normalize(),
        _x.crossVectors(r, _z)),
        _x.normalize(),
        _y.crossVectors(_z, _x),
        n[0] = _x.x,
        n[4] = _y.x,
        n[8] = _z.x,
        n[1] = _x.y,
        n[5] = _y.y,
        n[9] = _z.y,
        n[2] = _x.z,
        n[6] = _y.z,
        n[10] = _z.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const r = e.elements
          , n = t.elements
          , o = this.elements
          , l = r[0]
          , c = r[4]
          , u = r[8]
          , f = r[12]
          , p = r[1]
          , g = r[5]
          , v = r[9]
          , _ = r[13]
          , w = r[2]
          , S = r[6]
          , b = r[10]
          , C = r[14]
          , R = r[3]
          , T = r[7]
          , M = r[11]
          , P = r[15]
          , I = n[0]
          , k = n[4]
          , A = n[8]
          , O = n[12]
          , W = n[1]
          , Q = n[5]
          , H = n[9]
          , B = n[13]
          , D = n[2]
          , q = n[6]
          , V = n[10]
          , J = n[14]
          , U = n[3]
          , ce = n[7]
          , ee = n[11]
          , ne = n[15];
        return o[0] = l * I + c * W + u * D + f * U,
        o[4] = l * k + c * Q + u * q + f * ce,
        o[8] = l * A + c * H + u * V + f * ee,
        o[12] = l * O + c * B + u * J + f * ne,
        o[1] = p * I + g * W + v * D + _ * U,
        o[5] = p * k + g * Q + v * q + _ * ce,
        o[9] = p * A + g * H + v * V + _ * ee,
        o[13] = p * O + g * B + v * J + _ * ne,
        o[2] = w * I + S * W + b * D + C * U,
        o[6] = w * k + S * Q + b * q + C * ce,
        o[10] = w * A + S * H + b * V + C * ee,
        o[14] = w * O + S * B + b * J + C * ne,
        o[3] = R * I + T * W + M * D + P * U,
        o[7] = R * k + T * Q + M * q + P * ce,
        o[11] = R * A + T * H + M * V + P * ee,
        o[15] = R * O + T * B + M * J + P * ne,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , r = e[4]
          , n = e[8]
          , o = e[12]
          , l = e[1]
          , c = e[5]
          , u = e[9]
          , f = e[13]
          , p = e[2]
          , g = e[6]
          , v = e[10]
          , _ = e[14]
          , w = e[3]
          , S = e[7]
          , b = e[11]
          , C = e[15];
        return w * (+o * u * g - n * f * g - o * c * v + r * f * v + n * c * _ - r * u * _) + S * (+t * u * _ - t * f * v + o * l * v - n * l * _ + n * f * p - o * u * p) + b * (+t * f * g - t * c * _ - o * l * g + r * l * _ + o * c * p - r * f * p) + C * (-n * c * p - t * u * g + t * c * v + n * l * g - r * l * v + r * u * p)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, r) {
        const n = this.elements;
        return e.isVector3 ? (n[12] = e.x,
        n[13] = e.y,
        n[14] = e.z) : (n[12] = e,
        n[13] = t,
        n[14] = r),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , r = e[1]
          , n = e[2]
          , o = e[3]
          , l = e[4]
          , c = e[5]
          , u = e[6]
          , f = e[7]
          , p = e[8]
          , g = e[9]
          , v = e[10]
          , _ = e[11]
          , w = e[12]
          , S = e[13]
          , b = e[14]
          , C = e[15]
          , R = g * b * f - S * v * f + S * u * _ - c * b * _ - g * u * C + c * v * C
          , T = w * v * f - p * b * f - w * u * _ + l * b * _ + p * u * C - l * v * C
          , M = p * S * f - w * g * f + w * c * _ - l * S * _ - p * c * C + l * g * C
          , P = w * g * u - p * S * u - w * c * v + l * S * v + p * c * b - l * g * b
          , I = t * R + r * T + n * M + o * P;
        if (I === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const k = 1 / I;
        return e[0] = R * k,
        e[1] = (S * v * o - g * b * o - S * n * _ + r * b * _ + g * n * C - r * v * C) * k,
        e[2] = (c * b * o - S * u * o + S * n * f - r * b * f - c * n * C + r * u * C) * k,
        e[3] = (g * u * o - c * v * o - g * n * f + r * v * f + c * n * _ - r * u * _) * k,
        e[4] = T * k,
        e[5] = (p * b * o - w * v * o + w * n * _ - t * b * _ - p * n * C + t * v * C) * k,
        e[6] = (w * u * o - l * b * o - w * n * f + t * b * f + l * n * C - t * u * C) * k,
        e[7] = (l * v * o - p * u * o + p * n * f - t * v * f - l * n * _ + t * u * _) * k,
        e[8] = M * k,
        e[9] = (w * g * o - p * S * o - w * r * _ + t * S * _ + p * r * C - t * g * C) * k,
        e[10] = (l * S * o - w * c * o + w * r * f - t * S * f - l * r * C + t * c * C) * k,
        e[11] = (p * c * o - l * g * o - p * r * f + t * g * f + l * r * _ - t * c * _) * k,
        e[12] = P * k,
        e[13] = (p * S * n - w * g * n + w * r * v - t * S * v - p * r * b + t * g * b) * k,
        e[14] = (w * c * n - l * S * n - w * r * u + t * S * u + l * r * b - t * c * b) * k,
        e[15] = (l * g * n - p * c * n + p * r * u - t * g * u - l * r * v + t * c * v) * k,
        this
    }
    scale(e) {
        const t = this.elements
          , r = e.x
          , n = e.y
          , o = e.z;
        return t[0] *= r,
        t[4] *= n,
        t[8] *= o,
        t[1] *= r,
        t[5] *= n,
        t[9] *= o,
        t[2] *= r,
        t[6] *= n,
        t[10] *= o,
        t[3] *= r,
        t[7] *= n,
        t[11] *= o,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, r, n))
    }
    makeTranslation(e, t, r) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const r = Math.cos(t)
          , n = Math.sin(t)
          , o = 1 - r
          , l = e.x
          , c = e.y
          , u = e.z
          , f = o * l
          , p = o * c;
        return this.set(f * l + r, f * c - n * u, f * u + n * c, 0, f * c + n * u, p * c + r, p * u - n * l, 0, f * u - n * c, p * u + n * l, o * u * u + r, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, r) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, r, n, o, l) {
        return this.set(1, r, o, 0, e, 1, l, 0, t, n, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, r) {
        const n = this.elements
          , o = t._x
          , l = t._y
          , c = t._z
          , u = t._w
          , f = o + o
          , p = l + l
          , g = c + c
          , v = o * f
          , _ = o * p
          , w = o * g
          , S = l * p
          , b = l * g
          , C = c * g
          , R = u * f
          , T = u * p
          , M = u * g
          , P = r.x
          , I = r.y
          , k = r.z;
        return n[0] = (1 - (S + C)) * P,
        n[1] = (_ + M) * P,
        n[2] = (w - T) * P,
        n[3] = 0,
        n[4] = (_ - M) * I,
        n[5] = (1 - (v + C)) * I,
        n[6] = (b + R) * I,
        n[7] = 0,
        n[8] = (w + T) * k,
        n[9] = (b - R) * k,
        n[10] = (1 - (v + S)) * k,
        n[11] = 0,
        n[12] = e.x,
        n[13] = e.y,
        n[14] = e.z,
        n[15] = 1,
        this
    }
    decompose(e, t, r) {
        const n = this.elements;
        let o = _v1$5$1.set(n[0], n[1], n[2]).length();
        const l = _v1$5$1.set(n[4], n[5], n[6]).length()
          , c = _v1$5$1.set(n[8], n[9], n[10]).length();
        this.determinant() < 0 && (o = -o),
        e.x = n[12],
        e.y = n[13],
        e.z = n[14],
        _m1$2.copy(this);
        const f = 1 / o
          , p = 1 / l
          , g = 1 / c;
        return _m1$2.elements[0] *= f,
        _m1$2.elements[1] *= f,
        _m1$2.elements[2] *= f,
        _m1$2.elements[4] *= p,
        _m1$2.elements[5] *= p,
        _m1$2.elements[6] *= p,
        _m1$2.elements[8] *= g,
        _m1$2.elements[9] *= g,
        _m1$2.elements[10] *= g,
        t.setFromRotationMatrix(_m1$2),
        r.x = o,
        r.y = l,
        r.z = c,
        this
    }
    makePerspective(e, t, r, n, o, l) {
        const c = this.elements
          , u = 2 * o / (t - e)
          , f = 2 * o / (r - n)
          , p = (t + e) / (t - e)
          , g = (r + n) / (r - n)
          , v = -(l + o) / (l - o)
          , _ = -2 * l * o / (l - o);
        return c[0] = u,
        c[4] = 0,
        c[8] = p,
        c[12] = 0,
        c[1] = 0,
        c[5] = f,
        c[9] = g,
        c[13] = 0,
        c[2] = 0,
        c[6] = 0,
        c[10] = v,
        c[14] = _,
        c[3] = 0,
        c[7] = 0,
        c[11] = -1,
        c[15] = 0,
        this
    }
    makeOrthographic(e, t, r, n, o, l) {
        const c = this.elements
          , u = 1 / (t - e)
          , f = 1 / (r - n)
          , p = 1 / (l - o)
          , g = (t + e) * u
          , v = (r + n) * f
          , _ = (l + o) * p;
        return c[0] = 2 * u,
        c[4] = 0,
        c[8] = 0,
        c[12] = -g,
        c[1] = 0,
        c[5] = 2 * f,
        c[9] = 0,
        c[13] = -v,
        c[2] = 0,
        c[6] = 0,
        c[10] = -2 * p,
        c[14] = -_,
        c[3] = 0,
        c[7] = 0,
        c[11] = 0,
        c[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , r = e.elements;
        for (let n = 0; n < 16; n++)
            if (t[n] !== r[n])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let r = 0; r < 16; r++)
            this.elements[r] = e[r + t];
        return this
    }
    toArray(e=[], t=0) {
        const r = this.elements;
        return e[t] = r[0],
        e[t + 1] = r[1],
        e[t + 2] = r[2],
        e[t + 3] = r[3],
        e[t + 4] = r[4],
        e[t + 5] = r[5],
        e[t + 6] = r[6],
        e[t + 7] = r[7],
        e[t + 8] = r[8],
        e[t + 9] = r[9],
        e[t + 10] = r[10],
        e[t + 11] = r[11],
        e[t + 12] = r[12],
        e[t + 13] = r[13],
        e[t + 14] = r[14],
        e[t + 15] = r[15],
        e
    }
}
const _v1$5$1 = new Vector3
  , _m1$2 = new Matrix4
  , _zero = new Vector3(0,0,0)
  , _one = new Vector3(1,1,1)
  , _x = new Vector3
  , _y = new Vector3
  , _z = new Vector3
  , _matrix$1 = new Matrix4
  , _quaternion$3 = new Quaternion;
class Euler {
    constructor(e=0, t=0, r=0, n=Euler.DefaultOrder) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = r,
        this._order = n
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, r, n=this._order) {
        return this._x = e,
        this._y = t,
        this._z = r,
        this._order = n,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, r=!0) {
        const n = e.elements
          , o = n[0]
          , l = n[4]
          , c = n[8]
          , u = n[1]
          , f = n[5]
          , p = n[9]
          , g = n[2]
          , v = n[6]
          , _ = n[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(clamp$1(c, -1, 1)),
            Math.abs(c) < .9999999 ? (this._x = Math.atan2(-p, _),
            this._z = Math.atan2(-l, o)) : (this._x = Math.atan2(v, f),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-clamp$1(p, -1, 1)),
            Math.abs(p) < .9999999 ? (this._y = Math.atan2(c, _),
            this._z = Math.atan2(u, f)) : (this._y = Math.atan2(-g, o),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(clamp$1(v, -1, 1)),
            Math.abs(v) < .9999999 ? (this._y = Math.atan2(-g, _),
            this._z = Math.atan2(-l, f)) : (this._y = 0,
            this._z = Math.atan2(u, o));
            break;
        case "ZYX":
            this._y = Math.asin(-clamp$1(g, -1, 1)),
            Math.abs(g) < .9999999 ? (this._x = Math.atan2(v, _),
            this._z = Math.atan2(u, o)) : (this._x = 0,
            this._z = Math.atan2(-l, f));
            break;
        case "YZX":
            this._z = Math.asin(clamp$1(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._x = Math.atan2(-p, f),
            this._y = Math.atan2(-g, o)) : (this._x = 0,
            this._y = Math.atan2(c, _));
            break;
        case "XZY":
            this._z = Math.asin(-clamp$1(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(v, f),
            this._y = Math.atan2(c, o)) : (this._x = Math.atan2(-p, _),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        r === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, r) {
        return _matrix$1.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(_matrix$1, t, r)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return _quaternion$3.setFromEuler(this),
        this.setFromQuaternion(_quaternion$3, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
    toVector3() {
        console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
    }
}
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Layers {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let _object3DId = 0;
const _v1$4$1 = new Vector3
  , _q1$3 = new Quaternion
  , _m1$1 = new Matrix4
  , _target = new Vector3
  , _position$3 = new Vector3
  , _scale$2 = new Vector3
  , _quaternion$2 = new Quaternion
  , _xAxis = new Vector3(1,0,0)
  , _yAxis = new Vector3(0,1,0)
  , _zAxis = new Vector3(0,0,1)
  , _addedEvent = {
    type: "added"
}
  , _removedEvent = {
    type: "removed"
};
class Object3D extends EventDispatcher {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: _object3DId++
        }),
        this.uuid = generateUUID(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Object3D.DefaultUp.clone();
        const e = new Vector3
          , t = new Euler
          , r = new Quaternion
          , n = new Vector3(1,1,1);
        function o() {
            r.setFromEuler(t, !1)
        }
        function l() {
            t.setFromQuaternion(r, void 0, !1)
        }
        t._onChange(o),
        r._onChange(l),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            modelViewMatrix: {
                value: new Matrix4
            },
            normalMatrix: {
                value: new Matrix3
            }
        }),
        this.matrix = new Matrix4,
        this.matrixWorld = new Matrix4,
        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.matrixWorldAutoUpdate = Object3D.DefaultMatrixWorldAutoUpdate,
        this.layers = new Layers,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return _q1$3.setFromAxisAngle(e, t),
        this.quaternion.multiply(_q1$3),
        this
    }
    rotateOnWorldAxis(e, t) {
        return _q1$3.setFromAxisAngle(e, t),
        this.quaternion.premultiply(_q1$3),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(_xAxis, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(_yAxis, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(_zAxis, e)
    }
    translateOnAxis(e, t) {
        return _v1$4$1.copy(e).applyQuaternion(this.quaternion),
        this.position.add(_v1$4$1.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(_xAxis, e)
    }
    translateY(e) {
        return this.translateOnAxis(_yAxis, e)
    }
    translateZ(e) {
        return this.translateOnAxis(_zAxis, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(_m1$1.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, r) {
        e.isVector3 ? _target.copy(e) : _target.set(e, t, r);
        const n = this.parent;
        this.updateWorldMatrix(!0, !1),
        _position$3.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? _m1$1.lookAt(_position$3, _target, this.up) : _m1$1.lookAt(_target, _position$3, this.up),
        this.quaternion.setFromRotationMatrix(_m1$1),
        n && (_m1$1.extractRotation(n.matrixWorld),
        _q1$3.setFromRotationMatrix(_m1$1),
        this.quaternion.premultiply(_q1$3.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(_addedEvent)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let r = 0; r < arguments.length; r++)
                this.remove(arguments[r]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(_removedEvent)),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            t.parent = null,
            t.dispatchEvent(_removedEvent)
        }
        return this.children.length = 0,
        this
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        _m1$1.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        _m1$1.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(_m1$1),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let r = 0, n = this.children.length; r < n; r++) {
            const l = this.children[r].getObjectByProperty(e, t);
            if (l !== void 0)
                return l
        }
    }
    getObjectsByProperty(e, t) {
        let r = [];
        this[e] === t && r.push(this);
        for (let n = 0, o = this.children.length; n < o; n++) {
            const l = this.children[n].getObjectsByProperty(e, t);
            l.length > 0 && (r = r.concat(l))
        }
        return r
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(_position$3, e, _scale$2),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(_position$3, _quaternion$2, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let r = 0, n = t.length; r < n; r++)
            t[r].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let r = 0, n = t.length; r < n; r++)
            t[r].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let r = 0, n = t.length; r < n; r++) {
            const o = t[r];
            (o.matrixWorldAutoUpdate === !0 || e === !0) && o.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const r = this.parent;
        if (e === !0 && r !== null && r.matrixWorldAutoUpdate === !0 && r.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        t === !0) {
            const n = this.children;
            for (let o = 0, l = n.length; o < l; o++) {
                const c = n[o];
                c.matrixWorldAutoUpdate === !0 && c.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , r = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        r.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const n = {};
        n.uuid = this.uuid,
        n.type = this.type,
        this.name !== "" && (n.name = this.name),
        this.castShadow === !0 && (n.castShadow = !0),
        this.receiveShadow === !0 && (n.receiveShadow = !0),
        this.visible === !1 && (n.visible = !1),
        this.frustumCulled === !1 && (n.frustumCulled = !1),
        this.renderOrder !== 0 && (n.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        n.layers = this.layers.mask,
        n.matrix = this.matrix.toArray(),
        this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1),
        this.isInstancedMesh && (n.type = "InstancedMesh",
        n.count = this.count,
        n.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON()));
        function o(c, u) {
            return c[u.uuid] === void 0 && (c[u.uuid] = u.toJSON(e)),
            u.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (n.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            n.geometry = o(e.geometries, this.geometry);
            const c = this.geometry.parameters;
            if (c !== void 0 && c.shapes !== void 0) {
                const u = c.shapes;
                if (Array.isArray(u))
                    for (let f = 0, p = u.length; f < p; f++) {
                        const g = u[f];
                        o(e.shapes, g)
                    }
                else
                    o(e.shapes, u)
            }
        }
        if (this.isSkinnedMesh && (n.bindMode = this.bindMode,
        n.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (o(e.skeletons, this.skeleton),
        n.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const c = [];
                for (let u = 0, f = this.material.length; u < f; u++)
                    c.push(o(e.materials, this.material[u]));
                n.material = c
            } else
                n.material = o(e.materials, this.material);
        if (this.children.length > 0) {
            n.children = [];
            for (let c = 0; c < this.children.length; c++)
                n.children.push(this.children[c].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            n.animations = [];
            for (let c = 0; c < this.animations.length; c++) {
                const u = this.animations[c];
                n.animations.push(o(e.animations, u))
            }
        }
        if (t) {
            const c = l(e.geometries)
              , u = l(e.materials)
              , f = l(e.textures)
              , p = l(e.images)
              , g = l(e.shapes)
              , v = l(e.skeletons)
              , _ = l(e.animations)
              , w = l(e.nodes);
            c.length > 0 && (r.geometries = c),
            u.length > 0 && (r.materials = u),
            f.length > 0 && (r.textures = f),
            p.length > 0 && (r.images = p),
            g.length > 0 && (r.shapes = g),
            v.length > 0 && (r.skeletons = v),
            _.length > 0 && (r.animations = _),
            w.length > 0 && (r.nodes = w)
        }
        return r.object = n,
        r;
        function l(c) {
            const u = [];
            for (const f in c) {
                const p = c[f];
                delete p.metadata,
                u.push(p)
            }
            return u
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let r = 0; r < e.children.length; r++) {
                const n = e.children[r];
                this.add(n.clone())
            }
        return this
    }
}
Object3D.DefaultUp = new Vector3(0,1,0);
Object3D.DefaultMatrixAutoUpdate = !0;
Object3D.DefaultMatrixWorldAutoUpdate = !0;
const _v0$1$1 = new Vector3
  , _v1$3$1 = new Vector3
  , _v2$2 = new Vector3
  , _v3$1 = new Vector3
  , _vab = new Vector3
  , _vac = new Vector3
  , _vbc = new Vector3
  , _vap = new Vector3
  , _vbp = new Vector3
  , _vcp = new Vector3;
class Triangle {
    constructor(e=new Vector3, t=new Vector3, r=new Vector3) {
        this.a = e,
        this.b = t,
        this.c = r
    }
    static getNormal(e, t, r, n) {
        n.subVectors(r, t),
        _v0$1$1.subVectors(e, t),
        n.cross(_v0$1$1);
        const o = n.lengthSq();
        return o > 0 ? n.multiplyScalar(1 / Math.sqrt(o)) : n.set(0, 0, 0)
    }
    static getBarycoord(e, t, r, n, o) {
        _v0$1$1.subVectors(n, t),
        _v1$3$1.subVectors(r, t),
        _v2$2.subVectors(e, t);
        const l = _v0$1$1.dot(_v0$1$1)
          , c = _v0$1$1.dot(_v1$3$1)
          , u = _v0$1$1.dot(_v2$2)
          , f = _v1$3$1.dot(_v1$3$1)
          , p = _v1$3$1.dot(_v2$2)
          , g = l * f - c * c;
        if (g === 0)
            return o.set(-2, -1, -1);
        const v = 1 / g
          , _ = (f * u - c * p) * v
          , w = (l * p - c * u) * v;
        return o.set(1 - _ - w, w, _)
    }
    static containsPoint(e, t, r, n) {
        return this.getBarycoord(e, t, r, n, _v3$1),
        _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1
    }
    static getUV(e, t, r, n, o, l, c, u) {
        return this.getBarycoord(e, t, r, n, _v3$1),
        u.set(0, 0),
        u.addScaledVector(o, _v3$1.x),
        u.addScaledVector(l, _v3$1.y),
        u.addScaledVector(c, _v3$1.z),
        u
    }
    static isFrontFacing(e, t, r, n) {
        return _v0$1$1.subVectors(r, t),
        _v1$3$1.subVectors(e, t),
        _v0$1$1.cross(_v1$3$1).dot(n) < 0
    }
    set(e, t, r) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(r),
        this
    }
    setFromPointsAndIndices(e, t, r, n) {
        return this.a.copy(e[t]),
        this.b.copy(e[r]),
        this.c.copy(e[n]),
        this
    }
    setFromAttributeAndIndices(e, t, r, n) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, r),
        this.c.fromBufferAttribute(e, n),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return _v0$1$1.subVectors(this.c, this.b),
        _v1$3$1.subVectors(this.a, this.b),
        _v0$1$1.cross(_v1$3$1).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Triangle.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return Triangle.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, r, n, o) {
        return Triangle.getUV(e, this.a, this.b, this.c, t, r, n, o)
    }
    containsPoint(e) {
        return Triangle.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const r = this.a
          , n = this.b
          , o = this.c;
        let l, c;
        _vab.subVectors(n, r),
        _vac.subVectors(o, r),
        _vap.subVectors(e, r);
        const u = _vab.dot(_vap)
          , f = _vac.dot(_vap);
        if (u <= 0 && f <= 0)
            return t.copy(r);
        _vbp.subVectors(e, n);
        const p = _vab.dot(_vbp)
          , g = _vac.dot(_vbp);
        if (p >= 0 && g <= p)
            return t.copy(n);
        const v = u * g - p * f;
        if (v <= 0 && u >= 0 && p <= 0)
            return l = u / (u - p),
            t.copy(r).addScaledVector(_vab, l);
        _vcp.subVectors(e, o);
        const _ = _vab.dot(_vcp)
          , w = _vac.dot(_vcp);
        if (w >= 0 && _ <= w)
            return t.copy(o);
        const S = _ * f - u * w;
        if (S <= 0 && f >= 0 && w <= 0)
            return c = f / (f - w),
            t.copy(r).addScaledVector(_vac, c);
        const b = p * w - _ * g;
        if (b <= 0 && g - p >= 0 && _ - w >= 0)
            return _vbc.subVectors(o, n),
            c = (g - p) / (g - p + (_ - w)),
            t.copy(n).addScaledVector(_vbc, c);
        const C = 1 / (b + S + v);
        return l = S * C,
        c = v * C,
        t.copy(r).addScaledVector(_vab, l).addScaledVector(_vac, c)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
let materialId = 0;
class Material extends EventDispatcher {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: materialId++
        }),
        this.uuid = generateUUID(),
        this.name = "",
        this.type = "Material",
        this.blending = NormalBlending,
        this.side = FrontSide,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = SrcAlphaFactor,
        this.blendDst = OneMinusSrcAlphaFactor,
        this.blendEquation = AddEquation,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = LessEqualDepth,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = AlwaysStencilFunc,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = KeepStencilOp,
        this.stencilZFail = KeepStencilOp,
        this.stencilZPass = KeepStencilOp,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const r = e[t];
                if (r === void 0) {
                    console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    continue
                }
                const n = this[t];
                if (n === void 0) {
                    console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
                    continue
                }
                n && n.isColor ? n.set(r) : n && n.isVector3 && r && r.isVector3 ? n.copy(r) : this[t] = r
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const r = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.color && this.color.isColor && (r.color = this.color.getHex()),
        this.roughness !== void 0 && (r.roughness = this.roughness),
        this.metalness !== void 0 && (r.metalness = this.metalness),
        this.sheen !== void 0 && (r.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()),
        this.emissiveIntensity && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (r.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (r.shininess = this.shininess),
        this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.iridescence !== void 0 && (r.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid,
        r.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid,
        r.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid,
        r.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid,
        r.normalMapType = this.normalMapType,
        r.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid,
        r.displacementScale = this.displacementScale,
        r.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (r.combine = this.combine)),
        this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (r.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (r.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (r.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (r.size = this.size),
        this.shadowSide !== null && (r.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation),
        this.blending !== NormalBlending && (r.blending = this.blending),
        this.side !== FrontSide && (r.side = this.side),
        this.vertexColors && (r.vertexColors = !0),
        this.opacity < 1 && (r.opacity = this.opacity),
        this.transparent === !0 && (r.transparent = this.transparent),
        r.depthFunc = this.depthFunc,
        r.depthTest = this.depthTest,
        r.depthWrite = this.depthWrite,
        r.colorWrite = this.colorWrite,
        r.stencilWrite = this.stencilWrite,
        r.stencilWriteMask = this.stencilWriteMask,
        r.stencilFunc = this.stencilFunc,
        r.stencilRef = this.stencilRef,
        r.stencilFuncMask = this.stencilFuncMask,
        r.stencilFail = this.stencilFail,
        r.stencilZFail = this.stencilZFail,
        r.stencilZPass = this.stencilZPass,
        this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation),
        this.polygonOffset === !0 && (r.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth),
        this.dashSize !== void 0 && (r.dashSize = this.dashSize),
        this.gapSize !== void 0 && (r.gapSize = this.gapSize),
        this.scale !== void 0 && (r.scale = this.scale),
        this.dithering === !0 && (r.dithering = !0),
        this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
        this.alphaToCoverage === !0 && (r.alphaToCoverage = this.alphaToCoverage),
        this.premultipliedAlpha === !0 && (r.premultipliedAlpha = this.premultipliedAlpha),
        this.wireframe === !0 && (r.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (r.flatShading = this.flatShading),
        this.visible === !1 && (r.visible = !1),
        this.toneMapped === !1 && (r.toneMapped = !1),
        this.fog === !1 && (r.fog = !1),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData);
        function n(o) {
            const l = [];
            for (const c in o) {
                const u = o[c];
                delete u.metadata,
                l.push(u)
            }
            return l
        }
        if (t) {
            const o = n(e.textures)
              , l = n(e.images);
            o.length > 0 && (r.textures = o),
            l.length > 0 && (r.images = l)
        }
        return r
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let r = null;
        if (t !== null) {
            const n = t.length;
            r = new Array(n);
            for (let o = 0; o !== n; ++o)
                r[o] = t[o].clone()
        }
        return this.clippingPlanes = r,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class MeshBasicMaterial extends Material {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new Color(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = MultiplyOperation,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const _vector$9 = new Vector3
  , _vector2$1 = new Vector2;
class BufferAttribute {
    constructor(e, t, r=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = r,
        this.usage = StaticDrawUsage,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, r) {
        e *= this.itemSize,
        r *= t.itemSize;
        for (let n = 0, o = this.itemSize; n < o; n++)
            this.array[e + n] = t.array[r + n];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, r = this.count; t < r; t++)
                _vector2$1.fromBufferAttribute(this, t),
                _vector2$1.applyMatrix3(e),
                this.setXY(t, _vector2$1.x, _vector2$1.y);
        else if (this.itemSize === 3)
            for (let t = 0, r = this.count; t < r; t++)
                _vector$9.fromBufferAttribute(this, t),
                _vector$9.applyMatrix3(e),
                this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, r = this.count; t < r; t++)
            _vector$9.fromBufferAttribute(this, t),
            _vector$9.applyMatrix4(e),
            this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, r = this.count; t < r; t++)
            _vector$9.fromBufferAttribute(this, t),
            _vector$9.applyNormalMatrix(e),
            this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, r = this.count; t < r; t++)
            _vector$9.fromBufferAttribute(this, t),
            _vector$9.transformDirection(e),
            this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = denormalize(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = normalize(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = denormalize(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = normalize(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = denormalize(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = normalize(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = denormalize(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = normalize(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, r) {
        return e *= this.itemSize,
        this.normalized && (t = normalize(t, this.array),
        r = normalize(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this
    }
    setXYZ(e, t, r, n) {
        return e *= this.itemSize,
        this.normalized && (t = normalize(t, this.array),
        r = normalize(r, this.array),
        n = normalize(n, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this.array[e + 2] = n,
        this
    }
    setXYZW(e, t, r, n, o) {
        return e *= this.itemSize,
        this.normalized && (t = normalize(t, this.array),
        r = normalize(r, this.array),
        n = normalize(n, this.array),
        o = normalize(o, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this.array[e + 2] = n,
        this.array[e + 3] = o,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== StaticDrawUsage && (e.usage = this.usage),
        (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange),
        e
    }
    copyColorsArray() {
        console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
    }
    copyVector2sArray() {
        console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
    }
    copyVector3sArray() {
        console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
    }
    copyVector4sArray() {
        console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
    }
}
class Uint16BufferAttribute extends BufferAttribute {
    constructor(e, t, r) {
        super(new Uint16Array(e), t, r)
    }
}
class Uint32BufferAttribute extends BufferAttribute {
    constructor(e, t, r) {
        super(new Uint32Array(e), t, r)
    }
}
class Float32BufferAttribute extends BufferAttribute {
    constructor(e, t, r) {
        super(new Float32Array(e), t, r)
    }
}
let _id$1 = 0;
const _m1 = new Matrix4
  , _obj = new Object3D
  , _offset = new Vector3
  , _box$1 = new Box3
  , _boxMorphTargets = new Box3
  , _vector$8 = new Vector3;
class BufferGeometry extends EventDispatcher {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: _id$1++
        }),
        this.uuid = generateUUID(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (arrayNeedsUint32(e) ? Uint32BufferAttribute : Uint16BufferAttribute)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, r=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: r
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const r = this.attributes.normal;
        if (r !== void 0) {
            const o = new Matrix3().getNormalMatrix(e);
            r.applyNormalMatrix(o),
            r.needsUpdate = !0
        }
        const n = this.attributes.tangent;
        return n !== void 0 && (n.transformDirection(e),
        n.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return _m1.makeRotationFromQuaternion(e),
        this.applyMatrix4(_m1),
        this
    }
    rotateX(e) {
        return _m1.makeRotationX(e),
        this.applyMatrix4(_m1),
        this
    }
    rotateY(e) {
        return _m1.makeRotationY(e),
        this.applyMatrix4(_m1),
        this
    }
    rotateZ(e) {
        return _m1.makeRotationZ(e),
        this.applyMatrix4(_m1),
        this
    }
    translate(e, t, r) {
        return _m1.makeTranslation(e, t, r),
        this.applyMatrix4(_m1),
        this
    }
    scale(e, t, r) {
        return _m1.makeScale(e, t, r),
        this.applyMatrix4(_m1),
        this
    }
    lookAt(e) {
        return _obj.lookAt(e),
        _obj.updateMatrix(),
        this.applyMatrix4(_obj.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(_offset).negate(),
        this.translate(_offset.x, _offset.y, _offset.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let r = 0, n = e.length; r < n; r++) {
            const o = e[r];
            t.push(o.x, o.y, o.z || 0)
        }
        return this.setAttribute("position", new Float32BufferAttribute(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Box3);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingBox.set(new Vector3(-1 / 0,-1 / 0,-1 / 0), new Vector3(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let r = 0, n = t.length; r < n; r++) {
                    const o = t[r];
                    _box$1.setFromBufferAttribute(o),
                    this.morphTargetsRelative ? (_vector$8.addVectors(this.boundingBox.min, _box$1.min),
                    this.boundingBox.expandByPoint(_vector$8),
                    _vector$8.addVectors(this.boundingBox.max, _box$1.max),
                    this.boundingBox.expandByPoint(_vector$8)) : (this.boundingBox.expandByPoint(_box$1.min),
                    this.boundingBox.expandByPoint(_box$1.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Sphere);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingSphere.set(new Vector3, 1 / 0);
            return
        }
        if (e) {
            const r = this.boundingSphere.center;
            if (_box$1.setFromBufferAttribute(e),
            t)
                for (let o = 0, l = t.length; o < l; o++) {
                    const c = t[o];
                    _boxMorphTargets.setFromBufferAttribute(c),
                    this.morphTargetsRelative ? (_vector$8.addVectors(_box$1.min, _boxMorphTargets.min),
                    _box$1.expandByPoint(_vector$8),
                    _vector$8.addVectors(_box$1.max, _boxMorphTargets.max),
                    _box$1.expandByPoint(_vector$8)) : (_box$1.expandByPoint(_boxMorphTargets.min),
                    _box$1.expandByPoint(_boxMorphTargets.max))
                }
            _box$1.getCenter(r);
            let n = 0;
            for (let o = 0, l = e.count; o < l; o++)
                _vector$8.fromBufferAttribute(e, o),
                n = Math.max(n, r.distanceToSquared(_vector$8));
            if (t)
                for (let o = 0, l = t.length; o < l; o++) {
                    const c = t[o]
                      , u = this.morphTargetsRelative;
                    for (let f = 0, p = c.count; f < p; f++)
                        _vector$8.fromBufferAttribute(c, f),
                        u && (_offset.fromBufferAttribute(e, f),
                        _vector$8.add(_offset)),
                        n = Math.max(n, r.distanceToSquared(_vector$8))
                }
            this.boundingSphere.radius = Math.sqrt(n),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const r = e.array
          , n = t.position.array
          , o = t.normal.array
          , l = t.uv.array
          , c = n.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * c),4));
        const u = this.getAttribute("tangent").array
          , f = []
          , p = [];
        for (let W = 0; W < c; W++)
            f[W] = new Vector3,
            p[W] = new Vector3;
        const g = new Vector3
          , v = new Vector3
          , _ = new Vector3
          , w = new Vector2
          , S = new Vector2
          , b = new Vector2
          , C = new Vector3
          , R = new Vector3;
        function T(W, Q, H) {
            g.fromArray(n, W * 3),
            v.fromArray(n, Q * 3),
            _.fromArray(n, H * 3),
            w.fromArray(l, W * 2),
            S.fromArray(l, Q * 2),
            b.fromArray(l, H * 2),
            v.sub(g),
            _.sub(g),
            S.sub(w),
            b.sub(w);
            const B = 1 / (S.x * b.y - b.x * S.y);
            isFinite(B) && (C.copy(v).multiplyScalar(b.y).addScaledVector(_, -S.y).multiplyScalar(B),
            R.copy(_).multiplyScalar(S.x).addScaledVector(v, -b.x).multiplyScalar(B),
            f[W].add(C),
            f[Q].add(C),
            f[H].add(C),
            p[W].add(R),
            p[Q].add(R),
            p[H].add(R))
        }
        let M = this.groups;
        M.length === 0 && (M = [{
            start: 0,
            count: r.length
        }]);
        for (let W = 0, Q = M.length; W < Q; ++W) {
            const H = M[W]
              , B = H.start
              , D = H.count;
            for (let q = B, V = B + D; q < V; q += 3)
                T(r[q + 0], r[q + 1], r[q + 2])
        }
        const P = new Vector3
          , I = new Vector3
          , k = new Vector3
          , A = new Vector3;
        function O(W) {
            k.fromArray(o, W * 3),
            A.copy(k);
            const Q = f[W];
            P.copy(Q),
            P.sub(k.multiplyScalar(k.dot(Q))).normalize(),
            I.crossVectors(A, Q);
            const B = I.dot(p[W]) < 0 ? -1 : 1;
            u[W * 4] = P.x,
            u[W * 4 + 1] = P.y,
            u[W * 4 + 2] = P.z,
            u[W * 4 + 3] = B
        }
        for (let W = 0, Q = M.length; W < Q; ++W) {
            const H = M[W]
              , B = H.start
              , D = H.count;
            for (let q = B, V = B + D; q < V; q += 3)
                O(r[q + 0]),
                O(r[q + 1]),
                O(r[q + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let r = this.getAttribute("normal");
            if (r === void 0)
                r = new BufferAttribute(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", r);
            else
                for (let v = 0, _ = r.count; v < _; v++)
                    r.setXYZ(v, 0, 0, 0);
            const n = new Vector3
              , o = new Vector3
              , l = new Vector3
              , c = new Vector3
              , u = new Vector3
              , f = new Vector3
              , p = new Vector3
              , g = new Vector3;
            if (e)
                for (let v = 0, _ = e.count; v < _; v += 3) {
                    const w = e.getX(v + 0)
                      , S = e.getX(v + 1)
                      , b = e.getX(v + 2);
                    n.fromBufferAttribute(t, w),
                    o.fromBufferAttribute(t, S),
                    l.fromBufferAttribute(t, b),
                    p.subVectors(l, o),
                    g.subVectors(n, o),
                    p.cross(g),
                    c.fromBufferAttribute(r, w),
                    u.fromBufferAttribute(r, S),
                    f.fromBufferAttribute(r, b),
                    c.add(p),
                    u.add(p),
                    f.add(p),
                    r.setXYZ(w, c.x, c.y, c.z),
                    r.setXYZ(S, u.x, u.y, u.z),
                    r.setXYZ(b, f.x, f.y, f.z)
                }
            else
                for (let v = 0, _ = t.count; v < _; v += 3)
                    n.fromBufferAttribute(t, v + 0),
                    o.fromBufferAttribute(t, v + 1),
                    l.fromBufferAttribute(t, v + 2),
                    p.subVectors(l, o),
                    g.subVectors(n, o),
                    p.cross(g),
                    r.setXYZ(v + 0, p.x, p.y, p.z),
                    r.setXYZ(v + 1, p.x, p.y, p.z),
                    r.setXYZ(v + 2, p.x, p.y, p.z);
            this.normalizeNormals(),
            r.needsUpdate = !0
        }
    }
    merge() {
        return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),
        this
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, r = e.count; t < r; t++)
            _vector$8.fromBufferAttribute(e, t),
            _vector$8.normalize(),
            e.setXYZ(t, _vector$8.x, _vector$8.y, _vector$8.z)
    }
    toNonIndexed() {
        function e(c, u) {
            const f = c.array
              , p = c.itemSize
              , g = c.normalized
              , v = new f.constructor(u.length * p);
            let _ = 0
              , w = 0;
            for (let S = 0, b = u.length; S < b; S++) {
                c.isInterleavedBufferAttribute ? _ = u[S] * c.data.stride + c.offset : _ = u[S] * p;
                for (let C = 0; C < p; C++)
                    v[w++] = f[_++]
            }
            return new BufferAttribute(v,p,g)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new BufferGeometry
          , r = this.index.array
          , n = this.attributes;
        for (const c in n) {
            const u = n[c]
              , f = e(u, r);
            t.setAttribute(c, f)
        }
        const o = this.morphAttributes;
        for (const c in o) {
            const u = []
              , f = o[c];
            for (let p = 0, g = f.length; p < g; p++) {
                const v = f[p]
                  , _ = e(v, r);
                u.push(_)
            }
            t.morphAttributes[c] = u
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const l = this.groups;
        for (let c = 0, u = l.length; c < u; c++) {
            const f = l[c];
            t.addGroup(f.start, f.count, f.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const u = this.parameters;
            for (const f in u)
                u[f] !== void 0 && (e[f] = u[f]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const r = this.attributes;
        for (const u in r) {
            const f = r[u];
            e.data.attributes[u] = f.toJSON(e.data)
        }
        const n = {};
        let o = !1;
        for (const u in this.morphAttributes) {
            const f = this.morphAttributes[u]
              , p = [];
            for (let g = 0, v = f.length; g < v; g++) {
                const _ = f[g];
                p.push(_.toJSON(e.data))
            }
            p.length > 0 && (n[u] = p,
            o = !0)
        }
        o && (e.data.morphAttributes = n,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const l = this.groups;
        l.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(l)));
        const c = this.boundingSphere;
        return c !== null && (e.data.boundingSphere = {
            center: c.center.toArray(),
            radius: c.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const r = e.index;
        r !== null && this.setIndex(r.clone(t));
        const n = e.attributes;
        for (const f in n) {
            const p = n[f];
            this.setAttribute(f, p.clone(t))
        }
        const o = e.morphAttributes;
        for (const f in o) {
            const p = []
              , g = o[f];
            for (let v = 0, _ = g.length; v < _; v++)
                p.push(g[v].clone(t));
            this.morphAttributes[f] = p
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const l = e.groups;
        for (let f = 0, p = l.length; f < p; f++) {
            const g = l[f];
            this.addGroup(g.start, g.count, g.materialIndex)
        }
        const c = e.boundingBox;
        c !== null && (this.boundingBox = c.clone());
        const u = e.boundingSphere;
        return u !== null && (this.boundingSphere = u.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const _inverseMatrix$2 = new Matrix4
  , _ray$2 = new Ray
  , _sphere$3 = new Sphere
  , _vA$1 = new Vector3
  , _vB$1 = new Vector3
  , _vC$1 = new Vector3
  , _tempA = new Vector3
  , _morphA = new Vector3
  , _uvA$1 = new Vector2
  , _uvB$1 = new Vector2
  , _uvC$1 = new Vector2
  , _intersectionPoint = new Vector3
  , _intersectionPointWorld = new Vector3;
class Mesh extends Object3D {
    constructor(e=new BufferGeometry, t=new MeshBasicMaterial) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , r = Object.keys(t);
        if (r.length > 0) {
            const n = t[r[0]];
            if (n !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let o = 0, l = n.length; o < l; o++) {
                    const c = n[o].name || String(o);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[c] = o
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const r = this.geometry
          , n = r.attributes.position
          , o = r.morphAttributes.position
          , l = r.morphTargetsRelative;
        t.fromBufferAttribute(n, e);
        const c = this.morphTargetInfluences;
        if (o && c) {
            _morphA.set(0, 0, 0);
            for (let u = 0, f = o.length; u < f; u++) {
                const p = c[u]
                  , g = o[u];
                p !== 0 && (_tempA.fromBufferAttribute(g, e),
                l ? _morphA.addScaledVector(_tempA, p) : _morphA.addScaledVector(_tempA.sub(t), p))
            }
            t.add(_morphA)
        }
        return this.isSkinnedMesh && this.boneTransform(e, t),
        t
    }
    raycast(e, t) {
        const r = this.geometry
          , n = this.material
          , o = this.matrixWorld;
        if (n === void 0 || (r.boundingSphere === null && r.computeBoundingSphere(),
        _sphere$3.copy(r.boundingSphere),
        _sphere$3.applyMatrix4(o),
        e.ray.intersectsSphere(_sphere$3) === !1) || (_inverseMatrix$2.copy(o).invert(),
        _ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$2),
        r.boundingBox !== null && _ray$2.intersectsBox(r.boundingBox) === !1))
            return;
        let l;
        const c = r.index
          , u = r.attributes.position
          , f = r.attributes.uv
          , p = r.attributes.uv2
          , g = r.groups
          , v = r.drawRange;
        if (c !== null)
            if (Array.isArray(n))
                for (let _ = 0, w = g.length; _ < w; _++) {
                    const S = g[_]
                      , b = n[S.materialIndex]
                      , C = Math.max(S.start, v.start)
                      , R = Math.min(c.count, Math.min(S.start + S.count, v.start + v.count));
                    for (let T = C, M = R; T < M; T += 3) {
                        const P = c.getX(T)
                          , I = c.getX(T + 1)
                          , k = c.getX(T + 2);
                        l = checkBufferGeometryIntersection(this, b, e, _ray$2, f, p, P, I, k),
                        l && (l.faceIndex = Math.floor(T / 3),
                        l.face.materialIndex = S.materialIndex,
                        t.push(l))
                    }
                }
            else {
                const _ = Math.max(0, v.start)
                  , w = Math.min(c.count, v.start + v.count);
                for (let S = _, b = w; S < b; S += 3) {
                    const C = c.getX(S)
                      , R = c.getX(S + 1)
                      , T = c.getX(S + 2);
                    l = checkBufferGeometryIntersection(this, n, e, _ray$2, f, p, C, R, T),
                    l && (l.faceIndex = Math.floor(S / 3),
                    t.push(l))
                }
            }
        else if (u !== void 0)
            if (Array.isArray(n))
                for (let _ = 0, w = g.length; _ < w; _++) {
                    const S = g[_]
                      , b = n[S.materialIndex]
                      , C = Math.max(S.start, v.start)
                      , R = Math.min(u.count, Math.min(S.start + S.count, v.start + v.count));
                    for (let T = C, M = R; T < M; T += 3) {
                        const P = T
                          , I = T + 1
                          , k = T + 2;
                        l = checkBufferGeometryIntersection(this, b, e, _ray$2, f, p, P, I, k),
                        l && (l.faceIndex = Math.floor(T / 3),
                        l.face.materialIndex = S.materialIndex,
                        t.push(l))
                    }
                }
            else {
                const _ = Math.max(0, v.start)
                  , w = Math.min(u.count, v.start + v.count);
                for (let S = _, b = w; S < b; S += 3) {
                    const C = S
                      , R = S + 1
                      , T = S + 2;
                    l = checkBufferGeometryIntersection(this, n, e, _ray$2, f, p, C, R, T),
                    l && (l.faceIndex = Math.floor(S / 3),
                    t.push(l))
                }
            }
    }
}
function checkIntersection(a, e, t, r, n, o, l, c) {
    let u;
    if (e.side === BackSide ? u = r.intersectTriangle(l, o, n, !0, c) : u = r.intersectTriangle(n, o, l, e.side === FrontSide, c),
    u === null)
        return null;
    _intersectionPointWorld.copy(c),
    _intersectionPointWorld.applyMatrix4(a.matrixWorld);
    const f = t.ray.origin.distanceTo(_intersectionPointWorld);
    return f < t.near || f > t.far ? null : {
        distance: f,
        point: _intersectionPointWorld.clone(),
        object: a
    }
}
function checkBufferGeometryIntersection(a, e, t, r, n, o, l, c, u) {
    a.getVertexPosition(l, _vA$1),
    a.getVertexPosition(c, _vB$1),
    a.getVertexPosition(u, _vC$1);
    const f = checkIntersection(a, e, t, r, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (f) {
        n && (_uvA$1.fromBufferAttribute(n, l),
        _uvB$1.fromBufferAttribute(n, c),
        _uvC$1.fromBufferAttribute(n, u),
        f.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2)),
        o && (_uvA$1.fromBufferAttribute(o, l),
        _uvB$1.fromBufferAttribute(o, c),
        _uvC$1.fromBufferAttribute(o, u),
        f.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2));
        const p = {
            a: l,
            b: c,
            c: u,
            normal: new Vector3,
            materialIndex: 0
        };
        Triangle.getNormal(_vA$1, _vB$1, _vC$1, p.normal),
        f.face = p
    }
    return f
}
class BoxGeometry extends BufferGeometry {
    constructor(e=1, t=1, r=1, n=1, o=1, l=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: r,
            widthSegments: n,
            heightSegments: o,
            depthSegments: l
        };
        const c = this;
        n = Math.floor(n),
        o = Math.floor(o),
        l = Math.floor(l);
        const u = []
          , f = []
          , p = []
          , g = [];
        let v = 0
          , _ = 0;
        w("z", "y", "x", -1, -1, r, t, e, l, o, 0),
        w("z", "y", "x", 1, -1, r, t, -e, l, o, 1),
        w("x", "z", "y", 1, 1, e, r, t, n, l, 2),
        w("x", "z", "y", 1, -1, e, r, -t, n, l, 3),
        w("x", "y", "z", 1, -1, e, t, r, n, o, 4),
        w("x", "y", "z", -1, -1, e, t, -r, n, o, 5),
        this.setIndex(u),
        this.setAttribute("position", new Float32BufferAttribute(f,3)),
        this.setAttribute("normal", new Float32BufferAttribute(p,3)),
        this.setAttribute("uv", new Float32BufferAttribute(g,2));
        function w(S, b, C, R, T, M, P, I, k, A, O) {
            const W = M / k
              , Q = P / A
              , H = M / 2
              , B = P / 2
              , D = I / 2
              , q = k + 1
              , V = A + 1;
            let J = 0
              , U = 0;
            const ce = new Vector3;
            for (let ee = 0; ee < V; ee++) {
                const ne = ee * Q - B;
                for (let ae = 0; ae < q; ae++) {
                    const ve = ae * W - H;
                    ce[S] = ve * R,
                    ce[b] = ne * T,
                    ce[C] = D,
                    f.push(ce.x, ce.y, ce.z),
                    ce[S] = 0,
                    ce[b] = 0,
                    ce[C] = I > 0 ? 1 : -1,
                    p.push(ce.x, ce.y, ce.z),
                    g.push(ae / k),
                    g.push(1 - ee / A),
                    J += 1
                }
            }
            for (let ee = 0; ee < A; ee++)
                for (let ne = 0; ne < k; ne++) {
                    const ae = v + ne + q * ee
                      , ve = v + ne + q * (ee + 1)
                      , Y = v + (ne + 1) + q * (ee + 1)
                      , $ = v + (ne + 1) + q * ee;
                    u.push(ae, ve, $),
                    u.push(ve, Y, $),
                    U += 6
                }
            c.addGroup(_, U, O),
            _ += U,
            v += J
        }
    }
    static fromJSON(e) {
        return new BoxGeometry(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function cloneUniforms(a) {
    const e = {};
    for (const t in a) {
        e[t] = {};
        for (const r in a[t]) {
            const n = a[t][r];
            n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? e[t][r] = n.clone() : Array.isArray(n) ? e[t][r] = n.slice() : e[t][r] = n
        }
    }
    return e
}
function mergeUniforms(a) {
    const e = {};
    for (let t = 0; t < a.length; t++) {
        const r = cloneUniforms(a[t]);
        for (const n in r)
            e[n] = r[n]
    }
    return e
}
function cloneUniformsGroups(a) {
    const e = [];
    for (let t = 0; t < a.length; t++)
        e.push(a[t].clone());
    return e
}
function getUnlitUniformColorSpace(a) {
    return a.getRenderTarget() === null && a.outputEncoding === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace
}
const UniformsUtils = {
    clone: cloneUniforms,
    merge: mergeUniforms
};
var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ShaderMaterial extends Material {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = default_vertex,
        this.fragmentShader = default_fragment,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = cloneUniforms(e.uniforms),
        this.uniformsGroups = cloneUniformsGroups(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const n in this.uniforms) {
            const l = this.uniforms[n].value;
            l && l.isTexture ? t.uniforms[n] = {
                type: "t",
                value: l.toJSON(e).uuid
            } : l && l.isColor ? t.uniforms[n] = {
                type: "c",
                value: l.getHex()
            } : l && l.isVector2 ? t.uniforms[n] = {
                type: "v2",
                value: l.toArray()
            } : l && l.isVector3 ? t.uniforms[n] = {
                type: "v3",
                value: l.toArray()
            } : l && l.isVector4 ? t.uniforms[n] = {
                type: "v4",
                value: l.toArray()
            } : l && l.isMatrix3 ? t.uniforms[n] = {
                type: "m3",
                value: l.toArray()
            } : l && l.isMatrix4 ? t.uniforms[n] = {
                type: "m4",
                value: l.toArray()
            } : t.uniforms[n] = {
                value: l
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader;
        const r = {};
        for (const n in this.extensions)
            this.extensions[n] === !0 && (r[n] = !0);
        return Object.keys(r).length > 0 && (t.extensions = r),
        t
    }
}
class Camera extends Object3D {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new Matrix4,
        this.projectionMatrix = new Matrix4,
        this.projectionMatrixInverse = new Matrix4
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class PerspectiveCamera extends Camera {
    constructor(e=50, t=1, r=.1, n=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = r,
        this.far = n,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = RAD2DEG * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(DEG2RAD * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, r, n, o, l) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = r,
        this.view.offsetY = n,
        this.view.width = o,
        this.view.height = l,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(DEG2RAD * .5 * this.fov) / this.zoom
          , r = 2 * t
          , n = this.aspect * r
          , o = -.5 * n;
        const l = this.view;
        if (this.view !== null && this.view.enabled) {
            const u = l.fullWidth
              , f = l.fullHeight;
            o += l.offsetX * n / u,
            t -= l.offsetY * r / f,
            n *= l.width / u,
            r *= l.height / f
        }
        const c = this.filmOffset;
        c !== 0 && (o += e * c / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(o, o + n, t, t - r, e, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const fov = -90
  , aspect = 1;
class CubeCamera extends Object3D {
    constructor(e, t, r) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = r;
        const n = new PerspectiveCamera(fov,aspect,e,t);
        n.layers = this.layers,
        n.up.set(0, 1, 0),
        n.lookAt(1, 0, 0),
        this.add(n);
        const o = new PerspectiveCamera(fov,aspect,e,t);
        o.layers = this.layers,
        o.up.set(0, 1, 0),
        o.lookAt(-1, 0, 0),
        this.add(o);
        const l = new PerspectiveCamera(fov,aspect,e,t);
        l.layers = this.layers,
        l.up.set(0, 0, -1),
        l.lookAt(0, 1, 0),
        this.add(l);
        const c = new PerspectiveCamera(fov,aspect,e,t);
        c.layers = this.layers,
        c.up.set(0, 0, 1),
        c.lookAt(0, -1, 0),
        this.add(c);
        const u = new PerspectiveCamera(fov,aspect,e,t);
        u.layers = this.layers,
        u.up.set(0, 1, 0),
        u.lookAt(0, 0, 1),
        this.add(u);
        const f = new PerspectiveCamera(fov,aspect,e,t);
        f.layers = this.layers,
        f.up.set(0, 1, 0),
        f.lookAt(0, 0, -1),
        this.add(f)
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const r = this.renderTarget
          , [n,o,l,c,u,f] = this.children
          , p = e.getRenderTarget()
          , g = e.toneMapping
          , v = e.xr.enabled;
        e.toneMapping = NoToneMapping,
        e.xr.enabled = !1;
        const _ = r.texture.generateMipmaps;
        r.texture.generateMipmaps = !1,
        e.setRenderTarget(r, 0),
        e.render(t, n),
        e.setRenderTarget(r, 1),
        e.render(t, o),
        e.setRenderTarget(r, 2),
        e.render(t, l),
        e.setRenderTarget(r, 3),
        e.render(t, c),
        e.setRenderTarget(r, 4),
        e.render(t, u),
        r.texture.generateMipmaps = _,
        e.setRenderTarget(r, 5),
        e.render(t, f),
        e.setRenderTarget(p),
        e.toneMapping = g,
        e.xr.enabled = v,
        r.texture.needsPMREMUpdate = !0
    }
}
class CubeTexture extends Texture {
    constructor(e, t, r, n, o, l, c, u, f, p) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : CubeReflectionMapping,
        super(e, t, r, n, o, l, c, u, f, p),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const r = {
            width: e,
            height: e,
            depth: 1
        }
          , n = [r, r, r, r, r, r];
        this.texture = new CubeTexture(n,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : LinearFilter
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.encoding = t.encoding,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const r = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , n = new BoxGeometry(5,5,5)
          , o = new ShaderMaterial({
            name: "CubemapFromEquirect",
            uniforms: cloneUniforms(r.uniforms),
            vertexShader: r.vertexShader,
            fragmentShader: r.fragmentShader,
            side: BackSide,
            blending: NoBlending
        });
        o.uniforms.tEquirect.value = t;
        const l = new Mesh(n,o)
          , c = t.minFilter;
        return t.minFilter === LinearMipmapLinearFilter && (t.minFilter = LinearFilter),
        new CubeCamera(1,10,this).update(e, l),
        t.minFilter = c,
        l.geometry.dispose(),
        l.material.dispose(),
        this
    }
    clear(e, t, r, n) {
        const o = e.getRenderTarget();
        for (let l = 0; l < 6; l++)
            e.setRenderTarget(this, l),
            e.clear(t, r, n);
        e.setRenderTarget(o)
    }
}
const _vector1 = new Vector3
  , _vector2 = new Vector3
  , _normalMatrix = new Matrix3;
class Plane {
    constructor(e=new Vector3(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, r, n) {
        return this.normal.set(e, t, r),
        this.constant = n,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, r) {
        const n = _vector1.subVectors(r, t).cross(_vector2.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(n, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
    }
    intersectLine(e, t) {
        const r = e.delta(_vector1)
          , n = this.normal.dot(r);
        if (n === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const o = -(e.start.dot(this.normal) + this.constant) / n;
        return o < 0 || o > 1 ? null : t.copy(r).multiplyScalar(o).add(e.start)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , r = this.distanceToPoint(e.end);
        return t < 0 && r > 0 || r < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const r = t || _normalMatrix.getNormalMatrix(e)
          , n = this.coplanarPoint(_vector1).applyMatrix4(e)
          , o = this.normal.applyMatrix3(r).normalize();
        return this.constant = -n.dot(o),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const _sphere$2 = new Sphere
  , _vector$7 = new Vector3;
class Frustum {
    constructor(e=new Plane, t=new Plane, r=new Plane, n=new Plane, o=new Plane, l=new Plane) {
        this.planes = [e, t, r, n, o, l]
    }
    set(e, t, r, n, o, l) {
        const c = this.planes;
        return c[0].copy(e),
        c[1].copy(t),
        c[2].copy(r),
        c[3].copy(n),
        c[4].copy(o),
        c[5].copy(l),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let r = 0; r < 6; r++)
            t[r].copy(e.planes[r]);
        return this
    }
    setFromProjectionMatrix(e) {
        const t = this.planes
          , r = e.elements
          , n = r[0]
          , o = r[1]
          , l = r[2]
          , c = r[3]
          , u = r[4]
          , f = r[5]
          , p = r[6]
          , g = r[7]
          , v = r[8]
          , _ = r[9]
          , w = r[10]
          , S = r[11]
          , b = r[12]
          , C = r[13]
          , R = r[14]
          , T = r[15];
        return t[0].setComponents(c - n, g - u, S - v, T - b).normalize(),
        t[1].setComponents(c + n, g + u, S + v, T + b).normalize(),
        t[2].setComponents(c + o, g + f, S + _, T + C).normalize(),
        t[3].setComponents(c - o, g - f, S - _, T - C).normalize(),
        t[4].setComponents(c - l, g - p, S - w, T - R).normalize(),
        t[5].setComponents(c + l, g + p, S + w, T + R).normalize(),
        this
    }
    intersectsObject(e) {
        const t = e.geometry;
        return t.boundingSphere === null && t.computeBoundingSphere(),
        _sphere$2.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
        this.intersectsSphere(_sphere$2)
    }
    intersectsSprite(e) {
        return _sphere$2.center.set(0, 0, 0),
        _sphere$2.radius = .7071067811865476,
        _sphere$2.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(_sphere$2)
    }
    intersectsSphere(e) {
        const t = this.planes
          , r = e.center
          , n = -e.radius;
        for (let o = 0; o < 6; o++)
            if (t[o].distanceToPoint(r) < n)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let r = 0; r < 6; r++) {
            const n = t[r];
            if (_vector$7.x = n.normal.x > 0 ? e.max.x : e.min.x,
            _vector$7.y = n.normal.y > 0 ? e.max.y : e.min.y,
            _vector$7.z = n.normal.z > 0 ? e.max.z : e.min.z,
            n.distanceToPoint(_vector$7) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function WebGLAnimation() {
    let a = null
      , e = !1
      , t = null
      , r = null;
    function n(o, l) {
        t(o, l),
        r = a.requestAnimationFrame(n)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (r = a.requestAnimationFrame(n),
            e = !0)
        },
        stop: function() {
            a.cancelAnimationFrame(r),
            e = !1
        },
        setAnimationLoop: function(o) {
            t = o
        },
        setContext: function(o) {
            a = o
        }
    }
}
function WebGLAttributes(a, e) {
    const t = e.isWebGL2
      , r = new WeakMap;
    function n(f, p) {
        const g = f.array
          , v = f.usage
          , _ = a.createBuffer();
        a.bindBuffer(p, _),
        a.bufferData(p, g, v),
        f.onUploadCallback();
        let w;
        if (g instanceof Float32Array)
            w = 5126;
        else if (g instanceof Uint16Array)
            if (f.isFloat16BufferAttribute)
                if (t)
                    w = 5131;
                else
                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            else
                w = 5123;
        else if (g instanceof Int16Array)
            w = 5122;
        else if (g instanceof Uint32Array)
            w = 5125;
        else if (g instanceof Int32Array)
            w = 5124;
        else if (g instanceof Int8Array)
            w = 5120;
        else if (g instanceof Uint8Array)
            w = 5121;
        else if (g instanceof Uint8ClampedArray)
            w = 5121;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + g);
        return {
            buffer: _,
            type: w,
            bytesPerElement: g.BYTES_PER_ELEMENT,
            version: f.version
        }
    }
    function o(f, p, g) {
        const v = p.array
          , _ = p.updateRange;
        a.bindBuffer(g, f),
        _.count === -1 ? a.bufferSubData(g, 0, v) : (t ? a.bufferSubData(g, _.offset * v.BYTES_PER_ELEMENT, v, _.offset, _.count) : a.bufferSubData(g, _.offset * v.BYTES_PER_ELEMENT, v.subarray(_.offset, _.offset + _.count)),
        _.count = -1),
        p.onUploadCallback()
    }
    function l(f) {
        return f.isInterleavedBufferAttribute && (f = f.data),
        r.get(f)
    }
    function c(f) {
        f.isInterleavedBufferAttribute && (f = f.data);
        const p = r.get(f);
        p && (a.deleteBuffer(p.buffer),
        r.delete(f))
    }
    function u(f, p) {
        if (f.isGLBufferAttribute) {
            const v = r.get(f);
            (!v || v.version < f.version) && r.set(f, {
                buffer: f.buffer,
                type: f.type,
                bytesPerElement: f.elementSize,
                version: f.version
            });
            return
        }
        f.isInterleavedBufferAttribute && (f = f.data);
        const g = r.get(f);
        g === void 0 ? r.set(f, n(f, p)) : g.version < f.version && (o(g.buffer, f, p),
        g.version = f.version)
    }
    return {
        get: l,
        remove: c,
        update: u
    }
}
class PlaneGeometry extends BufferGeometry {
    constructor(e=1, t=1, r=1, n=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: r,
            heightSegments: n
        };
        const o = e / 2
          , l = t / 2
          , c = Math.floor(r)
          , u = Math.floor(n)
          , f = c + 1
          , p = u + 1
          , g = e / c
          , v = t / u
          , _ = []
          , w = []
          , S = []
          , b = [];
        for (let C = 0; C < p; C++) {
            const R = C * v - l;
            for (let T = 0; T < f; T++) {
                const M = T * g - o;
                w.push(M, -R, 0),
                S.push(0, 0, 1),
                b.push(T / c),
                b.push(1 - C / u)
            }
        }
        for (let C = 0; C < u; C++)
            for (let R = 0; R < c; R++) {
                const T = R + f * C
                  , M = R + f * (C + 1)
                  , P = R + 1 + f * (C + 1)
                  , I = R + 1 + f * C;
                _.push(T, M, I),
                _.push(M, P, I)
            }
        this.setIndex(_),
        this.setAttribute("position", new Float32BufferAttribute(w,3)),
        this.setAttribute("normal", new Float32BufferAttribute(S,3)),
        this.setAttribute("uv", new Float32BufferAttribute(b,2))
    }
    static fromJSON(e) {
        return new PlaneGeometry(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`
  , alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , alphatest_fragment = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`
  , alphatest_pars_fragment = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , begin_vertex = "vec3 transformed = vec3( position );"
  , beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , bsdfs = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`
  , iridescence_fragment = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`
  , clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`
  , color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`
  , common = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`
  , cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`
  , emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , encodings_pars_fragment = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , fog_vertex = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , fog_pars_vertex = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , lightmap_fragment = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`
  , lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , lights_lambert_fragment = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , lights_lambert_pars_fragment = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , envmap_physical_pars_fragment = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`
  , lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , lights_toon_pars_fragment = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , lights_phong_pars_fragment = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`
  , lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , lights_fragment_begin = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`
  , logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`
  , logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`
  , map_fragment = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , map_particle_pars_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , morphcolor_vertex = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`
  , morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`
  , morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`
  , normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`
  , normal_fragment_maps = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , normal_pars_fragment = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , normal_pars_vertex = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , normal_vertex = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`
  , clearcoat_normal_fragment_begin = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`
  , clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`
  , clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`
  , iridescence_pars_fragment = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , output_fragment = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`
  , premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , shadowmap_pars_fragment = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`
  , shadowmap_pars_vertex = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , shadowmap_vertex = `#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`
  , shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`
  , skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , tonemapping_pars_fragment = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , transmission_fragment = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`
  , transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`
  , uv_pars_fragment = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`
  , uv_pars_vertex = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`
  , uv_vertex = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`
  , uv2_pars_fragment = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`
  , uv2_pars_vertex = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`
  , uv2_vertex = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`
  , worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const vertex$h = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , fragment$h = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , vertex$g = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , fragment$g = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , vertex$f = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , fragment$f = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , vertex$e = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , fragment$e = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`
  , vertex$d = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , fragment$d = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , vertex$c = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , fragment$c = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , vertex$b = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , fragment$b = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , vertex$a = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , fragment$a = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$9 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , fragment$9 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , fragment$8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , fragment$7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , vertex$6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , fragment$6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , fragment$5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , fragment$4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , fragment$3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , vertex$2 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , fragment$2 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , vertex$1 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , fragment$1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , ShaderChunk = {
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    alphatest_pars_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    iridescence_fragment,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    encodings_fragment,
    encodings_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_fragment,
    lightmap_pars_fragment,
    lights_lambert_fragment,
    lights_lambert_pars_fragment,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphcolor_vertex,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normal_pars_fragment,
    normal_pars_vertex,
    normal_vertex,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    iridescence_pars_fragment,
    output_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmission_fragment,
    transmission_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    uv2_pars_fragment,
    uv2_pars_vertex,
    uv2_vertex,
    worldpos_vertex,
    background_vert: vertex$h,
    background_frag: fragment$h,
    backgroundCube_vert: vertex$g,
    backgroundCube_frag: fragment$g,
    cube_vert: vertex$f,
    cube_frag: fragment$f,
    depth_vert: vertex$e,
    depth_frag: fragment$e,
    distanceRGBA_vert: vertex$d,
    distanceRGBA_frag: fragment$d,
    equirect_vert: vertex$c,
    equirect_frag: fragment$c,
    linedashed_vert: vertex$b,
    linedashed_frag: fragment$b,
    meshbasic_vert: vertex$a,
    meshbasic_frag: fragment$a,
    meshlambert_vert: vertex$9,
    meshlambert_frag: fragment$9,
    meshmatcap_vert: vertex$8,
    meshmatcap_frag: fragment$8,
    meshnormal_vert: vertex$7,
    meshnormal_frag: fragment$7,
    meshphong_vert: vertex$6,
    meshphong_frag: fragment$6,
    meshphysical_vert: vertex$5,
    meshphysical_frag: fragment$5,
    meshtoon_vert: vertex$4,
    meshtoon_frag: fragment$4,
    points_vert: vertex$3,
    points_frag: fragment$3,
    shadow_vert: vertex$2,
    shadow_frag: fragment$2,
    sprite_vert: vertex$1,
    sprite_frag: fragment$1
}
  , UniformsLib = {
    common: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Matrix3
        },
        uv2Transform: {
            value: new Matrix3
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new Vector2(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Matrix3
        }
    },
    sprite: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new Vector2(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Matrix3
        }
    }
}
  , ShaderLib = {
    basic: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            }
        }]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            },
            specular: {
                value: new Color(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            }
        }]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
        uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ShaderChunk.meshnormal_vert,
        fragmentShader: ShaderChunk.meshnormal_frag
    },
    sprite: {
        uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Matrix3
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: ShaderChunk.backgroundCube_vert,
        fragmentShader: ShaderChunk.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
            referencePosition: {
                value: new Vector3
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
        uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
            color: {
                value: new Color(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
    }
};
ShaderLib.physical = {
    uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatNormalScale: {
            value: new Vector2(1,1)
        },
        clearcoatNormalMap: {
            value: null
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Color(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionSamplerSize: {
            value: new Vector2
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Color(0)
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularColor: {
            value: new Color(1,1,1)
        },
        specularColorMap: {
            value: null
        }
    }]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
};
const _rgb = {
    r: 0,
    b: 0,
    g: 0
};
function WebGLBackground(a, e, t, r, n, o, l) {
    const c = new Color(0);
    let u = o === !0 ? 0 : 1, f, p, g = null, v = 0, _ = null;
    function w(b, C) {
        let R = !1
          , T = C.isScene === !0 ? C.background : null;
        T && T.isTexture && (T = (C.backgroundBlurriness > 0 ? t : e).get(T));
        const M = a.xr
          , P = M.getSession && M.getSession();
        P && P.environmentBlendMode === "additive" && (T = null),
        T === null ? S(c, u) : T && T.isColor && (S(T, 1),
        R = !0),
        (a.autoClear || R) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil),
        T && (T.isCubeTexture || T.mapping === CubeUVReflectionMapping) ? (p === void 0 && (p = new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
            vertexShader: ShaderLib.backgroundCube.vertexShader,
            fragmentShader: ShaderLib.backgroundCube.fragmentShader,
            side: BackSide,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        p.geometry.deleteAttribute("normal"),
        p.geometry.deleteAttribute("uv"),
        p.onBeforeRender = function(I, k, A) {
            this.matrixWorld.copyPosition(A.matrixWorld)
        }
        ,
        Object.defineProperty(p.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        n.update(p)),
        p.material.uniforms.envMap.value = T,
        p.material.uniforms.flipEnvMap.value = T.isCubeTexture && T.isRenderTargetTexture === !1 ? -1 : 1,
        p.material.uniforms.backgroundBlurriness.value = C.backgroundBlurriness,
        p.material.uniforms.backgroundIntensity.value = C.backgroundIntensity,
        p.material.toneMapped = T.encoding !== sRGBEncoding,
        (g !== T || v !== T.version || _ !== a.toneMapping) && (p.material.needsUpdate = !0,
        g = T,
        v = T.version,
        _ = a.toneMapping),
        p.layers.enableAll(),
        b.unshift(p, p.geometry, p.material, 0, 0, null)) : T && T.isTexture && (f === void 0 && (f = new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        f.geometry.deleteAttribute("normal"),
        Object.defineProperty(f.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        n.update(f)),
        f.material.uniforms.t2D.value = T,
        f.material.uniforms.backgroundIntensity.value = C.backgroundIntensity,
        f.material.toneMapped = T.encoding !== sRGBEncoding,
        T.matrixAutoUpdate === !0 && T.updateMatrix(),
        f.material.uniforms.uvTransform.value.copy(T.matrix),
        (g !== T || v !== T.version || _ !== a.toneMapping) && (f.material.needsUpdate = !0,
        g = T,
        v = T.version,
        _ = a.toneMapping),
        f.layers.enableAll(),
        b.unshift(f, f.geometry, f.material, 0, 0, null))
    }
    function S(b, C) {
        b.getRGB(_rgb, getUnlitUniformColorSpace(a)),
        r.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, C, l)
    }
    return {
        getClearColor: function() {
            return c
        },
        setClearColor: function(b, C=1) {
            c.set(b),
            u = C,
            S(c, u)
        },
        getClearAlpha: function() {
            return u
        },
        setClearAlpha: function(b) {
            u = b,
            S(c, u)
        },
        render: w
    }
}
function WebGLBindingStates(a, e, t, r) {
    const n = a.getParameter(34921)
      , o = r.isWebGL2 ? null : e.get("OES_vertex_array_object")
      , l = r.isWebGL2 || o !== null
      , c = {}
      , u = b(null);
    let f = u
      , p = !1;
    function g(D, q, V, J, U) {
        let ce = !1;
        if (l) {
            const ee = S(J, V, q);
            f !== ee && (f = ee,
            _(f.object)),
            ce = C(D, J, V, U),
            ce && R(D, J, V, U)
        } else {
            const ee = q.wireframe === !0;
            (f.geometry !== J.id || f.program !== V.id || f.wireframe !== ee) && (f.geometry = J.id,
            f.program = V.id,
            f.wireframe = ee,
            ce = !0)
        }
        U !== null && t.update(U, 34963),
        (ce || p) && (p = !1,
        A(D, q, V, J),
        U !== null && a.bindBuffer(34963, t.get(U).buffer))
    }
    function v() {
        return r.isWebGL2 ? a.createVertexArray() : o.createVertexArrayOES()
    }
    function _(D) {
        return r.isWebGL2 ? a.bindVertexArray(D) : o.bindVertexArrayOES(D)
    }
    function w(D) {
        return r.isWebGL2 ? a.deleteVertexArray(D) : o.deleteVertexArrayOES(D)
    }
    function S(D, q, V) {
        const J = V.wireframe === !0;
        let U = c[D.id];
        U === void 0 && (U = {},
        c[D.id] = U);
        let ce = U[q.id];
        ce === void 0 && (ce = {},
        U[q.id] = ce);
        let ee = ce[J];
        return ee === void 0 && (ee = b(v()),
        ce[J] = ee),
        ee
    }
    function b(D) {
        const q = []
          , V = []
          , J = [];
        for (let U = 0; U < n; U++)
            q[U] = 0,
            V[U] = 0,
            J[U] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: q,
            enabledAttributes: V,
            attributeDivisors: J,
            object: D,
            attributes: {},
            index: null
        }
    }
    function C(D, q, V, J) {
        const U = f.attributes
          , ce = q.attributes;
        let ee = 0;
        const ne = V.getAttributes();
        for (const ae in ne)
            if (ne[ae].location >= 0) {
                const Y = U[ae];
                let $ = ce[ae];
                if ($ === void 0 && (ae === "instanceMatrix" && D.instanceMatrix && ($ = D.instanceMatrix),
                ae === "instanceColor" && D.instanceColor && ($ = D.instanceColor)),
                Y === void 0 || Y.attribute !== $ || $ && Y.data !== $.data)
                    return !0;
                ee++
            }
        return f.attributesNum !== ee || f.index !== J
    }
    function R(D, q, V, J) {
        const U = {}
          , ce = q.attributes;
        let ee = 0;
        const ne = V.getAttributes();
        for (const ae in ne)
            if (ne[ae].location >= 0) {
                let Y = ce[ae];
                Y === void 0 && (ae === "instanceMatrix" && D.instanceMatrix && (Y = D.instanceMatrix),
                ae === "instanceColor" && D.instanceColor && (Y = D.instanceColor));
                const $ = {};
                $.attribute = Y,
                Y && Y.data && ($.data = Y.data),
                U[ae] = $,
                ee++
            }
        f.attributes = U,
        f.attributesNum = ee,
        f.index = J
    }
    function T() {
        const D = f.newAttributes;
        for (let q = 0, V = D.length; q < V; q++)
            D[q] = 0
    }
    function M(D) {
        P(D, 0)
    }
    function P(D, q) {
        const V = f.newAttributes
          , J = f.enabledAttributes
          , U = f.attributeDivisors;
        V[D] = 1,
        J[D] === 0 && (a.enableVertexAttribArray(D),
        J[D] = 1),
        U[D] !== q && ((r.isWebGL2 ? a : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](D, q),
        U[D] = q)
    }
    function I() {
        const D = f.newAttributes
          , q = f.enabledAttributes;
        for (let V = 0, J = q.length; V < J; V++)
            q[V] !== D[V] && (a.disableVertexAttribArray(V),
            q[V] = 0)
    }
    function k(D, q, V, J, U, ce) {
        r.isWebGL2 === !0 && (V === 5124 || V === 5125) ? a.vertexAttribIPointer(D, q, V, U, ce) : a.vertexAttribPointer(D, q, V, J, U, ce)
    }
    function A(D, q, V, J) {
        if (r.isWebGL2 === !1 && (D.isInstancedMesh || J.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
            return;
        T();
        const U = J.attributes
          , ce = V.getAttributes()
          , ee = q.defaultAttributeValues;
        for (const ne in ce) {
            const ae = ce[ne];
            if (ae.location >= 0) {
                let ve = U[ne];
                if (ve === void 0 && (ne === "instanceMatrix" && D.instanceMatrix && (ve = D.instanceMatrix),
                ne === "instanceColor" && D.instanceColor && (ve = D.instanceColor)),
                ve !== void 0) {
                    const Y = ve.normalized
                      , $ = ve.itemSize
                      , L = t.get(ve);
                    if (L === void 0)
                        continue;
                    const N = L.buffer
                      , oe = L.type
                      , pe = L.bytesPerElement;
                    if (ve.isInterleavedBufferAttribute) {
                        const K = ve.data
                          , Se = K.stride
                          , Ce = ve.offset;
                        if (K.isInstancedInterleavedBuffer) {
                            for (let Te = 0; Te < ae.locationSize; Te++)
                                P(ae.location + Te, K.meshPerAttribute);
                            D.isInstancedMesh !== !0 && J._maxInstanceCount === void 0 && (J._maxInstanceCount = K.meshPerAttribute * K.count)
                        } else
                            for (let Te = 0; Te < ae.locationSize; Te++)
                                M(ae.location + Te);
                        a.bindBuffer(34962, N);
                        for (let Te = 0; Te < ae.locationSize; Te++)
                            k(ae.location + Te, $ / ae.locationSize, oe, Y, Se * pe, (Ce + $ / ae.locationSize * Te) * pe)
                    } else {
                        if (ve.isInstancedBufferAttribute) {
                            for (let K = 0; K < ae.locationSize; K++)
                                P(ae.location + K, ve.meshPerAttribute);
                            D.isInstancedMesh !== !0 && J._maxInstanceCount === void 0 && (J._maxInstanceCount = ve.meshPerAttribute * ve.count)
                        } else
                            for (let K = 0; K < ae.locationSize; K++)
                                M(ae.location + K);
                        a.bindBuffer(34962, N);
                        for (let K = 0; K < ae.locationSize; K++)
                            k(ae.location + K, $ / ae.locationSize, oe, Y, $ * pe, $ / ae.locationSize * K * pe)
                    }
                } else if (ee !== void 0) {
                    const Y = ee[ne];
                    if (Y !== void 0)
                        switch (Y.length) {
                        case 2:
                            a.vertexAttrib2fv(ae.location, Y);
                            break;
                        case 3:
                            a.vertexAttrib3fv(ae.location, Y);
                            break;
                        case 4:
                            a.vertexAttrib4fv(ae.location, Y);
                            break;
                        default:
                            a.vertexAttrib1fv(ae.location, Y)
                        }
                }
            }
        }
        I()
    }
    function O() {
        H();
        for (const D in c) {
            const q = c[D];
            for (const V in q) {
                const J = q[V];
                for (const U in J)
                    w(J[U].object),
                    delete J[U];
                delete q[V]
            }
            delete c[D]
        }
    }
    function W(D) {
        if (c[D.id] === void 0)
            return;
        const q = c[D.id];
        for (const V in q) {
            const J = q[V];
            for (const U in J)
                w(J[U].object),
                delete J[U];
            delete q[V]
        }
        delete c[D.id]
    }
    function Q(D) {
        for (const q in c) {
            const V = c[q];
            if (V[D.id] === void 0)
                continue;
            const J = V[D.id];
            for (const U in J)
                w(J[U].object),
                delete J[U];
            delete V[D.id]
        }
    }
    function H() {
        B(),
        p = !0,
        f !== u && (f = u,
        _(f.object))
    }
    function B() {
        u.geometry = null,
        u.program = null,
        u.wireframe = !1
    }
    return {
        setup: g,
        reset: H,
        resetDefaultState: B,
        dispose: O,
        releaseStatesOfGeometry: W,
        releaseStatesOfProgram: Q,
        initAttributes: T,
        enableAttribute: M,
        disableUnusedAttributes: I
    }
}
function WebGLBufferRenderer(a, e, t, r) {
    const n = r.isWebGL2;
    let o;
    function l(f) {
        o = f
    }
    function c(f, p) {
        a.drawArrays(o, f, p),
        t.update(p, o, 1)
    }
    function u(f, p, g) {
        if (g === 0)
            return;
        let v, _;
        if (n)
            v = a,
            _ = "drawArraysInstanced";
        else if (v = e.get("ANGLE_instanced_arrays"),
        _ = "drawArraysInstancedANGLE",
        v === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        v[_](o, f, p, g),
        t.update(p, o, g)
    }
    this.setMode = l,
    this.render = c,
    this.renderInstances = u
}
function WebGLCapabilities(a, e, t) {
    let r;
    function n() {
        if (r !== void 0)
            return r;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const k = e.get("EXT_texture_filter_anisotropic");
            r = a.getParameter(k.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            r = 0;
        return r
    }
    function o(k) {
        if (k === "highp") {
            if (a.getShaderPrecisionFormat(35633, 36338).precision > 0 && a.getShaderPrecisionFormat(35632, 36338).precision > 0)
                return "highp";
            k = "mediump"
        }
        return k === "mediump" && a.getShaderPrecisionFormat(35633, 36337).precision > 0 && a.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }
    const l = typeof WebGL2RenderingContext < "u" && a instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && a instanceof WebGL2ComputeRenderingContext;
    let c = t.precision !== void 0 ? t.precision : "highp";
    const u = o(c);
    u !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", u, "instead."),
    c = u);
    const f = l || e.has("WEBGL_draw_buffers")
      , p = t.logarithmicDepthBuffer === !0
      , g = a.getParameter(34930)
      , v = a.getParameter(35660)
      , _ = a.getParameter(3379)
      , w = a.getParameter(34076)
      , S = a.getParameter(34921)
      , b = a.getParameter(36347)
      , C = a.getParameter(36348)
      , R = a.getParameter(36349)
      , T = v > 0
      , M = l || e.has("OES_texture_float")
      , P = T && M
      , I = l ? a.getParameter(36183) : 0;
    return {
        isWebGL2: l,
        drawBuffers: f,
        getMaxAnisotropy: n,
        getMaxPrecision: o,
        precision: c,
        logarithmicDepthBuffer: p,
        maxTextures: g,
        maxVertexTextures: v,
        maxTextureSize: _,
        maxCubemapSize: w,
        maxAttributes: S,
        maxVertexUniforms: b,
        maxVaryings: C,
        maxFragmentUniforms: R,
        vertexTextures: T,
        floatFragmentTextures: M,
        floatVertexTextures: P,
        maxSamples: I
    }
}
function WebGLClipping(a) {
    const e = this;
    let t = null
      , r = 0
      , n = !1
      , o = !1;
    const l = new Plane
      , c = new Matrix3
      , u = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = u,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(g, v, _) {
        const w = g.length !== 0 || v || r !== 0 || n;
        return n = v,
        t = p(g, _, 0),
        r = g.length,
        w
    }
    ,
    this.beginShadows = function() {
        o = !0,
        p(null)
    }
    ,
    this.endShadows = function() {
        o = !1,
        f()
    }
    ,
    this.setState = function(g, v, _) {
        const w = g.clippingPlanes
          , S = g.clipIntersection
          , b = g.clipShadows
          , C = a.get(g);
        if (!n || w === null || w.length === 0 || o && !b)
            o ? p(null) : f();
        else {
            const R = o ? 0 : r
              , T = R * 4;
            let M = C.clippingState || null;
            u.value = M,
            M = p(w, v, T, _);
            for (let P = 0; P !== T; ++P)
                M[P] = t[P];
            C.clippingState = M,
            this.numIntersection = S ? this.numPlanes : 0,
            this.numPlanes += R
        }
    }
    ;
    function f() {
        u.value !== t && (u.value = t,
        u.needsUpdate = r > 0),
        e.numPlanes = r,
        e.numIntersection = 0
    }
    function p(g, v, _, w) {
        const S = g !== null ? g.length : 0;
        let b = null;
        if (S !== 0) {
            if (b = u.value,
            w !== !0 || b === null) {
                const C = _ + S * 4
                  , R = v.matrixWorldInverse;
                c.getNormalMatrix(R),
                (b === null || b.length < C) && (b = new Float32Array(C));
                for (let T = 0, M = _; T !== S; ++T,
                M += 4)
                    l.copy(g[T]).applyMatrix4(R, c),
                    l.normal.toArray(b, M),
                    b[M + 3] = l.constant
            }
            u.value = b,
            u.needsUpdate = !0
        }
        return e.numPlanes = S,
        e.numIntersection = 0,
        b
    }
}
function WebGLCubeMaps(a) {
    let e = new WeakMap;
    function t(l, c) {
        return c === EquirectangularReflectionMapping ? l.mapping = CubeReflectionMapping : c === EquirectangularRefractionMapping && (l.mapping = CubeRefractionMapping),
        l
    }
    function r(l) {
        if (l && l.isTexture && l.isRenderTargetTexture === !1) {
            const c = l.mapping;
            if (c === EquirectangularReflectionMapping || c === EquirectangularRefractionMapping)
                if (e.has(l)) {
                    const u = e.get(l).texture;
                    return t(u, l.mapping)
                } else {
                    const u = l.image;
                    if (u && u.height > 0) {
                        const f = new WebGLCubeRenderTarget(u.height / 2);
                        return f.fromEquirectangularTexture(a, l),
                        e.set(l, f),
                        l.addEventListener("dispose", n),
                        t(f.texture, l.mapping)
                    } else
                        return null
                }
        }
        return l
    }
    function n(l) {
        const c = l.target;
        c.removeEventListener("dispose", n);
        const u = e.get(c);
        u !== void 0 && (e.delete(c),
        u.dispose())
    }
    function o() {
        e = new WeakMap
    }
    return {
        get: r,
        dispose: o
    }
}
class OrthographicCamera extends Camera {
    constructor(e=-1, t=1, r=1, n=-1, o=.1, l=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = r,
        this.bottom = n,
        this.near = o,
        this.far = l,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, r, n, o, l) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = r,
        this.view.offsetY = n,
        this.view.width = o,
        this.view.height = l,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , r = (this.right + this.left) / 2
          , n = (this.top + this.bottom) / 2;
        let o = r - e
          , l = r + e
          , c = n + t
          , u = n - t;
        if (this.view !== null && this.view.enabled) {
            const f = (this.right - this.left) / this.view.fullWidth / this.zoom
              , p = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            o += f * this.view.offsetX,
            l = o + f * this.view.width,
            c -= p * this.view.offsetY,
            u = c - p * this.view.height
        }
        this.projectionMatrix.makeOrthographic(o, l, c, u, this.near, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const LOD_MIN = 4
  , EXTRA_LOD_SIGMA = [.125, .215, .35, .446, .526, .582]
  , MAX_SAMPLES = 20
  , _flatCamera = new OrthographicCamera
  , _clearColor = new Color;
let _oldTarget = null;
const PHI = (1 + Math.sqrt(5)) / 2
  , INV_PHI = 1 / PHI
  , _axisDirections = [new Vector3(1,1,1), new Vector3(-1,1,1), new Vector3(1,1,-1), new Vector3(-1,1,-1), new Vector3(0,PHI,INV_PHI), new Vector3(0,PHI,-INV_PHI), new Vector3(INV_PHI,0,PHI), new Vector3(-INV_PHI,0,PHI), new Vector3(PHI,INV_PHI,0), new Vector3(-PHI,INV_PHI,0)];
class PMREMGenerator {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, r=.1, n=100) {
        _oldTarget = this._renderer.getRenderTarget(),
        this._setSize(256);
        const o = this._allocateTargets();
        return o.depthBuffer = !0,
        this._sceneToCubeUV(e, r, n, o),
        t > 0 && this._blur(o, 0, 0, t),
        this._applyPMREM(o),
        this._cleanup(o),
        o
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(_oldTarget),
        e.scissorTest = !1,
        _setViewport(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === CubeReflectionMapping || e.mapping === CubeRefractionMapping ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        _oldTarget = this._renderer.getRenderTarget();
        const r = t || this._allocateTargets();
        return this._textureToCubeUV(e, r),
        this._applyPMREM(r),
        this._cleanup(r),
        r
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , r = {
            magFilter: LinearFilter,
            minFilter: LinearFilter,
            generateMipmaps: !1,
            type: HalfFloatType,
            format: RGBAFormat,
            encoding: LinearEncoding,
            depthBuffer: !1
        }
          , n = _createRenderTarget(e, t, r);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = _createRenderTarget(e, t, r);
            const {_lodMax: o} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = _createPlanes(o)),
            this._blurMaterial = _getBlurShader(o, e, t)
        }
        return n
    }
    _compileMaterial(e) {
        const t = new Mesh(this._lodPlanes[0],e);
        this._renderer.compile(t, _flatCamera)
    }
    _sceneToCubeUV(e, t, r, n) {
        const c = new PerspectiveCamera(90,1,t,r)
          , u = [1, -1, 1, 1, 1, 1]
          , f = [1, 1, 1, -1, -1, -1]
          , p = this._renderer
          , g = p.autoClear
          , v = p.toneMapping;
        p.getClearColor(_clearColor),
        p.toneMapping = NoToneMapping,
        p.autoClear = !1;
        const _ = new MeshBasicMaterial({
            name: "PMREM.Background",
            side: BackSide,
            depthWrite: !1,
            depthTest: !1
        })
          , w = new Mesh(new BoxGeometry,_);
        let S = !1;
        const b = e.background;
        b ? b.isColor && (_.color.copy(b),
        e.background = null,
        S = !0) : (_.color.copy(_clearColor),
        S = !0);
        for (let C = 0; C < 6; C++) {
            const R = C % 3;
            R === 0 ? (c.up.set(0, u[C], 0),
            c.lookAt(f[C], 0, 0)) : R === 1 ? (c.up.set(0, 0, u[C]),
            c.lookAt(0, f[C], 0)) : (c.up.set(0, u[C], 0),
            c.lookAt(0, 0, f[C]));
            const T = this._cubeSize;
            _setViewport(n, R * T, C > 2 ? T : 0, T, T),
            p.setRenderTarget(n),
            S && p.render(w, c),
            p.render(e, c)
        }
        w.geometry.dispose(),
        w.material.dispose(),
        p.toneMapping = v,
        p.autoClear = g,
        e.background = b
    }
    _textureToCubeUV(e, t) {
        const r = this._renderer
          , n = e.mapping === CubeReflectionMapping || e.mapping === CubeRefractionMapping;
        n ? (this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial());
        const o = n ? this._cubemapMaterial : this._equirectMaterial
          , l = new Mesh(this._lodPlanes[0],o)
          , c = o.uniforms;
        c.envMap.value = e;
        const u = this._cubeSize;
        _setViewport(t, 0, 0, 3 * u, 2 * u),
        r.setRenderTarget(t),
        r.render(l, _flatCamera)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , r = t.autoClear;
        t.autoClear = !1;
        for (let n = 1; n < this._lodPlanes.length; n++) {
            const o = Math.sqrt(this._sigmas[n] * this._sigmas[n] - this._sigmas[n - 1] * this._sigmas[n - 1])
              , l = _axisDirections[(n - 1) % _axisDirections.length];
            this._blur(e, n - 1, n, o, l)
        }
        t.autoClear = r
    }
    _blur(e, t, r, n, o) {
        const l = this._pingPongRenderTarget;
        this._halfBlur(e, l, t, r, n, "latitudinal", o),
        this._halfBlur(l, e, r, r, n, "longitudinal", o)
    }
    _halfBlur(e, t, r, n, o, l, c) {
        const u = this._renderer
          , f = this._blurMaterial;
        l !== "latitudinal" && l !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const p = 3
          , g = new Mesh(this._lodPlanes[n],f)
          , v = f.uniforms
          , _ = this._sizeLods[r] - 1
          , w = isFinite(o) ? Math.PI / (2 * _) : 2 * Math.PI / (2 * MAX_SAMPLES - 1)
          , S = o / w
          , b = isFinite(o) ? 1 + Math.floor(p * S) : MAX_SAMPLES;
        b > MAX_SAMPLES && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${b} samples when the maximum is set to ${MAX_SAMPLES}`);
        const C = [];
        let R = 0;
        for (let k = 0; k < MAX_SAMPLES; ++k) {
            const A = k / S
              , O = Math.exp(-A * A / 2);
            C.push(O),
            k === 0 ? R += O : k < b && (R += 2 * O)
        }
        for (let k = 0; k < C.length; k++)
            C[k] = C[k] / R;
        v.envMap.value = e.texture,
        v.samples.value = b,
        v.weights.value = C,
        v.latitudinal.value = l === "latitudinal",
        c && (v.poleAxis.value = c);
        const {_lodMax: T} = this;
        v.dTheta.value = w,
        v.mipInt.value = T - r;
        const M = this._sizeLods[n]
          , P = 3 * M * (n > T - LOD_MIN ? n - T + LOD_MIN : 0)
          , I = 4 * (this._cubeSize - M);
        _setViewport(t, P, I, 3 * M, 2 * M),
        u.setRenderTarget(t),
        u.render(g, _flatCamera)
    }
}
function _createPlanes(a) {
    const e = []
      , t = []
      , r = [];
    let n = a;
    const o = a - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    for (let l = 0; l < o; l++) {
        const c = Math.pow(2, n);
        t.push(c);
        let u = 1 / c;
        l > a - LOD_MIN ? u = EXTRA_LOD_SIGMA[l - a + LOD_MIN - 1] : l === 0 && (u = 0),
        r.push(u);
        const f = 1 / (c - 2)
          , p = -f
          , g = 1 + f
          , v = [p, p, g, p, g, g, p, p, g, g, p, g]
          , _ = 6
          , w = 6
          , S = 3
          , b = 2
          , C = 1
          , R = new Float32Array(S * w * _)
          , T = new Float32Array(b * w * _)
          , M = new Float32Array(C * w * _);
        for (let I = 0; I < _; I++) {
            const k = I % 3 * 2 / 3 - 1
              , A = I > 2 ? 0 : -1
              , O = [k, A, 0, k + 2 / 3, A, 0, k + 2 / 3, A + 1, 0, k, A, 0, k + 2 / 3, A + 1, 0, k, A + 1, 0];
            R.set(O, S * w * I),
            T.set(v, b * w * I);
            const W = [I, I, I, I, I, I];
            M.set(W, C * w * I)
        }
        const P = new BufferGeometry;
        P.setAttribute("position", new BufferAttribute(R,S)),
        P.setAttribute("uv", new BufferAttribute(T,b)),
        P.setAttribute("faceIndex", new BufferAttribute(M,C)),
        e.push(P),
        n > LOD_MIN && n--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: r
    }
}
function _createRenderTarget(a, e, t) {
    const r = new WebGLRenderTarget(a,e,t);
    return r.texture.mapping = CubeUVReflectionMapping,
    r.texture.name = "PMREM.cubeUv",
    r.scissorTest = !0,
    r
}
function _setViewport(a, e, t, r, n) {
    a.viewport.set(e, t, r, n),
    a.scissor.set(e, t, r, n)
}
function _getBlurShader(a, e, t) {
    const r = new Float32Array(MAX_SAMPLES)
      , n = new Vector3(0,1,0);
    return new ShaderMaterial({
        name: "SphericalGaussianBlur",
        defines: {
            n: MAX_SAMPLES,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${a}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: r
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: n
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}
function _getEquirectMaterial() {
    return new ShaderMaterial({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}
function _getCubemapMaterial() {
    return new ShaderMaterial({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}
function _getCommonVertexShader() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function WebGLCubeUVMaps(a) {
    let e = new WeakMap
      , t = null;
    function r(c) {
        if (c && c.isTexture) {
            const u = c.mapping
              , f = u === EquirectangularReflectionMapping || u === EquirectangularRefractionMapping
              , p = u === CubeReflectionMapping || u === CubeRefractionMapping;
            if (f || p)
                if (c.isRenderTargetTexture && c.needsPMREMUpdate === !0) {
                    c.needsPMREMUpdate = !1;
                    let g = e.get(c);
                    return t === null && (t = new PMREMGenerator(a)),
                    g = f ? t.fromEquirectangular(c, g) : t.fromCubemap(c, g),
                    e.set(c, g),
                    g.texture
                } else {
                    if (e.has(c))
                        return e.get(c).texture;
                    {
                        const g = c.image;
                        if (f && g && g.height > 0 || p && g && n(g)) {
                            t === null && (t = new PMREMGenerator(a));
                            const v = f ? t.fromEquirectangular(c) : t.fromCubemap(c);
                            return e.set(c, v),
                            c.addEventListener("dispose", o),
                            v.texture
                        } else
                            return null
                    }
                }
        }
        return c
    }
    function n(c) {
        let u = 0;
        const f = 6;
        for (let p = 0; p < f; p++)
            c[p] !== void 0 && u++;
        return u === f
    }
    function o(c) {
        const u = c.target;
        u.removeEventListener("dispose", o);
        const f = e.get(u);
        f !== void 0 && (e.delete(u),
        f.dispose())
    }
    function l() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: r,
        dispose: l
    }
}
function WebGLExtensions(a) {
    const e = {};
    function t(r) {
        if (e[r] !== void 0)
            return e[r];
        let n;
        switch (r) {
        case "WEBGL_depth_texture":
            n = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            n = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            n = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            n = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            n = a.getExtension(r)
        }
        return e[r] = n,
        n
    }
    return {
        has: function(r) {
            return t(r) !== null
        },
        init: function(r) {
            r.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"),
            t("OES_texture_float"),
            t("OES_texture_half_float"),
            t("OES_texture_half_float_linear"),
            t("OES_standard_derivatives"),
            t("OES_element_index_uint"),
            t("OES_vertex_array_object"),
            t("ANGLE_instanced_arrays")),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture")
        },
        get: function(r) {
            const n = t(r);
            return n === null && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."),
            n
        }
    }
}
function WebGLGeometries(a, e, t, r) {
    const n = {}
      , o = new WeakMap;
    function l(g) {
        const v = g.target;
        v.index !== null && e.remove(v.index);
        for (const w in v.attributes)
            e.remove(v.attributes[w]);
        v.removeEventListener("dispose", l),
        delete n[v.id];
        const _ = o.get(v);
        _ && (e.remove(_),
        o.delete(v)),
        r.releaseStatesOfGeometry(v),
        v.isInstancedBufferGeometry === !0 && delete v._maxInstanceCount,
        t.memory.geometries--
    }
    function c(g, v) {
        return n[v.id] === !0 || (v.addEventListener("dispose", l),
        n[v.id] = !0,
        t.memory.geometries++),
        v
    }
    function u(g) {
        const v = g.attributes;
        for (const w in v)
            e.update(v[w], 34962);
        const _ = g.morphAttributes;
        for (const w in _) {
            const S = _[w];
            for (let b = 0, C = S.length; b < C; b++)
                e.update(S[b], 34962)
        }
    }
    function f(g) {
        const v = []
          , _ = g.index
          , w = g.attributes.position;
        let S = 0;
        if (_ !== null) {
            const R = _.array;
            S = _.version;
            for (let T = 0, M = R.length; T < M; T += 3) {
                const P = R[T + 0]
                  , I = R[T + 1]
                  , k = R[T + 2];
                v.push(P, I, I, k, k, P)
            }
        } else {
            const R = w.array;
            S = w.version;
            for (let T = 0, M = R.length / 3 - 1; T < M; T += 3) {
                const P = T + 0
                  , I = T + 1
                  , k = T + 2;
                v.push(P, I, I, k, k, P)
            }
        }
        const b = new (arrayNeedsUint32(v) ? Uint32BufferAttribute : Uint16BufferAttribute)(v,1);
        b.version = S;
        const C = o.get(g);
        C && e.remove(C),
        o.set(g, b)
    }
    function p(g) {
        const v = o.get(g);
        if (v) {
            const _ = g.index;
            _ !== null && v.version < _.version && f(g)
        } else
            f(g);
        return o.get(g)
    }
    return {
        get: c,
        update: u,
        getWireframeAttribute: p
    }
}
function WebGLIndexedBufferRenderer(a, e, t, r) {
    const n = r.isWebGL2;
    let o;
    function l(v) {
        o = v
    }
    let c, u;
    function f(v) {
        c = v.type,
        u = v.bytesPerElement
    }
    function p(v, _) {
        a.drawElements(o, _, c, v * u),
        t.update(_, o, 1)
    }
    function g(v, _, w) {
        if (w === 0)
            return;
        let S, b;
        if (n)
            S = a,
            b = "drawElementsInstanced";
        else if (S = e.get("ANGLE_instanced_arrays"),
        b = "drawElementsInstancedANGLE",
        S === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        S[b](o, _, c, v * u, w),
        t.update(_, o, w)
    }
    this.setMode = l,
    this.setIndex = f,
    this.render = p,
    this.renderInstances = g
}
function WebGLInfo(a) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function r(o, l, c) {
        switch (t.calls++,
        l) {
        case 4:
            t.triangles += c * (o / 3);
            break;
        case 1:
            t.lines += c * (o / 2);
            break;
        case 3:
            t.lines += c * (o - 1);
            break;
        case 2:
            t.lines += c * o;
            break;
        case 0:
            t.points += c * o;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", l);
            break
        }
    }
    function n() {
        t.frame++,
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: n,
        update: r
    }
}
function numericalSort(a, e) {
    return a[0] - e[0]
}
function absNumericalSort(a, e) {
    return Math.abs(e[1]) - Math.abs(a[1])
}
function WebGLMorphtargets(a, e, t) {
    const r = {}
      , n = new Float32Array(8)
      , o = new WeakMap
      , l = new Vector4
      , c = [];
    for (let f = 0; f < 8; f++)
        c[f] = [f, 0];
    function u(f, p, g, v) {
        const _ = f.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const S = p.morphAttributes.position || p.morphAttributes.normal || p.morphAttributes.color
              , b = S !== void 0 ? S.length : 0;
            let C = o.get(p);
            if (C === void 0 || C.count !== b) {
                let V = function() {
                    D.dispose(),
                    o.delete(p),
                    p.removeEventListener("dispose", V)
                };
                var w = V;
                C !== void 0 && C.texture.dispose();
                const M = p.morphAttributes.position !== void 0
                  , P = p.morphAttributes.normal !== void 0
                  , I = p.morphAttributes.color !== void 0
                  , k = p.morphAttributes.position || []
                  , A = p.morphAttributes.normal || []
                  , O = p.morphAttributes.color || [];
                let W = 0;
                M === !0 && (W = 1),
                P === !0 && (W = 2),
                I === !0 && (W = 3);
                let Q = p.attributes.position.count * W
                  , H = 1;
                Q > e.maxTextureSize && (H = Math.ceil(Q / e.maxTextureSize),
                Q = e.maxTextureSize);
                const B = new Float32Array(Q * H * 4 * b)
                  , D = new DataArrayTexture(B,Q,H,b);
                D.type = FloatType,
                D.needsUpdate = !0;
                const q = W * 4;
                for (let J = 0; J < b; J++) {
                    const U = k[J]
                      , ce = A[J]
                      , ee = O[J]
                      , ne = Q * H * 4 * J;
                    for (let ae = 0; ae < U.count; ae++) {
                        const ve = ae * q;
                        M === !0 && (l.fromBufferAttribute(U, ae),
                        B[ne + ve + 0] = l.x,
                        B[ne + ve + 1] = l.y,
                        B[ne + ve + 2] = l.z,
                        B[ne + ve + 3] = 0),
                        P === !0 && (l.fromBufferAttribute(ce, ae),
                        B[ne + ve + 4] = l.x,
                        B[ne + ve + 5] = l.y,
                        B[ne + ve + 6] = l.z,
                        B[ne + ve + 7] = 0),
                        I === !0 && (l.fromBufferAttribute(ee, ae),
                        B[ne + ve + 8] = l.x,
                        B[ne + ve + 9] = l.y,
                        B[ne + ve + 10] = l.z,
                        B[ne + ve + 11] = ee.itemSize === 4 ? l.w : 1)
                    }
                }
                C = {
                    count: b,
                    texture: D,
                    size: new Vector2(Q,H)
                },
                o.set(p, C),
                p.addEventListener("dispose", V)
            }
            let R = 0;
            for (let M = 0; M < _.length; M++)
                R += _[M];
            const T = p.morphTargetsRelative ? 1 : 1 - R;
            v.getUniforms().setValue(a, "morphTargetBaseInfluence", T),
            v.getUniforms().setValue(a, "morphTargetInfluences", _),
            v.getUniforms().setValue(a, "morphTargetsTexture", C.texture, t),
            v.getUniforms().setValue(a, "morphTargetsTextureSize", C.size)
        } else {
            const S = _ === void 0 ? 0 : _.length;
            let b = r[p.id];
            if (b === void 0 || b.length !== S) {
                b = [];
                for (let P = 0; P < S; P++)
                    b[P] = [P, 0];
                r[p.id] = b
            }
            for (let P = 0; P < S; P++) {
                const I = b[P];
                I[0] = P,
                I[1] = _[P]
            }
            b.sort(absNumericalSort);
            for (let P = 0; P < 8; P++)
                P < S && b[P][1] ? (c[P][0] = b[P][0],
                c[P][1] = b[P][1]) : (c[P][0] = Number.MAX_SAFE_INTEGER,
                c[P][1] = 0);
            c.sort(numericalSort);
            const C = p.morphAttributes.position
              , R = p.morphAttributes.normal;
            let T = 0;
            for (let P = 0; P < 8; P++) {
                const I = c[P]
                  , k = I[0]
                  , A = I[1];
                k !== Number.MAX_SAFE_INTEGER && A ? (C && p.getAttribute("morphTarget" + P) !== C[k] && p.setAttribute("morphTarget" + P, C[k]),
                R && p.getAttribute("morphNormal" + P) !== R[k] && p.setAttribute("morphNormal" + P, R[k]),
                n[P] = A,
                T += A) : (C && p.hasAttribute("morphTarget" + P) === !0 && p.deleteAttribute("morphTarget" + P),
                R && p.hasAttribute("morphNormal" + P) === !0 && p.deleteAttribute("morphNormal" + P),
                n[P] = 0)
            }
            const M = p.morphTargetsRelative ? 1 : 1 - T;
            v.getUniforms().setValue(a, "morphTargetBaseInfluence", M),
            v.getUniforms().setValue(a, "morphTargetInfluences", n)
        }
    }
    return {
        update: u
    }
}
function WebGLObjects(a, e, t, r) {
    let n = new WeakMap;
    function o(u) {
        const f = r.render.frame
          , p = u.geometry
          , g = e.get(u, p);
        return n.get(g) !== f && (e.update(g),
        n.set(g, f)),
        u.isInstancedMesh && (u.hasEventListener("dispose", c) === !1 && u.addEventListener("dispose", c),
        t.update(u.instanceMatrix, 34962),
        u.instanceColor !== null && t.update(u.instanceColor, 34962)),
        g
    }
    function l() {
        n = new WeakMap
    }
    function c(u) {
        const f = u.target;
        f.removeEventListener("dispose", c),
        t.remove(f.instanceMatrix),
        f.instanceColor !== null && t.remove(f.instanceColor)
    }
    return {
        update: o,
        dispose: l
    }
}
const emptyTexture = new Texture
  , emptyArrayTexture = new DataArrayTexture
  , empty3dTexture = new Data3DTexture
  , emptyCubeTexture = new CubeTexture
  , arrayCacheF32 = []
  , arrayCacheI32 = []
  , mat4array = new Float32Array(16)
  , mat3array = new Float32Array(9)
  , mat2array = new Float32Array(4);
function flatten(a, e, t) {
    const r = a[0];
    if (r <= 0 || r > 0)
        return a;
    const n = e * t;
    let o = arrayCacheF32[n];
    if (o === void 0 && (o = new Float32Array(n),
    arrayCacheF32[n] = o),
    e !== 0) {
        r.toArray(o, 0);
        for (let l = 1, c = 0; l !== e; ++l)
            c += t,
            a[l].toArray(o, c)
    }
    return o
}
function arraysEqual(a, e) {
    if (a.length !== e.length)
        return !1;
    for (let t = 0, r = a.length; t < r; t++)
        if (a[t] !== e[t])
            return !1;
    return !0
}
function copyArray(a, e) {
    for (let t = 0, r = e.length; t < r; t++)
        a[t] = e[t]
}
function allocTexUnits(a, e) {
    let t = arrayCacheI32[e];
    t === void 0 && (t = new Int32Array(e),
    arrayCacheI32[e] = t);
    for (let r = 0; r !== e; ++r)
        t[r] = a.allocateTextureUnit();
    return t
}
function setValueV1f(a, e) {
    const t = this.cache;
    t[0] !== e && (a.uniform1f(this.addr, e),
    t[0] = e)
}
function setValueV2f(a, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (a.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (arraysEqual(t, e))
            return;
        a.uniform2fv(this.addr, e),
        copyArray(t, e)
    }
}
function setValueV3f(a, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (a.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (a.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (arraysEqual(t, e))
            return;
        a.uniform3fv(this.addr, e),
        copyArray(t, e)
    }
}
function setValueV4f(a, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (a.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (arraysEqual(t, e))
            return;
        a.uniform4fv(this.addr, e),
        copyArray(t, e)
    }
}
function setValueM2(a, e) {
    const t = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (arraysEqual(t, e))
            return;
        a.uniformMatrix2fv(this.addr, !1, e),
        copyArray(t, e)
    } else {
        if (arraysEqual(t, r))
            return;
        mat2array.set(r),
        a.uniformMatrix2fv(this.addr, !1, mat2array),
        copyArray(t, r)
    }
}
function setValueM3(a, e) {
    const t = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (arraysEqual(t, e))
            return;
        a.uniformMatrix3fv(this.addr, !1, e),
        copyArray(t, e)
    } else {
        if (arraysEqual(t, r))
            return;
        mat3array.set(r),
        a.uniformMatrix3fv(this.addr, !1, mat3array),
        copyArray(t, r)
    }
}
function setValueM4(a, e) {
    const t = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (arraysEqual(t, e))
            return;
        a.uniformMatrix4fv(this.addr, !1, e),
        copyArray(t, e)
    } else {
        if (arraysEqual(t, r))
            return;
        mat4array.set(r),
        a.uniformMatrix4fv(this.addr, !1, mat4array),
        copyArray(t, r)
    }
}
function setValueV1i(a, e) {
    const t = this.cache;
    t[0] !== e && (a.uniform1i(this.addr, e),
    t[0] = e)
}
function setValueV2i(a, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (a.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (arraysEqual(t, e))
            return;
        a.uniform2iv(this.addr, e),
        copyArray(t, e)
    }
}
function setValueV3i(a, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (a.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (arraysEqual(t, e))
            return;
        a.uniform3iv(this.addr, e),
        copyArray(t, e)
    }
}
function setValueV4i(a, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (a.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (arraysEqual(t, e))
            return;
        a.uniform4iv(this.addr, e),
        copyArray(t, e)
    }
}
function setValueV1ui(a, e) {
    const t = this.cache;
    t[0] !== e && (a.uniform1ui(this.addr, e),
    t[0] = e)
}
function setValueV2ui(a, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (a.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (arraysEqual(t, e))
            return;
        a.uniform2uiv(this.addr, e),
        copyArray(t, e)
    }
}
function setValueV3ui(a, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (a.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (arraysEqual(t, e))
            return;
        a.uniform3uiv(this.addr, e),
        copyArray(t, e)
    }
}
function setValueV4ui(a, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (a.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (arraysEqual(t, e))
            return;
        a.uniform4uiv(this.addr, e),
        copyArray(t, e)
    }
}
function setValueT1(a, e, t) {
    const r = this.cache
      , n = t.allocateTextureUnit();
    r[0] !== n && (a.uniform1i(this.addr, n),
    r[0] = n),
    t.setTexture2D(e || emptyTexture, n)
}
function setValueT3D1(a, e, t) {
    const r = this.cache
      , n = t.allocateTextureUnit();
    r[0] !== n && (a.uniform1i(this.addr, n),
    r[0] = n),
    t.setTexture3D(e || empty3dTexture, n)
}
function setValueT6(a, e, t) {
    const r = this.cache
      , n = t.allocateTextureUnit();
    r[0] !== n && (a.uniform1i(this.addr, n),
    r[0] = n),
    t.setTextureCube(e || emptyCubeTexture, n)
}
function setValueT2DArray1(a, e, t) {
    const r = this.cache
      , n = t.allocateTextureUnit();
    r[0] !== n && (a.uniform1i(this.addr, n),
    r[0] = n),
    t.setTexture2DArray(e || emptyArrayTexture, n)
}
function getSingularSetter(a) {
    switch (a) {
    case 5126:
        return setValueV1f;
    case 35664:
        return setValueV2f;
    case 35665:
        return setValueV3f;
    case 35666:
        return setValueV4f;
    case 35674:
        return setValueM2;
    case 35675:
        return setValueM3;
    case 35676:
        return setValueM4;
    case 5124:
    case 35670:
        return setValueV1i;
    case 35667:
    case 35671:
        return setValueV2i;
    case 35668:
    case 35672:
        return setValueV3i;
    case 35669:
    case 35673:
        return setValueV4i;
    case 5125:
        return setValueV1ui;
    case 36294:
        return setValueV2ui;
    case 36295:
        return setValueV3ui;
    case 36296:
        return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return setValueT1;
    case 35679:
    case 36299:
    case 36307:
        return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return setValueT2DArray1
    }
}
function setValueV1fArray(a, e) {
    a.uniform1fv(this.addr, e)
}
function setValueV2fArray(a, e) {
    const t = flatten(e, this.size, 2);
    a.uniform2fv(this.addr, t)
}
function setValueV3fArray(a, e) {
    const t = flatten(e, this.size, 3);
    a.uniform3fv(this.addr, t)
}
function setValueV4fArray(a, e) {
    const t = flatten(e, this.size, 4);
    a.uniform4fv(this.addr, t)
}
function setValueM2Array(a, e) {
    const t = flatten(e, this.size, 4);
    a.uniformMatrix2fv(this.addr, !1, t)
}
function setValueM3Array(a, e) {
    const t = flatten(e, this.size, 9);
    a.uniformMatrix3fv(this.addr, !1, t)
}
function setValueM4Array(a, e) {
    const t = flatten(e, this.size, 16);
    a.uniformMatrix4fv(this.addr, !1, t)
}
function setValueV1iArray(a, e) {
    a.uniform1iv(this.addr, e)
}
function setValueV2iArray(a, e) {
    a.uniform2iv(this.addr, e)
}
function setValueV3iArray(a, e) {
    a.uniform3iv(this.addr, e)
}
function setValueV4iArray(a, e) {
    a.uniform4iv(this.addr, e)
}
function setValueV1uiArray(a, e) {
    a.uniform1uiv(this.addr, e)
}
function setValueV2uiArray(a, e) {
    a.uniform2uiv(this.addr, e)
}
function setValueV3uiArray(a, e) {
    a.uniform3uiv(this.addr, e)
}
function setValueV4uiArray(a, e) {
    a.uniform4uiv(this.addr, e)
}
function setValueT1Array(a, e, t) {
    const r = this.cache
      , n = e.length
      , o = allocTexUnits(t, n);
    arraysEqual(r, o) || (a.uniform1iv(this.addr, o),
    copyArray(r, o));
    for (let l = 0; l !== n; ++l)
        t.setTexture2D(e[l] || emptyTexture, o[l])
}
function setValueT3DArray(a, e, t) {
    const r = this.cache
      , n = e.length
      , o = allocTexUnits(t, n);
    arraysEqual(r, o) || (a.uniform1iv(this.addr, o),
    copyArray(r, o));
    for (let l = 0; l !== n; ++l)
        t.setTexture3D(e[l] || empty3dTexture, o[l])
}
function setValueT6Array(a, e, t) {
    const r = this.cache
      , n = e.length
      , o = allocTexUnits(t, n);
    arraysEqual(r, o) || (a.uniform1iv(this.addr, o),
    copyArray(r, o));
    for (let l = 0; l !== n; ++l)
        t.setTextureCube(e[l] || emptyCubeTexture, o[l])
}
function setValueT2DArrayArray(a, e, t) {
    const r = this.cache
      , n = e.length
      , o = allocTexUnits(t, n);
    arraysEqual(r, o) || (a.uniform1iv(this.addr, o),
    copyArray(r, o));
    for (let l = 0; l !== n; ++l)
        t.setTexture2DArray(e[l] || emptyArrayTexture, o[l])
}
function getPureArraySetter(a) {
    switch (a) {
    case 5126:
        return setValueV1fArray;
    case 35664:
        return setValueV2fArray;
    case 35665:
        return setValueV3fArray;
    case 35666:
        return setValueV4fArray;
    case 35674:
        return setValueM2Array;
    case 35675:
        return setValueM3Array;
    case 35676:
        return setValueM4Array;
    case 5124:
    case 35670:
        return setValueV1iArray;
    case 35667:
    case 35671:
        return setValueV2iArray;
    case 35668:
    case 35672:
        return setValueV3iArray;
    case 35669:
    case 35673:
        return setValueV4iArray;
    case 5125:
        return setValueV1uiArray;
    case 36294:
        return setValueV2uiArray;
    case 36295:
        return setValueV3uiArray;
    case 36296:
        return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
        return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return setValueT2DArrayArray
    }
}
class SingleUniform {
    constructor(e, t, r) {
        this.id = e,
        this.addr = r,
        this.cache = [],
        this.setValue = getSingularSetter(t.type)
    }
}
class PureArrayUniform {
    constructor(e, t, r) {
        this.id = e,
        this.addr = r,
        this.cache = [],
        this.size = t.size,
        this.setValue = getPureArraySetter(t.type)
    }
}
class StructuredUniform {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, r) {
        const n = this.seq;
        for (let o = 0, l = n.length; o !== l; ++o) {
            const c = n[o];
            c.setValue(e, t[c.id], r)
        }
    }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(a, e) {
    a.seq.push(e),
    a.map[e.id] = e
}
function parseUniform(a, e, t) {
    const r = a.name
      , n = r.length;
    for (RePathPart.lastIndex = 0; ; ) {
        const o = RePathPart.exec(r)
          , l = RePathPart.lastIndex;
        let c = o[1];
        const u = o[2] === "]"
          , f = o[3];
        if (u && (c = c | 0),
        f === void 0 || f === "[" && l + 2 === n) {
            addUniform(t, f === void 0 ? new SingleUniform(c,a,e) : new PureArrayUniform(c,a,e));
            break
        } else {
            let g = t.map[c];
            g === void 0 && (g = new StructuredUniform(c),
            addUniform(t, g)),
            t = g
        }
    }
}
class WebGLUniforms {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const r = e.getProgramParameter(t, 35718);
        for (let n = 0; n < r; ++n) {
            const o = e.getActiveUniform(t, n)
              , l = e.getUniformLocation(t, o.name);
            parseUniform(o, l, this)
        }
    }
    setValue(e, t, r, n) {
        const o = this.map[t];
        o !== void 0 && o.setValue(e, r, n)
    }
    setOptional(e, t, r) {
        const n = t[r];
        n !== void 0 && this.setValue(e, r, n)
    }
    static upload(e, t, r, n) {
        for (let o = 0, l = t.length; o !== l; ++o) {
            const c = t[o]
              , u = r[c.id];
            u.needsUpdate !== !1 && c.setValue(e, u.value, n)
        }
    }
    static seqWithValue(e, t) {
        const r = [];
        for (let n = 0, o = e.length; n !== o; ++n) {
            const l = e[n];
            l.id in t && r.push(l)
        }
        return r
    }
}
function WebGLShader(a, e, t) {
    const r = a.createShader(e);
    return a.shaderSource(r, t),
    a.compileShader(r),
    r
}
let programIdCount = 0;
function handleSource(a, e) {
    const t = a.split(`
`)
      , r = []
      , n = Math.max(e - 6, 0)
      , o = Math.min(e + 6, t.length);
    for (let l = n; l < o; l++) {
        const c = l + 1;
        r.push(`${c === e ? ">" : " "} ${c}: ${t[l]}`)
    }
    return r.join(`
`)
}
function getEncodingComponents(a) {
    switch (a) {
    case LinearEncoding:
        return ["Linear", "( value )"];
    case sRGBEncoding:
        return ["sRGB", "( value )"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", a),
        ["Linear", "( value )"]
    }
}
function getShaderErrors(a, e, t) {
    const r = a.getShaderParameter(e, 35713)
      , n = a.getShaderInfoLog(e).trim();
    if (r && n === "")
        return "";
    const o = /ERROR: 0:(\d+)/.exec(n);
    if (o) {
        const l = parseInt(o[1]);
        return t.toUpperCase() + `

` + n + `

` + handleSource(a.getShaderSource(e), l)
    } else
        return n
}
function getTexelEncodingFunction(a, e) {
    const t = getEncodingComponents(e);
    return "vec4 " + a + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
}
function getToneMappingFunction(a, e) {
    let t;
    switch (e) {
    case LinearToneMapping:
        t = "Linear";
        break;
    case ReinhardToneMapping:
        t = "Reinhard";
        break;
    case CineonToneMapping:
        t = "OptimizedCineon";
        break;
    case ACESFilmicToneMapping:
        t = "ACESFilmic";
        break;
    case CustomToneMapping:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + a + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
function generateExtensions(a) {
    return [a.extensionDerivatives || a.envMapCubeUVHeight || a.bumpMap || a.tangentSpaceNormalMap || a.clearcoatNormalMap || a.flatShading || a.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (a.extensionFragDepth || a.logarithmicDepthBuffer) && a.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", a.extensionDrawBuffers && a.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (a.extensionShaderTextureLOD || a.envMap || a.transmission) && a.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(filterEmptyLine).join(`
`)
}
function generateDefines(a) {
    const e = [];
    for (const t in a) {
        const r = a[t];
        r !== !1 && e.push("#define " + t + " " + r)
    }
    return e.join(`
`)
}
function fetchAttributeLocations(a, e) {
    const t = {}
      , r = a.getProgramParameter(e, 35721);
    for (let n = 0; n < r; n++) {
        const o = a.getActiveAttrib(e, n)
          , l = o.name;
        let c = 1;
        o.type === 35674 && (c = 2),
        o.type === 35675 && (c = 3),
        o.type === 35676 && (c = 4),
        t[l] = {
            type: o.type,
            location: a.getAttribLocation(e, l),
            locationSize: c
        }
    }
    return t
}
function filterEmptyLine(a) {
    return a !== ""
}
function replaceLightNums(a, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return a.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function replaceClippingPlaneNums(a, e) {
    return a.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(a) {
    return a.replace(includePattern, includeReplacer)
}
function includeReplacer(a, e) {
    const t = ShaderChunk[e];
    if (t === void 0)
        throw new Error("Can not resolve #include <" + e + ">");
    return resolveIncludes(t)
}
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(a) {
    return a.replace(unrollLoopPattern, loopReplacer)
}
function loopReplacer(a, e, t, r) {
    let n = "";
    for (let o = parseInt(e); o < parseInt(t); o++)
        n += r.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
    return n
}
function generatePrecision(a) {
    let e = "precision " + a.precision + ` float;
precision ` + a.precision + " int;";
    return a.precision === "highp" ? e += `
#define HIGH_PRECISION` : a.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : a.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function generateShadowMapTypeDefine(a) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return a.shadowMapType === PCFShadowMap ? e = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === PCFSoftShadowMap ? e = "SHADOWMAP_TYPE_PCF_SOFT" : a.shadowMapType === VSMShadowMap && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function generateEnvMapTypeDefine(a) {
    let e = "ENVMAP_TYPE_CUBE";
    if (a.envMap)
        switch (a.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case CubeUVReflectionMapping:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function generateEnvMapModeDefine(a) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (a.envMap)
        switch (a.envMapMode) {
        case CubeRefractionMapping:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function generateEnvMapBlendingDefine(a) {
    let e = "ENVMAP_BLENDING_NONE";
    if (a.envMap)
        switch (a.combine) {
        case MultiplyOperation:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case MixOperation:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case AddOperation:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function generateCubeUVSize(a) {
    const e = a.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , r = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: r,
        maxMip: t
    }
}
function WebGLProgram(a, e, t, r) {
    const n = a.getContext()
      , o = t.defines;
    let l = t.vertexShader
      , c = t.fragmentShader;
    const u = generateShadowMapTypeDefine(t)
      , f = generateEnvMapTypeDefine(t)
      , p = generateEnvMapModeDefine(t)
      , g = generateEnvMapBlendingDefine(t)
      , v = generateCubeUVSize(t)
      , _ = t.isWebGL2 ? "" : generateExtensions(t)
      , w = generateDefines(o)
      , S = n.createProgram();
    let b, C, R = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (b = [w].filter(filterEmptyLine).join(`
`),
    b.length > 0 && (b += `
`),
    C = [_, w].filter(filterEmptyLine).join(`
`),
    C.length > 0 && (C += `
`)) : (b = [generatePrecision(t), "#define SHADER_NAME " + t.shaderName, w, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + p : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + u : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(filterEmptyLine).join(`
`),
    C = [_, generatePrecision(t), "#define SHADER_NAME " + t.shaderName, w, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + f : "", t.envMap ? "#define " + p : "", t.envMap ? "#define " + g : "", v ? "#define CUBEUV_TEXEL_WIDTH " + v.texelWidth : "", v ? "#define CUBEUV_TEXEL_HEIGHT " + v.texelHeight : "", v ? "#define CUBEUV_MAX_MIP " + v.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + u : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", t.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "", t.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", ShaderChunk.encodings_pars_fragment, getTexelEncodingFunction("linearToOutputTexel", t.outputEncoding), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(filterEmptyLine).join(`
`)),
    l = resolveIncludes(l),
    l = replaceLightNums(l, t),
    l = replaceClippingPlaneNums(l, t),
    c = resolveIncludes(c),
    c = replaceLightNums(c, t),
    c = replaceClippingPlaneNums(c, t),
    l = unrollLoops(l),
    c = unrollLoops(c),
    t.isWebGL2 && t.isRawShaderMaterial !== !0 && (R = `#version 300 es
`,
    b = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + b,
    C = ["#define varying in", t.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + C);
    const T = R + b + l
      , M = R + C + c
      , P = WebGLShader(n, 35633, T)
      , I = WebGLShader(n, 35632, M);
    if (n.attachShader(S, P),
    n.attachShader(S, I),
    t.index0AttributeName !== void 0 ? n.bindAttribLocation(S, 0, t.index0AttributeName) : t.morphTargets === !0 && n.bindAttribLocation(S, 0, "position"),
    n.linkProgram(S),
    a.debug.checkShaderErrors) {
        const O = n.getProgramInfoLog(S).trim()
          , W = n.getShaderInfoLog(P).trim()
          , Q = n.getShaderInfoLog(I).trim();
        let H = !0
          , B = !0;
        if (n.getProgramParameter(S, 35714) === !1) {
            H = !1;
            const D = getShaderErrors(n, P, "vertex")
              , q = getShaderErrors(n, I, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + n.getError() + " - VALIDATE_STATUS " + n.getProgramParameter(S, 35715) + `

Program Info Log: ` + O + `
` + D + `
` + q)
        } else
            O !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", O) : (W === "" || Q === "") && (B = !1);
        B && (this.diagnostics = {
            runnable: H,
            programLog: O,
            vertexShader: {
                log: W,
                prefix: b
            },
            fragmentShader: {
                log: Q,
                prefix: C
            }
        })
    }
    n.deleteShader(P),
    n.deleteShader(I);
    let k;
    this.getUniforms = function() {
        return k === void 0 && (k = new WebGLUniforms(n,S)),
        k
    }
    ;
    let A;
    return this.getAttributes = function() {
        return A === void 0 && (A = fetchAttributeLocations(n, S)),
        A
    }
    ,
    this.destroy = function() {
        r.releaseStatesOfProgram(this),
        n.deleteProgram(S),
        this.program = void 0
    }
    ,
    this.name = t.shaderName,
    this.id = programIdCount++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = S,
    this.vertexShader = P,
    this.fragmentShader = I,
    this
}
let _id = 0;
class WebGLShaderCache {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , r = e.fragmentShader
          , n = this._getShaderStage(t)
          , o = this._getShaderStage(r)
          , l = this._getShaderCacheForMaterial(e);
        return l.has(n) === !1 && (l.add(n),
        n.usedTimes++),
        l.has(o) === !1 && (l.add(o),
        o.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const r of t)
            r.usedTimes--,
            r.usedTimes === 0 && this.shaderCache.delete(r.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let r = t.get(e);
        return r === void 0 && (r = new Set,
        t.set(e, r)),
        r
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let r = t.get(e);
        return r === void 0 && (r = new WebGLShaderStage(e),
        t.set(e, r)),
        r
    }
}
class WebGLShaderStage {
    constructor(e) {
        this.id = _id++,
        this.code = e,
        this.usedTimes = 0
    }
}
function WebGLPrograms(a, e, t, r, n, o, l) {
    const c = new Layers
      , u = new WebGLShaderCache
      , f = []
      , p = n.isWebGL2
      , g = n.logarithmicDepthBuffer
      , v = n.vertexTextures;
    let _ = n.precision;
    const w = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function S(A, O, W, Q, H) {
        const B = Q.fog
          , D = H.geometry
          , q = A.isMeshStandardMaterial ? Q.environment : null
          , V = (A.isMeshStandardMaterial ? t : e).get(A.envMap || q)
          , J = V && V.mapping === CubeUVReflectionMapping ? V.image.height : null
          , U = w[A.type];
        A.precision !== null && (_ = n.getMaxPrecision(A.precision),
        _ !== A.precision && console.warn("THREE.WebGLProgram.getParameters:", A.precision, "not supported, using", _, "instead."));
        const ce = D.morphAttributes.position || D.morphAttributes.normal || D.morphAttributes.color
          , ee = ce !== void 0 ? ce.length : 0;
        let ne = 0;
        D.morphAttributes.position !== void 0 && (ne = 1),
        D.morphAttributes.normal !== void 0 && (ne = 2),
        D.morphAttributes.color !== void 0 && (ne = 3);
        let ae, ve, Y, $;
        if (U) {
            const Se = ShaderLib[U];
            ae = Se.vertexShader,
            ve = Se.fragmentShader
        } else
            ae = A.vertexShader,
            ve = A.fragmentShader,
            u.update(A),
            Y = u.getVertexShaderID(A),
            $ = u.getFragmentShaderID(A);
        const L = a.getRenderTarget()
          , N = A.alphaTest > 0
          , oe = A.clearcoat > 0
          , pe = A.iridescence > 0;
        return {
            isWebGL2: p,
            shaderID: U,
            shaderName: A.type,
            vertexShader: ae,
            fragmentShader: ve,
            defines: A.defines,
            customVertexShaderID: Y,
            customFragmentShaderID: $,
            isRawShaderMaterial: A.isRawShaderMaterial === !0,
            glslVersion: A.glslVersion,
            precision: _,
            instancing: H.isInstancedMesh === !0,
            instancingColor: H.isInstancedMesh === !0 && H.instanceColor !== null,
            supportsVertexTextures: v,
            outputEncoding: L === null ? a.outputEncoding : L.isXRRenderTarget === !0 ? L.texture.encoding : LinearEncoding,
            map: !!A.map,
            matcap: !!A.matcap,
            envMap: !!V,
            envMapMode: V && V.mapping,
            envMapCubeUVHeight: J,
            lightMap: !!A.lightMap,
            aoMap: !!A.aoMap,
            emissiveMap: !!A.emissiveMap,
            bumpMap: !!A.bumpMap,
            normalMap: !!A.normalMap,
            objectSpaceNormalMap: A.normalMapType === ObjectSpaceNormalMap,
            tangentSpaceNormalMap: A.normalMapType === TangentSpaceNormalMap,
            decodeVideoTexture: !!A.map && A.map.isVideoTexture === !0 && A.map.encoding === sRGBEncoding,
            clearcoat: oe,
            clearcoatMap: oe && !!A.clearcoatMap,
            clearcoatRoughnessMap: oe && !!A.clearcoatRoughnessMap,
            clearcoatNormalMap: oe && !!A.clearcoatNormalMap,
            iridescence: pe,
            iridescenceMap: pe && !!A.iridescenceMap,
            iridescenceThicknessMap: pe && !!A.iridescenceThicknessMap,
            displacementMap: !!A.displacementMap,
            roughnessMap: !!A.roughnessMap,
            metalnessMap: !!A.metalnessMap,
            specularMap: !!A.specularMap,
            specularIntensityMap: !!A.specularIntensityMap,
            specularColorMap: !!A.specularColorMap,
            opaque: A.transparent === !1 && A.blending === NormalBlending,
            alphaMap: !!A.alphaMap,
            alphaTest: N,
            gradientMap: !!A.gradientMap,
            sheen: A.sheen > 0,
            sheenColorMap: !!A.sheenColorMap,
            sheenRoughnessMap: !!A.sheenRoughnessMap,
            transmission: A.transmission > 0,
            transmissionMap: !!A.transmissionMap,
            thicknessMap: !!A.thicknessMap,
            combine: A.combine,
            vertexTangents: !!A.normalMap && !!D.attributes.tangent,
            vertexColors: A.vertexColors,
            vertexAlphas: A.vertexColors === !0 && !!D.attributes.color && D.attributes.color.itemSize === 4,
            vertexUvs: !!A.map || !!A.bumpMap || !!A.normalMap || !!A.specularMap || !!A.alphaMap || !!A.emissiveMap || !!A.roughnessMap || !!A.metalnessMap || !!A.clearcoatMap || !!A.clearcoatRoughnessMap || !!A.clearcoatNormalMap || !!A.iridescenceMap || !!A.iridescenceThicknessMap || !!A.displacementMap || !!A.transmissionMap || !!A.thicknessMap || !!A.specularIntensityMap || !!A.specularColorMap || !!A.sheenColorMap || !!A.sheenRoughnessMap,
            uvsVertexOnly: !(A.map || A.bumpMap || A.normalMap || A.specularMap || A.alphaMap || A.emissiveMap || A.roughnessMap || A.metalnessMap || A.clearcoatNormalMap || A.iridescenceMap || A.iridescenceThicknessMap || A.transmission > 0 || A.transmissionMap || A.thicknessMap || A.specularIntensityMap || A.specularColorMap || A.sheen > 0 || A.sheenColorMap || A.sheenRoughnessMap) && !!A.displacementMap,
            fog: !!B,
            useFog: A.fog === !0,
            fogExp2: B && B.isFogExp2,
            flatShading: !!A.flatShading,
            sizeAttenuation: A.sizeAttenuation,
            logarithmicDepthBuffer: g,
            skinning: H.isSkinnedMesh === !0,
            morphTargets: D.morphAttributes.position !== void 0,
            morphNormals: D.morphAttributes.normal !== void 0,
            morphColors: D.morphAttributes.color !== void 0,
            morphTargetsCount: ee,
            morphTextureStride: ne,
            numDirLights: O.directional.length,
            numPointLights: O.point.length,
            numSpotLights: O.spot.length,
            numSpotLightMaps: O.spotLightMap.length,
            numRectAreaLights: O.rectArea.length,
            numHemiLights: O.hemi.length,
            numDirLightShadows: O.directionalShadowMap.length,
            numPointLightShadows: O.pointShadowMap.length,
            numSpotLightShadows: O.spotShadowMap.length,
            numSpotLightShadowsWithMaps: O.numSpotLightShadowsWithMaps,
            numClippingPlanes: l.numPlanes,
            numClipIntersection: l.numIntersection,
            dithering: A.dithering,
            shadowMapEnabled: a.shadowMap.enabled && W.length > 0,
            shadowMapType: a.shadowMap.type,
            toneMapping: A.toneMapped ? a.toneMapping : NoToneMapping,
            physicallyCorrectLights: a.physicallyCorrectLights,
            premultipliedAlpha: A.premultipliedAlpha,
            doubleSided: A.side === DoubleSide,
            flipSided: A.side === BackSide,
            useDepthPacking: !!A.depthPacking,
            depthPacking: A.depthPacking || 0,
            index0AttributeName: A.index0AttributeName,
            extensionDerivatives: A.extensions && A.extensions.derivatives,
            extensionFragDepth: A.extensions && A.extensions.fragDepth,
            extensionDrawBuffers: A.extensions && A.extensions.drawBuffers,
            extensionShaderTextureLOD: A.extensions && A.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: p || r.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: p || r.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: p || r.has("EXT_shader_texture_lod"),
            customProgramCacheKey: A.customProgramCacheKey()
        }
    }
    function b(A) {
        const O = [];
        if (A.shaderID ? O.push(A.shaderID) : (O.push(A.customVertexShaderID),
        O.push(A.customFragmentShaderID)),
        A.defines !== void 0)
            for (const W in A.defines)
                O.push(W),
                O.push(A.defines[W]);
        return A.isRawShaderMaterial === !1 && (C(O, A),
        R(O, A),
        O.push(a.outputEncoding)),
        O.push(A.customProgramCacheKey),
        O.join()
    }
    function C(A, O) {
        A.push(O.precision),
        A.push(O.outputEncoding),
        A.push(O.envMapMode),
        A.push(O.envMapCubeUVHeight),
        A.push(O.combine),
        A.push(O.vertexUvs),
        A.push(O.fogExp2),
        A.push(O.sizeAttenuation),
        A.push(O.morphTargetsCount),
        A.push(O.morphAttributeCount),
        A.push(O.numDirLights),
        A.push(O.numPointLights),
        A.push(O.numSpotLights),
        A.push(O.numSpotLightMaps),
        A.push(O.numHemiLights),
        A.push(O.numRectAreaLights),
        A.push(O.numDirLightShadows),
        A.push(O.numPointLightShadows),
        A.push(O.numSpotLightShadows),
        A.push(O.numSpotLightShadowsWithMaps),
        A.push(O.shadowMapType),
        A.push(O.toneMapping),
        A.push(O.numClippingPlanes),
        A.push(O.numClipIntersection),
        A.push(O.depthPacking)
    }
    function R(A, O) {
        c.disableAll(),
        O.isWebGL2 && c.enable(0),
        O.supportsVertexTextures && c.enable(1),
        O.instancing && c.enable(2),
        O.instancingColor && c.enable(3),
        O.map && c.enable(4),
        O.matcap && c.enable(5),
        O.envMap && c.enable(6),
        O.lightMap && c.enable(7),
        O.aoMap && c.enable(8),
        O.emissiveMap && c.enable(9),
        O.bumpMap && c.enable(10),
        O.normalMap && c.enable(11),
        O.objectSpaceNormalMap && c.enable(12),
        O.tangentSpaceNormalMap && c.enable(13),
        O.clearcoat && c.enable(14),
        O.clearcoatMap && c.enable(15),
        O.clearcoatRoughnessMap && c.enable(16),
        O.clearcoatNormalMap && c.enable(17),
        O.iridescence && c.enable(18),
        O.iridescenceMap && c.enable(19),
        O.iridescenceThicknessMap && c.enable(20),
        O.displacementMap && c.enable(21),
        O.specularMap && c.enable(22),
        O.roughnessMap && c.enable(23),
        O.metalnessMap && c.enable(24),
        O.gradientMap && c.enable(25),
        O.alphaMap && c.enable(26),
        O.alphaTest && c.enable(27),
        O.vertexColors && c.enable(28),
        O.vertexAlphas && c.enable(29),
        O.vertexUvs && c.enable(30),
        O.vertexTangents && c.enable(31),
        O.uvsVertexOnly && c.enable(32),
        A.push(c.mask),
        c.disableAll(),
        O.fog && c.enable(0),
        O.useFog && c.enable(1),
        O.flatShading && c.enable(2),
        O.logarithmicDepthBuffer && c.enable(3),
        O.skinning && c.enable(4),
        O.morphTargets && c.enable(5),
        O.morphNormals && c.enable(6),
        O.morphColors && c.enable(7),
        O.premultipliedAlpha && c.enable(8),
        O.shadowMapEnabled && c.enable(9),
        O.physicallyCorrectLights && c.enable(10),
        O.doubleSided && c.enable(11),
        O.flipSided && c.enable(12),
        O.useDepthPacking && c.enable(13),
        O.dithering && c.enable(14),
        O.specularIntensityMap && c.enable(15),
        O.specularColorMap && c.enable(16),
        O.transmission && c.enable(17),
        O.transmissionMap && c.enable(18),
        O.thicknessMap && c.enable(19),
        O.sheen && c.enable(20),
        O.sheenColorMap && c.enable(21),
        O.sheenRoughnessMap && c.enable(22),
        O.decodeVideoTexture && c.enable(23),
        O.opaque && c.enable(24),
        A.push(c.mask)
    }
    function T(A) {
        const O = w[A.type];
        let W;
        if (O) {
            const Q = ShaderLib[O];
            W = UniformsUtils.clone(Q.uniforms)
        } else
            W = A.uniforms;
        return W
    }
    function M(A, O) {
        let W;
        for (let Q = 0, H = f.length; Q < H; Q++) {
            const B = f[Q];
            if (B.cacheKey === O) {
                W = B,
                ++W.usedTimes;
                break
            }
        }
        return W === void 0 && (W = new WebGLProgram(a,O,A,o),
        f.push(W)),
        W
    }
    function P(A) {
        if (--A.usedTimes === 0) {
            const O = f.indexOf(A);
            f[O] = f[f.length - 1],
            f.pop(),
            A.destroy()
        }
    }
    function I(A) {
        u.remove(A)
    }
    function k() {
        u.dispose()
    }
    return {
        getParameters: S,
        getProgramCacheKey: b,
        getUniforms: T,
        acquireProgram: M,
        releaseProgram: P,
        releaseShaderCache: I,
        programs: f,
        dispose: k
    }
}
function WebGLProperties() {
    let a = new WeakMap;
    function e(o) {
        let l = a.get(o);
        return l === void 0 && (l = {},
        a.set(o, l)),
        l
    }
    function t(o) {
        a.delete(o)
    }
    function r(o, l, c) {
        a.get(o)[l] = c
    }
    function n() {
        a = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: r,
        dispose: n
    }
}
function painterSortStable(a, e) {
    return a.groupOrder !== e.groupOrder ? a.groupOrder - e.groupOrder : a.renderOrder !== e.renderOrder ? a.renderOrder - e.renderOrder : a.material.id !== e.material.id ? a.material.id - e.material.id : a.z !== e.z ? a.z - e.z : a.id - e.id
}
function reversePainterSortStable(a, e) {
    return a.groupOrder !== e.groupOrder ? a.groupOrder - e.groupOrder : a.renderOrder !== e.renderOrder ? a.renderOrder - e.renderOrder : a.z !== e.z ? e.z - a.z : a.id - e.id
}
function WebGLRenderList() {
    const a = [];
    let e = 0;
    const t = []
      , r = []
      , n = [];
    function o() {
        e = 0,
        t.length = 0,
        r.length = 0,
        n.length = 0
    }
    function l(g, v, _, w, S, b) {
        let C = a[e];
        return C === void 0 ? (C = {
            id: g.id,
            object: g,
            geometry: v,
            material: _,
            groupOrder: w,
            renderOrder: g.renderOrder,
            z: S,
            group: b
        },
        a[e] = C) : (C.id = g.id,
        C.object = g,
        C.geometry = v,
        C.material = _,
        C.groupOrder = w,
        C.renderOrder = g.renderOrder,
        C.z = S,
        C.group = b),
        e++,
        C
    }
    function c(g, v, _, w, S, b) {
        const C = l(g, v, _, w, S, b);
        _.transmission > 0 ? r.push(C) : _.transparent === !0 ? n.push(C) : t.push(C)
    }
    function u(g, v, _, w, S, b) {
        const C = l(g, v, _, w, S, b);
        _.transmission > 0 ? r.unshift(C) : _.transparent === !0 ? n.unshift(C) : t.unshift(C)
    }
    function f(g, v) {
        t.length > 1 && t.sort(g || painterSortStable),
        r.length > 1 && r.sort(v || reversePainterSortStable),
        n.length > 1 && n.sort(v || reversePainterSortStable)
    }
    function p() {
        for (let g = e, v = a.length; g < v; g++) {
            const _ = a[g];
            if (_.id === null)
                break;
            _.id = null,
            _.object = null,
            _.geometry = null,
            _.material = null,
            _.group = null
        }
    }
    return {
        opaque: t,
        transmissive: r,
        transparent: n,
        init: o,
        push: c,
        unshift: u,
        finish: p,
        sort: f
    }
}
function WebGLRenderLists() {
    let a = new WeakMap;
    function e(r, n) {
        const o = a.get(r);
        let l;
        return o === void 0 ? (l = new WebGLRenderList,
        a.set(r, [l])) : n >= o.length ? (l = new WebGLRenderList,
        o.push(l)) : l = o[n],
        l
    }
    function t() {
        a = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function UniformsCache() {
    const a = {};
    return {
        get: function(e) {
            if (a[e.id] !== void 0)
                return a[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new Vector3,
                    color: new Color
                };
                break;
            case "SpotLight":
                t = {
                    position: new Vector3,
                    direction: new Vector3,
                    color: new Color,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new Vector3,
                    color: new Color,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new Vector3,
                    skyColor: new Color,
                    groundColor: new Color
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new Color,
                    position: new Vector3,
                    halfWidth: new Vector3,
                    halfHeight: new Vector3
                };
                break
            }
            return a[e.id] = t,
            t
        }
    }
}
function ShadowUniformsCache() {
    const a = {};
    return {
        get: function(e) {
            if (a[e.id] !== void 0)
                return a[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2
                };
                break;
            case "SpotLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2
                };
                break;
            case "PointLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return a[e.id] = t,
            t
        }
    }
}
let nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(a, e) {
    return (e.castShadow ? 2 : 0) - (a.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (a.map ? 1 : 0)
}
function WebGLLights(a, e) {
    const t = new UniformsCache
      , r = ShadowUniformsCache()
      , n = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0
    };
    for (let p = 0; p < 9; p++)
        n.probe.push(new Vector3);
    const o = new Vector3
      , l = new Matrix4
      , c = new Matrix4;
    function u(p, g) {
        let v = 0
          , _ = 0
          , w = 0;
        for (let Q = 0; Q < 9; Q++)
            n.probe[Q].set(0, 0, 0);
        let S = 0
          , b = 0
          , C = 0
          , R = 0
          , T = 0
          , M = 0
          , P = 0
          , I = 0
          , k = 0
          , A = 0;
        p.sort(shadowCastingAndTexturingLightsFirst);
        const O = g !== !0 ? Math.PI : 1;
        for (let Q = 0, H = p.length; Q < H; Q++) {
            const B = p[Q]
              , D = B.color
              , q = B.intensity
              , V = B.distance
              , J = B.shadow && B.shadow.map ? B.shadow.map.texture : null;
            if (B.isAmbientLight)
                v += D.r * q * O,
                _ += D.g * q * O,
                w += D.b * q * O;
            else if (B.isLightProbe)
                for (let U = 0; U < 9; U++)
                    n.probe[U].addScaledVector(B.sh.coefficients[U], q);
            else if (B.isDirectionalLight) {
                const U = t.get(B);
                if (U.color.copy(B.color).multiplyScalar(B.intensity * O),
                B.castShadow) {
                    const ce = B.shadow
                      , ee = r.get(B);
                    ee.shadowBias = ce.bias,
                    ee.shadowNormalBias = ce.normalBias,
                    ee.shadowRadius = ce.radius,
                    ee.shadowMapSize = ce.mapSize,
                    n.directionalShadow[S] = ee,
                    n.directionalShadowMap[S] = J,
                    n.directionalShadowMatrix[S] = B.shadow.matrix,
                    M++
                }
                n.directional[S] = U,
                S++
            } else if (B.isSpotLight) {
                const U = t.get(B);
                U.position.setFromMatrixPosition(B.matrixWorld),
                U.color.copy(D).multiplyScalar(q * O),
                U.distance = V,
                U.coneCos = Math.cos(B.angle),
                U.penumbraCos = Math.cos(B.angle * (1 - B.penumbra)),
                U.decay = B.decay,
                n.spot[C] = U;
                const ce = B.shadow;
                if (B.map && (n.spotLightMap[k] = B.map,
                k++,
                ce.updateMatrices(B),
                B.castShadow && A++),
                n.spotLightMatrix[C] = ce.matrix,
                B.castShadow) {
                    const ee = r.get(B);
                    ee.shadowBias = ce.bias,
                    ee.shadowNormalBias = ce.normalBias,
                    ee.shadowRadius = ce.radius,
                    ee.shadowMapSize = ce.mapSize,
                    n.spotShadow[C] = ee,
                    n.spotShadowMap[C] = J,
                    I++
                }
                C++
            } else if (B.isRectAreaLight) {
                const U = t.get(B);
                U.color.copy(D).multiplyScalar(q),
                U.halfWidth.set(B.width * .5, 0, 0),
                U.halfHeight.set(0, B.height * .5, 0),
                n.rectArea[R] = U,
                R++
            } else if (B.isPointLight) {
                const U = t.get(B);
                if (U.color.copy(B.color).multiplyScalar(B.intensity * O),
                U.distance = B.distance,
                U.decay = B.decay,
                B.castShadow) {
                    const ce = B.shadow
                      , ee = r.get(B);
                    ee.shadowBias = ce.bias,
                    ee.shadowNormalBias = ce.normalBias,
                    ee.shadowRadius = ce.radius,
                    ee.shadowMapSize = ce.mapSize,
                    ee.shadowCameraNear = ce.camera.near,
                    ee.shadowCameraFar = ce.camera.far,
                    n.pointShadow[b] = ee,
                    n.pointShadowMap[b] = J,
                    n.pointShadowMatrix[b] = B.shadow.matrix,
                    P++
                }
                n.point[b] = U,
                b++
            } else if (B.isHemisphereLight) {
                const U = t.get(B);
                U.skyColor.copy(B.color).multiplyScalar(q * O),
                U.groundColor.copy(B.groundColor).multiplyScalar(q * O),
                n.hemi[T] = U,
                T++
            }
        }
        R > 0 && (e.isWebGL2 || a.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1,
        n.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2) : a.has("OES_texture_half_float_linear") === !0 ? (n.rectAreaLTC1 = UniformsLib.LTC_HALF_1,
        n.rectAreaLTC2 = UniformsLib.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
        n.ambient[0] = v,
        n.ambient[1] = _,
        n.ambient[2] = w;
        const W = n.hash;
        (W.directionalLength !== S || W.pointLength !== b || W.spotLength !== C || W.rectAreaLength !== R || W.hemiLength !== T || W.numDirectionalShadows !== M || W.numPointShadows !== P || W.numSpotShadows !== I || W.numSpotMaps !== k) && (n.directional.length = S,
        n.spot.length = C,
        n.rectArea.length = R,
        n.point.length = b,
        n.hemi.length = T,
        n.directionalShadow.length = M,
        n.directionalShadowMap.length = M,
        n.pointShadow.length = P,
        n.pointShadowMap.length = P,
        n.spotShadow.length = I,
        n.spotShadowMap.length = I,
        n.directionalShadowMatrix.length = M,
        n.pointShadowMatrix.length = P,
        n.spotLightMatrix.length = I + k - A,
        n.spotLightMap.length = k,
        n.numSpotLightShadowsWithMaps = A,
        W.directionalLength = S,
        W.pointLength = b,
        W.spotLength = C,
        W.rectAreaLength = R,
        W.hemiLength = T,
        W.numDirectionalShadows = M,
        W.numPointShadows = P,
        W.numSpotShadows = I,
        W.numSpotMaps = k,
        n.version = nextVersion++)
    }
    function f(p, g) {
        let v = 0
          , _ = 0
          , w = 0
          , S = 0
          , b = 0;
        const C = g.matrixWorldInverse;
        for (let R = 0, T = p.length; R < T; R++) {
            const M = p[R];
            if (M.isDirectionalLight) {
                const P = n.directional[v];
                P.direction.setFromMatrixPosition(M.matrixWorld),
                o.setFromMatrixPosition(M.target.matrixWorld),
                P.direction.sub(o),
                P.direction.transformDirection(C),
                v++
            } else if (M.isSpotLight) {
                const P = n.spot[w];
                P.position.setFromMatrixPosition(M.matrixWorld),
                P.position.applyMatrix4(C),
                P.direction.setFromMatrixPosition(M.matrixWorld),
                o.setFromMatrixPosition(M.target.matrixWorld),
                P.direction.sub(o),
                P.direction.transformDirection(C),
                w++
            } else if (M.isRectAreaLight) {
                const P = n.rectArea[S];
                P.position.setFromMatrixPosition(M.matrixWorld),
                P.position.applyMatrix4(C),
                c.identity(),
                l.copy(M.matrixWorld),
                l.premultiply(C),
                c.extractRotation(l),
                P.halfWidth.set(M.width * .5, 0, 0),
                P.halfHeight.set(0, M.height * .5, 0),
                P.halfWidth.applyMatrix4(c),
                P.halfHeight.applyMatrix4(c),
                S++
            } else if (M.isPointLight) {
                const P = n.point[_];
                P.position.setFromMatrixPosition(M.matrixWorld),
                P.position.applyMatrix4(C),
                _++
            } else if (M.isHemisphereLight) {
                const P = n.hemi[b];
                P.direction.setFromMatrixPosition(M.matrixWorld),
                P.direction.transformDirection(C),
                b++
            }
        }
    }
    return {
        setup: u,
        setupView: f,
        state: n
    }
}
function WebGLRenderState(a, e) {
    const t = new WebGLLights(a,e)
      , r = []
      , n = [];
    function o() {
        r.length = 0,
        n.length = 0
    }
    function l(g) {
        r.push(g)
    }
    function c(g) {
        n.push(g)
    }
    function u(g) {
        t.setup(r, g)
    }
    function f(g) {
        t.setupView(r, g)
    }
    return {
        init: o,
        state: {
            lightsArray: r,
            shadowsArray: n,
            lights: t
        },
        setupLights: u,
        setupLightsView: f,
        pushLight: l,
        pushShadow: c
    }
}
function WebGLRenderStates(a, e) {
    let t = new WeakMap;
    function r(o, l=0) {
        const c = t.get(o);
        let u;
        return c === void 0 ? (u = new WebGLRenderState(a,e),
        t.set(o, [u])) : l >= c.length ? (u = new WebGLRenderState(a,e),
        c.push(u)) : u = c[l],
        u
    }
    function n() {
        t = new WeakMap
    }
    return {
        get: r,
        dispose: n
    }
}
class MeshDepthMaterial extends Material {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = BasicDepthPacking,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class MeshDistanceMaterial extends Material {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new Vector3,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.referencePosition.copy(e.referencePosition),
        this.nearDistance = e.nearDistance,
        this.farDistance = e.farDistance,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const vertex = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , fragment = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function WebGLShadowMap(a, e, t) {
    let r = new Frustum;
    const n = new Vector2
      , o = new Vector2
      , l = new Vector4
      , c = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking
    })
      , u = new MeshDistanceMaterial
      , f = {}
      , p = t.maxTextureSize
      , g = {
        0: BackSide,
        1: FrontSide,
        2: DoubleSide
    }
      , v = new ShaderMaterial({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Vector2
            },
            radius: {
                value: 4
            }
        },
        vertexShader: vertex,
        fragmentShader: fragment
    })
      , _ = v.clone();
    _.defines.HORIZONTAL_PASS = 1;
    const w = new BufferGeometry;
    w.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const S = new Mesh(w,v)
      , b = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = PCFShadowMap,
    this.render = function(M, P, I) {
        if (b.enabled === !1 || b.autoUpdate === !1 && b.needsUpdate === !1 || M.length === 0)
            return;
        const k = a.getRenderTarget()
          , A = a.getActiveCubeFace()
          , O = a.getActiveMipmapLevel()
          , W = a.state;
        W.setBlending(NoBlending),
        W.buffers.color.setClear(1, 1, 1, 1),
        W.buffers.depth.setTest(!0),
        W.setScissorTest(!1);
        for (let Q = 0, H = M.length; Q < H; Q++) {
            const B = M[Q]
              , D = B.shadow;
            if (D === void 0) {
                console.warn("THREE.WebGLShadowMap:", B, "has no shadow.");
                continue
            }
            if (D.autoUpdate === !1 && D.needsUpdate === !1)
                continue;
            n.copy(D.mapSize);
            const q = D.getFrameExtents();
            if (n.multiply(q),
            o.copy(D.mapSize),
            (n.x > p || n.y > p) && (n.x > p && (o.x = Math.floor(p / q.x),
            n.x = o.x * q.x,
            D.mapSize.x = o.x),
            n.y > p && (o.y = Math.floor(p / q.y),
            n.y = o.y * q.y,
            D.mapSize.y = o.y)),
            D.map === null) {
                const J = this.type !== VSMShadowMap ? {
                    minFilter: NearestFilter,
                    magFilter: NearestFilter
                } : {};
                D.map = new WebGLRenderTarget(n.x,n.y,J),
                D.map.texture.name = B.name + ".shadowMap",
                D.camera.updateProjectionMatrix()
            }
            a.setRenderTarget(D.map),
            a.clear();
            const V = D.getViewportCount();
            for (let J = 0; J < V; J++) {
                const U = D.getViewport(J);
                l.set(o.x * U.x, o.y * U.y, o.x * U.z, o.y * U.w),
                W.viewport(l),
                D.updateMatrices(B, J),
                r = D.getFrustum(),
                T(P, I, D.camera, B, this.type)
            }
            D.isPointLightShadow !== !0 && this.type === VSMShadowMap && C(D, I),
            D.needsUpdate = !1
        }
        b.needsUpdate = !1,
        a.setRenderTarget(k, A, O)
    }
    ;
    function C(M, P) {
        const I = e.update(S);
        v.defines.VSM_SAMPLES !== M.blurSamples && (v.defines.VSM_SAMPLES = M.blurSamples,
        _.defines.VSM_SAMPLES = M.blurSamples,
        v.needsUpdate = !0,
        _.needsUpdate = !0),
        M.mapPass === null && (M.mapPass = new WebGLRenderTarget(n.x,n.y)),
        v.uniforms.shadow_pass.value = M.map.texture,
        v.uniforms.resolution.value = M.mapSize,
        v.uniforms.radius.value = M.radius,
        a.setRenderTarget(M.mapPass),
        a.clear(),
        a.renderBufferDirect(P, null, I, v, S, null),
        _.uniforms.shadow_pass.value = M.mapPass.texture,
        _.uniforms.resolution.value = M.mapSize,
        _.uniforms.radius.value = M.radius,
        a.setRenderTarget(M.map),
        a.clear(),
        a.renderBufferDirect(P, null, I, _, S, null)
    }
    function R(M, P, I, k, A, O) {
        let W = null;
        const Q = I.isPointLight === !0 ? M.customDistanceMaterial : M.customDepthMaterial;
        if (Q !== void 0)
            W = Q;
        else if (W = I.isPointLight === !0 ? u : c,
        a.localClippingEnabled && P.clipShadows === !0 && Array.isArray(P.clippingPlanes) && P.clippingPlanes.length !== 0 || P.displacementMap && P.displacementScale !== 0 || P.alphaMap && P.alphaTest > 0 || P.map && P.alphaTest > 0) {
            const H = W.uuid
              , B = P.uuid;
            let D = f[H];
            D === void 0 && (D = {},
            f[H] = D);
            let q = D[B];
            q === void 0 && (q = W.clone(),
            D[B] = q),
            W = q
        }
        return W.visible = P.visible,
        W.wireframe = P.wireframe,
        O === VSMShadowMap ? W.side = P.shadowSide !== null ? P.shadowSide : P.side : W.side = P.shadowSide !== null ? P.shadowSide : g[P.side],
        W.alphaMap = P.alphaMap,
        W.alphaTest = P.alphaTest,
        W.map = P.map,
        W.clipShadows = P.clipShadows,
        W.clippingPlanes = P.clippingPlanes,
        W.clipIntersection = P.clipIntersection,
        W.displacementMap = P.displacementMap,
        W.displacementScale = P.displacementScale,
        W.displacementBias = P.displacementBias,
        W.wireframeLinewidth = P.wireframeLinewidth,
        W.linewidth = P.linewidth,
        I.isPointLight === !0 && W.isMeshDistanceMaterial === !0 && (W.referencePosition.setFromMatrixPosition(I.matrixWorld),
        W.nearDistance = k,
        W.farDistance = A),
        W
    }
    function T(M, P, I, k, A) {
        if (M.visible === !1)
            return;
        if (M.layers.test(P.layers) && (M.isMesh || M.isLine || M.isPoints) && (M.castShadow || M.receiveShadow && A === VSMShadowMap) && (!M.frustumCulled || r.intersectsObject(M))) {
            M.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse, M.matrixWorld);
            const Q = e.update(M)
              , H = M.material;
            if (Array.isArray(H)) {
                const B = Q.groups;
                for (let D = 0, q = B.length; D < q; D++) {
                    const V = B[D]
                      , J = H[V.materialIndex];
                    if (J && J.visible) {
                        const U = R(M, J, k, I.near, I.far, A);
                        a.renderBufferDirect(I, null, Q, U, M, V)
                    }
                }
            } else if (H.visible) {
                const B = R(M, H, k, I.near, I.far, A);
                a.renderBufferDirect(I, null, Q, B, M, null)
            }
        }
        const W = M.children;
        for (let Q = 0, H = W.length; Q < H; Q++)
            T(W[Q], P, I, k, A)
    }
}
function WebGLState(a, e, t) {
    const r = t.isWebGL2;
    function n() {
        let se = !1;
        const re = new Vector4;
        let Ie = null;
        const We = new Vector4(0,0,0,0);
        return {
            setMask: function(Ye) {
                Ie !== Ye && !se && (a.colorMask(Ye, Ye, Ye, Ye),
                Ie = Ye)
            },
            setLocked: function(Ye) {
                se = Ye
            },
            setClear: function(Ye, st, pt, gt, bt) {
                bt === !0 && (Ye *= gt,
                st *= gt,
                pt *= gt),
                re.set(Ye, st, pt, gt),
                We.equals(re) === !1 && (a.clearColor(Ye, st, pt, gt),
                We.copy(re))
            },
            reset: function() {
                se = !1,
                Ie = null,
                We.set(-1, 0, 0, 0)
            }
        }
    }
    function o() {
        let se = !1
          , re = null
          , Ie = null
          , We = null;
        return {
            setTest: function(Ye) {
                Ye ? N(2929) : oe(2929)
            },
            setMask: function(Ye) {
                re !== Ye && !se && (a.depthMask(Ye),
                re = Ye)
            },
            setFunc: function(Ye) {
                if (Ie !== Ye) {
                    switch (Ye) {
                    case NeverDepth:
                        a.depthFunc(512);
                        break;
                    case AlwaysDepth:
                        a.depthFunc(519);
                        break;
                    case LessDepth:
                        a.depthFunc(513);
                        break;
                    case LessEqualDepth:
                        a.depthFunc(515);
                        break;
                    case EqualDepth:
                        a.depthFunc(514);
                        break;
                    case GreaterEqualDepth:
                        a.depthFunc(518);
                        break;
                    case GreaterDepth:
                        a.depthFunc(516);
                        break;
                    case NotEqualDepth:
                        a.depthFunc(517);
                        break;
                    default:
                        a.depthFunc(515)
                    }
                    Ie = Ye
                }
            },
            setLocked: function(Ye) {
                se = Ye
            },
            setClear: function(Ye) {
                We !== Ye && (a.clearDepth(Ye),
                We = Ye)
            },
            reset: function() {
                se = !1,
                re = null,
                Ie = null,
                We = null
            }
        }
    }
    function l() {
        let se = !1
          , re = null
          , Ie = null
          , We = null
          , Ye = null
          , st = null
          , pt = null
          , gt = null
          , bt = null;
        return {
            setTest: function(ct) {
                se || (ct ? N(2960) : oe(2960))
            },
            setMask: function(ct) {
                re !== ct && !se && (a.stencilMask(ct),
                re = ct)
            },
            setFunc: function(ct, xt, vt) {
                (Ie !== ct || We !== xt || Ye !== vt) && (a.stencilFunc(ct, xt, vt),
                Ie = ct,
                We = xt,
                Ye = vt)
            },
            setOp: function(ct, xt, vt) {
                (st !== ct || pt !== xt || gt !== vt) && (a.stencilOp(ct, xt, vt),
                st = ct,
                pt = xt,
                gt = vt)
            },
            setLocked: function(ct) {
                se = ct
            },
            setClear: function(ct) {
                bt !== ct && (a.clearStencil(ct),
                bt = ct)
            },
            reset: function() {
                se = !1,
                re = null,
                Ie = null,
                We = null,
                Ye = null,
                st = null,
                pt = null,
                gt = null,
                bt = null
            }
        }
    }
    const c = new n
      , u = new o
      , f = new l
      , p = new WeakMap
      , g = new WeakMap;
    let v = {}
      , _ = {}
      , w = new WeakMap
      , S = []
      , b = null
      , C = !1
      , R = null
      , T = null
      , M = null
      , P = null
      , I = null
      , k = null
      , A = null
      , O = !1
      , W = null
      , Q = null
      , H = null
      , B = null
      , D = null;
    const q = a.getParameter(35661);
    let V = !1
      , J = 0;
    const U = a.getParameter(7938);
    U.indexOf("WebGL") !== -1 ? (J = parseFloat(/^WebGL (\d)/.exec(U)[1]),
    V = J >= 1) : U.indexOf("OpenGL ES") !== -1 && (J = parseFloat(/^OpenGL ES (\d)/.exec(U)[1]),
    V = J >= 2);
    let ce = null
      , ee = {};
    const ne = a.getParameter(3088)
      , ae = a.getParameter(2978)
      , ve = new Vector4().fromArray(ne)
      , Y = new Vector4().fromArray(ae);
    function $(se, re, Ie) {
        const We = new Uint8Array(4)
          , Ye = a.createTexture();
        a.bindTexture(se, Ye),
        a.texParameteri(se, 10241, 9728),
        a.texParameteri(se, 10240, 9728);
        for (let st = 0; st < Ie; st++)
            a.texImage2D(re + st, 0, 6408, 1, 1, 0, 6408, 5121, We);
        return Ye
    }
    const L = {};
    L[3553] = $(3553, 3553, 1),
    L[34067] = $(34067, 34069, 6),
    c.setClear(0, 0, 0, 1),
    u.setClear(1),
    f.setClear(0),
    N(2929),
    u.setFunc(LessEqualDepth),
    Ne(!1),
    Ue(CullFaceBack),
    N(2884),
    we(NoBlending);
    function N(se) {
        v[se] !== !0 && (a.enable(se),
        v[se] = !0)
    }
    function oe(se) {
        v[se] !== !1 && (a.disable(se),
        v[se] = !1)
    }
    function pe(se, re) {
        return _[se] !== re ? (a.bindFramebuffer(se, re),
        _[se] = re,
        r && (se === 36009 && (_[36160] = re),
        se === 36160 && (_[36009] = re)),
        !0) : !1
    }
    function K(se, re) {
        let Ie = S
          , We = !1;
        if (se)
            if (Ie = w.get(re),
            Ie === void 0 && (Ie = [],
            w.set(re, Ie)),
            se.isWebGLMultipleRenderTargets) {
                const Ye = se.texture;
                if (Ie.length !== Ye.length || Ie[0] !== 36064) {
                    for (let st = 0, pt = Ye.length; st < pt; st++)
                        Ie[st] = 36064 + st;
                    Ie.length = Ye.length,
                    We = !0
                }
            } else
                Ie[0] !== 36064 && (Ie[0] = 36064,
                We = !0);
        else
            Ie[0] !== 1029 && (Ie[0] = 1029,
            We = !0);
        We && (t.isWebGL2 ? a.drawBuffers(Ie) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ie))
    }
    function Se(se) {
        return b !== se ? (a.useProgram(se),
        b = se,
        !0) : !1
    }
    const Ce = {
        [AddEquation]: 32774,
        [SubtractEquation]: 32778,
        [ReverseSubtractEquation]: 32779
    };
    if (r)
        Ce[MinEquation] = 32775,
        Ce[MaxEquation] = 32776;
    else {
        const se = e.get("EXT_blend_minmax");
        se !== null && (Ce[MinEquation] = se.MIN_EXT,
        Ce[MaxEquation] = se.MAX_EXT)
    }
    const Te = {
        [ZeroFactor]: 0,
        [OneFactor]: 1,
        [SrcColorFactor]: 768,
        [SrcAlphaFactor]: 770,
        [SrcAlphaSaturateFactor]: 776,
        [DstColorFactor]: 774,
        [DstAlphaFactor]: 772,
        [OneMinusSrcColorFactor]: 769,
        [OneMinusSrcAlphaFactor]: 771,
        [OneMinusDstColorFactor]: 775,
        [OneMinusDstAlphaFactor]: 773
    };
    function we(se, re, Ie, We, Ye, st, pt, gt) {
        if (se === NoBlending) {
            C === !0 && (oe(3042),
            C = !1);
            return
        }
        if (C === !1 && (N(3042),
        C = !0),
        se !== CustomBlending) {
            if (se !== R || gt !== O) {
                if ((T !== AddEquation || I !== AddEquation) && (a.blendEquation(32774),
                T = AddEquation,
                I = AddEquation),
                gt)
                    switch (se) {
                    case NormalBlending:
                        a.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case AdditiveBlending:
                        a.blendFunc(1, 1);
                        break;
                    case SubtractiveBlending:
                        a.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case MultiplyBlending:
                        a.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", se);
                        break
                    }
                else
                    switch (se) {
                    case NormalBlending:
                        a.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case AdditiveBlending:
                        a.blendFunc(770, 1);
                        break;
                    case SubtractiveBlending:
                        a.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case MultiplyBlending:
                        a.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", se);
                        break
                    }
                M = null,
                P = null,
                k = null,
                A = null,
                R = se,
                O = gt
            }
            return
        }
        Ye = Ye || re,
        st = st || Ie,
        pt = pt || We,
        (re !== T || Ye !== I) && (a.blendEquationSeparate(Ce[re], Ce[Ye]),
        T = re,
        I = Ye),
        (Ie !== M || We !== P || st !== k || pt !== A) && (a.blendFuncSeparate(Te[Ie], Te[We], Te[st], Te[pt]),
        M = Ie,
        P = We,
        k = st,
        A = pt),
        R = se,
        O = !1
    }
    function Ae(se, re) {
        se.side === DoubleSide ? oe(2884) : N(2884);
        let Ie = se.side === BackSide;
        re && (Ie = !Ie),
        Ne(Ie),
        se.blending === NormalBlending && se.transparent === !1 ? we(NoBlending) : we(se.blending, se.blendEquation, se.blendSrc, se.blendDst, se.blendEquationAlpha, se.blendSrcAlpha, se.blendDstAlpha, se.premultipliedAlpha),
        u.setFunc(se.depthFunc),
        u.setTest(se.depthTest),
        u.setMask(se.depthWrite),
        c.setMask(se.colorWrite);
        const We = se.stencilWrite;
        f.setTest(We),
        We && (f.setMask(se.stencilWriteMask),
        f.setFunc(se.stencilFunc, se.stencilRef, se.stencilFuncMask),
        f.setOp(se.stencilFail, se.stencilZFail, se.stencilZPass)),
        Z(se.polygonOffset, se.polygonOffsetFactor, se.polygonOffsetUnits),
        se.alphaToCoverage === !0 ? N(32926) : oe(32926)
    }
    function Ne(se) {
        W !== se && (se ? a.frontFace(2304) : a.frontFace(2305),
        W = se)
    }
    function Ue(se) {
        se !== CullFaceNone ? (N(2884),
        se !== Q && (se === CullFaceBack ? a.cullFace(1029) : se === CullFaceFront ? a.cullFace(1028) : a.cullFace(1032))) : oe(2884),
        Q = se
    }
    function le(se) {
        se !== H && (V && a.lineWidth(se),
        H = se)
    }
    function Z(se, re, Ie) {
        se ? (N(32823),
        (B !== re || D !== Ie) && (a.polygonOffset(re, Ie),
        B = re,
        D = Ie)) : oe(32823)
    }
    function He(se) {
        se ? N(3089) : oe(3089)
    }
    function Ke(se) {
        se === void 0 && (se = 33984 + q - 1),
        ce !== se && (a.activeTexture(se),
        ce = se)
    }
    function j(se, re, Ie) {
        Ie === void 0 && (ce === null ? Ie = 33984 + q - 1 : Ie = ce);
        let We = ee[Ie];
        We === void 0 && (We = {
            type: void 0,
            texture: void 0
        },
        ee[Ie] = We),
        (We.type !== se || We.texture !== re) && (ce !== Ie && (a.activeTexture(Ie),
        ce = Ie),
        a.bindTexture(se, re || L[se]),
        We.type = se,
        We.texture = re)
    }
    function z() {
        const se = ee[ce];
        se !== void 0 && se.type !== void 0 && (a.bindTexture(se.type, null),
        se.type = void 0,
        se.texture = void 0)
    }
    function ge() {
        try {
            a.compressedTexImage2D.apply(a, arguments)
        } catch (se) {
            console.error("THREE.WebGLState:", se)
        }
    }
    function Ee() {
        try {
            a.compressedTexImage3D.apply(a, arguments)
        } catch (se) {
            console.error("THREE.WebGLState:", se)
        }
    }
    function Oe() {
        try {
            a.texSubImage2D.apply(a, arguments)
        } catch (se) {
            console.error("THREE.WebGLState:", se)
        }
    }
    function ze() {
        try {
            a.texSubImage3D.apply(a, arguments)
        } catch (se) {
            console.error("THREE.WebGLState:", se)
        }
    }
    function te() {
        try {
            a.compressedTexSubImage2D.apply(a, arguments)
        } catch (se) {
            console.error("THREE.WebGLState:", se)
        }
    }
    function be() {
        try {
            a.compressedTexSubImage3D.apply(a, arguments)
        } catch (se) {
            console.error("THREE.WebGLState:", se)
        }
    }
    function xe() {
        try {
            a.texStorage2D.apply(a, arguments)
        } catch (se) {
            console.error("THREE.WebGLState:", se)
        }
    }
    function ke() {
        try {
            a.texStorage3D.apply(a, arguments)
        } catch (se) {
            console.error("THREE.WebGLState:", se)
        }
    }
    function qe() {
        try {
            a.texImage2D.apply(a, arguments)
        } catch (se) {
            console.error("THREE.WebGLState:", se)
        }
    }
    function Ve() {
        try {
            a.texImage3D.apply(a, arguments)
        } catch (se) {
            console.error("THREE.WebGLState:", se)
        }
    }
    function Ge(se) {
        ve.equals(se) === !1 && (a.scissor(se.x, se.y, se.z, se.w),
        ve.copy(se))
    }
    function Xe(se) {
        Y.equals(se) === !1 && (a.viewport(se.x, se.y, se.z, se.w),
        Y.copy(se))
    }
    function Qe(se, re) {
        let Ie = g.get(re);
        Ie === void 0 && (Ie = new WeakMap,
        g.set(re, Ie));
        let We = Ie.get(se);
        We === void 0 && (We = a.getUniformBlockIndex(re, se.name),
        Ie.set(se, We))
    }
    function tt(se, re) {
        const We = g.get(re).get(se);
        p.get(re) !== We && (a.uniformBlockBinding(re, We, se.__bindingPointIndex),
        p.set(re, We))
    }
    function nt() {
        a.disable(3042),
        a.disable(2884),
        a.disable(2929),
        a.disable(32823),
        a.disable(3089),
        a.disable(2960),
        a.disable(32926),
        a.blendEquation(32774),
        a.blendFunc(1, 0),
        a.blendFuncSeparate(1, 0, 1, 0),
        a.colorMask(!0, !0, !0, !0),
        a.clearColor(0, 0, 0, 0),
        a.depthMask(!0),
        a.depthFunc(513),
        a.clearDepth(1),
        a.stencilMask(4294967295),
        a.stencilFunc(519, 0, 4294967295),
        a.stencilOp(7680, 7680, 7680),
        a.clearStencil(0),
        a.cullFace(1029),
        a.frontFace(2305),
        a.polygonOffset(0, 0),
        a.activeTexture(33984),
        a.bindFramebuffer(36160, null),
        r === !0 && (a.bindFramebuffer(36009, null),
        a.bindFramebuffer(36008, null)),
        a.useProgram(null),
        a.lineWidth(1),
        a.scissor(0, 0, a.canvas.width, a.canvas.height),
        a.viewport(0, 0, a.canvas.width, a.canvas.height),
        v = {},
        ce = null,
        ee = {},
        _ = {},
        w = new WeakMap,
        S = [],
        b = null,
        C = !1,
        R = null,
        T = null,
        M = null,
        P = null,
        I = null,
        k = null,
        A = null,
        O = !1,
        W = null,
        Q = null,
        H = null,
        B = null,
        D = null,
        ve.set(0, 0, a.canvas.width, a.canvas.height),
        Y.set(0, 0, a.canvas.width, a.canvas.height),
        c.reset(),
        u.reset(),
        f.reset()
    }
    return {
        buffers: {
            color: c,
            depth: u,
            stencil: f
        },
        enable: N,
        disable: oe,
        bindFramebuffer: pe,
        drawBuffers: K,
        useProgram: Se,
        setBlending: we,
        setMaterial: Ae,
        setFlipSided: Ne,
        setCullFace: Ue,
        setLineWidth: le,
        setPolygonOffset: Z,
        setScissorTest: He,
        activeTexture: Ke,
        bindTexture: j,
        unbindTexture: z,
        compressedTexImage2D: ge,
        compressedTexImage3D: Ee,
        texImage2D: qe,
        texImage3D: Ve,
        updateUBOMapping: Qe,
        uniformBlockBinding: tt,
        texStorage2D: xe,
        texStorage3D: ke,
        texSubImage2D: Oe,
        texSubImage3D: ze,
        compressedTexSubImage2D: te,
        compressedTexSubImage3D: be,
        scissor: Ge,
        viewport: Xe,
        reset: nt
    }
}
function WebGLTextures(a, e, t, r, n, o, l) {
    const c = n.isWebGL2
      , u = n.maxTextures
      , f = n.maxCubemapSize
      , p = n.maxTextureSize
      , g = n.maxSamples
      , v = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , _ = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , w = new WeakMap;
    let S;
    const b = new WeakMap;
    let C = !1;
    try {
        C = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function R(j, z) {
        return C ? new OffscreenCanvas(j,z) : createElementNS("canvas")
    }
    function T(j, z, ge, Ee) {
        let Oe = 1;
        if ((j.width > Ee || j.height > Ee) && (Oe = Ee / Math.max(j.width, j.height)),
        Oe < 1 || z === !0)
            if (typeof HTMLImageElement < "u" && j instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && j instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && j instanceof ImageBitmap) {
                const ze = z ? floorPowerOfTwo : Math.floor
                  , te = ze(Oe * j.width)
                  , be = ze(Oe * j.height);
                S === void 0 && (S = R(te, be));
                const xe = ge ? R(te, be) : S;
                return xe.width = te,
                xe.height = be,
                xe.getContext("2d").drawImage(j, 0, 0, te, be),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + j.width + "x" + j.height + ") to (" + te + "x" + be + ")."),
                xe
            } else
                return "data"in j && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + j.width + "x" + j.height + ")."),
                j;
        return j
    }
    function M(j) {
        return isPowerOfTwo(j.width) && isPowerOfTwo(j.height)
    }
    function P(j) {
        return c ? !1 : j.wrapS !== ClampToEdgeWrapping || j.wrapT !== ClampToEdgeWrapping || j.minFilter !== NearestFilter && j.minFilter !== LinearFilter
    }
    function I(j, z) {
        return j.generateMipmaps && z && j.minFilter !== NearestFilter && j.minFilter !== LinearFilter
    }
    function k(j) {
        a.generateMipmap(j)
    }
    function A(j, z, ge, Ee, Oe=!1) {
        if (c === !1)
            return z;
        if (j !== null) {
            if (a[j] !== void 0)
                return a[j];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + j + "'")
        }
        let ze = z;
        return z === 6403 && (ge === 5126 && (ze = 33326),
        ge === 5131 && (ze = 33325),
        ge === 5121 && (ze = 33321)),
        z === 33319 && (ge === 5126 && (ze = 33328),
        ge === 5131 && (ze = 33327),
        ge === 5121 && (ze = 33323)),
        z === 6408 && (ge === 5126 && (ze = 34836),
        ge === 5131 && (ze = 34842),
        ge === 5121 && (ze = Ee === sRGBEncoding && Oe === !1 ? 35907 : 32856),
        ge === 32819 && (ze = 32854),
        ge === 32820 && (ze = 32855)),
        (ze === 33325 || ze === 33326 || ze === 33327 || ze === 33328 || ze === 34842 || ze === 34836) && e.get("EXT_color_buffer_float"),
        ze
    }
    function O(j, z, ge) {
        return I(j, ge) === !0 || j.isFramebufferTexture && j.minFilter !== NearestFilter && j.minFilter !== LinearFilter ? Math.log2(Math.max(z.width, z.height)) + 1 : j.mipmaps !== void 0 && j.mipmaps.length > 0 ? j.mipmaps.length : j.isCompressedTexture && Array.isArray(j.image) ? z.mipmaps.length : 1
    }
    function W(j) {
        return j === NearestFilter || j === NearestMipmapNearestFilter || j === NearestMipmapLinearFilter ? 9728 : 9729
    }
    function Q(j) {
        const z = j.target;
        z.removeEventListener("dispose", Q),
        B(z),
        z.isVideoTexture && w.delete(z)
    }
    function H(j) {
        const z = j.target;
        z.removeEventListener("dispose", H),
        q(z)
    }
    function B(j) {
        const z = r.get(j);
        if (z.__webglInit === void 0)
            return;
        const ge = j.source
          , Ee = b.get(ge);
        if (Ee) {
            const Oe = Ee[z.__cacheKey];
            Oe.usedTimes--,
            Oe.usedTimes === 0 && D(j),
            Object.keys(Ee).length === 0 && b.delete(ge)
        }
        r.remove(j)
    }
    function D(j) {
        const z = r.get(j);
        a.deleteTexture(z.__webglTexture);
        const ge = j.source
          , Ee = b.get(ge);
        delete Ee[z.__cacheKey],
        l.memory.textures--
    }
    function q(j) {
        const z = j.texture
          , ge = r.get(j)
          , Ee = r.get(z);
        if (Ee.__webglTexture !== void 0 && (a.deleteTexture(Ee.__webglTexture),
        l.memory.textures--),
        j.depthTexture && j.depthTexture.dispose(),
        j.isWebGLCubeRenderTarget)
            for (let Oe = 0; Oe < 6; Oe++)
                a.deleteFramebuffer(ge.__webglFramebuffer[Oe]),
                ge.__webglDepthbuffer && a.deleteRenderbuffer(ge.__webglDepthbuffer[Oe]);
        else {
            if (a.deleteFramebuffer(ge.__webglFramebuffer),
            ge.__webglDepthbuffer && a.deleteRenderbuffer(ge.__webglDepthbuffer),
            ge.__webglMultisampledFramebuffer && a.deleteFramebuffer(ge.__webglMultisampledFramebuffer),
            ge.__webglColorRenderbuffer)
                for (let Oe = 0; Oe < ge.__webglColorRenderbuffer.length; Oe++)
                    ge.__webglColorRenderbuffer[Oe] && a.deleteRenderbuffer(ge.__webglColorRenderbuffer[Oe]);
            ge.__webglDepthRenderbuffer && a.deleteRenderbuffer(ge.__webglDepthRenderbuffer)
        }
        if (j.isWebGLMultipleRenderTargets)
            for (let Oe = 0, ze = z.length; Oe < ze; Oe++) {
                const te = r.get(z[Oe]);
                te.__webglTexture && (a.deleteTexture(te.__webglTexture),
                l.memory.textures--),
                r.remove(z[Oe])
            }
        r.remove(z),
        r.remove(j)
    }
    let V = 0;
    function J() {
        V = 0
    }
    function U() {
        const j = V;
        return j >= u && console.warn("THREE.WebGLTextures: Trying to use " + j + " texture units while this GPU supports only " + u),
        V += 1,
        j
    }
    function ce(j) {
        const z = [];
        return z.push(j.wrapS),
        z.push(j.wrapT),
        z.push(j.wrapR || 0),
        z.push(j.magFilter),
        z.push(j.minFilter),
        z.push(j.anisotropy),
        z.push(j.internalFormat),
        z.push(j.format),
        z.push(j.type),
        z.push(j.generateMipmaps),
        z.push(j.premultiplyAlpha),
        z.push(j.flipY),
        z.push(j.unpackAlignment),
        z.push(j.encoding),
        z.join()
    }
    function ee(j, z) {
        const ge = r.get(j);
        if (j.isVideoTexture && He(j),
        j.isRenderTargetTexture === !1 && j.version > 0 && ge.__version !== j.version) {
            const Ee = j.image;
            if (Ee === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (Ee.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                oe(ge, j, z);
                return
            }
        }
        t.bindTexture(3553, ge.__webglTexture, 33984 + z)
    }
    function ne(j, z) {
        const ge = r.get(j);
        if (j.version > 0 && ge.__version !== j.version) {
            oe(ge, j, z);
            return
        }
        t.bindTexture(35866, ge.__webglTexture, 33984 + z)
    }
    function ae(j, z) {
        const ge = r.get(j);
        if (j.version > 0 && ge.__version !== j.version) {
            oe(ge, j, z);
            return
        }
        t.bindTexture(32879, ge.__webglTexture, 33984 + z)
    }
    function ve(j, z) {
        const ge = r.get(j);
        if (j.version > 0 && ge.__version !== j.version) {
            pe(ge, j, z);
            return
        }
        t.bindTexture(34067, ge.__webglTexture, 33984 + z)
    }
    const Y = {
        [RepeatWrapping]: 10497,
        [ClampToEdgeWrapping]: 33071,
        [MirroredRepeatWrapping]: 33648
    }
      , $ = {
        [NearestFilter]: 9728,
        [NearestMipmapNearestFilter]: 9984,
        [NearestMipmapLinearFilter]: 9986,
        [LinearFilter]: 9729,
        [LinearMipmapNearestFilter]: 9985,
        [LinearMipmapLinearFilter]: 9987
    };
    function L(j, z, ge) {
        if (ge ? (a.texParameteri(j, 10242, Y[z.wrapS]),
        a.texParameteri(j, 10243, Y[z.wrapT]),
        (j === 32879 || j === 35866) && a.texParameteri(j, 32882, Y[z.wrapR]),
        a.texParameteri(j, 10240, $[z.magFilter]),
        a.texParameteri(j, 10241, $[z.minFilter])) : (a.texParameteri(j, 10242, 33071),
        a.texParameteri(j, 10243, 33071),
        (j === 32879 || j === 35866) && a.texParameteri(j, 32882, 33071),
        (z.wrapS !== ClampToEdgeWrapping || z.wrapT !== ClampToEdgeWrapping) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        a.texParameteri(j, 10240, W(z.magFilter)),
        a.texParameteri(j, 10241, W(z.minFilter)),
        z.minFilter !== NearestFilter && z.minFilter !== LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            const Ee = e.get("EXT_texture_filter_anisotropic");
            if (z.magFilter === NearestFilter || z.minFilter !== NearestMipmapLinearFilter && z.minFilter !== LinearMipmapLinearFilter || z.type === FloatType && e.has("OES_texture_float_linear") === !1 || c === !1 && z.type === HalfFloatType && e.has("OES_texture_half_float_linear") === !1)
                return;
            (z.anisotropy > 1 || r.get(z).__currentAnisotropy) && (a.texParameterf(j, Ee.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(z.anisotropy, n.getMaxAnisotropy())),
            r.get(z).__currentAnisotropy = z.anisotropy)
        }
    }
    function N(j, z) {
        let ge = !1;
        j.__webglInit === void 0 && (j.__webglInit = !0,
        z.addEventListener("dispose", Q));
        const Ee = z.source;
        let Oe = b.get(Ee);
        Oe === void 0 && (Oe = {},
        b.set(Ee, Oe));
        const ze = ce(z);
        if (ze !== j.__cacheKey) {
            Oe[ze] === void 0 && (Oe[ze] = {
                texture: a.createTexture(),
                usedTimes: 0
            },
            l.memory.textures++,
            ge = !0),
            Oe[ze].usedTimes++;
            const te = Oe[j.__cacheKey];
            te !== void 0 && (Oe[j.__cacheKey].usedTimes--,
            te.usedTimes === 0 && D(z)),
            j.__cacheKey = ze,
            j.__webglTexture = Oe[ze].texture
        }
        return ge
    }
    function oe(j, z, ge) {
        let Ee = 3553;
        (z.isDataArrayTexture || z.isCompressedArrayTexture) && (Ee = 35866),
        z.isData3DTexture && (Ee = 32879);
        const Oe = N(j, z)
          , ze = z.source;
        t.bindTexture(Ee, j.__webglTexture, 33984 + ge);
        const te = r.get(ze);
        if (ze.version !== te.__version || Oe === !0) {
            t.activeTexture(33984 + ge),
            a.pixelStorei(37440, z.flipY),
            a.pixelStorei(37441, z.premultiplyAlpha),
            a.pixelStorei(3317, z.unpackAlignment),
            a.pixelStorei(37443, 0);
            const be = P(z) && M(z.image) === !1;
            let xe = T(z.image, be, !1, p);
            xe = Ke(z, xe);
            const ke = M(xe) || c
              , qe = o.convert(z.format, z.encoding);
            let Ve = o.convert(z.type)
              , Ge = A(z.internalFormat, qe, Ve, z.encoding, z.isVideoTexture);
            L(Ee, z, ke);
            let Xe;
            const Qe = z.mipmaps
              , tt = c && z.isVideoTexture !== !0
              , nt = te.__version === void 0 || Oe === !0
              , se = O(z, xe, ke);
            if (z.isDepthTexture)
                Ge = 6402,
                c ? z.type === FloatType ? Ge = 36012 : z.type === UnsignedIntType ? Ge = 33190 : z.type === UnsignedInt248Type ? Ge = 35056 : Ge = 33189 : z.type === FloatType && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                z.format === DepthFormat && Ge === 6402 && z.type !== UnsignedShortType && z.type !== UnsignedIntType && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                z.type = UnsignedIntType,
                Ve = o.convert(z.type)),
                z.format === DepthStencilFormat && Ge === 6402 && (Ge = 34041,
                z.type !== UnsignedInt248Type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                z.type = UnsignedInt248Type,
                Ve = o.convert(z.type))),
                nt && (tt ? t.texStorage2D(3553, 1, Ge, xe.width, xe.height) : t.texImage2D(3553, 0, Ge, xe.width, xe.height, 0, qe, Ve, null));
            else if (z.isDataTexture)
                if (Qe.length > 0 && ke) {
                    tt && nt && t.texStorage2D(3553, se, Ge, Qe[0].width, Qe[0].height);
                    for (let re = 0, Ie = Qe.length; re < Ie; re++)
                        Xe = Qe[re],
                        tt ? t.texSubImage2D(3553, re, 0, 0, Xe.width, Xe.height, qe, Ve, Xe.data) : t.texImage2D(3553, re, Ge, Xe.width, Xe.height, 0, qe, Ve, Xe.data);
                    z.generateMipmaps = !1
                } else
                    tt ? (nt && t.texStorage2D(3553, se, Ge, xe.width, xe.height),
                    t.texSubImage2D(3553, 0, 0, 0, xe.width, xe.height, qe, Ve, xe.data)) : t.texImage2D(3553, 0, Ge, xe.width, xe.height, 0, qe, Ve, xe.data);
            else if (z.isCompressedTexture)
                if (z.isCompressedArrayTexture) {
                    tt && nt && t.texStorage3D(35866, se, Ge, Qe[0].width, Qe[0].height, xe.depth);
                    for (let re = 0, Ie = Qe.length; re < Ie; re++)
                        Xe = Qe[re],
                        z.format !== RGBAFormat ? qe !== null ? tt ? t.compressedTexSubImage3D(35866, re, 0, 0, 0, Xe.width, Xe.height, xe.depth, qe, Xe.data, 0, 0) : t.compressedTexImage3D(35866, re, Ge, Xe.width, Xe.height, xe.depth, 0, Xe.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : tt ? t.texSubImage3D(35866, re, 0, 0, 0, Xe.width, Xe.height, xe.depth, qe, Ve, Xe.data) : t.texImage3D(35866, re, Ge, Xe.width, Xe.height, xe.depth, 0, qe, Ve, Xe.data)
                } else {
                    tt && nt && t.texStorage2D(3553, se, Ge, Qe[0].width, Qe[0].height);
                    for (let re = 0, Ie = Qe.length; re < Ie; re++)
                        Xe = Qe[re],
                        z.format !== RGBAFormat ? qe !== null ? tt ? t.compressedTexSubImage2D(3553, re, 0, 0, Xe.width, Xe.height, qe, Xe.data) : t.compressedTexImage2D(3553, re, Ge, Xe.width, Xe.height, 0, Xe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : tt ? t.texSubImage2D(3553, re, 0, 0, Xe.width, Xe.height, qe, Ve, Xe.data) : t.texImage2D(3553, re, Ge, Xe.width, Xe.height, 0, qe, Ve, Xe.data)
                }
            else if (z.isDataArrayTexture)
                tt ? (nt && t.texStorage3D(35866, se, Ge, xe.width, xe.height, xe.depth),
                t.texSubImage3D(35866, 0, 0, 0, 0, xe.width, xe.height, xe.depth, qe, Ve, xe.data)) : t.texImage3D(35866, 0, Ge, xe.width, xe.height, xe.depth, 0, qe, Ve, xe.data);
            else if (z.isData3DTexture)
                tt ? (nt && t.texStorage3D(32879, se, Ge, xe.width, xe.height, xe.depth),
                t.texSubImage3D(32879, 0, 0, 0, 0, xe.width, xe.height, xe.depth, qe, Ve, xe.data)) : t.texImage3D(32879, 0, Ge, xe.width, xe.height, xe.depth, 0, qe, Ve, xe.data);
            else if (z.isFramebufferTexture) {
                if (nt)
                    if (tt)
                        t.texStorage2D(3553, se, Ge, xe.width, xe.height);
                    else {
                        let re = xe.width
                          , Ie = xe.height;
                        for (let We = 0; We < se; We++)
                            t.texImage2D(3553, We, Ge, re, Ie, 0, qe, Ve, null),
                            re >>= 1,
                            Ie >>= 1
                    }
            } else if (Qe.length > 0 && ke) {
                tt && nt && t.texStorage2D(3553, se, Ge, Qe[0].width, Qe[0].height);
                for (let re = 0, Ie = Qe.length; re < Ie; re++)
                    Xe = Qe[re],
                    tt ? t.texSubImage2D(3553, re, 0, 0, qe, Ve, Xe) : t.texImage2D(3553, re, Ge, qe, Ve, Xe);
                z.generateMipmaps = !1
            } else
                tt ? (nt && t.texStorage2D(3553, se, Ge, xe.width, xe.height),
                t.texSubImage2D(3553, 0, 0, 0, qe, Ve, xe)) : t.texImage2D(3553, 0, Ge, qe, Ve, xe);
            I(z, ke) && k(Ee),
            te.__version = ze.version,
            z.onUpdate && z.onUpdate(z)
        }
        j.__version = z.version
    }
    function pe(j, z, ge) {
        if (z.image.length !== 6)
            return;
        const Ee = N(j, z)
          , Oe = z.source;
        t.bindTexture(34067, j.__webglTexture, 33984 + ge);
        const ze = r.get(Oe);
        if (Oe.version !== ze.__version || Ee === !0) {
            t.activeTexture(33984 + ge),
            a.pixelStorei(37440, z.flipY),
            a.pixelStorei(37441, z.premultiplyAlpha),
            a.pixelStorei(3317, z.unpackAlignment),
            a.pixelStorei(37443, 0);
            const te = z.isCompressedTexture || z.image[0].isCompressedTexture
              , be = z.image[0] && z.image[0].isDataTexture
              , xe = [];
            for (let re = 0; re < 6; re++)
                !te && !be ? xe[re] = T(z.image[re], !1, !0, f) : xe[re] = be ? z.image[re].image : z.image[re],
                xe[re] = Ke(z, xe[re]);
            const ke = xe[0]
              , qe = M(ke) || c
              , Ve = o.convert(z.format, z.encoding)
              , Ge = o.convert(z.type)
              , Xe = A(z.internalFormat, Ve, Ge, z.encoding)
              , Qe = c && z.isVideoTexture !== !0
              , tt = ze.__version === void 0 || Ee === !0;
            let nt = O(z, ke, qe);
            L(34067, z, qe);
            let se;
            if (te) {
                Qe && tt && t.texStorage2D(34067, nt, Xe, ke.width, ke.height);
                for (let re = 0; re < 6; re++) {
                    se = xe[re].mipmaps;
                    for (let Ie = 0; Ie < se.length; Ie++) {
                        const We = se[Ie];
                        z.format !== RGBAFormat ? Ve !== null ? Qe ? t.compressedTexSubImage2D(34069 + re, Ie, 0, 0, We.width, We.height, Ve, We.data) : t.compressedTexImage2D(34069 + re, Ie, Xe, We.width, We.height, 0, We.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Qe ? t.texSubImage2D(34069 + re, Ie, 0, 0, We.width, We.height, Ve, Ge, We.data) : t.texImage2D(34069 + re, Ie, Xe, We.width, We.height, 0, Ve, Ge, We.data)
                    }
                }
            } else {
                se = z.mipmaps,
                Qe && tt && (se.length > 0 && nt++,
                t.texStorage2D(34067, nt, Xe, xe[0].width, xe[0].height));
                for (let re = 0; re < 6; re++)
                    if (be) {
                        Qe ? t.texSubImage2D(34069 + re, 0, 0, 0, xe[re].width, xe[re].height, Ve, Ge, xe[re].data) : t.texImage2D(34069 + re, 0, Xe, xe[re].width, xe[re].height, 0, Ve, Ge, xe[re].data);
                        for (let Ie = 0; Ie < se.length; Ie++) {
                            const Ye = se[Ie].image[re].image;
                            Qe ? t.texSubImage2D(34069 + re, Ie + 1, 0, 0, Ye.width, Ye.height, Ve, Ge, Ye.data) : t.texImage2D(34069 + re, Ie + 1, Xe, Ye.width, Ye.height, 0, Ve, Ge, Ye.data)
                        }
                    } else {
                        Qe ? t.texSubImage2D(34069 + re, 0, 0, 0, Ve, Ge, xe[re]) : t.texImage2D(34069 + re, 0, Xe, Ve, Ge, xe[re]);
                        for (let Ie = 0; Ie < se.length; Ie++) {
                            const We = se[Ie];
                            Qe ? t.texSubImage2D(34069 + re, Ie + 1, 0, 0, Ve, Ge, We.image[re]) : t.texImage2D(34069 + re, Ie + 1, Xe, Ve, Ge, We.image[re])
                        }
                    }
            }
            I(z, qe) && k(34067),
            ze.__version = Oe.version,
            z.onUpdate && z.onUpdate(z)
        }
        j.__version = z.version
    }
    function K(j, z, ge, Ee, Oe) {
        const ze = o.convert(ge.format, ge.encoding)
          , te = o.convert(ge.type)
          , be = A(ge.internalFormat, ze, te, ge.encoding);
        r.get(z).__hasExternalTextures || (Oe === 32879 || Oe === 35866 ? t.texImage3D(Oe, 0, be, z.width, z.height, z.depth, 0, ze, te, null) : t.texImage2D(Oe, 0, be, z.width, z.height, 0, ze, te, null)),
        t.bindFramebuffer(36160, j),
        Z(z) ? v.framebufferTexture2DMultisampleEXT(36160, Ee, Oe, r.get(ge).__webglTexture, 0, le(z)) : (Oe === 3553 || Oe >= 34069 && Oe <= 34074) && a.framebufferTexture2D(36160, Ee, Oe, r.get(ge).__webglTexture, 0),
        t.bindFramebuffer(36160, null)
    }
    function Se(j, z, ge) {
        if (a.bindRenderbuffer(36161, j),
        z.depthBuffer && !z.stencilBuffer) {
            let Ee = 33189;
            if (ge || Z(z)) {
                const Oe = z.depthTexture;
                Oe && Oe.isDepthTexture && (Oe.type === FloatType ? Ee = 36012 : Oe.type === UnsignedIntType && (Ee = 33190));
                const ze = le(z);
                Z(z) ? v.renderbufferStorageMultisampleEXT(36161, ze, Ee, z.width, z.height) : a.renderbufferStorageMultisample(36161, ze, Ee, z.width, z.height)
            } else
                a.renderbufferStorage(36161, Ee, z.width, z.height);
            a.framebufferRenderbuffer(36160, 36096, 36161, j)
        } else if (z.depthBuffer && z.stencilBuffer) {
            const Ee = le(z);
            ge && Z(z) === !1 ? a.renderbufferStorageMultisample(36161, Ee, 35056, z.width, z.height) : Z(z) ? v.renderbufferStorageMultisampleEXT(36161, Ee, 35056, z.width, z.height) : a.renderbufferStorage(36161, 34041, z.width, z.height),
            a.framebufferRenderbuffer(36160, 33306, 36161, j)
        } else {
            const Ee = z.isWebGLMultipleRenderTargets === !0 ? z.texture : [z.texture];
            for (let Oe = 0; Oe < Ee.length; Oe++) {
                const ze = Ee[Oe]
                  , te = o.convert(ze.format, ze.encoding)
                  , be = o.convert(ze.type)
                  , xe = A(ze.internalFormat, te, be, ze.encoding)
                  , ke = le(z);
                ge && Z(z) === !1 ? a.renderbufferStorageMultisample(36161, ke, xe, z.width, z.height) : Z(z) ? v.renderbufferStorageMultisampleEXT(36161, ke, xe, z.width, z.height) : a.renderbufferStorage(36161, xe, z.width, z.height)
            }
        }
        a.bindRenderbuffer(36161, null)
    }
    function Ce(j, z) {
        if (z && z.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(36160, j),
        !(z.depthTexture && z.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!r.get(z.depthTexture).__webglTexture || z.depthTexture.image.width !== z.width || z.depthTexture.image.height !== z.height) && (z.depthTexture.image.width = z.width,
        z.depthTexture.image.height = z.height,
        z.depthTexture.needsUpdate = !0),
        ee(z.depthTexture, 0);
        const Ee = r.get(z.depthTexture).__webglTexture
          , Oe = le(z);
        if (z.depthTexture.format === DepthFormat)
            Z(z) ? v.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, Ee, 0, Oe) : a.framebufferTexture2D(36160, 36096, 3553, Ee, 0);
        else if (z.depthTexture.format === DepthStencilFormat)
            Z(z) ? v.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, Ee, 0, Oe) : a.framebufferTexture2D(36160, 33306, 3553, Ee, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function Te(j) {
        const z = r.get(j)
          , ge = j.isWebGLCubeRenderTarget === !0;
        if (j.depthTexture && !z.__autoAllocateDepthBuffer) {
            if (ge)
                throw new Error("target.depthTexture not supported in Cube render targets");
            Ce(z.__webglFramebuffer, j)
        } else if (ge) {
            z.__webglDepthbuffer = [];
            for (let Ee = 0; Ee < 6; Ee++)
                t.bindFramebuffer(36160, z.__webglFramebuffer[Ee]),
                z.__webglDepthbuffer[Ee] = a.createRenderbuffer(),
                Se(z.__webglDepthbuffer[Ee], j, !1)
        } else
            t.bindFramebuffer(36160, z.__webglFramebuffer),
            z.__webglDepthbuffer = a.createRenderbuffer(),
            Se(z.__webglDepthbuffer, j, !1);
        t.bindFramebuffer(36160, null)
    }
    function we(j, z, ge) {
        const Ee = r.get(j);
        z !== void 0 && K(Ee.__webglFramebuffer, j, j.texture, 36064, 3553),
        ge !== void 0 && Te(j)
    }
    function Ae(j) {
        const z = j.texture
          , ge = r.get(j)
          , Ee = r.get(z);
        j.addEventListener("dispose", H),
        j.isWebGLMultipleRenderTargets !== !0 && (Ee.__webglTexture === void 0 && (Ee.__webglTexture = a.createTexture()),
        Ee.__version = z.version,
        l.memory.textures++);
        const Oe = j.isWebGLCubeRenderTarget === !0
          , ze = j.isWebGLMultipleRenderTargets === !0
          , te = M(j) || c;
        if (Oe) {
            ge.__webglFramebuffer = [];
            for (let be = 0; be < 6; be++)
                ge.__webglFramebuffer[be] = a.createFramebuffer()
        } else {
            if (ge.__webglFramebuffer = a.createFramebuffer(),
            ze)
                if (n.drawBuffers) {
                    const be = j.texture;
                    for (let xe = 0, ke = be.length; xe < ke; xe++) {
                        const qe = r.get(be[xe]);
                        qe.__webglTexture === void 0 && (qe.__webglTexture = a.createTexture(),
                        l.memory.textures++)
                    }
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (c && j.samples > 0 && Z(j) === !1) {
                const be = ze ? z : [z];
                ge.__webglMultisampledFramebuffer = a.createFramebuffer(),
                ge.__webglColorRenderbuffer = [],
                t.bindFramebuffer(36160, ge.__webglMultisampledFramebuffer);
                for (let xe = 0; xe < be.length; xe++) {
                    const ke = be[xe];
                    ge.__webglColorRenderbuffer[xe] = a.createRenderbuffer(),
                    a.bindRenderbuffer(36161, ge.__webglColorRenderbuffer[xe]);
                    const qe = o.convert(ke.format, ke.encoding)
                      , Ve = o.convert(ke.type)
                      , Ge = A(ke.internalFormat, qe, Ve, ke.encoding, j.isXRRenderTarget === !0)
                      , Xe = le(j);
                    a.renderbufferStorageMultisample(36161, Xe, Ge, j.width, j.height),
                    a.framebufferRenderbuffer(36160, 36064 + xe, 36161, ge.__webglColorRenderbuffer[xe])
                }
                a.bindRenderbuffer(36161, null),
                j.depthBuffer && (ge.__webglDepthRenderbuffer = a.createRenderbuffer(),
                Se(ge.__webglDepthRenderbuffer, j, !0)),
                t.bindFramebuffer(36160, null)
            }
        }
        if (Oe) {
            t.bindTexture(34067, Ee.__webglTexture),
            L(34067, z, te);
            for (let be = 0; be < 6; be++)
                K(ge.__webglFramebuffer[be], j, z, 36064, 34069 + be);
            I(z, te) && k(34067),
            t.unbindTexture()
        } else if (ze) {
            const be = j.texture;
            for (let xe = 0, ke = be.length; xe < ke; xe++) {
                const qe = be[xe]
                  , Ve = r.get(qe);
                t.bindTexture(3553, Ve.__webglTexture),
                L(3553, qe, te),
                K(ge.__webglFramebuffer, j, qe, 36064 + xe, 3553),
                I(qe, te) && k(3553)
            }
            t.unbindTexture()
        } else {
            let be = 3553;
            (j.isWebGL3DRenderTarget || j.isWebGLArrayRenderTarget) && (c ? be = j.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            t.bindTexture(be, Ee.__webglTexture),
            L(be, z, te),
            K(ge.__webglFramebuffer, j, z, 36064, be),
            I(z, te) && k(be),
            t.unbindTexture()
        }
        j.depthBuffer && Te(j)
    }
    function Ne(j) {
        const z = M(j) || c
          , ge = j.isWebGLMultipleRenderTargets === !0 ? j.texture : [j.texture];
        for (let Ee = 0, Oe = ge.length; Ee < Oe; Ee++) {
            const ze = ge[Ee];
            if (I(ze, z)) {
                const te = j.isWebGLCubeRenderTarget ? 34067 : 3553
                  , be = r.get(ze).__webglTexture;
                t.bindTexture(te, be),
                k(te),
                t.unbindTexture()
            }
        }
    }
    function Ue(j) {
        if (c && j.samples > 0 && Z(j) === !1) {
            const z = j.isWebGLMultipleRenderTargets ? j.texture : [j.texture]
              , ge = j.width
              , Ee = j.height;
            let Oe = 16384;
            const ze = []
              , te = j.stencilBuffer ? 33306 : 36096
              , be = r.get(j)
              , xe = j.isWebGLMultipleRenderTargets === !0;
            if (xe)
                for (let ke = 0; ke < z.length; ke++)
                    t.bindFramebuffer(36160, be.__webglMultisampledFramebuffer),
                    a.framebufferRenderbuffer(36160, 36064 + ke, 36161, null),
                    t.bindFramebuffer(36160, be.__webglFramebuffer),
                    a.framebufferTexture2D(36009, 36064 + ke, 3553, null, 0);
            t.bindFramebuffer(36008, be.__webglMultisampledFramebuffer),
            t.bindFramebuffer(36009, be.__webglFramebuffer);
            for (let ke = 0; ke < z.length; ke++) {
                ze.push(36064 + ke),
                j.depthBuffer && ze.push(te);
                const qe = be.__ignoreDepthValues !== void 0 ? be.__ignoreDepthValues : !1;
                if (qe === !1 && (j.depthBuffer && (Oe |= 256),
                j.stencilBuffer && (Oe |= 1024)),
                xe && a.framebufferRenderbuffer(36008, 36064, 36161, be.__webglColorRenderbuffer[ke]),
                qe === !0 && (a.invalidateFramebuffer(36008, [te]),
                a.invalidateFramebuffer(36009, [te])),
                xe) {
                    const Ve = r.get(z[ke]).__webglTexture;
                    a.framebufferTexture2D(36009, 36064, 3553, Ve, 0)
                }
                a.blitFramebuffer(0, 0, ge, Ee, 0, 0, ge, Ee, Oe, 9728),
                _ && a.invalidateFramebuffer(36008, ze)
            }
            if (t.bindFramebuffer(36008, null),
            t.bindFramebuffer(36009, null),
            xe)
                for (let ke = 0; ke < z.length; ke++) {
                    t.bindFramebuffer(36160, be.__webglMultisampledFramebuffer),
                    a.framebufferRenderbuffer(36160, 36064 + ke, 36161, be.__webglColorRenderbuffer[ke]);
                    const qe = r.get(z[ke]).__webglTexture;
                    t.bindFramebuffer(36160, be.__webglFramebuffer),
                    a.framebufferTexture2D(36009, 36064 + ke, 3553, qe, 0)
                }
            t.bindFramebuffer(36009, be.__webglMultisampledFramebuffer)
        }
    }
    function le(j) {
        return Math.min(g, j.samples)
    }
    function Z(j) {
        const z = r.get(j);
        return c && j.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && z.__useRenderToTexture !== !1
    }
    function He(j) {
        const z = l.render.frame;
        w.get(j) !== z && (w.set(j, z),
        j.update())
    }
    function Ke(j, z) {
        const ge = j.encoding
          , Ee = j.format
          , Oe = j.type;
        return j.isCompressedTexture === !0 || j.isVideoTexture === !0 || j.format === _SRGBAFormat || ge !== LinearEncoding && (ge === sRGBEncoding ? c === !1 ? e.has("EXT_sRGB") === !0 && Ee === RGBAFormat ? (j.format = _SRGBAFormat,
        j.minFilter = LinearFilter,
        j.generateMipmaps = !1) : z = ImageUtils.sRGBToLinear(z) : (Ee !== RGBAFormat || Oe !== UnsignedByteType) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", ge)),
        z
    }
    this.allocateTextureUnit = U,
    this.resetTextureUnits = J,
    this.setTexture2D = ee,
    this.setTexture2DArray = ne,
    this.setTexture3D = ae,
    this.setTextureCube = ve,
    this.rebindTextures = we,
    this.setupRenderTarget = Ae,
    this.updateRenderTargetMipmap = Ne,
    this.updateMultisampleRenderTarget = Ue,
    this.setupDepthRenderbuffer = Te,
    this.setupFrameBufferTexture = K,
    this.useMultisampledRTT = Z
}
function WebGLUtils(a, e, t) {
    const r = t.isWebGL2;
    function n(o, l=null) {
        let c;
        if (o === UnsignedByteType)
            return 5121;
        if (o === UnsignedShort4444Type)
            return 32819;
        if (o === UnsignedShort5551Type)
            return 32820;
        if (o === ByteType)
            return 5120;
        if (o === ShortType)
            return 5122;
        if (o === UnsignedShortType)
            return 5123;
        if (o === IntType)
            return 5124;
        if (o === UnsignedIntType)
            return 5125;
        if (o === FloatType)
            return 5126;
        if (o === HalfFloatType)
            return r ? 5131 : (c = e.get("OES_texture_half_float"),
            c !== null ? c.HALF_FLOAT_OES : null);
        if (o === AlphaFormat)
            return 6406;
        if (o === RGBAFormat)
            return 6408;
        if (o === LuminanceFormat)
            return 6409;
        if (o === LuminanceAlphaFormat)
            return 6410;
        if (o === DepthFormat)
            return 6402;
        if (o === DepthStencilFormat)
            return 34041;
        if (o === RGBFormat)
            return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),
            6408;
        if (o === _SRGBAFormat)
            return c = e.get("EXT_sRGB"),
            c !== null ? c.SRGB_ALPHA_EXT : null;
        if (o === RedFormat)
            return 6403;
        if (o === RedIntegerFormat)
            return 36244;
        if (o === RGFormat)
            return 33319;
        if (o === RGIntegerFormat)
            return 33320;
        if (o === RGBAIntegerFormat)
            return 36249;
        if (o === RGB_S3TC_DXT1_Format || o === RGBA_S3TC_DXT1_Format || o === RGBA_S3TC_DXT3_Format || o === RGBA_S3TC_DXT5_Format)
            if (l === sRGBEncoding)
                if (c = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                c !== null) {
                    if (o === RGB_S3TC_DXT1_Format)
                        return c.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (o === RGBA_S3TC_DXT1_Format)
                        return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (o === RGBA_S3TC_DXT3_Format)
                        return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (o === RGBA_S3TC_DXT5_Format)
                        return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (c = e.get("WEBGL_compressed_texture_s3tc"),
            c !== null) {
                if (o === RGB_S3TC_DXT1_Format)
                    return c.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (o === RGBA_S3TC_DXT1_Format)
                    return c.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (o === RGBA_S3TC_DXT3_Format)
                    return c.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (o === RGBA_S3TC_DXT5_Format)
                    return c.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (o === RGB_PVRTC_4BPPV1_Format || o === RGB_PVRTC_2BPPV1_Format || o === RGBA_PVRTC_4BPPV1_Format || o === RGBA_PVRTC_2BPPV1_Format)
            if (c = e.get("WEBGL_compressed_texture_pvrtc"),
            c !== null) {
                if (o === RGB_PVRTC_4BPPV1_Format)
                    return c.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (o === RGB_PVRTC_2BPPV1_Format)
                    return c.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (o === RGBA_PVRTC_4BPPV1_Format)
                    return c.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (o === RGBA_PVRTC_2BPPV1_Format)
                    return c.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (o === RGB_ETC1_Format)
            return c = e.get("WEBGL_compressed_texture_etc1"),
            c !== null ? c.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (o === RGB_ETC2_Format || o === RGBA_ETC2_EAC_Format)
            if (c = e.get("WEBGL_compressed_texture_etc"),
            c !== null) {
                if (o === RGB_ETC2_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ETC2 : c.COMPRESSED_RGB8_ETC2;
                if (o === RGBA_ETC2_EAC_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : c.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (o === RGBA_ASTC_4x4_Format || o === RGBA_ASTC_5x4_Format || o === RGBA_ASTC_5x5_Format || o === RGBA_ASTC_6x5_Format || o === RGBA_ASTC_6x6_Format || o === RGBA_ASTC_8x5_Format || o === RGBA_ASTC_8x6_Format || o === RGBA_ASTC_8x8_Format || o === RGBA_ASTC_10x5_Format || o === RGBA_ASTC_10x6_Format || o === RGBA_ASTC_10x8_Format || o === RGBA_ASTC_10x10_Format || o === RGBA_ASTC_12x10_Format || o === RGBA_ASTC_12x12_Format)
            if (c = e.get("WEBGL_compressed_texture_astc"),
            c !== null) {
                if (o === RGBA_ASTC_4x4_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : c.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (o === RGBA_ASTC_5x4_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : c.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (o === RGBA_ASTC_5x5_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : c.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (o === RGBA_ASTC_6x5_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : c.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (o === RGBA_ASTC_6x6_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : c.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (o === RGBA_ASTC_8x5_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : c.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (o === RGBA_ASTC_8x6_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : c.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (o === RGBA_ASTC_8x8_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : c.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (o === RGBA_ASTC_10x5_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : c.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (o === RGBA_ASTC_10x6_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : c.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (o === RGBA_ASTC_10x8_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : c.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (o === RGBA_ASTC_10x10_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : c.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (o === RGBA_ASTC_12x10_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : c.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (o === RGBA_ASTC_12x12_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : c.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (o === RGBA_BPTC_Format)
            if (c = e.get("EXT_texture_compression_bptc"),
            c !== null) {
                if (o === RGBA_BPTC_Format)
                    return l === sRGBEncoding ? c.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : c.COMPRESSED_RGBA_BPTC_UNORM_EXT
            } else
                return null;
        return o === UnsignedInt248Type ? r ? 34042 : (c = e.get("WEBGL_depth_texture"),
        c !== null ? c.UNSIGNED_INT_24_8_WEBGL : null) : a[o] !== void 0 ? a[o] : null
    }
    return {
        convert: n
    }
}
class ArrayCamera extends PerspectiveCamera {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class Group extends Object3D {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const _moveEvent = {
    type: "move"
};
class WebXRController {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new Group,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Group,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new Vector3,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new Vector3),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new Group,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new Vector3,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new Vector3),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const r of e.hand.values())
                    this._getHandJoint(t, r)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, r) {
        let n = null
          , o = null
          , l = null;
        const c = this._targetRay
          , u = this._grip
          , f = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (f && e.hand) {
                l = !0;
                for (const S of e.hand.values()) {
                    const b = t.getJointPose(S, r)
                      , C = this._getHandJoint(f, S);
                    b !== null && (C.matrix.fromArray(b.transform.matrix),
                    C.matrix.decompose(C.position, C.rotation, C.scale),
                    C.jointRadius = b.radius),
                    C.visible = b !== null
                }
                const p = f.joints["index-finger-tip"]
                  , g = f.joints["thumb-tip"]
                  , v = p.position.distanceTo(g.position)
                  , _ = .02
                  , w = .005;
                f.inputState.pinching && v > _ + w ? (f.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !f.inputState.pinching && v <= _ - w && (f.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                u !== null && e.gripSpace && (o = t.getPose(e.gripSpace, r),
                o !== null && (u.matrix.fromArray(o.transform.matrix),
                u.matrix.decompose(u.position, u.rotation, u.scale),
                o.linearVelocity ? (u.hasLinearVelocity = !0,
                u.linearVelocity.copy(o.linearVelocity)) : u.hasLinearVelocity = !1,
                o.angularVelocity ? (u.hasAngularVelocity = !0,
                u.angularVelocity.copy(o.angularVelocity)) : u.hasAngularVelocity = !1));
            c !== null && (n = t.getPose(e.targetRaySpace, r),
            n === null && o !== null && (n = o),
            n !== null && (c.matrix.fromArray(n.transform.matrix),
            c.matrix.decompose(c.position, c.rotation, c.scale),
            n.linearVelocity ? (c.hasLinearVelocity = !0,
            c.linearVelocity.copy(n.linearVelocity)) : c.hasLinearVelocity = !1,
            n.angularVelocity ? (c.hasAngularVelocity = !0,
            c.angularVelocity.copy(n.angularVelocity)) : c.hasAngularVelocity = !1,
            this.dispatchEvent(_moveEvent)))
        }
        return c !== null && (c.visible = n !== null),
        u !== null && (u.visible = o !== null),
        f !== null && (f.visible = l !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const r = new Group;
            r.matrixAutoUpdate = !1,
            r.visible = !1,
            e.joints[t.jointName] = r,
            e.add(r)
        }
        return e.joints[t.jointName]
    }
}
class DepthTexture extends Texture {
    constructor(e, t, r, n, o, l, c, u, f, p) {
        if (p = p !== void 0 ? p : DepthFormat,
        p !== DepthFormat && p !== DepthStencilFormat)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        r === void 0 && p === DepthFormat && (r = UnsignedIntType),
        r === void 0 && p === DepthStencilFormat && (r = UnsignedInt248Type),
        super(null, n, o, l, c, u, p, r, f),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = c !== void 0 ? c : NearestFilter,
        this.minFilter = u !== void 0 ? u : NearestFilter,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class WebXRManager extends EventDispatcher {
    constructor(e, t) {
        super();
        const r = this;
        let n = null
          , o = 1
          , l = null
          , c = "local-floor"
          , u = null
          , f = null
          , p = null
          , g = null
          , v = null
          , _ = null;
        const w = t.getContextAttributes();
        let S = null
          , b = null;
        const C = []
          , R = []
          , T = new Set
          , M = new Map
          , P = new PerspectiveCamera;
        P.layers.enable(1),
        P.viewport = new Vector4;
        const I = new PerspectiveCamera;
        I.layers.enable(2),
        I.viewport = new Vector4;
        const k = [P, I]
          , A = new ArrayCamera;
        A.layers.enable(1),
        A.layers.enable(2);
        let O = null
          , W = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(ne) {
            let ae = C[ne];
            return ae === void 0 && (ae = new WebXRController,
            C[ne] = ae),
            ae.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(ne) {
            let ae = C[ne];
            return ae === void 0 && (ae = new WebXRController,
            C[ne] = ae),
            ae.getGripSpace()
        }
        ,
        this.getHand = function(ne) {
            let ae = C[ne];
            return ae === void 0 && (ae = new WebXRController,
            C[ne] = ae),
            ae.getHandSpace()
        }
        ;
        function Q(ne) {
            const ae = R.indexOf(ne.inputSource);
            if (ae === -1)
                return;
            const ve = C[ae];
            ve !== void 0 && ve.dispatchEvent({
                type: ne.type,
                data: ne.inputSource
            })
        }
        function H() {
            n.removeEventListener("select", Q),
            n.removeEventListener("selectstart", Q),
            n.removeEventListener("selectend", Q),
            n.removeEventListener("squeeze", Q),
            n.removeEventListener("squeezestart", Q),
            n.removeEventListener("squeezeend", Q),
            n.removeEventListener("end", H),
            n.removeEventListener("inputsourceschange", B);
            for (let ne = 0; ne < C.length; ne++) {
                const ae = R[ne];
                ae !== null && (R[ne] = null,
                C[ne].disconnect(ae))
            }
            O = null,
            W = null,
            e.setRenderTarget(S),
            v = null,
            g = null,
            p = null,
            n = null,
            b = null,
            ee.stop(),
            r.isPresenting = !1,
            r.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(ne) {
            o = ne,
            r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(ne) {
            c = ne,
            r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return u || l
        }
        ,
        this.setReferenceSpace = function(ne) {
            u = ne
        }
        ,
        this.getBaseLayer = function() {
            return g !== null ? g : v
        }
        ,
        this.getBinding = function() {
            return p
        }
        ,
        this.getFrame = function() {
            return _
        }
        ,
        this.getSession = function() {
            return n
        }
        ,
        this.setSession = async function(ne) {
            if (n = ne,
            n !== null) {
                if (S = e.getRenderTarget(),
                n.addEventListener("select", Q),
                n.addEventListener("selectstart", Q),
                n.addEventListener("selectend", Q),
                n.addEventListener("squeeze", Q),
                n.addEventListener("squeezestart", Q),
                n.addEventListener("squeezeend", Q),
                n.addEventListener("end", H),
                n.addEventListener("inputsourceschange", B),
                w.xrCompatible !== !0 && await t.makeXRCompatible(),
                n.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    const ae = {
                        antialias: n.renderState.layers === void 0 ? w.antialias : !0,
                        alpha: w.alpha,
                        depth: w.depth,
                        stencil: w.stencil,
                        framebufferScaleFactor: o
                    };
                    v = new XRWebGLLayer(n,t,ae),
                    n.updateRenderState({
                        baseLayer: v
                    }),
                    b = new WebGLRenderTarget(v.framebufferWidth,v.framebufferHeight,{
                        format: RGBAFormat,
                        type: UnsignedByteType,
                        encoding: e.outputEncoding,
                        stencilBuffer: w.stencil
                    })
                } else {
                    let ae = null
                      , ve = null
                      , Y = null;
                    w.depth && (Y = w.stencil ? 35056 : 33190,
                    ae = w.stencil ? DepthStencilFormat : DepthFormat,
                    ve = w.stencil ? UnsignedInt248Type : UnsignedIntType);
                    const $ = {
                        colorFormat: 32856,
                        depthFormat: Y,
                        scaleFactor: o
                    };
                    p = new XRWebGLBinding(n,t),
                    g = p.createProjectionLayer($),
                    n.updateRenderState({
                        layers: [g]
                    }),
                    b = new WebGLRenderTarget(g.textureWidth,g.textureHeight,{
                        format: RGBAFormat,
                        type: UnsignedByteType,
                        depthTexture: new DepthTexture(g.textureWidth,g.textureHeight,ve,void 0,void 0,void 0,void 0,void 0,void 0,ae),
                        stencilBuffer: w.stencil,
                        encoding: e.outputEncoding,
                        samples: w.antialias ? 4 : 0
                    });
                    const L = e.properties.get(b);
                    L.__ignoreDepthValues = g.ignoreDepthValues
                }
                b.isXRRenderTarget = !0,
                this.setFoveation(1),
                u = null,
                l = await n.requestReferenceSpace(c),
                ee.setContext(n),
                ee.start(),
                r.isPresenting = !0,
                r.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ;
        function B(ne) {
            for (let ae = 0; ae < ne.removed.length; ae++) {
                const ve = ne.removed[ae]
                  , Y = R.indexOf(ve);
                Y >= 0 && (R[Y] = null,
                C[Y].disconnect(ve))
            }
            for (let ae = 0; ae < ne.added.length; ae++) {
                const ve = ne.added[ae];
                let Y = R.indexOf(ve);
                if (Y === -1) {
                    for (let L = 0; L < C.length; L++)
                        if (L >= R.length) {
                            R.push(ve),
                            Y = L;
                            break
                        } else if (R[L] === null) {
                            R[L] = ve,
                            Y = L;
                            break
                        }
                    if (Y === -1)
                        break
                }
                const $ = C[Y];
                $ && $.connect(ve)
            }
        }
        const D = new Vector3
          , q = new Vector3;
        function V(ne, ae, ve) {
            D.setFromMatrixPosition(ae.matrixWorld),
            q.setFromMatrixPosition(ve.matrixWorld);
            const Y = D.distanceTo(q)
              , $ = ae.projectionMatrix.elements
              , L = ve.projectionMatrix.elements
              , N = $[14] / ($[10] - 1)
              , oe = $[14] / ($[10] + 1)
              , pe = ($[9] + 1) / $[5]
              , K = ($[9] - 1) / $[5]
              , Se = ($[8] - 1) / $[0]
              , Ce = (L[8] + 1) / L[0]
              , Te = N * Se
              , we = N * Ce
              , Ae = Y / (-Se + Ce)
              , Ne = Ae * -Se;
            ae.matrixWorld.decompose(ne.position, ne.quaternion, ne.scale),
            ne.translateX(Ne),
            ne.translateZ(Ae),
            ne.matrixWorld.compose(ne.position, ne.quaternion, ne.scale),
            ne.matrixWorldInverse.copy(ne.matrixWorld).invert();
            const Ue = N + Ae
              , le = oe + Ae
              , Z = Te - Ne
              , He = we + (Y - Ne)
              , Ke = pe * oe / le * Ue
              , j = K * oe / le * Ue;
            ne.projectionMatrix.makePerspective(Z, He, Ke, j, Ue, le)
        }
        function J(ne, ae) {
            ae === null ? ne.matrixWorld.copy(ne.matrix) : ne.matrixWorld.multiplyMatrices(ae.matrixWorld, ne.matrix),
            ne.matrixWorldInverse.copy(ne.matrixWorld).invert()
        }
        this.updateCamera = function(ne) {
            if (n === null)
                return;
            A.near = I.near = P.near = ne.near,
            A.far = I.far = P.far = ne.far,
            (O !== A.near || W !== A.far) && (n.updateRenderState({
                depthNear: A.near,
                depthFar: A.far
            }),
            O = A.near,
            W = A.far);
            const ae = ne.parent
              , ve = A.cameras;
            J(A, ae);
            for (let $ = 0; $ < ve.length; $++)
                J(ve[$], ae);
            A.matrixWorld.decompose(A.position, A.quaternion, A.scale),
            ne.matrix.copy(A.matrix),
            ne.matrix.decompose(ne.position, ne.quaternion, ne.scale);
            const Y = ne.children;
            for (let $ = 0, L = Y.length; $ < L; $++)
                Y[$].updateMatrixWorld(!0);
            ve.length === 2 ? V(A, P, I) : A.projectionMatrix.copy(P.projectionMatrix)
        }
        ,
        this.getCamera = function() {
            return A
        }
        ,
        this.getFoveation = function() {
            if (g !== null)
                return g.fixedFoveation;
            if (v !== null)
                return v.fixedFoveation
        }
        ,
        this.setFoveation = function(ne) {
            g !== null && (g.fixedFoveation = ne),
            v !== null && v.fixedFoveation !== void 0 && (v.fixedFoveation = ne)
        }
        ,
        this.getPlanes = function() {
            return T
        }
        ;
        let U = null;
        function ce(ne, ae) {
            if (f = ae.getViewerPose(u || l),
            _ = ae,
            f !== null) {
                const ve = f.views;
                v !== null && (e.setRenderTargetFramebuffer(b, v.framebuffer),
                e.setRenderTarget(b));
                let Y = !1;
                ve.length !== A.cameras.length && (A.cameras.length = 0,
                Y = !0);
                for (let $ = 0; $ < ve.length; $++) {
                    const L = ve[$];
                    let N = null;
                    if (v !== null)
                        N = v.getViewport(L);
                    else {
                        const pe = p.getViewSubImage(g, L);
                        N = pe.viewport,
                        $ === 0 && (e.setRenderTargetTextures(b, pe.colorTexture, g.ignoreDepthValues ? void 0 : pe.depthStencilTexture),
                        e.setRenderTarget(b))
                    }
                    let oe = k[$];
                    oe === void 0 && (oe = new PerspectiveCamera,
                    oe.layers.enable($),
                    oe.viewport = new Vector4,
                    k[$] = oe),
                    oe.matrix.fromArray(L.transform.matrix),
                    oe.projectionMatrix.fromArray(L.projectionMatrix),
                    oe.viewport.set(N.x, N.y, N.width, N.height),
                    $ === 0 && A.matrix.copy(oe.matrix),
                    Y === !0 && A.cameras.push(oe)
                }
            }
            for (let ve = 0; ve < C.length; ve++) {
                const Y = R[ve]
                  , $ = C[ve];
                Y !== null && $ !== void 0 && $.update(Y, ae, u || l)
            }
            if (U && U(ne, ae),
            ae.detectedPlanes) {
                r.dispatchEvent({
                    type: "planesdetected",
                    data: ae.detectedPlanes
                });
                let ve = null;
                for (const Y of T)
                    ae.detectedPlanes.has(Y) || (ve === null && (ve = []),
                    ve.push(Y));
                if (ve !== null)
                    for (const Y of ve)
                        T.delete(Y),
                        M.delete(Y),
                        r.dispatchEvent({
                            type: "planeremoved",
                            data: Y
                        });
                for (const Y of ae.detectedPlanes)
                    if (!T.has(Y))
                        T.add(Y),
                        M.set(Y, ae.lastChangedTime),
                        r.dispatchEvent({
                            type: "planeadded",
                            data: Y
                        });
                    else {
                        const $ = M.get(Y);
                        Y.lastChangedTime > $ && (M.set(Y, Y.lastChangedTime),
                        r.dispatchEvent({
                            type: "planechanged",
                            data: Y
                        }))
                    }
            }
            _ = null
        }
        const ee = new WebGLAnimation;
        ee.setAnimationLoop(ce),
        this.setAnimationLoop = function(ne) {
            U = ne
        }
        ,
        this.dispose = function() {}
    }
}
function WebGLMaterials(a, e) {
    function t(S, b) {
        b.color.getRGB(S.fogColor.value, getUnlitUniformColorSpace(a)),
        b.isFog ? (S.fogNear.value = b.near,
        S.fogFar.value = b.far) : b.isFogExp2 && (S.fogDensity.value = b.density)
    }
    function r(S, b, C, R, T) {
        b.isMeshBasicMaterial || b.isMeshLambertMaterial ? n(S, b) : b.isMeshToonMaterial ? (n(S, b),
        p(S, b)) : b.isMeshPhongMaterial ? (n(S, b),
        f(S, b)) : b.isMeshStandardMaterial ? (n(S, b),
        g(S, b),
        b.isMeshPhysicalMaterial && v(S, b, T)) : b.isMeshMatcapMaterial ? (n(S, b),
        _(S, b)) : b.isMeshDepthMaterial ? n(S, b) : b.isMeshDistanceMaterial ? (n(S, b),
        w(S, b)) : b.isMeshNormalMaterial ? n(S, b) : b.isLineBasicMaterial ? (o(S, b),
        b.isLineDashedMaterial && l(S, b)) : b.isPointsMaterial ? c(S, b, C, R) : b.isSpriteMaterial ? u(S, b) : b.isShadowMaterial ? (S.color.value.copy(b.color),
        S.opacity.value = b.opacity) : b.isShaderMaterial && (b.uniformsNeedUpdate = !1)
    }
    function n(S, b) {
        S.opacity.value = b.opacity,
        b.color && S.diffuse.value.copy(b.color),
        b.emissive && S.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity),
        b.map && (S.map.value = b.map),
        b.alphaMap && (S.alphaMap.value = b.alphaMap),
        b.bumpMap && (S.bumpMap.value = b.bumpMap,
        S.bumpScale.value = b.bumpScale,
        b.side === BackSide && (S.bumpScale.value *= -1)),
        b.displacementMap && (S.displacementMap.value = b.displacementMap,
        S.displacementScale.value = b.displacementScale,
        S.displacementBias.value = b.displacementBias),
        b.emissiveMap && (S.emissiveMap.value = b.emissiveMap),
        b.normalMap && (S.normalMap.value = b.normalMap,
        S.normalScale.value.copy(b.normalScale),
        b.side === BackSide && S.normalScale.value.negate()),
        b.specularMap && (S.specularMap.value = b.specularMap),
        b.alphaTest > 0 && (S.alphaTest.value = b.alphaTest);
        const C = e.get(b).envMap;
        if (C && (S.envMap.value = C,
        S.flipEnvMap.value = C.isCubeTexture && C.isRenderTargetTexture === !1 ? -1 : 1,
        S.reflectivity.value = b.reflectivity,
        S.ior.value = b.ior,
        S.refractionRatio.value = b.refractionRatio),
        b.lightMap) {
            S.lightMap.value = b.lightMap;
            const M = a.physicallyCorrectLights !== !0 ? Math.PI : 1;
            S.lightMapIntensity.value = b.lightMapIntensity * M
        }
        b.aoMap && (S.aoMap.value = b.aoMap,
        S.aoMapIntensity.value = b.aoMapIntensity);
        let R;
        b.map ? R = b.map : b.specularMap ? R = b.specularMap : b.displacementMap ? R = b.displacementMap : b.normalMap ? R = b.normalMap : b.bumpMap ? R = b.bumpMap : b.roughnessMap ? R = b.roughnessMap : b.metalnessMap ? R = b.metalnessMap : b.alphaMap ? R = b.alphaMap : b.emissiveMap ? R = b.emissiveMap : b.clearcoatMap ? R = b.clearcoatMap : b.clearcoatNormalMap ? R = b.clearcoatNormalMap : b.clearcoatRoughnessMap ? R = b.clearcoatRoughnessMap : b.iridescenceMap ? R = b.iridescenceMap : b.iridescenceThicknessMap ? R = b.iridescenceThicknessMap : b.specularIntensityMap ? R = b.specularIntensityMap : b.specularColorMap ? R = b.specularColorMap : b.transmissionMap ? R = b.transmissionMap : b.thicknessMap ? R = b.thicknessMap : b.sheenColorMap ? R = b.sheenColorMap : b.sheenRoughnessMap && (R = b.sheenRoughnessMap),
        R !== void 0 && (R.isWebGLRenderTarget && (R = R.texture),
        R.matrixAutoUpdate === !0 && R.updateMatrix(),
        S.uvTransform.value.copy(R.matrix));
        let T;
        b.aoMap ? T = b.aoMap : b.lightMap && (T = b.lightMap),
        T !== void 0 && (T.isWebGLRenderTarget && (T = T.texture),
        T.matrixAutoUpdate === !0 && T.updateMatrix(),
        S.uv2Transform.value.copy(T.matrix))
    }
    function o(S, b) {
        S.diffuse.value.copy(b.color),
        S.opacity.value = b.opacity
    }
    function l(S, b) {
        S.dashSize.value = b.dashSize,
        S.totalSize.value = b.dashSize + b.gapSize,
        S.scale.value = b.scale
    }
    function c(S, b, C, R) {
        S.diffuse.value.copy(b.color),
        S.opacity.value = b.opacity,
        S.size.value = b.size * C,
        S.scale.value = R * .5,
        b.map && (S.map.value = b.map),
        b.alphaMap && (S.alphaMap.value = b.alphaMap),
        b.alphaTest > 0 && (S.alphaTest.value = b.alphaTest);
        let T;
        b.map ? T = b.map : b.alphaMap && (T = b.alphaMap),
        T !== void 0 && (T.matrixAutoUpdate === !0 && T.updateMatrix(),
        S.uvTransform.value.copy(T.matrix))
    }
    function u(S, b) {
        S.diffuse.value.copy(b.color),
        S.opacity.value = b.opacity,
        S.rotation.value = b.rotation,
        b.map && (S.map.value = b.map),
        b.alphaMap && (S.alphaMap.value = b.alphaMap),
        b.alphaTest > 0 && (S.alphaTest.value = b.alphaTest);
        let C;
        b.map ? C = b.map : b.alphaMap && (C = b.alphaMap),
        C !== void 0 && (C.matrixAutoUpdate === !0 && C.updateMatrix(),
        S.uvTransform.value.copy(C.matrix))
    }
    function f(S, b) {
        S.specular.value.copy(b.specular),
        S.shininess.value = Math.max(b.shininess, 1e-4)
    }
    function p(S, b) {
        b.gradientMap && (S.gradientMap.value = b.gradientMap)
    }
    function g(S, b) {
        S.roughness.value = b.roughness,
        S.metalness.value = b.metalness,
        b.roughnessMap && (S.roughnessMap.value = b.roughnessMap),
        b.metalnessMap && (S.metalnessMap.value = b.metalnessMap),
        e.get(b).envMap && (S.envMapIntensity.value = b.envMapIntensity)
    }
    function v(S, b, C) {
        S.ior.value = b.ior,
        b.sheen > 0 && (S.sheenColor.value.copy(b.sheenColor).multiplyScalar(b.sheen),
        S.sheenRoughness.value = b.sheenRoughness,
        b.sheenColorMap && (S.sheenColorMap.value = b.sheenColorMap),
        b.sheenRoughnessMap && (S.sheenRoughnessMap.value = b.sheenRoughnessMap)),
        b.clearcoat > 0 && (S.clearcoat.value = b.clearcoat,
        S.clearcoatRoughness.value = b.clearcoatRoughness,
        b.clearcoatMap && (S.clearcoatMap.value = b.clearcoatMap),
        b.clearcoatRoughnessMap && (S.clearcoatRoughnessMap.value = b.clearcoatRoughnessMap),
        b.clearcoatNormalMap && (S.clearcoatNormalScale.value.copy(b.clearcoatNormalScale),
        S.clearcoatNormalMap.value = b.clearcoatNormalMap,
        b.side === BackSide && S.clearcoatNormalScale.value.negate())),
        b.iridescence > 0 && (S.iridescence.value = b.iridescence,
        S.iridescenceIOR.value = b.iridescenceIOR,
        S.iridescenceThicknessMinimum.value = b.iridescenceThicknessRange[0],
        S.iridescenceThicknessMaximum.value = b.iridescenceThicknessRange[1],
        b.iridescenceMap && (S.iridescenceMap.value = b.iridescenceMap),
        b.iridescenceThicknessMap && (S.iridescenceThicknessMap.value = b.iridescenceThicknessMap)),
        b.transmission > 0 && (S.transmission.value = b.transmission,
        S.transmissionSamplerMap.value = C.texture,
        S.transmissionSamplerSize.value.set(C.width, C.height),
        b.transmissionMap && (S.transmissionMap.value = b.transmissionMap),
        S.thickness.value = b.thickness,
        b.thicknessMap && (S.thicknessMap.value = b.thicknessMap),
        S.attenuationDistance.value = b.attenuationDistance,
        S.attenuationColor.value.copy(b.attenuationColor)),
        S.specularIntensity.value = b.specularIntensity,
        S.specularColor.value.copy(b.specularColor),
        b.specularIntensityMap && (S.specularIntensityMap.value = b.specularIntensityMap),
        b.specularColorMap && (S.specularColorMap.value = b.specularColorMap)
    }
    function _(S, b) {
        b.matcap && (S.matcap.value = b.matcap)
    }
    function w(S, b) {
        S.referencePosition.value.copy(b.referencePosition),
        S.nearDistance.value = b.nearDistance,
        S.farDistance.value = b.farDistance
    }
    return {
        refreshFogUniforms: t,
        refreshMaterialUniforms: r
    }
}
function WebGLUniformsGroups(a, e, t, r) {
    let n = {}
      , o = {}
      , l = [];
    const c = t.isWebGL2 ? a.getParameter(35375) : 0;
    function u(R, T) {
        const M = T.program;
        r.uniformBlockBinding(R, M)
    }
    function f(R, T) {
        let M = n[R.id];
        M === void 0 && (w(R),
        M = p(R),
        n[R.id] = M,
        R.addEventListener("dispose", b));
        const P = T.program;
        r.updateUBOMapping(R, P);
        const I = e.render.frame;
        o[R.id] !== I && (v(R),
        o[R.id] = I)
    }
    function p(R) {
        const T = g();
        R.__bindingPointIndex = T;
        const M = a.createBuffer()
          , P = R.__size
          , I = R.usage;
        return a.bindBuffer(35345, M),
        a.bufferData(35345, P, I),
        a.bindBuffer(35345, null),
        a.bindBufferBase(35345, T, M),
        M
    }
    function g() {
        for (let R = 0; R < c; R++)
            if (l.indexOf(R) === -1)
                return l.push(R),
                R;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function v(R) {
        const T = n[R.id]
          , M = R.uniforms
          , P = R.__cache;
        a.bindBuffer(35345, T);
        for (let I = 0, k = M.length; I < k; I++) {
            const A = M[I];
            if (_(A, I, P) === !0) {
                const O = A.__offset
                  , W = Array.isArray(A.value) ? A.value : [A.value];
                let Q = 0;
                for (let H = 0; H < W.length; H++) {
                    const B = W[H]
                      , D = S(B);
                    typeof B == "number" ? (A.__data[0] = B,
                    a.bufferSubData(35345, O + Q, A.__data)) : B.isMatrix3 ? (A.__data[0] = B.elements[0],
                    A.__data[1] = B.elements[1],
                    A.__data[2] = B.elements[2],
                    A.__data[3] = B.elements[0],
                    A.__data[4] = B.elements[3],
                    A.__data[5] = B.elements[4],
                    A.__data[6] = B.elements[5],
                    A.__data[7] = B.elements[0],
                    A.__data[8] = B.elements[6],
                    A.__data[9] = B.elements[7],
                    A.__data[10] = B.elements[8],
                    A.__data[11] = B.elements[0]) : (B.toArray(A.__data, Q),
                    Q += D.storage / Float32Array.BYTES_PER_ELEMENT)
                }
                a.bufferSubData(35345, O, A.__data)
            }
        }
        a.bindBuffer(35345, null)
    }
    function _(R, T, M) {
        const P = R.value;
        if (M[T] === void 0) {
            if (typeof P == "number")
                M[T] = P;
            else {
                const I = Array.isArray(P) ? P : [P]
                  , k = [];
                for (let A = 0; A < I.length; A++)
                    k.push(I[A].clone());
                M[T] = k
            }
            return !0
        } else if (typeof P == "number") {
            if (M[T] !== P)
                return M[T] = P,
                !0
        } else {
            const I = Array.isArray(M[T]) ? M[T] : [M[T]]
              , k = Array.isArray(P) ? P : [P];
            for (let A = 0; A < I.length; A++) {
                const O = I[A];
                if (O.equals(k[A]) === !1)
                    return O.copy(k[A]),
                    !0
            }
        }
        return !1
    }
    function w(R) {
        const T = R.uniforms;
        let M = 0;
        const P = 16;
        let I = 0;
        for (let k = 0, A = T.length; k < A; k++) {
            const O = T[k]
              , W = {
                boundary: 0,
                storage: 0
            }
              , Q = Array.isArray(O.value) ? O.value : [O.value];
            for (let H = 0, B = Q.length; H < B; H++) {
                const D = Q[H]
                  , q = S(D);
                W.boundary += q.boundary,
                W.storage += q.storage
            }
            if (O.__data = new Float32Array(W.storage / Float32Array.BYTES_PER_ELEMENT),
            O.__offset = M,
            k > 0) {
                I = M % P;
                const H = P - I;
                I !== 0 && H - W.boundary < 0 && (M += P - I,
                O.__offset = M)
            }
            M += W.storage
        }
        return I = M % P,
        I > 0 && (M += P - I),
        R.__size = M,
        R.__cache = {},
        this
    }
    function S(R) {
        const T = {
            boundary: 0,
            storage: 0
        };
        return typeof R == "number" ? (T.boundary = 4,
        T.storage = 4) : R.isVector2 ? (T.boundary = 8,
        T.storage = 8) : R.isVector3 || R.isColor ? (T.boundary = 16,
        T.storage = 12) : R.isVector4 ? (T.boundary = 16,
        T.storage = 16) : R.isMatrix3 ? (T.boundary = 48,
        T.storage = 48) : R.isMatrix4 ? (T.boundary = 64,
        T.storage = 64) : R.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", R),
        T
    }
    function b(R) {
        const T = R.target;
        T.removeEventListener("dispose", b);
        const M = l.indexOf(T.__bindingPointIndex);
        l.splice(M, 1),
        a.deleteBuffer(n[T.id]),
        delete n[T.id],
        delete o[T.id]
    }
    function C() {
        for (const R in n)
            a.deleteBuffer(n[R]);
        l = [],
        n = {},
        o = {}
    }
    return {
        bind: u,
        update: f,
        dispose: C
    }
}
function createCanvasElement() {
    const a = createElementNS("canvas");
    return a.style.display = "block",
    a
}
function WebGLRenderer(a={}) {
    this.isWebGLRenderer = !0;
    const e = a.canvas !== void 0 ? a.canvas : createCanvasElement()
      , t = a.context !== void 0 ? a.context : null
      , r = a.depth !== void 0 ? a.depth : !0
      , n = a.stencil !== void 0 ? a.stencil : !0
      , o = a.antialias !== void 0 ? a.antialias : !1
      , l = a.premultipliedAlpha !== void 0 ? a.premultipliedAlpha : !0
      , c = a.preserveDrawingBuffer !== void 0 ? a.preserveDrawingBuffer : !1
      , u = a.powerPreference !== void 0 ? a.powerPreference : "default"
      , f = a.failIfMajorPerformanceCaveat !== void 0 ? a.failIfMajorPerformanceCaveat : !1;
    let p;
    t !== null ? p = t.getContextAttributes().alpha : p = a.alpha !== void 0 ? a.alpha : !1;
    let g = null
      , v = null;
    const _ = []
      , w = [];
    this.domElement = e,
    this.debug = {
        checkShaderErrors: !0
    },
    this.autoClear = !0,
    this.autoClearColor = !0,
    this.autoClearDepth = !0,
    this.autoClearStencil = !0,
    this.sortObjects = !0,
    this.clippingPlanes = [],
    this.localClippingEnabled = !1,
    this.outputEncoding = LinearEncoding,
    this.physicallyCorrectLights = !1,
    this.toneMapping = NoToneMapping,
    this.toneMappingExposure = 1;
    const S = this;
    let b = !1
      , C = 0
      , R = 0
      , T = null
      , M = -1
      , P = null;
    const I = new Vector4
      , k = new Vector4;
    let A = null
      , O = e.width
      , W = e.height
      , Q = 1
      , H = null
      , B = null;
    const D = new Vector4(0,0,O,W)
      , q = new Vector4(0,0,O,W);
    let V = !1;
    const J = new Frustum;
    let U = !1
      , ce = !1
      , ee = null;
    const ne = new Matrix4
      , ae = new Vector2
      , ve = new Vector3
      , Y = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
    };
    function $() {
        return T === null ? Q : 1
    }
    let L = t;
    function N(G, fe) {
        for (let de = 0; de < G.length; de++) {
            const he = G[de]
              , Me = e.getContext(he, fe);
            if (Me !== null)
                return Me
        }
        return null
    }
    try {
        const G = {
            alpha: !0,
            depth: r,
            stencil: n,
            antialias: o,
            premultipliedAlpha: l,
            preserveDrawingBuffer: c,
            powerPreference: u,
            failIfMajorPerformanceCaveat: f
        };
        if ("setAttribute"in e && e.setAttribute("data-engine", `three.js r${REVISION}`),
        e.addEventListener("webglcontextlost", Ge, !1),
        e.addEventListener("webglcontextrestored", Xe, !1),
        e.addEventListener("webglcontextcreationerror", Qe, !1),
        L === null) {
            const fe = ["webgl2", "webgl", "experimental-webgl"];
            if (S.isWebGL1Renderer === !0 && fe.shift(),
            L = N(fe, G),
            L === null)
                throw N(fe) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
        }
        L.getShaderPrecisionFormat === void 0 && (L.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        }
        )
    } catch (G) {
        throw console.error("THREE.WebGLRenderer: " + G.message),
        G
    }
    let oe, pe, K, Se, Ce, Te, we, Ae, Ne, Ue, le, Z, He, Ke, j, z, ge, Ee, Oe, ze, te, be, xe, ke;
    function qe() {
        oe = new WebGLExtensions(L),
        pe = new WebGLCapabilities(L,oe,a),
        oe.init(pe),
        be = new WebGLUtils(L,oe,pe),
        K = new WebGLState(L,oe,pe),
        Se = new WebGLInfo,
        Ce = new WebGLProperties,
        Te = new WebGLTextures(L,oe,K,Ce,pe,be,Se),
        we = new WebGLCubeMaps(S),
        Ae = new WebGLCubeUVMaps(S),
        Ne = new WebGLAttributes(L,pe),
        xe = new WebGLBindingStates(L,oe,Ne,pe),
        Ue = new WebGLGeometries(L,Ne,Se,xe),
        le = new WebGLObjects(L,Ue,Ne,Se),
        Oe = new WebGLMorphtargets(L,pe,Te),
        z = new WebGLClipping(Ce),
        Z = new WebGLPrograms(S,we,Ae,oe,pe,xe,z),
        He = new WebGLMaterials(S,Ce),
        Ke = new WebGLRenderLists,
        j = new WebGLRenderStates(oe,pe),
        Ee = new WebGLBackground(S,we,Ae,K,le,p,l),
        ge = new WebGLShadowMap(S,le,pe),
        ke = new WebGLUniformsGroups(L,Se,pe,K),
        ze = new WebGLBufferRenderer(L,oe,Se,pe),
        te = new WebGLIndexedBufferRenderer(L,oe,Se,pe),
        Se.programs = Z.programs,
        S.capabilities = pe,
        S.extensions = oe,
        S.properties = Ce,
        S.renderLists = Ke,
        S.shadowMap = ge,
        S.state = K,
        S.info = Se
    }
    qe();
    const Ve = new WebXRManager(S,L);
    this.xr = Ve,
    this.getContext = function() {
        return L
    }
    ,
    this.getContextAttributes = function() {
        return L.getContextAttributes()
    }
    ,
    this.forceContextLoss = function() {
        const G = oe.get("WEBGL_lose_context");
        G && G.loseContext()
    }
    ,
    this.forceContextRestore = function() {
        const G = oe.get("WEBGL_lose_context");
        G && G.restoreContext()
    }
    ,
    this.getPixelRatio = function() {
        return Q
    }
    ,
    this.setPixelRatio = function(G) {
        G !== void 0 && (Q = G,
        this.setSize(O, W, !1))
    }
    ,
    this.getSize = function(G) {
        return G.set(O, W)
    }
    ,
    this.setSize = function(G, fe, de) {
        if (Ve.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return
        }
        O = G,
        W = fe,
        e.width = Math.floor(G * Q),
        e.height = Math.floor(fe * Q),
        de !== !1 && (e.style.width = G + "px",
        e.style.height = fe + "px"),
        this.setViewport(0, 0, G, fe)
    }
    ,
    this.getDrawingBufferSize = function(G) {
        return G.set(O * Q, W * Q).floor()
    }
    ,
    this.setDrawingBufferSize = function(G, fe, de) {
        O = G,
        W = fe,
        Q = de,
        e.width = Math.floor(G * de),
        e.height = Math.floor(fe * de),
        this.setViewport(0, 0, G, fe)
    }
    ,
    this.getCurrentViewport = function(G) {
        return G.copy(I)
    }
    ,
    this.getViewport = function(G) {
        return G.copy(D)
    }
    ,
    this.setViewport = function(G, fe, de, he) {
        G.isVector4 ? D.set(G.x, G.y, G.z, G.w) : D.set(G, fe, de, he),
        K.viewport(I.copy(D).multiplyScalar(Q).floor())
    }
    ,
    this.getScissor = function(G) {
        return G.copy(q)
    }
    ,
    this.setScissor = function(G, fe, de, he) {
        G.isVector4 ? q.set(G.x, G.y, G.z, G.w) : q.set(G, fe, de, he),
        K.scissor(k.copy(q).multiplyScalar(Q).floor())
    }
    ,
    this.getScissorTest = function() {
        return V
    }
    ,
    this.setScissorTest = function(G) {
        K.setScissorTest(V = G)
    }
    ,
    this.setOpaqueSort = function(G) {
        H = G
    }
    ,
    this.setTransparentSort = function(G) {
        B = G
    }
    ,
    this.getClearColor = function(G) {
        return G.copy(Ee.getClearColor())
    }
    ,
    this.setClearColor = function() {
        Ee.setClearColor.apply(Ee, arguments)
    }
    ,
    this.getClearAlpha = function() {
        return Ee.getClearAlpha()
    }
    ,
    this.setClearAlpha = function() {
        Ee.setClearAlpha.apply(Ee, arguments)
    }
    ,
    this.clear = function(G=!0, fe=!0, de=!0) {
        let he = 0;
        G && (he |= 16384),
        fe && (he |= 256),
        de && (he |= 1024),
        L.clear(he)
    }
    ,
    this.clearColor = function() {
        this.clear(!0, !1, !1)
    }
    ,
    this.clearDepth = function() {
        this.clear(!1, !0, !1)
    }
    ,
    this.clearStencil = function() {
        this.clear(!1, !1, !0)
    }
    ,
    this.dispose = function() {
        e.removeEventListener("webglcontextlost", Ge, !1),
        e.removeEventListener("webglcontextrestored", Xe, !1),
        e.removeEventListener("webglcontextcreationerror", Qe, !1),
        Ke.dispose(),
        j.dispose(),
        Ce.dispose(),
        we.dispose(),
        Ae.dispose(),
        le.dispose(),
        xe.dispose(),
        ke.dispose(),
        Z.dispose(),
        Ve.dispose(),
        Ve.removeEventListener("sessionstart", We),
        Ve.removeEventListener("sessionend", Ye),
        ee && (ee.dispose(),
        ee = null),
        st.stop()
    }
    ;
    function Ge(G) {
        G.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        b = !0
    }
    function Xe() {
        console.log("THREE.WebGLRenderer: Context Restored."),
        b = !1;
        const G = Se.autoReset
          , fe = ge.enabled
          , de = ge.autoUpdate
          , he = ge.needsUpdate
          , Me = ge.type;
        qe(),
        Se.autoReset = G,
        ge.enabled = fe,
        ge.autoUpdate = de,
        ge.needsUpdate = he,
        ge.type = Me
    }
    function Qe(G) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", G.statusMessage)
    }
    function tt(G) {
        const fe = G.target;
        fe.removeEventListener("dispose", tt),
        nt(fe)
    }
    function nt(G) {
        se(G),
        Ce.remove(G)
    }
    function se(G) {
        const fe = Ce.get(G).programs;
        fe !== void 0 && (fe.forEach(function(de) {
            Z.releaseProgram(de)
        }),
        G.isShaderMaterial && Z.releaseShaderCache(G))
    }
    this.renderBufferDirect = function(G, fe, de, he, Me, E) {
        fe === null && (fe = Y);
        const F = Me.isMesh && Me.matrixWorld.determinant() < 0
          , X = Rt(G, fe, de, he, Me);
        K.setMaterial(he, F);
        let ie = de.index
          , me = 1;
        he.wireframe === !0 && (ie = Ue.getWireframeAttribute(de),
        me = 2);
        const ue = de.drawRange
          , ye = de.attributes.position;
        let Pe = ue.start * me
          , De = (ue.start + ue.count) * me;
        E !== null && (Pe = Math.max(Pe, E.start * me),
        De = Math.min(De, (E.start + E.count) * me)),
        ie !== null ? (Pe = Math.max(Pe, 0),
        De = Math.min(De, ie.count)) : ye != null && (Pe = Math.max(Pe, 0),
        De = Math.min(De, ye.count));
        const Re = De - Pe;
        if (Re < 0 || Re === 1 / 0)
            return;
        xe.setup(Me, he, X, de, ie);
        let Fe, Be = ze;
        if (ie !== null && (Fe = Ne.get(ie),
        Be = te,
        Be.setIndex(Fe)),
        Me.isMesh)
            he.wireframe === !0 ? (K.setLineWidth(he.wireframeLinewidth * $()),
            Be.setMode(1)) : Be.setMode(4);
        else if (Me.isLine) {
            let Le = he.linewidth;
            Le === void 0 && (Le = 1),
            K.setLineWidth(Le * $()),
            Me.isLineSegments ? Be.setMode(1) : Me.isLineLoop ? Be.setMode(2) : Be.setMode(3)
        } else
            Me.isPoints ? Be.setMode(0) : Me.isSprite && Be.setMode(4);
        if (Me.isInstancedMesh)
            Be.renderInstances(Pe, Re, Me.count);
        else if (de.isInstancedBufferGeometry) {
            const Le = de._maxInstanceCount !== void 0 ? de._maxInstanceCount : 1 / 0
              , Je = Math.min(de.instanceCount, Le);
            Be.renderInstances(Pe, Re, Je)
        } else
            Be.render(Pe, Re)
    }
    ,
    this.compile = function(G, fe) {
        function de(he, Me, E) {
            he.transparent === !0 && he.side === TwoPassDoubleSide ? (he.side = BackSide,
            he.needsUpdate = !0,
            vt(he, Me, E),
            he.side = FrontSide,
            he.needsUpdate = !0,
            vt(he, Me, E),
            he.side = TwoPassDoubleSide) : vt(he, Me, E)
        }
        v = j.get(G),
        v.init(),
        w.push(v),
        G.traverseVisible(function(he) {
            he.isLight && he.layers.test(fe.layers) && (v.pushLight(he),
            he.castShadow && v.pushShadow(he))
        }),
        v.setupLights(S.physicallyCorrectLights),
        G.traverse(function(he) {
            const Me = he.material;
            if (Me)
                if (Array.isArray(Me))
                    for (let E = 0; E < Me.length; E++) {
                        const F = Me[E];
                        de(F, G, he)
                    }
                else
                    de(Me, G, he)
        }),
        w.pop(),
        v = null
    }
    ;
    let re = null;
    function Ie(G) {
        re && re(G)
    }
    function We() {
        st.stop()
    }
    function Ye() {
        st.start()
    }
    const st = new WebGLAnimation;
    st.setAnimationLoop(Ie),
    typeof self < "u" && st.setContext(self),
    this.setAnimationLoop = function(G) {
        re = G,
        Ve.setAnimationLoop(G),
        G === null ? st.stop() : st.start()
    }
    ,
    Ve.addEventListener("sessionstart", We),
    Ve.addEventListener("sessionend", Ye),
    this.render = function(G, fe) {
        if (fe !== void 0 && fe.isCamera !== !0) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return
        }
        if (b === !0)
            return;
        G.matrixWorldAutoUpdate === !0 && G.updateMatrixWorld(),
        fe.parent === null && fe.matrixWorldAutoUpdate === !0 && fe.updateMatrixWorld(),
        Ve.enabled === !0 && Ve.isPresenting === !0 && (Ve.cameraAutoUpdate === !0 && Ve.updateCamera(fe),
        fe = Ve.getCamera()),
        G.isScene === !0 && G.onBeforeRender(S, G, fe, T),
        v = j.get(G, w.length),
        v.init(),
        w.push(v),
        ne.multiplyMatrices(fe.projectionMatrix, fe.matrixWorldInverse),
        J.setFromProjectionMatrix(ne),
        ce = this.localClippingEnabled,
        U = z.init(this.clippingPlanes, ce, fe),
        g = Ke.get(G, _.length),
        g.init(),
        _.push(g),
        pt(G, fe, 0, S.sortObjects),
        g.finish(),
        S.sortObjects === !0 && g.sort(H, B),
        U === !0 && z.beginShadows();
        const de = v.state.shadowsArray;
        if (ge.render(de, G, fe),
        U === !0 && z.endShadows(),
        this.info.autoReset === !0 && this.info.reset(),
        Ee.render(g, G),
        v.setupLights(S.physicallyCorrectLights),
        fe.isArrayCamera) {
            const he = fe.cameras;
            for (let Me = 0, E = he.length; Me < E; Me++) {
                const F = he[Me];
                gt(g, G, F, F.viewport)
            }
        } else
            gt(g, G, fe);
        T !== null && (Te.updateMultisampleRenderTarget(T),
        Te.updateRenderTargetMipmap(T)),
        G.isScene === !0 && G.onAfterRender(S, G, fe),
        xe.resetDefaultState(),
        M = -1,
        P = null,
        w.pop(),
        w.length > 0 ? v = w[w.length - 1] : v = null,
        _.pop(),
        _.length > 0 ? g = _[_.length - 1] : g = null
    }
    ;
    function pt(G, fe, de, he) {
        if (G.visible === !1)
            return;
        if (G.layers.test(fe.layers)) {
            if (G.isGroup)
                de = G.renderOrder;
            else if (G.isLOD)
                G.autoUpdate === !0 && G.update(fe);
            else if (G.isLight)
                v.pushLight(G),
                G.castShadow && v.pushShadow(G);
            else if (G.isSprite) {
                if (!G.frustumCulled || J.intersectsSprite(G)) {
                    he && ve.setFromMatrixPosition(G.matrixWorld).applyMatrix4(ne);
                    const F = le.update(G)
                      , X = G.material;
                    X.visible && g.push(G, F, X, de, ve.z, null)
                }
            } else if ((G.isMesh || G.isLine || G.isPoints) && (G.isSkinnedMesh && G.skeleton.frame !== Se.render.frame && (G.skeleton.update(),
            G.skeleton.frame = Se.render.frame),
            !G.frustumCulled || J.intersectsObject(G))) {
                he && ve.setFromMatrixPosition(G.matrixWorld).applyMatrix4(ne);
                const F = le.update(G)
                  , X = G.material;
                if (Array.isArray(X)) {
                    const ie = F.groups;
                    for (let me = 0, ue = ie.length; me < ue; me++) {
                        const ye = ie[me]
                          , Pe = X[ye.materialIndex];
                        Pe && Pe.visible && g.push(G, F, Pe, de, ve.z, ye)
                    }
                } else
                    X.visible && g.push(G, F, X, de, ve.z, null)
            }
        }
        const E = G.children;
        for (let F = 0, X = E.length; F < X; F++)
            pt(E[F], fe, de, he)
    }
    function gt(G, fe, de, he) {
        const Me = G.opaque
          , E = G.transmissive
          , F = G.transparent;
        v.setupLightsView(de),
        E.length > 0 && bt(Me, fe, de),
        he && K.viewport(I.copy(he)),
        Me.length > 0 && ct(Me, fe, de),
        E.length > 0 && ct(E, fe, de),
        F.length > 0 && ct(F, fe, de),
        K.buffers.depth.setTest(!0),
        K.buffers.depth.setMask(!0),
        K.buffers.color.setMask(!0),
        K.setPolygonOffset(!1)
    }
    function bt(G, fe, de) {
        const he = pe.isWebGL2;
        ee === null && (ee = new WebGLRenderTarget(1,1,{
            generateMipmaps: !0,
            type: oe.has("EXT_color_buffer_half_float") ? HalfFloatType : UnsignedByteType,
            minFilter: LinearMipmapLinearFilter,
            samples: he && o === !0 ? 4 : 0
        })),
        S.getDrawingBufferSize(ae),
        he ? ee.setSize(ae.x, ae.y) : ee.setSize(floorPowerOfTwo(ae.x), floorPowerOfTwo(ae.y));
        const Me = S.getRenderTarget();
        S.setRenderTarget(ee),
        S.clear();
        const E = S.toneMapping;
        S.toneMapping = NoToneMapping,
        ct(G, fe, de),
        S.toneMapping = E,
        Te.updateMultisampleRenderTarget(ee),
        Te.updateRenderTargetMipmap(ee),
        S.setRenderTarget(Me)
    }
    function ct(G, fe, de) {
        const he = fe.isScene === !0 ? fe.overrideMaterial : null;
        for (let Me = 0, E = G.length; Me < E; Me++) {
            const F = G[Me]
              , X = F.object
              , ie = F.geometry
              , me = he === null ? F.material : he
              , ue = F.group;
            X.layers.test(de.layers) && xt(X, fe, de, ie, me, ue)
        }
    }
    function xt(G, fe, de, he, Me, E) {
        G.onBeforeRender(S, fe, de, he, Me, E),
        G.modelViewMatrix.multiplyMatrices(de.matrixWorldInverse, G.matrixWorld),
        G.normalMatrix.getNormalMatrix(G.modelViewMatrix),
        Me.onBeforeRender(S, fe, de, he, G, E),
        Me.transparent === !0 && Me.side === TwoPassDoubleSide ? (Me.side = BackSide,
        Me.needsUpdate = !0,
        S.renderBufferDirect(de, fe, he, Me, G, E),
        Me.side = FrontSide,
        Me.needsUpdate = !0,
        S.renderBufferDirect(de, fe, he, Me, G, E),
        Me.side = TwoPassDoubleSide) : S.renderBufferDirect(de, fe, he, Me, G, E),
        G.onAfterRender(S, fe, de, he, Me, E)
    }
    function vt(G, fe, de) {
        fe.isScene !== !0 && (fe = Y);
        const he = Ce.get(G)
          , Me = v.state.lights
          , E = v.state.shadowsArray
          , F = Me.state.version
          , X = Z.getParameters(G, Me.state, E, fe, de)
          , ie = Z.getProgramCacheKey(X);
        let me = he.programs;
        he.environment = G.isMeshStandardMaterial ? fe.environment : null,
        he.fog = fe.fog,
        he.envMap = (G.isMeshStandardMaterial ? Ae : we).get(G.envMap || he.environment),
        me === void 0 && (G.addEventListener("dispose", tt),
        me = new Map,
        he.programs = me);
        let ue = me.get(ie);
        if (ue !== void 0) {
            if (he.currentProgram === ue && he.lightsStateVersion === F)
                return Mt(G, X),
                ue
        } else
            X.uniforms = Z.getUniforms(G),
            G.onBuild(de, X, S),
            G.onBeforeCompile(X, S),
            ue = Z.acquireProgram(X, ie),
            me.set(ie, ue),
            he.uniforms = X.uniforms;
        const ye = he.uniforms;
        (!G.isShaderMaterial && !G.isRawShaderMaterial || G.clipping === !0) && (ye.clippingPlanes = z.uniform),
        Mt(G, X),
        he.needsLights = Pt(G),
        he.lightsStateVersion = F,
        he.needsLights && (ye.ambientLightColor.value = Me.state.ambient,
        ye.lightProbe.value = Me.state.probe,
        ye.directionalLights.value = Me.state.directional,
        ye.directionalLightShadows.value = Me.state.directionalShadow,
        ye.spotLights.value = Me.state.spot,
        ye.spotLightShadows.value = Me.state.spotShadow,
        ye.rectAreaLights.value = Me.state.rectArea,
        ye.ltc_1.value = Me.state.rectAreaLTC1,
        ye.ltc_2.value = Me.state.rectAreaLTC2,
        ye.pointLights.value = Me.state.point,
        ye.pointLightShadows.value = Me.state.pointShadow,
        ye.hemisphereLights.value = Me.state.hemi,
        ye.directionalShadowMap.value = Me.state.directionalShadowMap,
        ye.directionalShadowMatrix.value = Me.state.directionalShadowMatrix,
        ye.spotShadowMap.value = Me.state.spotShadowMap,
        ye.spotLightMatrix.value = Me.state.spotLightMatrix,
        ye.spotLightMap.value = Me.state.spotLightMap,
        ye.pointShadowMap.value = Me.state.pointShadowMap,
        ye.pointShadowMatrix.value = Me.state.pointShadowMatrix);
        const Pe = ue.getUniforms()
          , De = WebGLUniforms.seqWithValue(Pe.seq, ye);
        return he.currentProgram = ue,
        he.uniformsList = De,
        ue
    }
    function Mt(G, fe) {
        const de = Ce.get(G);
        de.outputEncoding = fe.outputEncoding,
        de.instancing = fe.instancing,
        de.skinning = fe.skinning,
        de.morphTargets = fe.morphTargets,
        de.morphNormals = fe.morphNormals,
        de.morphColors = fe.morphColors,
        de.morphTargetsCount = fe.morphTargetsCount,
        de.numClippingPlanes = fe.numClippingPlanes,
        de.numIntersection = fe.numClipIntersection,
        de.vertexAlphas = fe.vertexAlphas,
        de.vertexTangents = fe.vertexTangents,
        de.toneMapping = fe.toneMapping
    }
    function Rt(G, fe, de, he, Me) {
        fe.isScene !== !0 && (fe = Y),
        Te.resetTextureUnits();
        const E = fe.fog
          , F = he.isMeshStandardMaterial ? fe.environment : null
          , X = T === null ? S.outputEncoding : T.isXRRenderTarget === !0 ? T.texture.encoding : LinearEncoding
          , ie = (he.isMeshStandardMaterial ? Ae : we).get(he.envMap || F)
          , me = he.vertexColors === !0 && !!de.attributes.color && de.attributes.color.itemSize === 4
          , ue = !!he.normalMap && !!de.attributes.tangent
          , ye = !!de.morphAttributes.position
          , Pe = !!de.morphAttributes.normal
          , De = !!de.morphAttributes.color
          , Re = he.toneMapped ? S.toneMapping : NoToneMapping
          , Fe = de.morphAttributes.position || de.morphAttributes.normal || de.morphAttributes.color
          , Be = Fe !== void 0 ? Fe.length : 0
          , Le = Ce.get(he)
          , Je = v.state.lights;
        if (U === !0 && (ce === !0 || G !== P)) {
            const it = G === P && he.id === M;
            z.setState(he, G, it)
        }
        let je = !1;
        he.version === Le.__version ? (Le.needsLights && Le.lightsStateVersion !== Je.state.version || Le.outputEncoding !== X || Me.isInstancedMesh && Le.instancing === !1 || !Me.isInstancedMesh && Le.instancing === !0 || Me.isSkinnedMesh && Le.skinning === !1 || !Me.isSkinnedMesh && Le.skinning === !0 || Le.envMap !== ie || he.fog === !0 && Le.fog !== E || Le.numClippingPlanes !== void 0 && (Le.numClippingPlanes !== z.numPlanes || Le.numIntersection !== z.numIntersection) || Le.vertexAlphas !== me || Le.vertexTangents !== ue || Le.morphTargets !== ye || Le.morphNormals !== Pe || Le.morphColors !== De || Le.toneMapping !== Re || pe.isWebGL2 === !0 && Le.morphTargetsCount !== Be) && (je = !0) : (je = !0,
        Le.__version = he.version);
        let $e = Le.currentProgram;
        je === !0 && ($e = vt(he, fe, Me));
        let Ze = !1
          , rt = !1
          , ut = !1;
        const ot = $e.getUniforms()
          , ft = Le.uniforms;
        if (K.useProgram($e.program) && (Ze = !0,
        rt = !0,
        ut = !0),
        he.id !== M && (M = he.id,
        rt = !0),
        Ze || P !== G) {
            if (ot.setValue(L, "projectionMatrix", G.projectionMatrix),
            pe.logarithmicDepthBuffer && ot.setValue(L, "logDepthBufFC", 2 / (Math.log(G.far + 1) / Math.LN2)),
            P !== G && (P = G,
            rt = !0,
            ut = !0),
            he.isShaderMaterial || he.isMeshPhongMaterial || he.isMeshToonMaterial || he.isMeshStandardMaterial || he.envMap) {
                const it = ot.map.cameraPosition;
                it !== void 0 && it.setValue(L, ve.setFromMatrixPosition(G.matrixWorld))
            }
            (he.isMeshPhongMaterial || he.isMeshToonMaterial || he.isMeshLambertMaterial || he.isMeshBasicMaterial || he.isMeshStandardMaterial || he.isShaderMaterial) && ot.setValue(L, "isOrthographic", G.isOrthographicCamera === !0),
            (he.isMeshPhongMaterial || he.isMeshToonMaterial || he.isMeshLambertMaterial || he.isMeshBasicMaterial || he.isMeshStandardMaterial || he.isShaderMaterial || he.isShadowMaterial || Me.isSkinnedMesh) && ot.setValue(L, "viewMatrix", G.matrixWorldInverse)
        }
        if (Me.isSkinnedMesh) {
            ot.setOptional(L, Me, "bindMatrix"),
            ot.setOptional(L, Me, "bindMatrixInverse");
            const it = Me.skeleton;
            it && (pe.floatVertexTextures ? (it.boneTexture === null && it.computeBoneTexture(),
            ot.setValue(L, "boneTexture", it.boneTexture, Te),
            ot.setValue(L, "boneTextureSize", it.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
        }
        const at = de.morphAttributes;
        if ((at.position !== void 0 || at.normal !== void 0 || at.color !== void 0 && pe.isWebGL2 === !0) && Oe.update(Me, de, he, $e),
        (rt || Le.receiveShadow !== Me.receiveShadow) && (Le.receiveShadow = Me.receiveShadow,
        ot.setValue(L, "receiveShadow", Me.receiveShadow)),
        he.isMeshGouraudMaterial && he.envMap !== null && (ft.envMap.value = ie,
        ft.flipEnvMap.value = ie.isCubeTexture && ie.isRenderTargetTexture === !1 ? -1 : 1),
        rt && (ot.setValue(L, "toneMappingExposure", S.toneMappingExposure),
        Le.needsLights && wt(ft, ut),
        E && he.fog === !0 && He.refreshFogUniforms(ft, E),
        He.refreshMaterialUniforms(ft, he, Q, W, ee),
        WebGLUniforms.upload(L, Le.uniformsList, ft, Te)),
        he.isShaderMaterial && he.uniformsNeedUpdate === !0 && (WebGLUniforms.upload(L, Le.uniformsList, ft, Te),
        he.uniformsNeedUpdate = !1),
        he.isSpriteMaterial && ot.setValue(L, "center", Me.center),
        ot.setValue(L, "modelViewMatrix", Me.modelViewMatrix),
        ot.setValue(L, "normalMatrix", Me.normalMatrix),
        ot.setValue(L, "modelMatrix", Me.matrixWorld),
        he.isShaderMaterial || he.isRawShaderMaterial) {
            const it = he.uniformsGroups;
            for (let dt = 0, _t = it.length; dt < _t; dt++)
                if (pe.isWebGL2) {
                    const mt = it[dt];
                    ke.update(mt, $e),
                    ke.bind(mt, $e)
                } else
                    console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
        }
        return $e
    }
    function wt(G, fe) {
        G.ambientLightColor.needsUpdate = fe,
        G.lightProbe.needsUpdate = fe,
        G.directionalLights.needsUpdate = fe,
        G.directionalLightShadows.needsUpdate = fe,
        G.pointLights.needsUpdate = fe,
        G.pointLightShadows.needsUpdate = fe,
        G.spotLights.needsUpdate = fe,
        G.spotLightShadows.needsUpdate = fe,
        G.rectAreaLights.needsUpdate = fe,
        G.hemisphereLights.needsUpdate = fe
    }
    function Pt(G) {
        return G.isMeshLambertMaterial || G.isMeshToonMaterial || G.isMeshPhongMaterial || G.isMeshStandardMaterial || G.isShadowMaterial || G.isShaderMaterial && G.lights === !0
    }
    this.getActiveCubeFace = function() {
        return C
    }
    ,
    this.getActiveMipmapLevel = function() {
        return R
    }
    ,
    this.getRenderTarget = function() {
        return T
    }
    ,
    this.setRenderTargetTextures = function(G, fe, de) {
        Ce.get(G.texture).__webglTexture = fe,
        Ce.get(G.depthTexture).__webglTexture = de;
        const he = Ce.get(G);
        he.__hasExternalTextures = !0,
        he.__hasExternalTextures && (he.__autoAllocateDepthBuffer = de === void 0,
        he.__autoAllocateDepthBuffer || oe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
        he.__useRenderToTexture = !1))
    }
    ,
    this.setRenderTargetFramebuffer = function(G, fe) {
        const de = Ce.get(G);
        de.__webglFramebuffer = fe,
        de.__useDefaultFramebuffer = fe === void 0
    }
    ,
    this.setRenderTarget = function(G, fe=0, de=0) {
        T = G,
        C = fe,
        R = de;
        let he = !0
          , Me = null
          , E = !1
          , F = !1;
        if (G) {
            const ie = Ce.get(G);
            ie.__useDefaultFramebuffer !== void 0 ? (K.bindFramebuffer(36160, null),
            he = !1) : ie.__webglFramebuffer === void 0 ? Te.setupRenderTarget(G) : ie.__hasExternalTextures && Te.rebindTextures(G, Ce.get(G.texture).__webglTexture, Ce.get(G.depthTexture).__webglTexture);
            const me = G.texture;
            (me.isData3DTexture || me.isDataArrayTexture || me.isCompressedArrayTexture) && (F = !0);
            const ue = Ce.get(G).__webglFramebuffer;
            G.isWebGLCubeRenderTarget ? (Me = ue[fe],
            E = !0) : pe.isWebGL2 && G.samples > 0 && Te.useMultisampledRTT(G) === !1 ? Me = Ce.get(G).__webglMultisampledFramebuffer : Me = ue,
            I.copy(G.viewport),
            k.copy(G.scissor),
            A = G.scissorTest
        } else
            I.copy(D).multiplyScalar(Q).floor(),
            k.copy(q).multiplyScalar(Q).floor(),
            A = V;
        if (K.bindFramebuffer(36160, Me) && pe.drawBuffers && he && K.drawBuffers(G, Me),
        K.viewport(I),
        K.scissor(k),
        K.setScissorTest(A),
        E) {
            const ie = Ce.get(G.texture);
            L.framebufferTexture2D(36160, 36064, 34069 + fe, ie.__webglTexture, de)
        } else if (F) {
            const ie = Ce.get(G.texture)
              , me = fe || 0;
            L.framebufferTextureLayer(36160, 36064, ie.__webglTexture, de || 0, me)
        }
        M = -1
    }
    ,
    this.readRenderTargetPixels = function(G, fe, de, he, Me, E, F) {
        if (!(G && G.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return
        }
        let X = Ce.get(G).__webglFramebuffer;
        if (G.isWebGLCubeRenderTarget && F !== void 0 && (X = X[F]),
        X) {
            K.bindFramebuffer(36160, X);
            try {
                const ie = G.texture
                  , me = ie.format
                  , ue = ie.type;
                if (me !== RGBAFormat && be.convert(me) !== L.getParameter(35739)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return
                }
                const ye = ue === HalfFloatType && (oe.has("EXT_color_buffer_half_float") || pe.isWebGL2 && oe.has("EXT_color_buffer_float"));
                if (ue !== UnsignedByteType && be.convert(ue) !== L.getParameter(35738) && !(ue === FloatType && (pe.isWebGL2 || oe.has("OES_texture_float") || oe.has("WEBGL_color_buffer_float"))) && !ye) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return
                }
                fe >= 0 && fe <= G.width - he && de >= 0 && de <= G.height - Me && L.readPixels(fe, de, he, Me, be.convert(me), be.convert(ue), E)
            } finally {
                const ie = T !== null ? Ce.get(T).__webglFramebuffer : null;
                K.bindFramebuffer(36160, ie)
            }
        }
    }
    ,
    this.copyFramebufferToTexture = function(G, fe, de=0) {
        const he = Math.pow(2, -de)
          , Me = Math.floor(fe.image.width * he)
          , E = Math.floor(fe.image.height * he);
        Te.setTexture2D(fe, 0),
        L.copyTexSubImage2D(3553, de, 0, 0, G.x, G.y, Me, E),
        K.unbindTexture()
    }
    ,
    this.copyTextureToTexture = function(G, fe, de, he=0) {
        const Me = fe.image.width
          , E = fe.image.height
          , F = be.convert(de.format)
          , X = be.convert(de.type);
        Te.setTexture2D(de, 0),
        L.pixelStorei(37440, de.flipY),
        L.pixelStorei(37441, de.premultiplyAlpha),
        L.pixelStorei(3317, de.unpackAlignment),
        fe.isDataTexture ? L.texSubImage2D(3553, he, G.x, G.y, Me, E, F, X, fe.image.data) : fe.isCompressedTexture ? L.compressedTexSubImage2D(3553, he, G.x, G.y, fe.mipmaps[0].width, fe.mipmaps[0].height, F, fe.mipmaps[0].data) : L.texSubImage2D(3553, he, G.x, G.y, F, X, fe.image),
        he === 0 && de.generateMipmaps && L.generateMipmap(3553),
        K.unbindTexture()
    }
    ,
    this.copyTextureToTexture3D = function(G, fe, de, he, Me=0) {
        if (S.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return
        }
        const E = G.max.x - G.min.x + 1
          , F = G.max.y - G.min.y + 1
          , X = G.max.z - G.min.z + 1
          , ie = be.convert(he.format)
          , me = be.convert(he.type);
        let ue;
        if (he.isData3DTexture)
            Te.setTexture3D(he, 0),
            ue = 32879;
        else if (he.isDataArrayTexture)
            Te.setTexture2DArray(he, 0),
            ue = 35866;
        else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return
        }
        L.pixelStorei(37440, he.flipY),
        L.pixelStorei(37441, he.premultiplyAlpha),
        L.pixelStorei(3317, he.unpackAlignment);
        const ye = L.getParameter(3314)
          , Pe = L.getParameter(32878)
          , De = L.getParameter(3316)
          , Re = L.getParameter(3315)
          , Fe = L.getParameter(32877)
          , Be = de.isCompressedTexture ? de.mipmaps[0] : de.image;
        L.pixelStorei(3314, Be.width),
        L.pixelStorei(32878, Be.height),
        L.pixelStorei(3316, G.min.x),
        L.pixelStorei(3315, G.min.y),
        L.pixelStorei(32877, G.min.z),
        de.isDataTexture || de.isData3DTexture ? L.texSubImage3D(ue, Me, fe.x, fe.y, fe.z, E, F, X, ie, me, Be.data) : de.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
        L.compressedTexSubImage3D(ue, Me, fe.x, fe.y, fe.z, E, F, X, ie, Be.data)) : L.texSubImage3D(ue, Me, fe.x, fe.y, fe.z, E, F, X, ie, me, Be),
        L.pixelStorei(3314, ye),
        L.pixelStorei(32878, Pe),
        L.pixelStorei(3316, De),
        L.pixelStorei(3315, Re),
        L.pixelStorei(32877, Fe),
        Me === 0 && he.generateMipmaps && L.generateMipmap(ue),
        K.unbindTexture()
    }
    ,
    this.initTexture = function(G) {
        G.isCubeTexture ? Te.setTextureCube(G, 0) : G.isData3DTexture ? Te.setTexture3D(G, 0) : G.isDataArrayTexture || G.isCompressedArrayTexture ? Te.setTexture2DArray(G, 0) : Te.setTexture2D(G, 0),
        K.unbindTexture()
    }
    ,
    this.resetState = function() {
        C = 0,
        R = 0,
        T = null,
        K.reset(),
        xe.reset()
    }
    ,
    typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
        detail: this
    }))
}
class WebGL1Renderer extends WebGLRenderer {
}
WebGL1Renderer.prototype.isWebGL1Renderer = !0;
class Scene extends Object3D {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.backgroundIntensity = this.backgroundIntensity),
        t
    }
    get autoUpdate() {
        return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
        this.matrixWorldAutoUpdate
    }
    set autoUpdate(e) {
        console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
        this.matrixWorldAutoUpdate = e
    }
}
class InterleavedBuffer {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = StaticDrawUsage,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0,
        this.uuid = generateUUID()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, r) {
        e *= this.stride,
        r *= t.stride;
        for (let n = 0, o = this.stride; n < o; n++)
            this.array[e + n] = t.array[r + n];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , r = new this.constructor(t,this.stride);
        return r.setUsage(this.usage),
        r
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const _vector$6 = new Vector3;
class InterleavedBufferAttribute {
    constructor(e, t, r, n=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = r,
        this.normalized = n
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, r = this.data.count; t < r; t++)
            _vector$6.fromBufferAttribute(this, t),
            _vector$6.applyMatrix4(e),
            this.setXYZ(t, _vector$6.x, _vector$6.y, _vector$6.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, r = this.count; t < r; t++)
            _vector$6.fromBufferAttribute(this, t),
            _vector$6.applyNormalMatrix(e),
            this.setXYZ(t, _vector$6.x, _vector$6.y, _vector$6.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, r = this.count; t < r; t++)
            _vector$6.fromBufferAttribute(this, t),
            _vector$6.transformDirection(e),
            this.setXYZ(t, _vector$6.x, _vector$6.y, _vector$6.z);
        return this
    }
    setX(e, t) {
        return this.normalized && (t = normalize(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = normalize(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = normalize(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = normalize(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = denormalize(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = denormalize(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = denormalize(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = denormalize(t, this.array)),
        t
    }
    setXY(e, t, r) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = normalize(t, this.array),
        r = normalize(r, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = r,
        this
    }
    setXYZ(e, t, r, n) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = normalize(t, this.array),
        r = normalize(r, this.array),
        n = normalize(n, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = r,
        this.data.array[e + 2] = n,
        this
    }
    setXYZW(e, t, r, n, o) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = normalize(t, this.array),
        r = normalize(r, this.array),
        n = normalize(n, this.array),
        o = normalize(o, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = r,
        this.data.array[e + 2] = n,
        this.data.array[e + 3] = o,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let r = 0; r < this.count; r++) {
                const n = r * this.data.stride + this.offset;
                for (let o = 0; o < this.itemSize; o++)
                    t.push(this.data.array[n + o])
            }
            return new BufferAttribute(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new InterleavedBufferAttribute(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let r = 0; r < this.count; r++) {
                const n = r * this.data.stride + this.offset;
                for (let o = 0; o < this.itemSize; o++)
                    t.push(this.data.array[n + o])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
class DataTexture extends Texture {
    constructor(e=null, t=1, r=1, n, o, l, c, u, f=NearestFilter, p=NearestFilter, g, v) {
        super(null, l, c, u, f, p, n, o, g, v),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: r
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class InstancedBufferAttribute extends BufferAttribute {
    constructor(e, t, r, n=1) {
        super(e, t, r),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = n
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
class LineBasicMaterial extends Material {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new Color(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const _start$1 = new Vector3
  , _end$1 = new Vector3
  , _inverseMatrix$1 = new Matrix4
  , _ray$1 = new Ray
  , _sphere$1 = new Sphere;
let Line$1 = class extends Object3D {
    constructor(e=new BufferGeometry, t=new LineBasicMaterial) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , r = [0];
            for (let n = 1, o = t.count; n < o; n++)
                _start$1.fromBufferAttribute(t, n - 1),
                _end$1.fromBufferAttribute(t, n),
                r[n] = r[n - 1],
                r[n] += _start$1.distanceTo(_end$1);
            e.setAttribute("lineDistance", new Float32BufferAttribute(r,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const r = this.geometry
          , n = this.matrixWorld
          , o = e.params.Line.threshold
          , l = r.drawRange;
        if (r.boundingSphere === null && r.computeBoundingSphere(),
        _sphere$1.copy(r.boundingSphere),
        _sphere$1.applyMatrix4(n),
        _sphere$1.radius += o,
        e.ray.intersectsSphere(_sphere$1) === !1)
            return;
        _inverseMatrix$1.copy(n).invert(),
        _ray$1.copy(e.ray).applyMatrix4(_inverseMatrix$1);
        const c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , u = c * c
          , f = new Vector3
          , p = new Vector3
          , g = new Vector3
          , v = new Vector3
          , _ = this.isLineSegments ? 2 : 1
          , w = r.index
          , b = r.attributes.position;
        if (w !== null) {
            const C = Math.max(0, l.start)
              , R = Math.min(w.count, l.start + l.count);
            for (let T = C, M = R - 1; T < M; T += _) {
                const P = w.getX(T)
                  , I = w.getX(T + 1);
                if (f.fromBufferAttribute(b, P),
                p.fromBufferAttribute(b, I),
                _ray$1.distanceSqToSegment(f, p, v, g) > u)
                    continue;
                v.applyMatrix4(this.matrixWorld);
                const A = e.ray.origin.distanceTo(v);
                A < e.near || A > e.far || t.push({
                    distance: A,
                    point: g.clone().applyMatrix4(this.matrixWorld),
                    index: T,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            const C = Math.max(0, l.start)
              , R = Math.min(b.count, l.start + l.count);
            for (let T = C, M = R - 1; T < M; T += _) {
                if (f.fromBufferAttribute(b, T),
                p.fromBufferAttribute(b, T + 1),
                _ray$1.distanceSqToSegment(f, p, v, g) > u)
                    continue;
                v.applyMatrix4(this.matrixWorld);
                const I = e.ray.origin.distanceTo(v);
                I < e.near || I > e.far || t.push({
                    distance: I,
                    point: g.clone().applyMatrix4(this.matrixWorld),
                    index: T,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , r = Object.keys(t);
        if (r.length > 0) {
            const n = t[r[0]];
            if (n !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let o = 0, l = n.length; o < l; o++) {
                    const c = n[o].name || String(o);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[c] = o
                }
            }
        }
    }
}
;
const _start = new Vector3
  , _end = new Vector3;
class LineSegments extends Line$1 {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , r = [];
            for (let n = 0, o = t.count; n < o; n += 2)
                _start.fromBufferAttribute(t, n),
                _end.fromBufferAttribute(t, n + 1),
                r[n] = n === 0 ? 0 : r[n - 1],
                r[n + 1] = r[n] + _start.distanceTo(_end);
            e.setAttribute("lineDistance", new Float32BufferAttribute(r,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class PointsMaterial extends Material {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new Color(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const _inverseMatrix = new Matrix4
  , _ray = new Ray
  , _sphere = new Sphere
  , _position$2 = new Vector3;
class Points extends Object3D {
    constructor(e=new BufferGeometry, t=new PointsMaterial) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const r = this.geometry
          , n = this.matrixWorld
          , o = e.params.Points.threshold
          , l = r.drawRange;
        if (r.boundingSphere === null && r.computeBoundingSphere(),
        _sphere.copy(r.boundingSphere),
        _sphere.applyMatrix4(n),
        _sphere.radius += o,
        e.ray.intersectsSphere(_sphere) === !1)
            return;
        _inverseMatrix.copy(n).invert(),
        _ray.copy(e.ray).applyMatrix4(_inverseMatrix);
        const c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , u = c * c
          , f = r.index
          , g = r.attributes.position;
        if (f !== null) {
            const v = Math.max(0, l.start)
              , _ = Math.min(f.count, l.start + l.count);
            for (let w = v, S = _; w < S; w++) {
                const b = f.getX(w);
                _position$2.fromBufferAttribute(g, b),
                testPoint(_position$2, b, u, n, e, t, this)
            }
        } else {
            const v = Math.max(0, l.start)
              , _ = Math.min(g.count, l.start + l.count);
            for (let w = v, S = _; w < S; w++)
                _position$2.fromBufferAttribute(g, w),
                testPoint(_position$2, w, u, n, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , r = Object.keys(t);
        if (r.length > 0) {
            const n = t[r[0]];
            if (n !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let o = 0, l = n.length; o < l; o++) {
                    const c = n[o].name || String(o);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[c] = o
                }
            }
        }
    }
}
function testPoint(a, e, t, r, n, o, l) {
    const c = _ray.distanceSqToPoint(a);
    if (c < t) {
        const u = new Vector3;
        _ray.closestPointToPoint(a, u),
        u.applyMatrix4(r);
        const f = n.ray.origin.distanceTo(u);
        if (f < n.near || f > n.far)
            return;
        o.push({
            distance: f,
            distanceToRay: Math.sqrt(c),
            point: u,
            index: e,
            face: null,
            object: l
        })
    }
}
class VideoTexture extends Texture {
    constructor(e, t, r, n, o, l, c, u, f) {
        super(e, t, r, n, o, l, c, u, f),
        this.isVideoTexture = !0,
        this.minFilter = l !== void 0 ? l : LinearFilter,
        this.magFilter = o !== void 0 ? o : LinearFilter,
        this.generateMipmaps = !1;
        const p = this;
        function g() {
            p.needsUpdate = !0,
            e.requestVideoFrameCallback(g)
        }
        "requestVideoFrameCallback"in e && e.requestVideoFrameCallback(g)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class Curve {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(e, t) {
        const r = this.getUtoTmapping(e);
        return this.getPoint(r, t)
    }
    getPoints(e=5) {
        const t = [];
        for (let r = 0; r <= e; r++)
            t.push(this.getPoint(r / e));
        return t
    }
    getSpacedPoints(e=5) {
        const t = [];
        for (let r = 0; r <= e; r++)
            t.push(this.getPointAt(r / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let r, n = this.getPoint(0), o = 0;
        t.push(0);
        for (let l = 1; l <= e; l++)
            r = this.getPoint(l / e),
            o += r.distanceTo(n),
            t.push(o),
            n = r;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t) {
        const r = this.getLengths();
        let n = 0;
        const o = r.length;
        let l;
        t ? l = t : l = e * r[o - 1];
        let c = 0, u = o - 1, f;
        for (; c <= u; )
            if (n = Math.floor(c + (u - c) / 2),
            f = r[n] - l,
            f < 0)
                c = n + 1;
            else if (f > 0)
                u = n - 1;
            else {
                u = n;
                break
            }
        if (n = u,
        r[n] === l)
            return n / (o - 1);
        const p = r[n]
          , v = r[n + 1] - p
          , _ = (l - p) / v;
        return (n + _) / (o - 1)
    }
    getTangent(e, t) {
        let n = e - 1e-4
          , o = e + 1e-4;
        n < 0 && (n = 0),
        o > 1 && (o = 1);
        const l = this.getPoint(n)
          , c = this.getPoint(o)
          , u = t || (l.isVector2 ? new Vector2 : new Vector3);
        return u.copy(c).sub(l).normalize(),
        u
    }
    getTangentAt(e, t) {
        const r = this.getUtoTmapping(e);
        return this.getTangent(r, t)
    }
    computeFrenetFrames(e, t) {
        const r = new Vector3
          , n = []
          , o = []
          , l = []
          , c = new Vector3
          , u = new Matrix4;
        for (let _ = 0; _ <= e; _++) {
            const w = _ / e;
            n[_] = this.getTangentAt(w, new Vector3)
        }
        o[0] = new Vector3,
        l[0] = new Vector3;
        let f = Number.MAX_VALUE;
        const p = Math.abs(n[0].x)
          , g = Math.abs(n[0].y)
          , v = Math.abs(n[0].z);
        p <= f && (f = p,
        r.set(1, 0, 0)),
        g <= f && (f = g,
        r.set(0, 1, 0)),
        v <= f && r.set(0, 0, 1),
        c.crossVectors(n[0], r).normalize(),
        o[0].crossVectors(n[0], c),
        l[0].crossVectors(n[0], o[0]);
        for (let _ = 1; _ <= e; _++) {
            if (o[_] = o[_ - 1].clone(),
            l[_] = l[_ - 1].clone(),
            c.crossVectors(n[_ - 1], n[_]),
            c.length() > Number.EPSILON) {
                c.normalize();
                const w = Math.acos(clamp$1(n[_ - 1].dot(n[_]), -1, 1));
                o[_].applyMatrix4(u.makeRotationAxis(c, w))
            }
            l[_].crossVectors(n[_], o[_])
        }
        if (t === !0) {
            let _ = Math.acos(clamp$1(o[0].dot(o[e]), -1, 1));
            _ /= e,
            n[0].dot(c.crossVectors(o[0], o[e])) > 0 && (_ = -_);
            for (let w = 1; w <= e; w++)
                o[w].applyMatrix4(u.makeRotationAxis(n[w], _ * w)),
                l[w].crossVectors(n[w], o[w])
        }
        return {
            tangents: n,
            normals: o,
            binormals: l
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class EllipseCurve extends Curve {
    constructor(e=0, t=0, r=1, n=1, o=0, l=Math.PI * 2, c=!1, u=0) {
        super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = r,
        this.yRadius = n,
        this.aStartAngle = o,
        this.aEndAngle = l,
        this.aClockwise = c,
        this.aRotation = u
    }
    getPoint(e, t) {
        const r = t || new Vector2
          , n = Math.PI * 2;
        let o = this.aEndAngle - this.aStartAngle;
        const l = Math.abs(o) < Number.EPSILON;
        for (; o < 0; )
            o += n;
        for (; o > n; )
            o -= n;
        o < Number.EPSILON && (l ? o = 0 : o = n),
        this.aClockwise === !0 && !l && (o === n ? o = -n : o = o - n);
        const c = this.aStartAngle + e * o;
        let u = this.aX + this.xRadius * Math.cos(c)
          , f = this.aY + this.yRadius * Math.sin(c);
        if (this.aRotation !== 0) {
            const p = Math.cos(this.aRotation)
              , g = Math.sin(this.aRotation)
              , v = u - this.aX
              , _ = f - this.aY;
            u = v * p - _ * g + this.aX,
            f = v * g + _ * p + this.aY
        }
        return r.set(u, f)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
class ArcCurve extends EllipseCurve {
    constructor(e, t, r, n, o, l) {
        super(e, t, r, r, n, o, l),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
}
function CubicPoly() {
    let a = 0
      , e = 0
      , t = 0
      , r = 0;
    function n(o, l, c, u) {
        a = o,
        e = c,
        t = -3 * o + 3 * l - 2 * c - u,
        r = 2 * o - 2 * l + c + u
    }
    return {
        initCatmullRom: function(o, l, c, u, f) {
            n(l, c, f * (c - o), f * (u - l))
        },
        initNonuniformCatmullRom: function(o, l, c, u, f, p, g) {
            let v = (l - o) / f - (c - o) / (f + p) + (c - l) / p
              , _ = (c - l) / p - (u - l) / (p + g) + (u - c) / g;
            v *= p,
            _ *= p,
            n(l, c, v, _)
        },
        calc: function(o) {
            const l = o * o
              , c = l * o;
            return a + e * o + t * l + r * c
        }
    }
}
const tmp = new Vector3
  , px = new CubicPoly
  , py = new CubicPoly
  , pz = new CubicPoly;
class CatmullRomCurve3 extends Curve {
    constructor(e=[], t=!1, r="centripetal", n=.5) {
        super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = r,
        this.tension = n
    }
    getPoint(e, t=new Vector3) {
        const r = t
          , n = this.points
          , o = n.length
          , l = (o - (this.closed ? 0 : 1)) * e;
        let c = Math.floor(l)
          , u = l - c;
        this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / o) + 1) * o : u === 0 && c === o - 1 && (c = o - 2,
        u = 1);
        let f, p;
        this.closed || c > 0 ? f = n[(c - 1) % o] : (tmp.subVectors(n[0], n[1]).add(n[0]),
        f = tmp);
        const g = n[c % o]
          , v = n[(c + 1) % o];
        if (this.closed || c + 2 < o ? p = n[(c + 2) % o] : (tmp.subVectors(n[o - 1], n[o - 2]).add(n[o - 1]),
        p = tmp),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            const _ = this.curveType === "chordal" ? .5 : .25;
            let w = Math.pow(f.distanceToSquared(g), _)
              , S = Math.pow(g.distanceToSquared(v), _)
              , b = Math.pow(v.distanceToSquared(p), _);
            S < 1e-4 && (S = 1),
            w < 1e-4 && (w = S),
            b < 1e-4 && (b = S),
            px.initNonuniformCatmullRom(f.x, g.x, v.x, p.x, w, S, b),
            py.initNonuniformCatmullRom(f.y, g.y, v.y, p.y, w, S, b),
            pz.initNonuniformCatmullRom(f.z, g.z, v.z, p.z, w, S, b)
        } else
            this.curveType === "catmullrom" && (px.initCatmullRom(f.x, g.x, v.x, p.x, this.tension),
            py.initCatmullRom(f.y, g.y, v.y, p.y, this.tension),
            pz.initCatmullRom(f.z, g.z, v.z, p.z, this.tension));
        return r.set(px.calc(u), py.calc(u), pz.calc(u)),
        r
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, r = e.points.length; t < r; t++) {
            const n = e.points[t];
            this.points.push(n.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, r = this.points.length; t < r; t++) {
            const n = this.points[t];
            e.points.push(n.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, r = e.points.length; t < r; t++) {
            const n = e.points[t];
            this.points.push(new Vector3().fromArray(n))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
function CatmullRom(a, e, t, r, n) {
    const o = (r - e) * .5
      , l = (n - t) * .5
      , c = a * a
      , u = a * c;
    return (2 * t - 2 * r + o + l) * u + (-3 * t + 3 * r - 2 * o - l) * c + o * a + t
}
function QuadraticBezierP0(a, e) {
    const t = 1 - a;
    return t * t * e
}
function QuadraticBezierP1(a, e) {
    return 2 * (1 - a) * a * e
}
function QuadraticBezierP2(a, e) {
    return a * a * e
}
function QuadraticBezier(a, e, t, r) {
    return QuadraticBezierP0(a, e) + QuadraticBezierP1(a, t) + QuadraticBezierP2(a, r)
}
function CubicBezierP0(a, e) {
    const t = 1 - a;
    return t * t * t * e
}
function CubicBezierP1(a, e) {
    const t = 1 - a;
    return 3 * t * t * a * e
}
function CubicBezierP2(a, e) {
    return 3 * (1 - a) * a * a * e
}
function CubicBezierP3(a, e) {
    return a * a * a * e
}
function CubicBezier(a, e, t, r, n) {
    return CubicBezierP0(a, e) + CubicBezierP1(a, t) + CubicBezierP2(a, r) + CubicBezierP3(a, n)
}
class CubicBezierCurve extends Curve {
    constructor(e=new Vector2, t=new Vector2, r=new Vector2, n=new Vector2) {
        super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = r,
        this.v3 = n
    }
    getPoint(e, t=new Vector2) {
        const r = t
          , n = this.v0
          , o = this.v1
          , l = this.v2
          , c = this.v3;
        return r.set(CubicBezier(e, n.x, o.x, l.x, c.x), CubicBezier(e, n.y, o.y, l.y, c.y)),
        r
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class CubicBezierCurve3 extends Curve {
    constructor(e=new Vector3, t=new Vector3, r=new Vector3, n=new Vector3) {
        super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = r,
        this.v3 = n
    }
    getPoint(e, t=new Vector3) {
        const r = t
          , n = this.v0
          , o = this.v1
          , l = this.v2
          , c = this.v3;
        return r.set(CubicBezier(e, n.x, o.x, l.x, c.x), CubicBezier(e, n.y, o.y, l.y, c.y), CubicBezier(e, n.z, o.z, l.z, c.z)),
        r
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class LineCurve extends Curve {
    constructor(e=new Vector2, t=new Vector2) {
        super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new Vector2) {
        const r = t;
        return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1),
        r.multiplyScalar(e).add(this.v1)),
        r
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t) {
        const r = t || new Vector2;
        return r.copy(this.v2).sub(this.v1).normalize(),
        r
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class LineCurve3 extends Curve {
    constructor(e=new Vector3, t=new Vector3) {
        super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new Vector3) {
        const r = t;
        return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1),
        r.multiplyScalar(e).add(this.v1)),
        r
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class QuadraticBezierCurve extends Curve {
    constructor(e=new Vector2, t=new Vector2, r=new Vector2) {
        super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = r
    }
    getPoint(e, t=new Vector2) {
        const r = t
          , n = this.v0
          , o = this.v1
          , l = this.v2;
        return r.set(QuadraticBezier(e, n.x, o.x, l.x), QuadraticBezier(e, n.y, o.y, l.y)),
        r
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class QuadraticBezierCurve3 extends Curve {
    constructor(e=new Vector3, t=new Vector3, r=new Vector3) {
        super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = r
    }
    getPoint(e, t=new Vector3) {
        const r = t
          , n = this.v0
          , o = this.v1
          , l = this.v2;
        return r.set(QuadraticBezier(e, n.x, o.x, l.x), QuadraticBezier(e, n.y, o.y, l.y), QuadraticBezier(e, n.z, o.z, l.z)),
        r
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class SplineCurve extends Curve {
    constructor(e=[]) {
        super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, t=new Vector2) {
        const r = t
          , n = this.points
          , o = (n.length - 1) * e
          , l = Math.floor(o)
          , c = o - l
          , u = n[l === 0 ? l : l - 1]
          , f = n[l]
          , p = n[l > n.length - 2 ? n.length - 1 : l + 1]
          , g = n[l > n.length - 3 ? n.length - 1 : l + 2];
        return r.set(CatmullRom(c, u.x, f.x, p.x, g.x), CatmullRom(c, u.y, f.y, p.y, g.y)),
        r
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, r = e.points.length; t < r; t++) {
            const n = e.points[t];
            this.points.push(n.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, r = this.points.length; t < r; t++) {
            const n = this.points[t];
            e.points.push(n.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, r = e.points.length; t < r; t++) {
            const n = e.points[t];
            this.points.push(new Vector2().fromArray(n))
        }
        return this
    }
}
var Curves = Object.freeze({
    __proto__: null,
    ArcCurve,
    CatmullRomCurve3,
    CubicBezierCurve,
    CubicBezierCurve3,
    EllipseCurve,
    LineCurve,
    LineCurve3,
    QuadraticBezierCurve,
    QuadraticBezierCurve3,
    SplineCurve
});
class CurvePath extends Curve {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0)
          , t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new LineCurve(t,e))
    }
    getPoint(e, t) {
        const r = e * this.getLength()
          , n = this.getCurveLengths();
        let o = 0;
        for (; o < n.length; ) {
            if (n[o] >= r) {
                const l = n[o] - r
                  , c = this.curves[o]
                  , u = c.getLength()
                  , f = u === 0 ? 0 : 1 - l / u;
                return c.getPointAt(f, t)
            }
            o++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let r = 0, n = this.curves.length; r < n; r++)
            t += this.curves[r].getLength(),
            e.push(t);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        const t = [];
        for (let r = 0; r <= e; r++)
            t.push(this.getPoint(r / e));
        return this.autoClose && t.push(t[0]),
        t
    }
    getPoints(e=12) {
        const t = [];
        let r;
        for (let n = 0, o = this.curves; n < o.length; n++) {
            const l = o[n]
              , c = l.isEllipseCurve ? e * 2 : l.isLineCurve || l.isLineCurve3 ? 1 : l.isSplineCurve ? e * l.points.length : e
              , u = l.getPoints(c);
            for (let f = 0; f < u.length; f++) {
                const p = u[f];
                r && r.equals(p) || (t.push(p),
                r = p)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
        t
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let t = 0, r = e.curves.length; t < r; t++) {
            const n = e.curves[t];
            this.curves.push(n.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let t = 0, r = this.curves.length; t < r; t++) {
            const n = this.curves[t];
            e.curves.push(n.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let t = 0, r = e.curves.length; t < r; t++) {
            const n = e.curves[t];
            this.curves.push(new Curves[n.type]().fromJSON(n))
        }
        return this
    }
}
class Path extends CurvePath {
    constructor(e) {
        super(),
        this.type = "Path",
        this.currentPoint = new Vector2,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, r = e.length; t < r; t++)
            this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t),
        this
    }
    lineTo(e, t) {
        const r = new LineCurve(this.currentPoint.clone(),new Vector2(e,t));
        return this.curves.push(r),
        this.currentPoint.set(e, t),
        this
    }
    quadraticCurveTo(e, t, r, n) {
        const o = new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(e,t),new Vector2(r,n));
        return this.curves.push(o),
        this.currentPoint.set(r, n),
        this
    }
    bezierCurveTo(e, t, r, n, o, l) {
        const c = new CubicBezierCurve(this.currentPoint.clone(),new Vector2(e,t),new Vector2(r,n),new Vector2(o,l));
        return this.curves.push(c),
        this.currentPoint.set(o, l),
        this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e)
          , r = new SplineCurve(t);
        return this.curves.push(r),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, t, r, n, o, l) {
        const c = this.currentPoint.x
          , u = this.currentPoint.y;
        return this.absarc(e + c, t + u, r, n, o, l),
        this
    }
    absarc(e, t, r, n, o, l) {
        return this.absellipse(e, t, r, r, n, o, l),
        this
    }
    ellipse(e, t, r, n, o, l, c, u) {
        const f = this.currentPoint.x
          , p = this.currentPoint.y;
        return this.absellipse(e + f, t + p, r, n, o, l, c, u),
        this
    }
    absellipse(e, t, r, n, o, l, c, u) {
        const f = new EllipseCurve(e,t,r,n,o,l,c,u);
        if (this.curves.length > 0) {
            const g = f.getPoint(0);
            g.equals(this.currentPoint) || this.lineTo(g.x, g.y)
        }
        this.curves.push(f);
        const p = f.getPoint(1);
        return this.currentPoint.copy(p),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
class CircleGeometry extends BufferGeometry {
    constructor(e=1, t=32, r=0, n=Math.PI * 2) {
        super(),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: r,
            thetaLength: n
        },
        t = Math.max(3, t);
        const o = []
          , l = []
          , c = []
          , u = []
          , f = new Vector3
          , p = new Vector2;
        l.push(0, 0, 0),
        c.push(0, 0, 1),
        u.push(.5, .5);
        for (let g = 0, v = 3; g <= t; g++,
        v += 3) {
            const _ = r + g / t * n;
            f.x = e * Math.cos(_),
            f.y = e * Math.sin(_),
            l.push(f.x, f.y, f.z),
            c.push(0, 0, 1),
            p.x = (l[v] / e + 1) / 2,
            p.y = (l[v + 1] / e + 1) / 2,
            u.push(p.x, p.y)
        }
        for (let g = 1; g <= t; g++)
            o.push(g, g + 1, 0);
        this.setIndex(o),
        this.setAttribute("position", new Float32BufferAttribute(l,3)),
        this.setAttribute("normal", new Float32BufferAttribute(c,3)),
        this.setAttribute("uv", new Float32BufferAttribute(u,2))
    }
    static fromJSON(e) {
        return new CircleGeometry(e.radius,e.segments,e.thetaStart,e.thetaLength)
    }
}
class Shape extends Path {
    constructor(e) {
        super(e),
        this.uuid = generateUUID(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let r = 0, n = this.holes.length; r < n; r++)
            t[r] = this.holes[r].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let t = 0, r = e.holes.length; t < r; t++) {
            const n = e.holes[t];
            this.holes.push(n.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let t = 0, r = this.holes.length; t < r; t++) {
            const n = this.holes[t];
            e.holes.push(n.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let t = 0, r = e.holes.length; t < r; t++) {
            const n = e.holes[t];
            this.holes.push(new Path().fromJSON(n))
        }
        return this
    }
}
const Earcut = {
    triangulate: function(a, e, t=2) {
        const r = e && e.length
          , n = r ? e[0] * t : a.length;
        let o = linkedList(a, 0, n, t, !0);
        const l = [];
        if (!o || o.next === o.prev)
            return l;
        let c, u, f, p, g, v, _;
        if (r && (o = eliminateHoles(a, e, o, t)),
        a.length > 80 * t) {
            c = f = a[0],
            u = p = a[1];
            for (let w = t; w < n; w += t)
                g = a[w],
                v = a[w + 1],
                g < c && (c = g),
                v < u && (u = v),
                g > f && (f = g),
                v > p && (p = v);
            _ = Math.max(f - c, p - u),
            _ = _ !== 0 ? 32767 / _ : 0
        }
        return earcutLinked(o, l, t, c, u, _, 0),
        l
    }
};
function linkedList(a, e, t, r, n) {
    let o, l;
    if (n === signedArea(a, e, t, r) > 0)
        for (o = e; o < t; o += r)
            l = insertNode(o, a[o], a[o + 1], l);
    else
        for (o = t - r; o >= e; o -= r)
            l = insertNode(o, a[o], a[o + 1], l);
    return l && equals(l, l.next) && (removeNode(l),
    l = l.next),
    l
}
function filterPoints(a, e) {
    if (!a)
        return a;
    e || (e = a);
    let t = a, r;
    do
        if (r = !1,
        !t.steiner && (equals(t, t.next) || area(t.prev, t, t.next) === 0)) {
            if (removeNode(t),
            t = e = t.prev,
            t === t.next)
                break;
            r = !0
        } else
            t = t.next;
    while (r || t !== e);
    return e
}
function earcutLinked(a, e, t, r, n, o, l) {
    if (!a)
        return;
    !l && o && indexCurve(a, r, n, o);
    let c = a, u, f;
    for (; a.prev !== a.next; ) {
        if (u = a.prev,
        f = a.next,
        o ? isEarHashed(a, r, n, o) : isEar(a)) {
            e.push(u.i / t | 0),
            e.push(a.i / t | 0),
            e.push(f.i / t | 0),
            removeNode(a),
            a = f.next,
            c = f.next;
            continue
        }
        if (a = f,
        a === c) {
            l ? l === 1 ? (a = cureLocalIntersections(filterPoints(a), e, t),
            earcutLinked(a, e, t, r, n, o, 2)) : l === 2 && splitEarcut(a, e, t, r, n, o) : earcutLinked(filterPoints(a), e, t, r, n, o, 1);
            break
        }
    }
}
function isEar(a) {
    const e = a.prev
      , t = a
      , r = a.next;
    if (area(e, t, r) >= 0)
        return !1;
    const n = e.x
      , o = t.x
      , l = r.x
      , c = e.y
      , u = t.y
      , f = r.y
      , p = n < o ? n < l ? n : l : o < l ? o : l
      , g = c < u ? c < f ? c : f : u < f ? u : f
      , v = n > o ? n > l ? n : l : o > l ? o : l
      , _ = c > u ? c > f ? c : f : u > f ? u : f;
    let w = r.next;
    for (; w !== e; ) {
        if (w.x >= p && w.x <= v && w.y >= g && w.y <= _ && pointInTriangle(n, c, o, u, l, f, w.x, w.y) && area(w.prev, w, w.next) >= 0)
            return !1;
        w = w.next
    }
    return !0
}
function isEarHashed(a, e, t, r) {
    const n = a.prev
      , o = a
      , l = a.next;
    if (area(n, o, l) >= 0)
        return !1;
    const c = n.x
      , u = o.x
      , f = l.x
      , p = n.y
      , g = o.y
      , v = l.y
      , _ = c < u ? c < f ? c : f : u < f ? u : f
      , w = p < g ? p < v ? p : v : g < v ? g : v
      , S = c > u ? c > f ? c : f : u > f ? u : f
      , b = p > g ? p > v ? p : v : g > v ? g : v
      , C = zOrder(_, w, e, t, r)
      , R = zOrder(S, b, e, t, r);
    let T = a.prevZ
      , M = a.nextZ;
    for (; T && T.z >= C && M && M.z <= R; ) {
        if (T.x >= _ && T.x <= S && T.y >= w && T.y <= b && T !== n && T !== l && pointInTriangle(c, p, u, g, f, v, T.x, T.y) && area(T.prev, T, T.next) >= 0 || (T = T.prevZ,
        M.x >= _ && M.x <= S && M.y >= w && M.y <= b && M !== n && M !== l && pointInTriangle(c, p, u, g, f, v, M.x, M.y) && area(M.prev, M, M.next) >= 0))
            return !1;
        M = M.nextZ
    }
    for (; T && T.z >= C; ) {
        if (T.x >= _ && T.x <= S && T.y >= w && T.y <= b && T !== n && T !== l && pointInTriangle(c, p, u, g, f, v, T.x, T.y) && area(T.prev, T, T.next) >= 0)
            return !1;
        T = T.prevZ
    }
    for (; M && M.z <= R; ) {
        if (M.x >= _ && M.x <= S && M.y >= w && M.y <= b && M !== n && M !== l && pointInTriangle(c, p, u, g, f, v, M.x, M.y) && area(M.prev, M, M.next) >= 0)
            return !1;
        M = M.nextZ
    }
    return !0
}
function cureLocalIntersections(a, e, t) {
    let r = a;
    do {
        const n = r.prev
          , o = r.next.next;
        !equals(n, o) && intersects(n, r, r.next, o) && locallyInside(n, o) && locallyInside(o, n) && (e.push(n.i / t | 0),
        e.push(r.i / t | 0),
        e.push(o.i / t | 0),
        removeNode(r),
        removeNode(r.next),
        r = a = o),
        r = r.next
    } while (r !== a);
    return filterPoints(r)
}
function splitEarcut(a, e, t, r, n, o) {
    let l = a;
    do {
        let c = l.next.next;
        for (; c !== l.prev; ) {
            if (l.i !== c.i && isValidDiagonal(l, c)) {
                let u = splitPolygon(l, c);
                l = filterPoints(l, l.next),
                u = filterPoints(u, u.next),
                earcutLinked(l, e, t, r, n, o, 0),
                earcutLinked(u, e, t, r, n, o, 0);
                return
            }
            c = c.next
        }
        l = l.next
    } while (l !== a)
}
function eliminateHoles(a, e, t, r) {
    const n = [];
    let o, l, c, u, f;
    for (o = 0,
    l = e.length; o < l; o++)
        c = e[o] * r,
        u = o < l - 1 ? e[o + 1] * r : a.length,
        f = linkedList(a, c, u, r, !1),
        f === f.next && (f.steiner = !0),
        n.push(getLeftmost(f));
    for (n.sort(compareX),
    o = 0; o < n.length; o++)
        t = eliminateHole(n[o], t);
    return t
}
function compareX(a, e) {
    return a.x - e.x
}
function eliminateHole(a, e) {
    const t = findHoleBridge(a, e);
    if (!t)
        return e;
    const r = splitPolygon(t, a);
    return filterPoints(r, r.next),
    filterPoints(t, t.next)
}
function findHoleBridge(a, e) {
    let t = e, r = -1 / 0, n;
    const o = a.x
      , l = a.y;
    do {
        if (l <= t.y && l >= t.next.y && t.next.y !== t.y) {
            const v = t.x + (l - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (v <= o && v > r && (r = v,
            n = t.x < t.next.x ? t : t.next,
            v === o))
                return n
        }
        t = t.next
    } while (t !== e);
    if (!n)
        return null;
    const c = n
      , u = n.x
      , f = n.y;
    let p = 1 / 0, g;
    t = n;
    do
        o >= t.x && t.x >= u && o !== t.x && pointInTriangle(l < f ? o : r, l, u, f, l < f ? r : o, l, t.x, t.y) && (g = Math.abs(l - t.y) / (o - t.x),
        locallyInside(t, a) && (g < p || g === p && (t.x > n.x || t.x === n.x && sectorContainsSector(n, t))) && (n = t,
        p = g)),
        t = t.next;
    while (t !== c);
    return n
}
function sectorContainsSector(a, e) {
    return area(a.prev, a, e.prev) < 0 && area(e.next, a, a.next) < 0
}
function indexCurve(a, e, t, r) {
    let n = a;
    do
        n.z === 0 && (n.z = zOrder(n.x, n.y, e, t, r)),
        n.prevZ = n.prev,
        n.nextZ = n.next,
        n = n.next;
    while (n !== a);
    n.prevZ.nextZ = null,
    n.prevZ = null,
    sortLinked(n)
}
function sortLinked(a) {
    let e, t, r, n, o, l, c, u, f = 1;
    do {
        for (t = a,
        a = null,
        o = null,
        l = 0; t; ) {
            for (l++,
            r = t,
            c = 0,
            e = 0; e < f && (c++,
            r = r.nextZ,
            !!r); e++)
                ;
            for (u = f; c > 0 || u > 0 && r; )
                c !== 0 && (u === 0 || !r || t.z <= r.z) ? (n = t,
                t = t.nextZ,
                c--) : (n = r,
                r = r.nextZ,
                u--),
                o ? o.nextZ = n : a = n,
                n.prevZ = o,
                o = n;
            t = r
        }
        o.nextZ = null,
        f *= 2
    } while (l > 1);
    return a
}
function zOrder(a, e, t, r, n) {
    return a = (a - t) * n | 0,
    e = (e - r) * n | 0,
    a = (a | a << 8) & 16711935,
    a = (a | a << 4) & 252645135,
    a = (a | a << 2) & 858993459,
    a = (a | a << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    a | e << 1
}
function getLeftmost(a) {
    let e = a
      , t = a;
    do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
        e = e.next;
    while (e !== a);
    return t
}
function pointInTriangle(a, e, t, r, n, o, l, c) {
    return (n - l) * (e - c) >= (a - l) * (o - c) && (a - l) * (r - c) >= (t - l) * (e - c) && (t - l) * (o - c) >= (n - l) * (r - c)
}
function isValidDiagonal(a, e) {
    return a.next.i !== e.i && a.prev.i !== e.i && !intersectsPolygon(a, e) && (locallyInside(a, e) && locallyInside(e, a) && middleInside(a, e) && (area(a.prev, a, e.prev) || area(a, e.prev, e)) || equals(a, e) && area(a.prev, a, a.next) > 0 && area(e.prev, e, e.next) > 0)
}
function area(a, e, t) {
    return (e.y - a.y) * (t.x - e.x) - (e.x - a.x) * (t.y - e.y)
}
function equals(a, e) {
    return a.x === e.x && a.y === e.y
}
function intersects(a, e, t, r) {
    const n = sign(area(a, e, t))
      , o = sign(area(a, e, r))
      , l = sign(area(t, r, a))
      , c = sign(area(t, r, e));
    return !!(n !== o && l !== c || n === 0 && onSegment(a, t, e) || o === 0 && onSegment(a, r, e) || l === 0 && onSegment(t, a, r) || c === 0 && onSegment(t, e, r))
}
function onSegment(a, e, t) {
    return e.x <= Math.max(a.x, t.x) && e.x >= Math.min(a.x, t.x) && e.y <= Math.max(a.y, t.y) && e.y >= Math.min(a.y, t.y)
}
function sign(a) {
    return a > 0 ? 1 : a < 0 ? -1 : 0
}
function intersectsPolygon(a, e) {
    let t = a;
    do {
        if (t.i !== a.i && t.next.i !== a.i && t.i !== e.i && t.next.i !== e.i && intersects(t, t.next, a, e))
            return !0;
        t = t.next
    } while (t !== a);
    return !1
}
function locallyInside(a, e) {
    return area(a.prev, a, a.next) < 0 ? area(a, e, a.next) >= 0 && area(a, a.prev, e) >= 0 : area(a, e, a.prev) < 0 || area(a, a.next, e) < 0
}
function middleInside(a, e) {
    let t = a
      , r = !1;
    const n = (a.x + e.x) / 2
      , o = (a.y + e.y) / 2;
    do
        t.y > o != t.next.y > o && t.next.y !== t.y && n < (t.next.x - t.x) * (o - t.y) / (t.next.y - t.y) + t.x && (r = !r),
        t = t.next;
    while (t !== a);
    return r
}
function splitPolygon(a, e) {
    const t = new Node(a.i,a.x,a.y)
      , r = new Node(e.i,e.x,e.y)
      , n = a.next
      , o = e.prev;
    return a.next = e,
    e.prev = a,
    t.next = n,
    n.prev = t,
    r.next = t,
    t.prev = r,
    o.next = r,
    r.prev = o,
    r
}
function insertNode(a, e, t, r) {
    const n = new Node(a,e,t);
    return r ? (n.next = r.next,
    n.prev = r,
    r.next.prev = n,
    r.next = n) : (n.prev = n,
    n.next = n),
    n
}
function removeNode(a) {
    a.next.prev = a.prev,
    a.prev.next = a.next,
    a.prevZ && (a.prevZ.nextZ = a.nextZ),
    a.nextZ && (a.nextZ.prevZ = a.prevZ)
}
function Node(a, e, t) {
    this.i = a,
    this.x = e,
    this.y = t,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function signedArea(a, e, t, r) {
    let n = 0;
    for (let o = e, l = t - r; o < t; o += r)
        n += (a[l] - a[o]) * (a[o + 1] + a[l + 1]),
        l = o;
    return n
}
class ShapeUtils {
    static area(e) {
        const t = e.length;
        let r = 0;
        for (let n = t - 1, o = 0; o < t; n = o++)
            r += e[n].x * e[o].y - e[o].x * e[n].y;
        return r * .5
    }
    static isClockWise(e) {
        return ShapeUtils.area(e) < 0
    }
    static triangulateShape(e, t) {
        const r = []
          , n = []
          , o = [];
        removeDupEndPts(e),
        addContour(r, e);
        let l = e.length;
        t.forEach(removeDupEndPts);
        for (let u = 0; u < t.length; u++)
            n.push(l),
            l += t[u].length,
            addContour(r, t[u]);
        const c = Earcut.triangulate(r, n);
        for (let u = 0; u < c.length; u += 3)
            o.push(c.slice(u, u + 3));
        return o
    }
}
function removeDupEndPts(a) {
    const e = a.length;
    e > 2 && a[e - 1].equals(a[0]) && a.pop()
}
function addContour(a, e) {
    for (let t = 0; t < e.length; t++)
        a.push(e[t].x),
        a.push(e[t].y)
}
class ShapeGeometry extends BufferGeometry {
    constructor(e=new Shape([new Vector2(0,.5), new Vector2(-.5,-.5), new Vector2(.5,-.5)]), t=12) {
        super(),
        this.type = "ShapeGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        };
        const r = []
          , n = []
          , o = []
          , l = [];
        let c = 0
          , u = 0;
        if (Array.isArray(e) === !1)
            f(e);
        else
            for (let p = 0; p < e.length; p++)
                f(e[p]),
                this.addGroup(c, u, p),
                c += u,
                u = 0;
        this.setIndex(r),
        this.setAttribute("position", new Float32BufferAttribute(n,3)),
        this.setAttribute("normal", new Float32BufferAttribute(o,3)),
        this.setAttribute("uv", new Float32BufferAttribute(l,2));
        function f(p) {
            const g = n.length / 3
              , v = p.extractPoints(t);
            let _ = v.shape;
            const w = v.holes;
            ShapeUtils.isClockWise(_) === !1 && (_ = _.reverse());
            for (let b = 0, C = w.length; b < C; b++) {
                const R = w[b];
                ShapeUtils.isClockWise(R) === !0 && (w[b] = R.reverse())
            }
            const S = ShapeUtils.triangulateShape(_, w);
            for (let b = 0, C = w.length; b < C; b++) {
                const R = w[b];
                _ = _.concat(R)
            }
            for (let b = 0, C = _.length; b < C; b++) {
                const R = _[b];
                n.push(R.x, R.y, 0),
                o.push(0, 0, 1),
                l.push(R.x, R.y)
            }
            for (let b = 0, C = S.length; b < C; b++) {
                const R = S[b]
                  , T = R[0] + g
                  , M = R[1] + g
                  , P = R[2] + g;
                r.push(T, M, P),
                u += 3
            }
        }
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes;
        return toJSON(t, e)
    }
    static fromJSON(e, t) {
        const r = [];
        for (let n = 0, o = e.shapes.length; n < o; n++) {
            const l = t[e.shapes[n]];
            r.push(l)
        }
        return new ShapeGeometry(r,e.curveSegments)
    }
}
function toJSON(a, e) {
    if (e.shapes = [],
    Array.isArray(a))
        for (let t = 0, r = a.length; t < r; t++) {
            const n = a[t];
            e.shapes.push(n.uuid)
        }
    else
        e.shapes.push(a.uuid);
    return e
}
class SphereGeometry extends BufferGeometry {
    constructor(e=1, t=32, r=16, n=0, o=Math.PI * 2, l=0, c=Math.PI) {
        super(),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: r,
            phiStart: n,
            phiLength: o,
            thetaStart: l,
            thetaLength: c
        },
        t = Math.max(3, Math.floor(t)),
        r = Math.max(2, Math.floor(r));
        const u = Math.min(l + c, Math.PI);
        let f = 0;
        const p = []
          , g = new Vector3
          , v = new Vector3
          , _ = []
          , w = []
          , S = []
          , b = [];
        for (let C = 0; C <= r; C++) {
            const R = []
              , T = C / r;
            let M = 0;
            C == 0 && l == 0 ? M = .5 / t : C == r && u == Math.PI && (M = -.5 / t);
            for (let P = 0; P <= t; P++) {
                const I = P / t;
                g.x = -e * Math.cos(n + I * o) * Math.sin(l + T * c),
                g.y = e * Math.cos(l + T * c),
                g.z = e * Math.sin(n + I * o) * Math.sin(l + T * c),
                w.push(g.x, g.y, g.z),
                v.copy(g).normalize(),
                S.push(v.x, v.y, v.z),
                b.push(I + M, 1 - T),
                R.push(f++)
            }
            p.push(R)
        }
        for (let C = 0; C < r; C++)
            for (let R = 0; R < t; R++) {
                const T = p[C][R + 1]
                  , M = p[C][R]
                  , P = p[C + 1][R]
                  , I = p[C + 1][R + 1];
                (C !== 0 || l > 0) && _.push(T, M, I),
                (C !== r - 1 || u < Math.PI) && _.push(M, P, I)
            }
        this.setIndex(_),
        this.setAttribute("position", new Float32BufferAttribute(w,3)),
        this.setAttribute("normal", new Float32BufferAttribute(S,3)),
        this.setAttribute("uv", new Float32BufferAttribute(b,2))
    }
    static fromJSON(e) {
        return new SphereGeometry(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
    }
}
class RawShaderMaterial extends ShaderMaterial {
    constructor(e) {
        super(e),
        this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"
    }
}
class MeshNormalMaterial extends Material {
    constructor(e) {
        super(),
        this.isMeshNormalMaterial = !0,
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = TangentSpaceNormalMap,
        this.normalScale = new Vector2(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.flatShading = e.flatShading,
        this
    }
}
const Cache = {
    enabled: !1,
    files: {},
    add: function(a, e) {
        this.enabled !== !1 && (this.files[a] = e)
    },
    get: function(a) {
        if (this.enabled !== !1)
            return this.files[a]
    },
    remove: function(a) {
        delete this.files[a]
    },
    clear: function() {
        this.files = {}
    }
};
class LoadingManager {
    constructor(e, t, r) {
        const n = this;
        let o = !1, l = 0, c = 0, u;
        const f = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = r,
        this.itemStart = function(p) {
            c++,
            o === !1 && n.onStart !== void 0 && n.onStart(p, l, c),
            o = !0
        }
        ,
        this.itemEnd = function(p) {
            l++,
            n.onProgress !== void 0 && n.onProgress(p, l, c),
            l === c && (o = !1,
            n.onLoad !== void 0 && n.onLoad())
        }
        ,
        this.itemError = function(p) {
            n.onError !== void 0 && n.onError(p)
        }
        ,
        this.resolveURL = function(p) {
            return u ? u(p) : p
        }
        ,
        this.setURLModifier = function(p) {
            return u = p,
            this
        }
        ,
        this.addHandler = function(p, g) {
            return f.push(p, g),
            this
        }
        ,
        this.removeHandler = function(p) {
            const g = f.indexOf(p);
            return g !== -1 && f.splice(g, 2),
            this
        }
        ,
        this.getHandler = function(p) {
            for (let g = 0, v = f.length; g < v; g += 2) {
                const _ = f[g]
                  , w = f[g + 1];
                if (_.global && (_.lastIndex = 0),
                _.test(p))
                    return w
            }
            return null
        }
    }
}
const DefaultLoadingManager = new LoadingManager;
class Loader {
    constructor(e) {
        this.manager = e !== void 0 ? e : DefaultLoadingManager,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const r = this;
        return new Promise(function(n, o) {
            r.load(e, n, t, o)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
const loading = {};
class HttpError extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class FileLoader extends Loader {
    constructor(e) {
        super(e)
    }
    load(e, t, r, n) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const o = Cache.get(e);
        if (o !== void 0)
            return this.manager.itemStart(e),
            setTimeout( () => {
                t && t(o),
                this.manager.itemEnd(e)
            }
            , 0),
            o;
        if (loading[e] !== void 0) {
            loading[e].push({
                onLoad: t,
                onProgress: r,
                onError: n
            });
            return
        }
        loading[e] = [],
        loading[e].push({
            onLoad: t,
            onProgress: r,
            onError: n
        });
        const l = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , c = this.mimeType
          , u = this.responseType;
        fetch(l).then(f => {
            if (f.status === 200 || f.status === 0) {
                if (f.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || f.body === void 0 || f.body.getReader === void 0)
                    return f;
                const p = loading[e]
                  , g = f.body.getReader()
                  , v = f.headers.get("Content-Length") || f.headers.get("X-File-Size")
                  , _ = v ? parseInt(v) : 0
                  , w = _ !== 0;
                let S = 0;
                const b = new ReadableStream({
                    start(C) {
                        R();
                        function R() {
                            g.read().then( ({done: T, value: M}) => {
                                if (T)
                                    C.close();
                                else {
                                    S += M.byteLength;
                                    const P = new ProgressEvent("progress",{
                                        lengthComputable: w,
                                        loaded: S,
                                        total: _
                                    });
                                    for (let I = 0, k = p.length; I < k; I++) {
                                        const A = p[I];
                                        A.onProgress && A.onProgress(P)
                                    }
                                    C.enqueue(M),
                                    R()
                                }
                            }
                            )
                        }
                    }
                });
                return new Response(b)
            } else
                throw new HttpError(`fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`,f)
        }
        ).then(f => {
            switch (u) {
            case "arraybuffer":
                return f.arrayBuffer();
            case "blob":
                return f.blob();
            case "document":
                return f.text().then(p => new DOMParser().parseFromString(p, c));
            case "json":
                return f.json();
            default:
                if (c === void 0)
                    return f.text();
                {
                    const g = /charset="?([^;"\s]*)"?/i.exec(c)
                      , v = g && g[1] ? g[1].toLowerCase() : void 0
                      , _ = new TextDecoder(v);
                    return f.arrayBuffer().then(w => _.decode(w))
                }
            }
        }
        ).then(f => {
            Cache.add(e, f);
            const p = loading[e];
            delete loading[e];
            for (let g = 0, v = p.length; g < v; g++) {
                const _ = p[g];
                _.onLoad && _.onLoad(f)
            }
        }
        ).catch(f => {
            const p = loading[e];
            if (p === void 0)
                throw this.manager.itemError(e),
                f;
            delete loading[e];
            for (let g = 0, v = p.length; g < v; g++) {
                const _ = p[g];
                _.onError && _.onError(f)
            }
            this.manager.itemError(e)
        }
        ).finally( () => {
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class DataTextureLoader extends Loader {
    constructor(e) {
        super(e)
    }
    load(e, t, r, n) {
        const o = this
          , l = new DataTexture
          , c = new FileLoader(this.manager);
        return c.setResponseType("arraybuffer"),
        c.setRequestHeader(this.requestHeader),
        c.setPath(this.path),
        c.setWithCredentials(o.withCredentials),
        c.load(e, function(u) {
            const f = o.parse(u);
            f && (f.image !== void 0 ? l.image = f.image : f.data !== void 0 && (l.image.width = f.width,
            l.image.height = f.height,
            l.image.data = f.data),
            l.wrapS = f.wrapS !== void 0 ? f.wrapS : ClampToEdgeWrapping,
            l.wrapT = f.wrapT !== void 0 ? f.wrapT : ClampToEdgeWrapping,
            l.magFilter = f.magFilter !== void 0 ? f.magFilter : LinearFilter,
            l.minFilter = f.minFilter !== void 0 ? f.minFilter : LinearFilter,
            l.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1,
            f.encoding !== void 0 && (l.encoding = f.encoding),
            f.flipY !== void 0 && (l.flipY = f.flipY),
            f.format !== void 0 && (l.format = f.format),
            f.type !== void 0 && (l.type = f.type),
            f.mipmaps !== void 0 && (l.mipmaps = f.mipmaps,
            l.minFilter = LinearMipmapLinearFilter),
            f.mipmapCount === 1 && (l.minFilter = LinearFilter),
            f.generateMipmaps !== void 0 && (l.generateMipmaps = f.generateMipmaps),
            l.needsUpdate = !0,
            t && t(l, f))
        }, r, n),
        l
    }
}
class InstancedBufferGeometry extends BufferGeometry {
    constructor() {
        super(),
        this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e),
        this.instanceCount = e.instanceCount,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e
    }
}
let _context;
class AudioContext {
    static getContext() {
        return _context === void 0 && (_context = new (window.AudioContext || window.webkitAudioContext)),
        _context
    }
    static setContext(e) {
        _context = e
    }
}
class Clock {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = now(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const t = now();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
function now() {
    return (typeof performance > "u" ? Date : performance).now()
}
const _position$1 = new Vector3
  , _quaternion$1 = new Quaternion
  , _scale$1 = new Vector3
  , _orientation$1 = new Vector3;
class AudioListener extends Object3D {
    constructor() {
        super(),
        this.type = "AudioListener",
        this.context = AudioContext.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new Clock
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        this.filter = null),
        this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return this.filter !== null ? (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
        this.filter = e,
        this.gain.connect(this.filter),
        this.filter.connect(this.context.destination),
        this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener
          , r = this.up;
        if (this.timeDelta = this._clock.getDelta(),
        this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1),
        _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1),
        t.positionX) {
            const n = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(_position$1.x, n),
            t.positionY.linearRampToValueAtTime(_position$1.y, n),
            t.positionZ.linearRampToValueAtTime(_position$1.z, n),
            t.forwardX.linearRampToValueAtTime(_orientation$1.x, n),
            t.forwardY.linearRampToValueAtTime(_orientation$1.y, n),
            t.forwardZ.linearRampToValueAtTime(_orientation$1.z, n),
            t.upX.linearRampToValueAtTime(r.x, n),
            t.upY.linearRampToValueAtTime(r.y, n),
            t.upZ.linearRampToValueAtTime(r.z, n)
        } else
            t.setPosition(_position$1.x, _position$1.y, _position$1.z),
            t.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, r.x, r.y, r.z)
    }
}
let Audio$1 = class extends Object3D {
    constructor(e) {
        super(),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = e,
        this.connect(),
        this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource(e),
        this.connect(),
        this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource(e),
        this.connect(),
        this
    }
    setBuffer(e) {
        return this.buffer = e,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this
    }
    play(e=0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return t.buffer = this.buffer,
        t.loop = this.loop,
        t.loopStart = this.loopStart,
        t.loopEnd = this.loopEnd,
        t.onended = this.onEnded.bind(this),
        t.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = t,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1),
        this
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0,
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1,
        this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else
            this.source.connect(this.getOutput());
        return this._connected = !0,
        this
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
        } else
            this.source.disconnect(this.getOutput());
        return this._connected = !1,
        this
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []),
        this._connected === !0 ? (this.disconnect(),
        this.filters = e.slice(),
        this.connect()) : this.filters = e.slice(),
        this
    }
    setDetune(e) {
        if (this.detune = e,
        this.source.detune !== void 0)
            return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
            this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e,
        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
        this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
        !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e,
        this.isPlaying === !0 && (this.source.loop = this.loop),
        this
    }
    setLoopStart(e) {
        return this.loopStart = e,
        this
    }
    setLoopEnd(e) {
        return this.loopEnd = e,
        this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
}
;
const _position = new Vector3
  , _quaternion = new Quaternion
  , _scale = new Vector3
  , _orientation = new Vector3;
class PositionalAudio extends Audio$1 {
    constructor(e) {
        super(e),
        this.panner = this.context.createPanner(),
        this.panner.panningModel = "HRTF",
        this.panner.connect(this.gain)
    }
    disconnect() {
        super.disconnect(),
        this.panner.disconnect(this.gain)
    }
    getOutput() {
        return this.panner
    }
    getRefDistance() {
        return this.panner.refDistance
    }
    setRefDistance(e) {
        return this.panner.refDistance = e,
        this
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor
    }
    setRolloffFactor(e) {
        return this.panner.rolloffFactor = e,
        this
    }
    getDistanceModel() {
        return this.panner.distanceModel
    }
    setDistanceModel(e) {
        return this.panner.distanceModel = e,
        this
    }
    getMaxDistance() {
        return this.panner.maxDistance
    }
    setMaxDistance(e) {
        return this.panner.maxDistance = e,
        this
    }
    setDirectionalCone(e, t, r) {
        return this.panner.coneInnerAngle = e,
        this.panner.coneOuterAngle = t,
        this.panner.coneOuterGain = r,
        this
    }
    updateMatrixWorld(e) {
        if (super.updateMatrixWorld(e),
        this.hasPlaybackControl === !0 && this.isPlaying === !1)
            return;
        this.matrixWorld.decompose(_position, _quaternion, _scale),
        _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
        const t = this.panner;
        if (t.positionX) {
            const r = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(_position.x, r),
            t.positionY.linearRampToValueAtTime(_position.y, r),
            t.positionZ.linearRampToValueAtTime(_position.z, r),
            t.orientationX.linearRampToValueAtTime(_orientation.x, r),
            t.orientationY.linearRampToValueAtTime(_orientation.y, r),
            t.orientationZ.linearRampToValueAtTime(_orientation.z, r)
        } else
            t.setPosition(_position.x, _position.y, _position.z),
            t.setOrientation(_orientation.x, _orientation.y, _orientation.z)
    }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
    constructor(e, t, r=1) {
        super(e, t),
        this.isInstancedInterleavedBuffer = !0,
        this.meshPerAttribute = r
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    clone(e) {
        const t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute,
        t
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0,
        t.meshPerAttribute = this.meshPerAttribute,
        t
    }
}
class Spherical {
    constructor(e=1, t=0, r=0) {
        return this.radius = e,
        this.phi = t,
        this.theta = r,
        this
    }
    set(e, t, r) {
        return this.radius = e,
        this.phi = t,
        this.theta = r,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, r) {
        return this.radius = Math.sqrt(e * e + t * t + r * r),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, r),
        this.phi = Math.acos(clamp$1(t / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const _vector$4 = new Vector2;
class Box2 {
    constructor(e=new Vector2(1 / 0,1 / 0), t=new Vector2(-1 / 0,-1 / 0)) {
        this.isBox2 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, r = e.length; t < r; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const r = _vector$4.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(r),
        this.max.copy(e).add(r),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0,
        this.max.x = this.max.y = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return _vector$4.copy(e).clamp(this.min, this.max).sub(e).length()
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
class ShapePath {
    constructor() {
        this.type = "ShapePath",
        this.color = new Color,
        this.subPaths = [],
        this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new Path,
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t),
        this
    }
    quadraticCurveTo(e, t, r, n) {
        return this.currentPath.quadraticCurveTo(e, t, r, n),
        this
    }
    bezierCurveTo(e, t, r, n, o, l) {
        return this.currentPath.bezierCurveTo(e, t, r, n, o, l),
        this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e),
        this
    }
    toShapes(e) {
        function t(C) {
            const R = [];
            for (let T = 0, M = C.length; T < M; T++) {
                const P = C[T]
                  , I = new Shape;
                I.curves = P.curves,
                R.push(I)
            }
            return R
        }
        function r(C, R) {
            const T = R.length;
            let M = !1;
            for (let P = T - 1, I = 0; I < T; P = I++) {
                let k = R[P]
                  , A = R[I]
                  , O = A.x - k.x
                  , W = A.y - k.y;
                if (Math.abs(W) > Number.EPSILON) {
                    if (W < 0 && (k = R[I],
                    O = -O,
                    A = R[P],
                    W = -W),
                    C.y < k.y || C.y > A.y)
                        continue;
                    if (C.y === k.y) {
                        if (C.x === k.x)
                            return !0
                    } else {
                        const Q = W * (C.x - k.x) - O * (C.y - k.y);
                        if (Q === 0)
                            return !0;
                        if (Q < 0)
                            continue;
                        M = !M
                    }
                } else {
                    if (C.y !== k.y)
                        continue;
                    if (A.x <= C.x && C.x <= k.x || k.x <= C.x && C.x <= A.x)
                        return !0
                }
            }
            return M
        }
        const n = ShapeUtils.isClockWise
          , o = this.subPaths;
        if (o.length === 0)
            return [];
        let l, c, u;
        const f = [];
        if (o.length === 1)
            return c = o[0],
            u = new Shape,
            u.curves = c.curves,
            f.push(u),
            f;
        let p = !n(o[0].getPoints());
        p = e ? !p : p;
        const g = []
          , v = [];
        let _ = [], w = 0, S;
        v[w] = void 0,
        _[w] = [];
        for (let C = 0, R = o.length; C < R; C++)
            c = o[C],
            S = c.getPoints(),
            l = n(S),
            l = e ? !l : l,
            l ? (!p && v[w] && w++,
            v[w] = {
                s: new Shape,
                p: S
            },
            v[w].s.curves = c.curves,
            p && w++,
            _[w] = []) : _[w].push({
                h: c,
                p: S[0]
            });
        if (!v[0])
            return t(o);
        if (v.length > 1) {
            let C = !1
              , R = 0;
            for (let T = 0, M = v.length; T < M; T++)
                g[T] = [];
            for (let T = 0, M = v.length; T < M; T++) {
                const P = _[T];
                for (let I = 0; I < P.length; I++) {
                    const k = P[I];
                    let A = !0;
                    for (let O = 0; O < v.length; O++)
                        r(k.p, v[O].p) && (T !== O && R++,
                        A ? (A = !1,
                        g[O].push(k)) : C = !0);
                    A && g[T].push(k)
                }
            }
            R > 0 && C === !1 && (_ = g)
        }
        let b;
        for (let C = 0, R = v.length; C < R; C++) {
            u = v[C].s,
            f.push(u),
            b = _[C];
            for (let T = 0, M = b.length; T < M; T++)
                u.holes.push(b[T].h)
        }
        return f
    }
}
const _tables = _generateTables();
function _generateTables() {
    const a = new ArrayBuffer(4)
      , e = new Float32Array(a)
      , t = new Uint32Array(a)
      , r = new Uint32Array(512)
      , n = new Uint32Array(512);
    for (let u = 0; u < 256; ++u) {
        const f = u - 127;
        f < -27 ? (r[u] = 0,
        r[u | 256] = 32768,
        n[u] = 24,
        n[u | 256] = 24) : f < -14 ? (r[u] = 1024 >> -f - 14,
        r[u | 256] = 1024 >> -f - 14 | 32768,
        n[u] = -f - 1,
        n[u | 256] = -f - 1) : f <= 15 ? (r[u] = f + 15 << 10,
        r[u | 256] = f + 15 << 10 | 32768,
        n[u] = 13,
        n[u | 256] = 13) : f < 128 ? (r[u] = 31744,
        r[u | 256] = 64512,
        n[u] = 24,
        n[u | 256] = 24) : (r[u] = 31744,
        r[u | 256] = 64512,
        n[u] = 13,
        n[u | 256] = 13)
    }
    const o = new Uint32Array(2048)
      , l = new Uint32Array(64)
      , c = new Uint32Array(64);
    for (let u = 1; u < 1024; ++u) {
        let f = u << 13
          , p = 0;
        for (; !(f & 8388608); )
            f <<= 1,
            p -= 8388608;
        f &= -8388609,
        p += 947912704,
        o[u] = f | p
    }
    for (let u = 1024; u < 2048; ++u)
        o[u] = 939524096 + (u - 1024 << 13);
    for (let u = 1; u < 31; ++u)
        l[u] = u << 23;
    l[31] = 1199570944,
    l[32] = 2147483648;
    for (let u = 33; u < 63; ++u)
        l[u] = 2147483648 + (u - 32 << 23);
    l[63] = 3347054592;
    for (let u = 1; u < 64; ++u)
        u !== 32 && (c[u] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: r,
        shiftTable: n,
        mantissaTable: o,
        exponentTable: l,
        offsetTable: c
    }
}
function toHalfFloat(a) {
    Math.abs(a) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    a = clamp$1(a, -65504, 65504),
    _tables.floatView[0] = a;
    const e = _tables.uint32View[0]
      , t = e >> 23 & 511;
    return _tables.baseTable[t] + ((e & 8388607) >> _tables.shiftTable[t])
}
function fromHalfFloat(a) {
    const e = a >> 10;
    return _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[e] + (a & 1023)] + _tables.exponentTable[e],
    _tables.floatView[0]
}
var DataUtils = Object.freeze({
    __proto__: null,
    toHalfFloat,
    fromHalfFloat
});
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: REVISION
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = REVISION);
class MathUtils {
    PI = Math.PI;
    PI2 = this.PI * 2;
    HALF_PI = this.PI * .5;
    DEG2RAD = this.PI / 180;
    RAD2DEG = 180 / this.PI;
    linearStep(e, t, r) {
        return this.clamp((r - e) / (t - e), 0, 1)
    }
    step(e, t) {
        return t < e ? 0 : 1
    }
    clamp(e, t, r) {
        return e < t ? t : e > r ? r : e
    }
    mod(e, t) {
        return e - t * Math.floor(e / t)
    }
    mix(e, t, r) {
        return e + (t - e) * r
    }
    cMix(e, t, r) {
        return e + (t - e) * this.clamp(r, 0, 1)
    }
    unMix(e, t, r) {
        return (r - e) / (t - e)
    }
    cUnMix(e, t, r) {
        return this.clamp((r - e) / (t - e), 0, 1)
    }
    saturate(e) {
        return this.clamp(e, 0, 1)
    }
    fit(e, t, r, n, o, l) {
        return e = this.cUnMix(t, r, e),
        l && (e = l(e)),
        n + e * (o - n)
    }
    unClampedFit(e, t, r, n, o, l) {
        return e = this.unMix(t, r, e),
        l && (e = l(e)),
        n + e * (o - n)
    }
    lerp(e, t, r) {
        return e * (1 - r) + t * r
    }
    loop(e, t, r) {
        return e -= t,
        r -= t,
        (e < 0 ? (r - Math.abs(e) % r) % r : e % r) + t
    }
    normalize(e, t, r) {
        return Math.max(0, Math.min(1, e - t / r - t))
    }
    smoothstep(e, t, r) {
        return r = this.cUnMix(e, t, r),
        r * r * (3 - r * 2)
    }
    fract(e) {
        return e - Math.floor(e)
    }
    hash(e) {
        return this.fract(Math.sin(e) * 43758.5453123)
    }
    hash2(e, t) {
        return this.fract(Math.sin(e * 12.9898 + t * 4.1414) * 43758.5453)
    }
    sign(e) {
        return e ? e < 0 ? -1 : 1 : 0
    }
    isPowerOfTwo(e) {
        return (e & -e) === e
    }
    powerTwoCeilingBase(e) {
        return Math.ceil(Math.log(e) / Math.log(2))
    }
    powerTwoCeiling(e) {
        return this.isPowerOfTwo(e) ? e : 1 << this.powerTwoCeilingBase(e)
    }
    powerTwoFloorBase(e) {
        return Math.floor(Math.log(e) / Math.log(2))
    }
    powerTwoFloor(e) {
        return this.isPowerOfTwo(e) ? e : 1 << this.powerTwoFloorBase(e)
    }
    latLngBearing(e, t, r, n) {
        let o = Math.sin(n - t) * Math.cos(r)
          , l = Math.cos(e) * Math.sin(r) - Math.sin(e) * Math.cos(r) * Math.cos(n - t);
        return Math.atan2(o, l)
    }
    distanceTo(e, t) {
        return Math.sqrt(e * e + t * t)
    }
    distanceSqrTo(e, t) {
        return e * e + t * t
    }
    distanceTo3(e, t, r) {
        return Math.sqrt(e * e + t * t + r * r)
    }
    distanceSqrTo3(e, t, r) {
        return e * e + t * t + r * r
    }
    latLngDistance(e, t, r, n) {
        let o = Math.sin((r - e) / 2)
          , l = Math.sin((n - t) / 2)
          , c = o * o + Math.cos(e) * Math.cos(r) * l * l;
        return 2 * Math.atan2(Math.sqrt(c), Math.sqrt(1 - c))
    }
    cubicBezier(e, t, r, n, o) {
        let l = (t - e) * 3
          , c = (r - t) * 3 - l
          , u = n - e - l - c
          , f = o * o
          , p = f * o;
        return u * p + c * f + l * o + e
    }
    cubicBezierFn(e, t, r, n) {
        let o = (t - e) * 3
          , l = (r - t) * 3 - o
          , c = n - e - o - l;
        return u => {
            let f = u * u
              , p = f * u;
            return c * p + l * f + o * u + e
        }
    }
    normalizeAngle(e) {
        return e += this.PI,
        e = e < 0 ? this.PI2 - Math.abs(e % PI2) : e % this.PI2,
        e -= this.PI,
        e
    }
    closestAngleTo(e, t) {
        return e + this.normalizeAngle(t - e)
    }
    randomRange(e, t) {
        return e + Math.random() * (t - e)
    }
    randomRangeInt(e, t) {
        return Math.floor(this.randomRange(e, t + 1))
    }
    padZero(e, t) {
        return e.toString().length >= t ? e : (Math.pow(10, t) + Math.floor(e)).toString().substring(1)
    }
    lerpColor(e, t, r) {
        const n = e >> 16
          , o = e >> 8 & 255
          , l = e & 255
          , c = t >> 16
          , u = t >> 8 & 255
          , f = t & 255
          , p = n + r * (c - n)
          , g = o + r * (u - o)
          , v = l + r * (f - l);
        return (p << 16) + (g << 8) + (v | 0)
    }
    getSeedRandomFn(e) {
        let t = 1779033703
          , r = 3144134277
          , n = 1013904242
          , o = 2773480762;
        for (let l = 0, c; l < e.length; l++)
            c = e.charCodeAt(l),
            t = r ^ Math.imul(t ^ c, 597399067),
            r = n ^ Math.imul(r ^ c, 2869860233),
            n = o ^ Math.imul(n ^ c, 951274213),
            o = t ^ Math.imul(o ^ c, 2716044179);
        return _sfc32(Math.imul(n ^ t >>> 18, 597399067), Math.imul(o ^ r >>> 22, 2869860233), Math.imul(t ^ n >>> 17, 951274213), Math.imul(r ^ o >>> 19, 2716044179))
    }
}
function _sfc32(a, e, t, r) {
    return function() {
        a |= 0,
        e |= 0,
        t |= 0,
        r |= 0;
        var n = (a + e | 0) + r | 0;
        return r = r + 1 | 0,
        a = e ^ e >>> 9,
        e = t + (t << 3) | 0,
        t = t << 21 | t >>> 11,
        t = t + n | 0,
        (n >>> 0) / 4294967296
    }
}
const math = new MathUtils;
var isSSR = typeof window > "u"
  , DetectUA = function() {
    function a(e) {
        this.userAgent = e || (!isSSR && window.navigator ? window.navigator.userAgent : ""),
        this.isAndroidDevice = !/like android/i.test(this.userAgent) && /android/i.test(this.userAgent),
        this.iOSDevice = this.match(1, /(iphone|ipod|ipad)/i).toLowerCase(),
        !isSSR && navigator.platform === "MacIntel" && navigator.maxTouchPoints > 2 && !window.MSStream && (this.iOSDevice = "ipad")
    }
    return a.prototype.match = function(e, t) {
        var r = this.userAgent.match(t);
        return r && r.length > 1 && r[e] || ""
    }
    ,
    Object.defineProperty(a.prototype, "isMobile", {
        get: function() {
            return !this.isTablet && (/[^-]mobi/i.test(this.userAgent) || this.iOSDevice === "iphone" || this.iOSDevice === "ipod" || this.isAndroidDevice || /nexus\s*[0-6]\s*/i.test(this.userAgent))
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(a.prototype, "isTablet", {
        get: function() {
            return /tablet/i.test(this.userAgent) && !/tablet pc/i.test(this.userAgent) || this.iOSDevice === "ipad" || this.isAndroidDevice && !/[^-]mobi/i.test(this.userAgent) || !/nexus\s*[0-6]\s*/i.test(this.userAgent) && /nexus\s*[0-9]+/i.test(this.userAgent)
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(a.prototype, "isDesktop", {
        get: function() {
            return !this.isMobile && !this.isTablet
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(a.prototype, "isMacOS", {
        get: function() {
            return /macintosh/i.test(this.userAgent) && {
                version: this.match(1, /mac os x (\d+(\.?_?\d+)+)/i).replace(/[_\s]/g, ".").split(".").map(function(e) {
                    return e
                })[1]
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(a.prototype, "isWindows", {
        get: function() {
            return /windows /i.test(this.userAgent) && {
                version: this.match(1, /Windows ((NT|XP)( \d\d?.\d)?)/i)
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(a.prototype, "isiOS", {
        get: function() {
            return !!this.iOSDevice && {
                version: this.match(1, /os (\d+([_\s]\d+)*) like mac os x/i).replace(/[_\s]/g, ".") || this.match(1, /version\/(\d+(\.\d+)?)/i)
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(a.prototype, "isAndroid", {
        get: function() {
            return this.isAndroidDevice && {
                version: this.match(1, /android[ \/-](\d+(\.\d+)*)/i)
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(a.prototype, "browser", {
        get: function() {
            var e = this.match(1, /version\/(\d+(\.\d+)?)/i);
            return /opera/i.test(this.userAgent) ? {
                name: "Opera",
                version: e || this.match(1, /(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
            } : /opr\/|opios/i.test(this.userAgent) ? {
                name: "Opera",
                version: this.match(1, /(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || e
            } : /SamsungBrowser/i.test(this.userAgent) ? {
                name: "Samsung Internet for Android",
                version: e || this.match(1, /(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
            } : /yabrowser/i.test(this.userAgent) ? {
                name: "Yandex Browser",
                version: e || this.match(1, /(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
            } : /ucbrowser/i.test(this.userAgent) ? {
                name: "UC Browser",
                version: this.match(1, /(?:ucbrowser)[\s\/](\d+(\.\d+)?)/i)
            } : /msie|trident/i.test(this.userAgent) ? {
                name: "Internet Explorer",
                version: this.match(1, /(?:msie |rv:)(\d+(\.\d+)?)/i)
            } : /(edge|edgios|edga|edg)/i.test(this.userAgent) ? {
                name: "Microsoft Edge",
                version: this.match(2, /(edge|edgios|edga|edg)\/(\d+(\.\d+)?)/i)
            } : /firefox|iceweasel|fxios/i.test(this.userAgent) ? {
                name: "Firefox",
                version: this.match(1, /(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
            } : /chromium/i.test(this.userAgent) ? {
                name: "Chromium",
                version: this.match(1, /(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || e
            } : /chrome|crios|crmo/i.test(this.userAgent) ? {
                name: "Chrome",
                version: this.match(1, /(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
            } : /safari|applewebkit/i.test(this.userAgent) ? {
                name: "Safari",
                version: e
            } : {
                name: this.match(1, /^(.*)\/(.*) /),
                version: this.match(2, /^(.*)\/(.*) /)
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    a
}();
let detectUA = new DetectUA
  , userAgent = (navigator.userAgent || navigator.vendor).toLowerCase()
  , browserName = detectUA.browser.name
  , audioElem = document.createElement("audio");
class Browser {
    isMobile = detectUA.isMobile || detectUA.isTablet;
    isDesktop = detectUA.isDesktop;
    device = this.isMobile ? "mobile" : "desktop";
    isAndroid = !!detectUA.isAndroid;
    isIOS = !!detectUA.isiOS;
    isMacOS = !!detectUA.isMacOS;
    isWindows = detectUA.isWindows.version !== null;
    isLinux = userAgent.indexOf("linux") != -1;
    ua = userAgent;
    isEdge = browserName === "Microsoft Edge";
    isIE = browserName === "Internet Explorer";
    isFirefox = browserName === "Firefox";
    isChrome = browserName === "Chrome";
    isOpera = browserName === "Opera";
    isSafari = browserName === "Safari";
    isSupportMSAA = !userAgent.match("version/15.4 ");
    isSupportOgg = !!audioElem.canPlayType("audio/ogg");
    isRetina = window.devicePixelRatio && window.devicePixelRatio >= 1.5;
    devicePixelRatio = window.devicePixelRatio || 1;
    cpuCoreCount = navigator.hardwareConcurrency || 1;
    baseUrl = document.location.origin;
    isIFrame = window.self !== window.top;
    constructor() {}
}
const browser$1 = new Browser;
let CDN_PATH = "";
window.location.hostname == "lusion.co" && (CDN_PATH = "https://lusion.dev");
window.location.hostname == "lusion.dev" && (window.location.href = "https://lusion.co" + window.location.pathname + window.location.search);
class Settings {
    CDN_PATH = "";
    TEAM_PATH = "/assets/team/";
    TEAM_PATH = "/assets/team/";
    PROJECT_PATH = "/assets/projects/";
    MODEL_PATH = "/assets/models/";
    IMAGE_PATH = "/assets/images/";
    TEXTURE_PATH = "/assets/textures/";
    AUDIO_PATH = "/assets/audios/";
    SPRITE_PATH = "/assets/sprites/";
    RENDER_TARGET_FLOAT_TYPE = null;
    DATA_FLOAT_TYPE = null;
    USE_FLOAT_PACKING = !1;
    USE_WEBGL2 = !0;
    DPR = Math.min(1.5, browser$1.devicePixelRatio) || 1;
    USE_PIXEL_LIMIT = !0;
    MAX_PIXEL_COUNT = 2560 * 1440;
    MOBILE_WIDTH = 812;
    IS_SMALL_SCREEN = Math.min(window.screen.width, window.screen.height) <= 820;
    JUMP_SECTION = "";
    JUMP_OFFSET = 0;
    USE_HD = !1;
    SHOW_DETAILS = "";
    CROSS_ORIGINS = {
        "https://lusion.dev/": "anonymous"
    };
    IS_DEV = !1;
    LOG = !1;
    SKIP_ANIMATION = !1;
    WEBGL_OFF = !1;
    LOOK_DEV_MODE = !1;
    TEST_TUNNEL = !1;
    HOME_TEST = !1;
    OPEN_CONTACT = !1;
    TEST_BALLOONS = !1;
    BALLOON_COLOR = "";
    USE_AUDIO = browser$1.isSupportOgg && !browser$1.isMobile;
    constructor() {
        if (window.URLSearchParams) {
            const t = (r => [...r].reduce( (n, [o,l]) => (n[o] = l === "" ? !0 : l,
            n), {}))(new URLSearchParams(window.location.search));
            this.override(t);
            for (const r in this)
                r.indexOf("_PATH") > -1 && (this["LOCAL_" + r] = this[r],
                this[r] = CDN_PATH + this[r])
        }
    }
    override(e) {
        for (const t in e)
            if (this[t] !== void 0) {
                const r = e[t].toString();
                typeof this[t] == "boolean" ? this[t] = !(r === "0" || r === !1) : typeof this[t] == "number" ? this[t] = parseFloat(r) : typeof this[t] == "string" && (this[t] = r)
            }
        this.USE_HD && (this.USE_PIXEL_LIMIT = !1)
    }
}
const settings = new Settings;
var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(a) {
    return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a
}
var minSignal$1 = {
    exports: {}
};
(function(a) {
    (function(e) {
        function t() {
            this._listeners = [],
            this.dispatchCount = 0
        }
        var r = t.prototype;
        r.add = c,
        r.addOnce = u,
        r.remove = f,
        r.dispatch = p;
        var n = "Callback function is missing!"
          , o = Array.prototype.slice;
        function l(g) {
            g.sort(function(v, _) {
                return v = v.p,
                _ = _.p,
                _ < v ? 1 : _ > v ? -1 : 0
            })
        }
        function c(g, v, _, w) {
            if (!g)
                throw n;
            _ = _ || 0;
            for (var S = this._listeners, b, C, R, T = S.length; T--; )
                if (b = S[T],
                b.f === g && b.c === v)
                    return !1;
            typeof _ == "function" && (C = _,
            _ = w,
            R = 4),
            S.unshift({
                f: g,
                c: v,
                p: _,
                r: C || g,
                a: o.call(arguments, R || 3),
                j: 0
            }),
            l(S)
        }
        function u(g, v, _, w) {
            if (!g)
                throw n;
            var S = this
              , b = function() {
                return S.remove.call(S, g, v),
                g.apply(v, o.call(arguments, 0))
            };
            w = o.call(arguments, 0),
            w.length === 1 && w.push(e),
            w.splice(2, 0, b),
            c.apply(S, w)
        }
        function f(g, v) {
            if (!g)
                return this._listeners.length = 0,
                !0;
            for (var _ = this._listeners, w, S = _.length; S--; )
                if (w = _[S],
                w.f === g && (!v || w.c === v))
                    return w.j = 0,
                    _.splice(S, 1),
                    !0;
            return !1
        }
        function p(g) {
            g = o.call(arguments, 0),
            this.dispatchCount++;
            for (var v = this.dispatchCount, _ = this._listeners, w, S, b = _.length; b--; )
                if (w = _[b],
                w && w.j < v && (w.j = v,
                w.r.apply(w.c, w.a.concat(g)) === !1)) {
                    S = w;
                    break
                }
            for (_ = this._listeners,
            b = _.length; b--; )
                _[b].j = 0;
            return S
        }
        a.exports = t
    }
    )()
}
)(minSignal$1);
var minSignalExports$1 = minSignal$1.exports;
const MinSignal$2 = getDefaultExportFromCjs(minSignalExports$1);
var quickLoader$b = {
    exports: {}
}
  , minSignal = {
    exports: {}
};
(function(a) {
    (function(e) {
        function t() {
            this._listeners = [],
            this.dispatchCount = 0
        }
        var r = t.prototype;
        r.add = c,
        r.addOnce = u,
        r.remove = f,
        r.dispatch = p;
        var n = "Callback function is missing!"
          , o = Array.prototype.slice;
        function l(g) {
            g.sort(function(v, _) {
                return v = v.p,
                _ = _.p,
                _ < v ? 1 : v > _ ? -1 : 0
            })
        }
        function c(g, v, _, w) {
            if (!g)
                throw n;
            _ = _ || 0;
            for (var S = this._listeners, b, C, R, T = S.length; T--; )
                if (b = S[T],
                b.f === g && b.c === v)
                    return !1;
            typeof _ == "function" && (C = _,
            _ = w,
            R = 4),
            S.unshift({
                f: g,
                c: v,
                p: _,
                r: C || g,
                a: o.call(arguments, R || 3),
                j: 0
            }),
            l(S)
        }
        function u(g, v, _, w) {
            if (!g)
                throw n;
            var S = this
              , b = function() {
                return S.remove.call(S, g, v),
                g.apply(v, o.call(arguments, 0))
            };
            w = o.call(arguments, 0),
            w.length === 1 && w.push(e),
            w.splice(2, 0, b),
            c.apply(S, w)
        }
        function f(g, v) {
            if (!g)
                return this._listeners.length = 0,
                !0;
            for (var _ = this._listeners, w, S = _.length; S--; )
                if (w = _[S],
                w.f === g && (!v || w.c === v))
                    return w.j = 0,
                    _.splice(S, 1),
                    !0;
            return !1
        }
        function p(g) {
            g = o.call(arguments, 0),
            this.dispatchCount++;
            for (var v = this.dispatchCount, _ = this._listeners, w, S, b = _.length; b--; )
                if (w = _[b],
                w && w.j < v && (w.j = v,
                w.r.apply(w.c, w.a.concat(g)) === !1)) {
                    S = w;
                    break
                }
            for (_ = this._listeners,
            b = _.length; b--; )
                _[b].j = 0;
            return S
        }
        a.exports = t
    }
    )()
}
)(minSignal);
var minSignalExports = minSignal.exports, MinSignal$1 = minSignalExports, undef$3;
function QuickLoader() {
    this.isLoading = !1,
    this.totalWeight = 0,
    this.loadedWeight = 0,
    this.itemUrls = {},
    this.itemList = [],
    this.loadingSignal = new MinSignal$1,
    this.crossOriginMap = {},
    this.queue = [],
    this.activeItems = [],
    this.maxActiveItems = 4
}
var _p$9 = QuickLoader.prototype;
_p$9.addChunk = addChunk;
_p$9.setCrossOrigin = setCrossOrigin;
_p$9.add = add;
_p$9.load = load$7;
_p$9.start = start$1;
_p$9.loadNext = loadNext;
_p$9._createItem = _createItem;
_p$9._onLoading = _onLoading$1;
_p$9.VERSION = "0.1.17";
_p$9.register = register;
_p$9.retrieveAll = retrieveAll;
_p$9.retrieve = retrieve;
_p$9.testExtensions = testExtensions;
_p$9.create = create;
_p$9.check = check;
var addedItems = _p$9.addedItems = {}
  , loadedItems = _p$9.loadedItems = {}
  , ITEM_CLASS_LIST = _p$9.ITEM_CLASS_LIST = []
  , ITEM_CLASSES = _p$9.ITEM_CLASSES = {};
quickLoader$b.exports = create();
function setCrossOrigin(a, e) {
    this.crossOriginMap[a] = e
}
function addChunk(a, e) {
    var t, r, n, o, l, c = retrieveAll(a, e);
    for (t = 0,
    n = c.length; t < n; t++)
        for (l = c[t],
        r = 0,
        o = l.items.length; r < o; r++)
            this.add(l.items[r], {
                type: l.type
            });
    return c
}
function add(a, e) {
    var t = addedItems[a];
    return t || (t = this._createItem(a, e && e.type ? e.type : retrieve(a).type, e)),
    e && e.onLoad && t.onLoaded.addOnce(e.onLoad),
    this.itemUrls[a] || (this.itemUrls[a] = t,
    this.itemList.push(t),
    this.totalWeight += t.weight),
    t
}
function load$7(a, e) {
    var t = addedItems[a];
    return t || (t = this._createItem(a, e && e.type ? e.type : retrieve(a).type, e)),
    e && e.onLoad && t.onLoaded.addOnce(e.onLoad),
    loadedItems[a] ? t.dispatch() : t.isStartLoaded || t.load(),
    t
}
function start$1(a) {
    a && this.loadingSignal.add(a),
    this.isLoading = !0;
    var e = this.itemList.length;
    if (e) {
        var t = this.itemList.splice(0, this.itemList.length), r;
        for (var n in this.itemUrls)
            delete this.itemUrls[n];
        for (var o = 0; o < e; o++) {
            r = t[o];
            var l = !!loadedItems[r.url];
            r.onLoaded.addOnce(_onItemLoad, this, -1024, r, t, l),
            r.hasLoading && r.loadingSignal.add(_onLoading$1, this, -1024, r, t, undef$3),
            l ? r.dispatch(_onItemLoad) : r.isStartLoaded || this.queue.push(r)
        }
        this.queue.length && this.loadNext()
    } else
        _onItemLoad.call(this, undef$3, this.itemList)
}
function loadNext() {
    if (this.queue.length && this.activeItems.length < this.maxActiveItems) {
        var a = this.queue.shift();
        this.activeItems.push(a),
        this.loadNext(),
        a.load()
    }
}
function _onLoading$1(a, e, t, r, n) {
    a && !a.isLoaded && a.getCombinedPercent(r) === 1 || (n === undef$3 && (this.loadedWeight = _getLoadedWeight(e),
    n = this.loadedWeight / this.totalWeight),
    t = t || this.loadingSignal,
    t.dispatch(n, a))
}
function _getLoadedWeight(a) {
    for (var e = 0, t = 0, r = a.length; t < r; t++)
        e += a[t].loadedWeight;
    return e
}
function _onItemLoad(a, e, t) {
    if (this.loadedWeight = _getLoadedWeight(e),
    !t) {
        for (var r = this.activeItems, n = r.length; n--; )
            if (r[n] === a) {
                r.splice(n, 1);
                break
            }
    }
    var o = this.loadingSignal;
    this.loadedWeight === this.totalWeight ? (this.isLoading = !1,
    this.loadedWeight = 0,
    this.totalWeight = 0,
    this.loadingSignal = new MinSignal$1,
    this._onLoading(a, e, o, 1, 1),
    a && a.noCache && _removeItemCache(a)) : (this._onLoading(a, e, o, 1, this.loadedWeight / this.totalWeight),
    a && a.noCache && _removeItemCache(a),
    t || this.loadNext())
}
function _removeItemCache(a) {
    var e = a.url;
    a.content = undef$3,
    addedItems[e] = undef$3,
    loadedItems[e] = undef$3
}
function _createItem(a, e, t) {
    if (t = t || {},
    !t.crossOrigin) {
        for (var r in this.crossOriginMap)
            if (a.indexOf(r) === 0) {
                t.crossOrigin = this.crossOriginMap[r];
                break
            }
    }
    return new ITEM_CLASSES[e](a,t)
}
function register(a) {
    ITEM_CLASSES[a.type] || (ITEM_CLASS_LIST.push(a),
    ITEM_CLASSES[a.type] = a)
}
function retrieveAll(a, e) {
    var t, r, n = a.length, o = [];
    if (n && typeof a != "string")
        for (t = 0; t < n; t++)
            r = retrieve(a[t], e),
            r && (o = o.concat(r));
    else
        r = retrieve(a, e),
        r && (o = o.concat(r));
    return o
}
function retrieve(a, e) {
    var t, r, n, o, l;
    if (e)
        o = ITEM_CLASSES[e],
        n = o.retrieve(a);
    else
        for (t = 0,
        r = ITEM_CLASS_LIST.length; t < r; t++) {
            if (o = ITEM_CLASS_LIST[t],
            l = o.type,
            typeof a == "string") {
                if (testExtensions(a, o)) {
                    n = [a];
                    break
                }
            } else if (n = o.retrieve(a),
            n && n.length && typeof n[0] == "string" && testExtensions(n[0], o))
                break;
            n = undef$3,
            l = undef$3
        }
    if (n)
        return {
            type: e || l,
            items: n
        }
}
function testExtensions(a, e) {
    if (a) {
        for (var t = _getExtension(a), r = e.extensions, n = r.length; n--; )
            if (t === r[n])
                return !0;
        return !1
    }
}
function _getExtension(a) {
    return a.split(".").pop().split(/#|\?/)[0]
}
function create() {
    return new QuickLoader
}
function check() {
    var a = []
      , e = [];
    for (var t in addedItems)
        a.push(t),
        loadedItems[t] || e.push(addedItems[t]);
    console.log({
        added: a,
        notLoaded: e
    })
}
var quickLoaderExports = quickLoader$b.exports
  , MinSignal = minSignalExports
  , quickLoader$a = quickLoaderExports;
function AbstractItem$6(a, e) {
    if (a) {
        this.url = a,
        this.loadedWeight = 0,
        this.weight = 1,
        this.postPercent = 0;
        for (var t in e)
            this[t] = e[t];
        this.type || (this.type = this.constructor.type),
        this.hasLoading && (this.loadingSignal = new MinSignal,
        this.loadingSignal.add(_onLoading, this),
        this.onLoading && this.loadingSignal.add(this.onLoading)),
        this.onPost ? (this.onPostLoadingSignal = new MinSignal,
        this.onPostLoadingSignal.add(this._onPostLoading, this),
        this.postWeightRatio = this.postWeightRatio || .1) : this.postWeightRatio = 0;
        var r = this;
        this.boundOnLoad = function() {
            r._onLoad()
        }
        ,
        this.onLoaded = new MinSignal,
        quickLoader$a.addedItems[a] = this
    }
}
var AbstractItem_1 = AbstractItem$6
  , _p$8 = AbstractItem$6.prototype;
_p$8.load = load$6;
_p$8._onLoad = _onLoad$6;
_p$8._onLoading = _onLoading;
_p$8._onPostLoading = _onPostLoading;
_p$8._onLoadComplete = _onLoadComplete;
_p$8.getCombinedPercent = getCombinedPercent;
_p$8.dispatch = dispatch;
AbstractItem$6.extensions = [];
AbstractItem$6.retrieve = function() {
    return !1
}
;
function load$6() {
    this.isStartLoaded = !0
}
function _onLoad$6() {
    this.onPost ? this.onPost.call(this, this.content, this.onPostLoadingSignal) : this._onLoadComplete()
}
function _onPostLoading(a) {
    this.postPercent = a,
    this.hasLoading && this.loadingSignal.dispatch(1),
    a === 1 && this._onLoadComplete()
}
function _onLoadComplete() {
    this.isLoaded = !0,
    this.loadedWeight = this.weight,
    quickLoader$a.loadedItems[this.url] = this,
    this.onLoaded.dispatch(this.content)
}
function getCombinedPercent(a) {
    return a * (1 - this.postWeightRatio) + this.postWeightRatio * this.postPercent
}
function _onLoading(a) {
    this.loadedWeight = this.weight * this.getCombinedPercent(a)
}
function dispatch() {
    this.hasLoading && this.loadingSignal.remove(),
    this.onLoaded.dispatch(this.content)
}
var AbstractItem$5 = AbstractItem_1
  , quickLoader$9 = quickLoaderExports;
function __generateFuncName() {
    return "_jsonp" + new Date().getTime() + ~~(Math.random() * 1e8)
}
function JSONPItem(a) {
    a && _super$7.constructor.apply(this, arguments)
}
JSONPItem.type = "jsonp";
JSONPItem.extensions = [];
quickLoader$9.register(JSONPItem);
JSONPItem.retrieve = function(a) {
    return typeof a == "string" && a.indexOf("=") > -1 ? [a] : !1
}
;
var _super$7 = AbstractItem$5.prototype
  , _p$7 = JSONPItem.prototype = new AbstractItem$5;
_p$7.constructor = JSONPItem;
_p$7.load = load$5;
function load$5(a) {
    _super$7.load.apply(this, arguments);
    var e = this
      , t = this.url.lastIndexOf("=") + 1
      , r = this.url.substr(0, t)
      , n = this.url.substr(t);
    n.length === 0 ? (n = __generateFuncName(),
    this.jsonpCallback = a) : this.jsonpCallback = this.jsonpCallback || window[n],
    window[n] = function(l) {
        o.parentNode && o.parentNode.removeChild(o),
        e.content = l,
        e._onLoad()
    }
    ;
    var o = document.createElement("script");
    o.type = "text/javascript",
    o.src = r + n,
    document.getElementsByTagName("head")[0].appendChild(o)
}
var AbstractItem$4 = AbstractItem_1, quickLoader$8 = quickLoaderExports, undef$2, IS_SUPPORT_XML_HTTP_REQUEST = !!window.XMLHttpRequest;
function XHRItem$2(a) {
    a && (_super$6.constructor.apply(this, arguments),
    this.responseType = this.responseType || "",
    this.method = this.method || "GET")
}
var XHRItem_1 = XHRItem$2;
XHRItem$2.type = "xhr";
XHRItem$2.extensions = [];
quickLoader$8.register(XHRItem$2);
XHRItem$2.retrieve = function() {
    return !1
}
;
var _super$6 = AbstractItem$4.prototype
  , _p$6 = XHRItem$2.prototype = new AbstractItem$4;
_p$6.constructor = XHRItem$2;
_p$6.load = load$4;
_p$6._onXmlHttpChange = _onXmlHttpChange;
_p$6._onXmlHttpProgress = _onXmlHttpProgress;
_p$6._onLoad = _onLoad$5;
function load$4() {
    _super$6.load.apply(this, arguments);
    var a = this, e;
    IS_SUPPORT_XML_HTTP_REQUEST ? e = this.xmlhttp = new XMLHttpRequest : e = this.xmlhttp = new ActiveXObject("Microsoft.XMLHTTP"),
    this.hasLoading && (e.onprogress = function(t) {
        a._onXmlHttpProgress(t)
    }
    ),
    e.onreadystatechange = function() {
        a._onXmlHttpChange()
    }
    ,
    e.open(this.method, this.url, !0),
    this.xmlhttp.responseType = this.responseType,
    IS_SUPPORT_XML_HTTP_REQUEST ? e.send(null) : e.send()
}
function _onXmlHttpProgress(a) {
    this.loadingSignal.dispatch(a.loaded / a.total)
}
function _onXmlHttpChange() {
    this.xmlhttp.readyState === 4 && this.xmlhttp.status === 200 && this._onLoad(this.xmlhttp)
}
function _onLoad$5() {
    this.content || (this.content = this.xmlhttp.response),
    this.xmlhttp = undef$2,
    _super$6._onLoad.call(this)
}
var XHRItem$1 = XHRItem_1
  , quickLoader$7 = quickLoaderExports;
function TextItem$1(a, e) {
    a && (e.responseType = "text",
    _super$5.constructor.apply(this, arguments))
}
var TextItem_1 = TextItem$1;
TextItem$1.type = "text";
TextItem$1.extensions = ["html", "txt", "svg"];
quickLoader$7.register(TextItem$1);
TextItem$1.retrieve = function() {
    return !1
}
;
var _super$5 = XHRItem$1.prototype
  , _p$5 = TextItem$1.prototype = new XHRItem$1;
_p$5.constructor = TextItem$1;
_p$5._onLoad = _onLoad$4;
function _onLoad$4() {
    this.content || (this.content = this.xmlhttp.responseText),
    _super$5._onLoad.apply(this, arguments)
}
var TextItem = TextItem_1
  , quickLoader$6 = quickLoaderExports;
function JSONItem(a) {
    a && _super$4.constructor.apply(this, arguments)
}
JSONItem.type = "json";
JSONItem.extensions = ["json"];
quickLoader$6.register(JSONItem);
JSONItem.retrieve = function() {
    return !1
}
;
var _super$4 = TextItem.prototype
  , _p$4 = JSONItem.prototype = new TextItem;
_p$4.constructor = JSONItem;
_p$4._onLoad = _onLoad$3;
function _onLoad$3() {
    this.content || (this.content = window.JSON && window.JSON.parse ? JSON.parse(this.xmlhttp.responseText.toString()) : eval(this.xmlhttp.responseText.toString())),
    _super$4._onLoad.call(this)
}
var AbstractItem$3 = AbstractItem_1, quickLoader$5 = quickLoaderExports, undef$1;
function AudioItem$1(a, e) {
    if (a) {
        this.loadThrough = !e || e.loadThrough === undef$1 ? !0 : e.loadThrough,
        _super$3.constructor.apply(this, arguments);
        try {
            this.content = this.content || new Audio
        } catch {
            this.content = this.content || document.createElement("audio")
        }
        this.crossOrigin && (this.content.crossOrigin = this.crossOrigin)
    }
}
AudioItem$1.type = "audio";
AudioItem$1.extensions = ["mp3", "ogg"];
quickLoader$5.register(AudioItem$1);
AudioItem$1.retrieve = function(a) {
    return !1
}
;
var _super$3 = AbstractItem$3.prototype
  , _p$3 = AudioItem$1.prototype = new AbstractItem$3;
_p$3.constructor = AudioItem$1;
_p$3.load = load$3;
_p$3._onLoad = _onLoad$2;
function load$3() {
    _super$3.load.apply(this, arguments);
    var a = this
      , e = a.content;
    e.src = this.url,
    this.loadThrough ? e.addEventListener("canplaythrough", this.boundOnLoad, !1) : e.addEventListener("canplay", this.boundOnLoad, !1),
    e.load()
}
function _onLoad$2() {
    this.content.removeEventListener("canplaythrough", this.boundOnLoad, !1),
    this.content.removeEventListener("canplay", this.boundOnLoad, !1),
    !this.isLoaded && _super$3._onLoad.call(this)
}
var AbstractItem$2 = AbstractItem_1, quickLoader$4 = quickLoaderExports, undef;
function VideoItem(a, e) {
    if (a) {
        this.loadThrough = !e || e.loadThrough === undef ? !0 : e.loadThrough,
        _super$2.constructor.apply(this, arguments);
        try {
            this.content = this.content || new Video
        } catch {
            this.content = this.content || document.createElement("video")
        }
        this.crossOrigin && (this.content.crossOrigin = this.crossOrigin)
    }
}
VideoItem.type = "video";
VideoItem.extensions = ["mp4", "webm", "ogv"];
quickLoader$4.register(VideoItem);
VideoItem.retrieve = function(a) {
    return !1
}
;
var _super$2 = AbstractItem$2.prototype
  , _p$2 = VideoItem.prototype = new AbstractItem$2;
_p$2.constructor = VideoItem;
_p$2.load = load$2;
_p$2._onLoad = _onLoad$1;
function load$2() {
    _super$2.load.apply(this, arguments);
    var a = this.content;
    a.preload = "auto",
    a.src = this.url,
    this.loadThrough ? a.addEventListener("canplaythrough", this.boundOnLoad, !1) : a.addEventListener("canplay", this.boundOnLoad, !1),
    a.load()
}
function _onLoad$1() {
    this.content.removeEventListener("canplaythrough", this.boundOnLoad),
    this.content.removeEventListener("canplay", this.boundOnLoad),
    !this.isLoaded && _super$2._onLoad.call(this)
}
var AbstractItem$1 = AbstractItem_1
  , quickLoader$3 = quickLoaderExports;
function AnyItem$3(a, e) {
    a && (_super$1.constructor.call(this, a, e),
    !this.loadFunc && console && console[console.error || console.log]("require loadFunc in the config object."))
}
AnyItem$3.type = "any";
AnyItem$3.extensions = [];
quickLoader$3.register(AnyItem$3);
AnyItem$3.retrieve = function() {
    return !1
}
;
var _super$1 = AbstractItem$1.prototype
  , _p$1 = AnyItem$3.prototype = new AbstractItem$1;
_p$1.constructor = AnyItem$3;
_p$1.load = load$1;
function load$1() {
    var a = this;
    this.loadFunc(this.url, function(e) {
        a.content = e,
        _super$1._onLoad.call(a)
    }, this.loadingSignal)
}
function computedStyle$2(a, e, t, r) {
    if (t = window.getComputedStyle,
    r = t ? t(a) : a.currentStyle,
    r)
        return r[e.replace(/-(\w)/gi, function(n, o) {
            return o.toUpperCase()
        })]
}
var computedStyle_commonjs = computedStyle$2
  , AbstractItem = AbstractItem_1
  , computedStyle$1 = computedStyle_commonjs
  , quickLoader$2 = quickLoaderExports;
function ImageItem$1(a, e) {
    a && (_super.constructor.apply(this, arguments),
    this.content = this.content || new Image,
    this.crossOrigin && (this.content.crossOrigin = this.crossOrigin))
}
var _super = AbstractItem.prototype
  , _p = ImageItem$1.prototype = new AbstractItem;
_p.constructor = ImageItem$1;
_p.load = load;
_p._onLoad = _onLoad;
ImageItem$1.retrieve = function(a) {
    if (a.nodeType && a.style) {
        var e = [];
        a.nodeName.toLowerCase() === "img" && a.src.indexOf(";") < 0 && e.push(a.src),
        computedStyle$1(a, "background-image").replace(/s?url\(\s*?['"]?([^;]*?)['"]?\s*?\)/g, function(r, n) {
            e.push(n)
        });
        for (var t = e.length; t--; )
            _isNotData(e[t]) || e.splice(t, 1);
        return e.length ? e : !1
    } else
        return typeof a == "string" ? [a] : !1
}
;
ImageItem$1.type = "image";
ImageItem$1.extensions = ["jpg", "gif", "png"];
quickLoader$2.register(ImageItem$1);
function load() {
    _super.load.apply(this, arguments);
    var a = this.content;
    a.onload = this.boundOnLoad,
    a.src = this.url
}
function _onLoad() {
    delete this.content.onload,
    this.width = this.content.width,
    this.height = this.content.height,
    _super._onLoad.call(this)
}
function _isNotData(a) {
    return a.indexOf("data:") !== 0
}
var quickLoader = quickLoaderExports;
const quickLoader$1 = getDefaultExportFromCjs(quickLoader);
let computedStyle = getComputedStyle(document.documentElement);
class Properties {
    win = window;
    isSecureConnection = window.location.protocol === "https:";
    loader = quickLoader$1.create();
    percent = 0;
    easedPercent = 0;
    domRoot = document.querySelector(":root");
    _isSupportedDevice = !1;
    _isSupportedBrowser = !1;
    _isSupportedWebGL = !1;
    _isSupportedMobileOrientation = !1;
    _isSupported = !1;
    time = 0;
    deltaTime = 0;
    hasInitialized = !1;
    hasStarted = !1;
    startTime = 0;
    viewportWidth = 0;
    viewportHeight = 0;
    width = 0;
    height = 0;
    useMobileLayout = !1;
    renderer = null;
    scene = null;
    camera = null;
    cameraDirection = new Vector3(0,0,1);
    postprocessing = null;
    resolution = new Vector2;
    viewportResolution = new Vector2;
    bgColor = new Color;
    canvas = null;
    gl = null;
    webglDPR = 1;
    webglOpts = {
        antialias: !1,
        alpha: !1,
        xrCompatible: !1,
        powerPreference: "high-performance"
    };
    sharedUniforms = {
        u_aspect: {
            value: 1
        },
        u_cameraDirection: {
            value: this.cameraDirection
        },
        u_dpr: {
            value: 1
        },
        u_time: {
            value: 0
        },
        u_deltaTime: {
            value: 1
        },
        u_resolution: {
            value: this.resolution
        },
        u_viewportResolution: {
            value: this.viewportResolution
        },
        u_bgColor: {
            value: this.bgColor
        },
        u_globalRadius: {
            value: 0
        }
    };
    initTaskList = [];
    changeCamera = new MinSignal$2;
    smaa = null;
    fxaa = null;
    aboutPageHeroEfxPrepass = null;
    cameraMotionBlur = null;
    aboutPageHeroEfx = null;
    gtao = null;
    bloom = null;
    screenPaintDistortion = null;
    final = null;
    offWhiteColorHex = computedStyle.getPropertyValue("--color-off-white").trim();
    blackColorHex = computedStyle.getPropertyValue("--color-black").trim();
    blueColorHex = computedStyle.getPropertyValue("--color-blue").trim();
    bgColorHex = computedStyle.getPropertyValue("--color-off-white").trim();
    opacity = 1;
    cameraLookX = 0;
    cameraLookY = 0;
    defaults = {
        defaultCameraPosition: new Vector3(0,0,5),
        defaultLookAtPosition: new Vector3(0,0,0),
        autoScrollSpeed: 0,
        cameraNear: .1,
        cameraFar: 200,
        clearAlpha: 1,
        cameraFov: 45,
        cameraUsePhysical: !1,
        cameraFilmGauge: 35,
        cameraFocalLength: 35,
        cameraDollyZoomFovOffset: 0,
        screenPaintOffsetRatio: 1,
        cameraViewportOffsetX: 0,
        cameraViewportOffsetY: 0,
        cameraDistance: 5,
        cameraLookStrength: 0,
        cameraLookEaseDamp: .1,
        cameraShakePositionStrength: 0,
        cameraShakePositionSpeed: .15,
        cameraShakeRotationStrength: 0,
        cameraShakeRotationSpeed: .3,
        cameraDollyZoomFovOffset: 0,
        bloomAmount: 0,
        bloomRadius: 0,
        bloomThreshold: 0,
        bloomSmoothWidth: 0,
        bloomSaturation: 1,
        bloomHighPassMultiplier: 1,
        haloWidth: .6,
        haloRGBShift: .02,
        haloStrength: 0,
        haloMaskInner: .3,
        haloMaskOuter: .5,
        useFinal: !1,
        vignetteFrom: 2,
        vignetteTo: 5,
        vignetteColorHex: "#000000",
        saturation: 1,
        contrast: 0,
        brightness: 1,
        tintColorHex: "#000000",
        tintOpacity: 0,
        screenPaintNeedsMouseDown: !1,
        screenPaintMinRadius: 0,
        screenPaintMaxRadius: 100,
        screenPaintRadiusDistanceRange: 100,
        screenPaintPushStrength: 25,
        screenPaintVelocityDissipation: .975,
        screenPaintWeight1Dissipation: .95,
        screenPaintWeight2Dissipation: .8,
        screenPaintUseNoise: !0,
        screenPaintCurlScale: .02,
        screenPaintCurlStrength: 3,
        screenPaintDistortionAmount: 3,
        screenPaintDistortionRGBShift: .5,
        screenPaintDistortionColorMultiplier: 10,
        screenPaintDistortionMultiplier: 5,
        upscalerAmount: 1,
        upscalerSharpness: 1,
        isSmaaEnabled: !settings.USE_HD
    };
    onFirstClicked = new MinSignal$2;
    isPreloaderFinished = !1;
    balloonsColorIndex = 0;
    globalRadius = 0;
    isContactFromProjectPage = !1;
    constructor() {}
    reset() {
        for (let e in this.defaults)
            this[e] = this.defaults[e];
        this.smaa && (this.smaa.enabled = !0)
    }
}
const properties = new Properties;
var _populated = !1, _ie, _firefox, _opera, _webkit, _chrome, _ie_real_version, _osx, _windows, _linux, _android, _win64, _iphone, _ipad, _native, _mobile;
function _populate() {
    if (!_populated) {
        _populated = !0;
        var a = navigator.userAgent
          , e = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(a)
          , t = /(Mac OS X)|(Windows)|(Linux)/.exec(a);
        if (_iphone = /\b(iPhone|iP[ao]d)/.exec(a),
        _ipad = /\b(iP[ao]d)/.exec(a),
        _android = /Android/i.exec(a),
        _native = /FBAN\/\w+;/i.exec(a),
        _mobile = /Mobile/i.exec(a),
        _win64 = !!/Win64/.exec(a),
        e) {
            _ie = e[1] ? parseFloat(e[1]) : e[5] ? parseFloat(e[5]) : NaN,
            _ie && document && document.documentMode && (_ie = document.documentMode);
            var r = /(?:Trident\/(\d+.\d+))/.exec(a);
            _ie_real_version = r ? parseFloat(r[1]) + 4 : _ie,
            _firefox = e[2] ? parseFloat(e[2]) : NaN,
            _opera = e[3] ? parseFloat(e[3]) : NaN,
            _webkit = e[4] ? parseFloat(e[4]) : NaN,
            _webkit ? (e = /(?:Chrome\/(\d+\.\d+))/.exec(a),
            _chrome = e && e[1] ? parseFloat(e[1]) : NaN) : _chrome = NaN
        } else
            _ie = _firefox = _opera = _chrome = _webkit = NaN;
        if (t) {
            if (t[1]) {
                var n = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(a);
                _osx = n ? parseFloat(n[1].replace("_", ".")) : !0
            } else
                _osx = !1;
            _windows = !!t[2],
            _linux = !!t[3]
        } else
            _osx = _windows = _linux = !1
    }
}
var UserAgent_DEPRECATED$1 = {
    ie: function() {
        return _populate() || _ie
    },
    ieCompatibilityMode: function() {
        return _populate() || _ie_real_version > _ie
    },
    ie64: function() {
        return UserAgent_DEPRECATED$1.ie() && _win64
    },
    firefox: function() {
        return _populate() || _firefox
    },
    opera: function() {
        return _populate() || _opera
    },
    webkit: function() {
        return _populate() || _webkit
    },
    safari: function() {
        return UserAgent_DEPRECATED$1.webkit()
    },
    chrome: function() {
        return _populate() || _chrome
    },
    windows: function() {
        return _populate() || _windows
    },
    osx: function() {
        return _populate() || _osx
    },
    linux: function() {
        return _populate() || _linux
    },
    iphone: function() {
        return _populate() || _iphone
    },
    mobile: function() {
        return _populate() || _iphone || _ipad || _android || _mobile
    },
    nativeApp: function() {
        return _populate() || _native
    },
    android: function() {
        return _populate() || _android
    },
    ipad: function() {
        return _populate() || _ipad
    }
}, UserAgent_DEPRECATED_1 = UserAgent_DEPRECATED$1, canUseDOM = !!(typeof window < "u" && window.document && window.document.createElement), ExecutionEnvironment$1 = {
    canUseDOM,
    canUseWorkers: typeof Worker < "u",
    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
    canUseViewport: canUseDOM && !!window.screen,
    isInWorker: !canUseDOM
}, ExecutionEnvironment_1 = ExecutionEnvironment$1, ExecutionEnvironment = ExecutionEnvironment_1, useHasFeature;
ExecutionEnvironment.canUseDOM && (useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported$1(a, e) {
    if (!ExecutionEnvironment.canUseDOM || e && !("addEventListener"in document))
        return !1;
    var t = "on" + a
      , r = t in document;
    if (!r) {
        var n = document.createElement("div");
        n.setAttribute(t, "return;"),
        r = typeof n[t] == "function"
    }
    return !r && useHasFeature && a === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")),
    r
}
var isEventSupported_1 = isEventSupported$1
  , UserAgent_DEPRECATED = UserAgent_DEPRECATED_1
  , isEventSupported = isEventSupported_1
  , PIXEL_STEP = 10
  , LINE_HEIGHT = 40
  , PAGE_HEIGHT = 800;
function normalizeWheel$2(a) {
    var e = 0
      , t = 0
      , r = 0
      , n = 0;
    return "detail"in a && (t = a.detail),
    "wheelDelta"in a && (t = -a.wheelDelta / 120),
    "wheelDeltaY"in a && (t = -a.wheelDeltaY / 120),
    "wheelDeltaX"in a && (e = -a.wheelDeltaX / 120),
    "axis"in a && a.axis === a.HORIZONTAL_AXIS && (e = t,
    t = 0),
    r = e * PIXEL_STEP,
    n = t * PIXEL_STEP,
    "deltaY"in a && (n = a.deltaY),
    "deltaX"in a && (r = a.deltaX),
    (r || n) && a.deltaMode && (a.deltaMode == 1 ? (r *= LINE_HEIGHT,
    n *= LINE_HEIGHT) : (r *= PAGE_HEIGHT,
    n *= PAGE_HEIGHT)),
    r && !e && (e = r < 1 ? -1 : 1),
    n && !t && (t = n < 1 ? -1 : 1),
    {
        spinX: e,
        spinY: t,
        pixelX: r,
        pixelY: n
    }
}
normalizeWheel$2.getEventType = function() {
    return UserAgent_DEPRECATED.firefox() ? "DOMMouseScroll" : isEventSupported("wheel") ? "wheel" : "mousewheel"
}
;
var normalizeWheel_1 = normalizeWheel$2
  , normalizeWheel = normalizeWheel_1;
const normalizeWheel$1 = getDefaultExportFromCjs(normalizeWheel);
class SecondOrderDynamics {
    target0 = null;
    target = null;
    prevTarget = null;
    value = null;
    valueVel = null;
    k1;
    k2;
    k3;
    _f;
    _z;
    _r;
    _w;
    _z;
    _d;
    _targetVelCache;
    _cache1;
    _cache2;
    _k1Stable;
    _k2Stable;
    isVector = null;
    isRobust = null;
    constructor(e, t=1.5, r=.8, n=2, o=!0) {
        this.isRobust = o,
        this.isVector = typeof e == "object",
        this.setFZR(t, r, n),
        this.isVector ? (this.target = e,
        this.target0 = e.clone(),
        this.prevTarget = e.clone(),
        this.value = e.clone(),
        this.valueVel = e.clone().setScalar(0),
        this._targetVelCache = this.valueVel.clone(),
        this._cache1 = this.valueVel.clone(),
        this._cache2 = this.valueVel.clone(),
        this.update = this._updateVector,
        this.reset = this._resetVector) : (this.target0 = e,
        this.prevTarget = e,
        this.value = e,
        this.valueVel = 0,
        this.update = this._updateNumber,
        this.reset = this._resetNumber),
        this.computeStableCoefficients = o ? this._computeRobustStableCoefficients : this._computeStableCoefficients
    }
    update(e, t=0) {}
    reset(e=null) {}
    _resetVector(e=this.target0) {
        this.valueVel.setScalar(0),
        this.prevTarget.copy(e),
        this.target.copy(e),
        this.value.copy(e)
    }
    _resetNumber(e=this.target0) {
        this.valueVel = 0,
        this.prevTarget = e,
        this.target = e,
        this.value = e
    }
    setFZR(e=this._f, t=this._z, r=this._r) {
        let n = Math.PI * 2 * e;
        this.isRobust && (this._w = n,
        this._z = t,
        this._d = this._w * Math.sqrt(Math.abs(this._z * this._z - 1))),
        this.k1 = t / (Math.PI * e),
        this.k2 = 1 / (n * n),
        this.k3 = r * t / n
    }
    _computeStableCoefficients(e) {
        this._k1Stable = this.k1,
        this._k2Stable = Math.max(this.k2, 1.1 * e * e / 4 + e * this.k1 / 2)
    }
    _computeRobustStableCoefficients(e) {
        if (this._w * e < this._z)
            this._k1Stable = this.k1,
            this._k2Stable = Math.max(this.k2, e * e / 2 + e * this.k1 / 2, e * this.k1);
        else {
            let t = Math.exp(-this._z * this._w * e)
              , r = 2 * t * (this._z <= 1 ? Math.cos(e * this._d) : Math.cosh(e * this._d))
              , n = t * t
              , o = e / (1 + n - r);
            this._k1Stable = (1 - n) * o,
            this._k2Stable = e * o
        }
    }
    _updateVector(e, t=this.target) {
        e > 0 && (this._targetVelCache.copy(t).sub(this.prevTarget).divideScalar(e),
        this.prevTarget.copy(t),
        this.computeStableCoefficients(e),
        this.value.add(this._cache1.copy(this.valueVel).multiplyScalar(e)),
        this._cache1.copy(t).add(this._targetVelCache.multiplyScalar(this.k3)).sub(this.value).sub(this._cache2.copy(this.valueVel).multiplyScalar(this._k1Stable)).multiplyScalar(e / this._k2Stable),
        this.valueVel.add(this._cache1))
    }
    _updateNumber(e, t=this.target) {
        if (e > 0) {
            let r = (t - this.prevTarget) / e;
            this.prevTarget = t,
            this.computeStableCoefficients(e),
            this.valueVel += (t + this.k3 * r - this.value - this._k1Stable * this.valueVel) * (e / this._k2Stable),
            this.value += this.valueVel * e
        }
    }
}
class Input {
    onDowned = new MinSignal$2;
    onMoved = new MinSignal$2;
    onUped = new MinSignal$2;
    onClicked = new MinSignal$2;
    onWheeled = new MinSignal$2;
    onXScrolled = new MinSignal$2;
    onYScrolled = new MinSignal$2;
    wasDown = !1;
    isDown = !1;
    downTime = 0;
    hasClicked = !1;
    hasMoved = !1;
    hadMoved = !1;
    justClicked = !1;
    mouseXY = new Vector2;
    _prevMouseXY = new Vector2;
    prevMouseXY = new Vector2;
    mousePixelXY = new Vector2;
    _prevMousePixelXY = new Vector2;
    prevMousePixelXY = new Vector2;
    downXY = new Vector2;
    downPixelXY = new Vector2;
    deltaXY = new Vector2;
    deltaPixelXY = new Vector2;
    deltaDownXY = new Vector2;
    deltaDownPixelXY = new Vector2;
    deltaDownPixelDistance = 0;
    deltaWheel = 0;
    deltaDragScrollX = 0;
    deltaScrollX = 0;
    deltaDragScrollY = 0;
    deltaScrollY = 0;
    isDragScrollingX = !1;
    isDragScrollingY = !1;
    isWheelScrolling = !1;
    dragScrollXMomentum = 0;
    dragScrollYMomentum = 0;
    dragScrollMomentumMultiplier = 10;
    canDesktopDragScroll = !1;
    needsCheckDragScrollDirection = !1;
    lastScrollXDirection = 0;
    lastScrollYDirection = 0;
    easedMouseDynamics = {};
    dragScrollDynamic;
    downThroughElems = [];
    currThroughElems = [];
    prevThroughElems = [];
    clickThroughElems = [];
    preInit() {
        const e = document;
        e.addEventListener("mousedown", this._onDown.bind(this)),
        e.addEventListener("touchstart", this._getTouchBound(this, this._onDown)),
        e.addEventListener("mousemove", this._onMove.bind(this)),
        e.addEventListener("touchmove", this._getTouchBound(this, this._onMove)),
        e.addEventListener("mouseup", this._onUp.bind(this)),
        e.addEventListener("touchend", this._getTouchBound(this, this._onUp)),
        e.addEventListener("wheel", this._onWheel.bind(this)),
        e.addEventListener("mousewheel", this._onWheel.bind(this)),
        this.addEasedInput("default", 1.35, .5, 1.25),
        this.dragScrollDynamic = this.addEasedInput("dragScroll", 2, 1, 1),
        this.onUped.addOnce( () => {
            properties.onFirstClicked.dispatch()
        }
        )
    }
    init() {}
    resize() {
        for (let e in this.easedMouseDynamics)
            this.easedMouseDynamics[e].reset()
    }
    update(e) {
        for (let t in this.easedMouseDynamics) {
            let r = this.easedMouseDynamics[t];
            r.target.copy(this.mouseXY),
            r.update(e)
        }
    }
    addEasedInput(e, t=1.5, r=.8, n=2) {
        return this.easedMouseDynamics[e] = new SecondOrderDynamics(new Vector2,t,r,n)
    }
    postUpdate(e) {
        this.prevThroughElems.length = 0,
        this.prevThroughElems.concat(this.currThroughElems),
        this.deltaWheel = 0,
        this.deltaDragScrollX = 0,
        this.deltaDragScrollY = 0,
        this.deltaScrollX = 0,
        this.deltaScrollY = 0,
        this.dragScrollXMomentum = 0,
        this.dragScrollYMomentum = 0,
        this.deltaXY.set(0, 0),
        this.deltaPixelXY.set(0, 0),
        this.prevMouseXY.copy(this.mouseXY),
        this.prevMousePixelXY.copy(this.mousePixelXY),
        this.hadMoved = this.hasMoved,
        this.wasDown = this.isDown,
        this.justClicked = !1,
        this.isWheelScrolling = !1
    }
    _onWheel(e) {
        let t = normalizeWheel$1(e).pixelY;
        t = math.clamp(t, -200, 200),
        this.deltaWheel += t,
        this.deltaScrollX = this.deltaDragScrollX + this.deltaWheel,
        this.deltaScrollY = this.deltaDragScrollY + this.deltaWheel,
        this.lastScrollXDirection = this.deltaWheel > 0 ? 1 : -1,
        this.lastScrollYDirection = this.deltaWheel > 0 ? 1 : -1,
        this.isWheelScrolling = !0,
        this.onWheeled.dispatch(e.target),
        this.onXScrolled.dispatch(e.target),
        this.onYScrolled.dispatch(e.target)
    }
    _onDown(e) {
        this.isDown = !0,
        this.downTime = +new Date,
        this.prevThroughElems.length = 0,
        this._setThroughElementsByEvent(e, this.downThroughElems),
        this._getInputXY(e, this.downXY),
        this._getInputPixelXY(e, this.downPixelXY),
        this._prevMouseXY.copy(this.downXY),
        this._prevMousePixelXY.copy(this.downPixelXY),
        this.deltaXY.set(0, 0),
        this.deltaPixelXY.set(0, 0),
        this._getInputXY(e, this.mouseXY),
        this.dragScrollDynamic.reset(this.mouseXY),
        this.isDragScrollingX = !1,
        this.isDragScrollingY = !1,
        this.needsCheckDragScrollDirection = !1,
        this._onMove(e),
        this.onDowned.dispatch(e),
        this.needsCheckDragScrollDirection = !0
    }
    _onMove(e) {
        this._getInputXY(e, this.mouseXY),
        this._getInputPixelXY(e, this.mousePixelXY),
        this.deltaXY.copy(this.mouseXY).sub(this._prevMouseXY),
        this.deltaPixelXY.copy(this.mousePixelXY).sub(this._prevMousePixelXY),
        this._prevMouseXY.copy(this.mouseXY),
        this._prevMousePixelXY.copy(this.mousePixelXY),
        this.hasMoved = this.deltaXY.length() > 0,
        this.isDown && (this.deltaDownXY.copy(this.mouseXY).sub(this.downXY),
        this.deltaDownPixelXY.copy(this.mousePixelXY).sub(this.downPixelXY),
        this.deltaDownPixelDistance = this.deltaDownPixelXY.length(),
        (browser$1.isMobile || this.canDesktopDragScroll) && (this.needsCheckDragScrollDirection && (this.isDragScrollingX = Math.abs(this.deltaPixelXY.x) > Math.abs(this.deltaPixelXY.y),
        this.isDragScrollingY = !this.isDragScrollingX,
        this.needsCheckDragScrollDirection = !1),
        this.isDragScrollingX && (this.deltaDragScrollX += -this.deltaPixelXY.x,
        this.deltaScrollX += -this.deltaPixelXY.x + this.deltaWheel,
        this.lastScrollXDirection = this.deltaDragScrollX > 0 ? 1 : -1,
        this.onXScrolled.dispatch(e.target)),
        this.isDragScrollingY && (this.deltaDragScrollY += -this.deltaPixelXY.y,
        this.deltaScrollY += -this.deltaPixelXY.y + this.deltaWheel,
        this.lastScrollYDirection = this.deltaDragScrollY > 0 ? 1 : -1,
        this.onYScrolled.dispatch(e.target)))),
        this._setThroughElementsByEvent(e, this.currThroughElems),
        this.onMoved.dispatch(e)
    }
    _onUp(e) {
        const t = e.clientX - this.downPixelXY.x
          , r = e.clientY - this.downPixelXY.y;
        Math.sqrt(t * t + r * r) < 40 && +new Date - this.downTime < 300 && (this._setThroughElementsByEvent(e, this.clickThroughElems),
        this._getInputXY(e, this.mouseXY),
        this.hasClicked = !0,
        this.justClicked = !0,
        this.onClicked.dispatch(e)),
        this.deltaDownXY.set(0, 0),
        this.deltaDownPixelXY.set(0, 0),
        this.deltaDownPixelDistance = 0,
        this.dragScrollXMomentum = this.dragScrollDynamic.valueVel.y * properties.viewportWidth * this.dragScrollMomentumMultiplier * properties.deltaTime,
        this.dragScrollYMomentum = this.dragScrollDynamic.valueVel.y * properties.viewportHeight * this.dragScrollMomentumMultiplier * properties.deltaTime,
        this.isDown = !1,
        this.needsCheckDragScrollDirection = !1,
        this.onUped.dispatch(e)
    }
    _getTouchBound(e, t, r) {
        return function(n) {
            r && n.preventDefault && n.preventDefault(),
            t.call(e, n.changedTouches[0] || n.touches[0])
        }
    }
    _getInputXY(e, t) {
        return t.set(e.clientX / properties.viewportWidth * 2 - 1, 1 - e.clientY / properties.viewportHeight * 2),
        t
    }
    _getInputPixelXY(e, t) {
        t.set(e.clientX, e.clientY)
    }
    _setThroughElementsByEvent(e, t) {
        let r = e.target;
        for (t.length = 0; r.parentNode; )
            t.push(r),
            r = r.parentNode
    }
    hasThroughElem(e, t) {
        let r = this[t + "ThroughElems"] || this.currThroughElems
          , n = r.length;
        for (; n--; )
            if (r[n] === e)
                return !0;
        return !1
    }
    hasThroughElemWithClass(e, t) {
        let r = this[t + "ThroughElems"] || this.currThroughElems
          , n = r.length;
        for (; n--; )
            if (r[n].classList.contains(e))
                return r[n];
        return null
    }
}
const input = new Input;
class ScrollDomRange {
    constructor(e, t) {
        this.dom = e,
        this.isVertical = t,
        this.needsUpdate = !0,
        this.forcedUpdate = !0,
        this.screenX = 0,
        this.screenY = 0,
        this.ratio = 0,
        this.screenRatio = 0,
        this.isActive = !1,
        this._left = 0,
        this._right = 0,
        this._top = 0,
        this._bottom = 0,
        this.left = 0,
        this.right = 0,
        this.top = 0,
        this.bottom = 0,
        this.width = 0,
        this.height = 0,
        this.showScreenOffset = 0,
        this.hideScreenOffset = 0
    }
    update(e, t, r, n) {
        if (n = n || this.needsUpdate,
        n) {
            let c = this.dom.getBoundingClientRect();
            this.needsUpdate = !1,
            this._left = c.left,
            this._right = c.right,
            this._top = c.top,
            this._bottom = c.bottom,
            this.width = c.width,
            this.height = c.height,
            this.forcedUpdate = !1,
            this.isVertical ? (this._top += e,
            this._bottom += e) : (this._left += e,
            this._right += e)
        }
        this.left = this._left,
        this.right = this._right,
        this.top = this._top,
        this.bottom = this._bottom,
        this.isVertical ? (this.top += r,
        this.bottom += r) : (this.left += r,
        this.right += r),
        this.screenX = this.left,
        this.screenY = this.top;
        let o;
        this.isVertical ? o = this.screenY -= e : o = this.screenX -= e;
        let l = this.isVertical ? this.height : this.width;
        this.ratio = Math.min(0, math.unClampedFit(o, t, t - l, -1, 0)),
        this.ratio += Math.max(0, math.unClampedFit(o, 0, -l, 0, 1)),
        this.screenRatio = math.fit(o, t, -l, -1, 1),
        this.showScreenOffset = -(o - t) / t,
        this.hideScreenOffset = -(o + l) / t,
        this.isActive = this.ratio >= -1 && this.ratio <= 1
    }
}
let instances = [];
class Tween {
    constructor(e, t) {
        this.target = e,
        this.fromProperties = {},
        this.toProperties = {},
        this.onComplete = t,
        this.t = 0,
        this.duration = 0,
        this.autoUpdate = !0,
        instances.push(this)
    }
    static autoUpdate(e) {
        for (let t = 0; t < instances.length; t++) {
            let r = instances[t];
            r.autoUpdate && r.update(e)
        }
    }
    restart() {
        this.isActive = !0,
        this.t = 0
    }
    kill() {
        this.t = this.duration
    }
    to(e, t, r=null) {
        let n = {};
        for (let o in t)
            n[o] = this.target[o];
        this.fromTo(e, n, t, r)
    }
    fromTo(e, t, r, n) {
        this.duration = e,
        this.ease = n,
        this.fromProperties = t,
        this.toProperties = r,
        this.restart(),
        this.update(0, this.duration == 0)
    }
    update(e=0, t=!1) {
        if (this.t < this.duration || t) {
            this.t = Math.min(this.duration, this.t + e);
            let r = this.t / this.duration;
            this.ease && (r = this.ease(r));
            for (let n in this.toProperties)
                this.target[n] = math.mix(this.fromProperties[n], this.toProperties[n], r);
            this.t == this.duration && this.onComplete && this.onComplete()
        }
    }
}
const blitVert = `#define GLSLIFY 1
attribute vec2 position;varying vec2 v_uv;void main(){v_uv=position*0.5+0.5;gl_Position=vec4(position,0.0,1.0);}`
  , blitFrag = `#define GLSLIFY 1
uniform sampler2D u_texture;varying vec2 v_uv;void main(){gl_FragColor=texture2D(u_texture,v_uv);}`
  , uvBlitVert = `#define GLSLIFY 1
attribute vec2 position;attribute vec2 uv;varying vec2 v_uv;void main(){v_uv=uv;gl_Position=vec4(position,0.0,1.0);}`
  , clearFrag = `#define GLSLIFY 1
uniform vec4 u_color;varying vec2 v_uv;void main(){gl_FragColor=u_color;}`
  , debugVert = `#define GLSLIFY 1
attribute vec3 position;attribute vec2 uv;uniform vec4 u_transform;varying vec2 v_uv;void main(){v_uv=uv;gl_Position=vec4(position.xy*u_transform.zw+u_transform.xy,0.0,1.0);}`;
class FboHelper {
    isWebGL2;
    renderer;
    quadGeom;
    triGeom;
    floatType;
    precisionPrefix;
    precisionPrefix2;
    vertexShader;
    _scene;
    _camera;
    _tri;
    copyMaterial;
    uvCopyMaterial;
    clearMaterial;
    _debugScene;
    _debugMesh;
    _debugMaterial;
    init(e, t) {
        this.renderer = e,
        this.floatType = t,
        this.isWebGL2 = this.renderer.capabilities.isWebGL2,
        this._scene = new Scene,
        this._camera = new Camera,
        this._camera.position.z = 1,
        this.triGeom = new BufferGeometry,
        this.triGeom.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0, 4, -1, 0, -1, 4, 0]),3)),
        this.quadGeom = new PlaneGeometry(2,2),
        this._tri = new Mesh(this.triGeom),
        this._tri.frustumCulled = !1,
        this._scene.add(this._tri),
        this.precisionPrefix = `precision ${this.renderer.capabilities.precision} float;
`,
        this.precisionPrefix2 = `#version 300 es
			precision ${this.renderer.capabilities.precision} float;
			precision ${this.renderer.capabilities.precision} int;
			#define IS_WEBGL2 true
		`,
        this.isWebGL2 ? (this.vertexPrefix = `${this.precisionPrefix2}
				precision mediump sampler2DArray;
				#define attribute in
				#define varying out
				#define texture2D texture
			`,
        this.fragmentPrefix = `${this.precisionPrefix2}
				#define varying in
				out highp vec4 pc_fragColor;
				#define gl_FragColor pc_fragColor
				#define gl_FragDepthEXT gl_FragDepth
				#define texture2D texture
				#define textureCube texture
				#define texture2DProj textureProj
				#define texture2DLodEXT textureLod
				#define texture2DProjLodEXT textureProjLod
				#define textureCubeLodEXT textureLod
				#define texture2DGradEXT textureGrad
				#define texture2DProjGradEXT textureProjGrad
				#define textureCubeGradEXT textureGrad
			`) : (this.vertexPrefix = this.precisionPrefix,
        this.fragmentPrefix = this.precisionPrefix),
        this.renderer.getContext().getExtension("OES_standard_derivatives"),
        this.vertexShader = this.precisionPrefix + blitVert,
        this.copyMaterial = new RawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                }
            },
            vertexShader: this.vertexShader,
            fragmentShader: this.precisionPrefix + blitFrag,
            depthTest: !1,
            depthWrite: !1,
            blending: NoBlending
        }),
        this.uvCopyMaterial = new RawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                }
            },
            vertexShader: this.precisionPrefix + uvBlitVert,
            fragmentShader: this.precisionPrefix + blitFrag,
            depthTest: !1,
            depthWrite: !1,
            blending: NoBlending
        }),
        this.clearMaterial = new RawShaderMaterial({
            uniforms: {
                u_color: {
                    value: new Vector4(1,1,1,1)
                }
            },
            vertexShader: this.vertexShader,
            fragmentShader: this.precisionPrefix + clearFrag,
            depthTest: !1,
            depthWrite: !1,
            blending: NoBlending
        });
        const r = new PlaneGeometry(1,1);
        r.translate(.5, -.5, 0),
        this._debugMaterial = new RawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_transform: {
                    value: new Vector4(0,0,1,1)
                }
            },
            vertexShader: this.precisionPrefix + debugVert,
            fragmentShader: this.precisionPrefix + blitFrag,
            depthTest: !1,
            depthWrite: !1,
            blending: NoBlending
        }),
        this._debugMesh = new Mesh(r,this._debugMaterial),
        this._debugScene = new Scene,
        this._debugScene.frustumCulled = !1,
        this._debugScene.add(this._debugMesh)
    }
    copy(e, t) {
        const r = this.copyMaterial;
        r && (r.uniforms.u_texture.value = e,
        this.render(r, t))
    }
    uvCopy(e, t) {
        const r = this.uvCopyMaterial;
        r && (r.uniforms.u_texture.value = e,
        this.render(r, t))
    }
    render(e, t) {
        this._tri && this.renderer && this._scene && this._camera && (this._tri.material = e,
        t && this.renderer.setRenderTarget(t),
        this.renderer.render(this._scene, this._camera))
    }
    renderGeometry(e, t, r) {
        this._tri && this.triGeom && (this._tri.geometry = e,
        this.render(t, r),
        this._tri.geometry = this.triGeom)
    }
    renderMesh(e, t, r=this._camera) {
        this._tri && this.renderer && this._scene && r && (this._tri.visible = !1,
        this._scene.add(e),
        t && this.renderer.setRenderTarget(t || null),
        this.renderer.render(this._scene, r),
        t && this.renderer.setRenderTarget(null),
        this._scene.remove(e),
        this._tri.visible = !0)
    }
    debugTo(e, t, r, n, o) {
        if (!(this.renderer && this._debugMaterial && this._debugScene && this._camera))
            return;
        t = t || e.width || e.image.width,
        r = r || e.height || e.image.height,
        n = n || 0,
        o = o || 0;
        const l = this.renderer.getSize(new Vector2);
        n = n / l.width * 2 - 1,
        o = 1 - o / l.height * 2,
        t = t / l.width * 2,
        r = r / l.height * 2,
        this._debugMaterial.uniforms.u_texture.value = e,
        this._debugMaterial.uniforms.u_transform.value.set(n, o, t, r);
        const c = this.getColorState();
        this.renderer.autoClearColor = !1,
        this.renderer.setRenderTarget(null),
        this.renderer.render(this._debugScene, this._camera),
        this.setColorState(c)
    }
    parseDefines(e) {
        let t = "";
        for (const r in e) {
            const n = e[r];
            n === !0 ? t += `#define ${r}
` : t += `#define ${r} ${n}
`
        }
        return t
    }
    clearColor(e, t, r, n, o) {
        this.clearMaterial && (this.clearMaterial.uniforms.u_color.value.set(e, t, r, n),
        this.render(this.clearMaterial, o))
    }
    getColorState() {
        if (!this.renderer)
            return {
                autoClear: !0,
                autoClearColor: !0,
                autoClearStencil: !0,
                autoClearDepth: !0,
                clearColor: 0,
                clearAlpha: 1
            };
        const e = new Color;
        return this.renderer.getClearColor(e),
        {
            autoClear: this.renderer.autoClear,
            autoClearColor: this.renderer.autoClearColor,
            autoClearStencil: this.renderer.autoClearStencil,
            autoClearDepth: this.renderer.autoClearDepth,
            clearColor: e.getHex(),
            clearAlpha: this.renderer.getClearAlpha()
        }
    }
    setColorState(e) {
        this.renderer && (this.renderer.setClearColor(e.clearColor, e.clearAlpha),
        this.renderer.autoClear = e.autoClear,
        this.renderer.autoClearColor = e.autoClearColor,
        this.renderer.autoClearStencil = e.autoClearStencil,
        this.renderer.autoClearDepth = e.autoClearDepth)
    }
    createRawShaderMaterial(e) {
        e = Object.assign({
            depthTest: !1,
            depthWrite: !1,
            blending: NoBlending,
            vertexShader: blitVert,
            fragmentShader: blitFrag,
            derivatives: !1
        }, e),
        e.vertexShader = (e.vertexShaderPrefix ? e.vertexShaderPrefix : e.derivatives ? this.vertexPrefix : this.precisionPrefix) + e.vertexShader,
        e.fragmentShader = (e.fragmentShaderPrefix ? e.fragmentShaderPrefix : e.derivatives ? this.fragmentPrefix : this.precisionPrefix) + e.fragmentShader,
        delete e.vertexShaderPrefix,
        delete e.fragmentShaderPrefix,
        delete e.derivatives;
        let t = new RawShaderMaterial(e);
        return taskManager.add(t),
        t
    }
    createDataTexture(e, t, r, n=!1, o=!0) {
        let l = new DataTexture(e,t,r,RGBAFormat,n ? FloatType : UnsignedByteType,UVMapping,ClampToEdgeWrapping,ClampToEdgeWrapping,o ? NearestFilter : LinearFilter,o ? NearestFilter : LinearFilter,0);
        return l.needsUpdate = !0,
        l
    }
    createRenderTarget(e, t, r=!1, n=!1, o=0) {
        return new WebGLRenderTarget(e,t,{
            wrapS: ClampToEdgeWrapping,
            wrapT: ClampToEdgeWrapping,
            magFilter: r ? NearestFilter : LinearFilter,
            minFilter: r ? NearestFilter : LinearFilter,
            type: typeof n == "boolean" ? n ? this.floatType : UnsignedByteType : n,
            anisotropy: 0,
            encoding: LinearEncoding,
            depthBuffer: !1,
            stencilBuffer: !1,
            samples: browser$1.isSupportMSAA ? o : 0
        })
    }
    createMultisampleRenderTarget(e, t, r=!1, n=!1, o=8) {
        return !(this.renderer && this.isWebGL2) || !browser$1.isSupportMSAA ? this.createRenderTarget(e, t, r, n) : new WebGLRenderTarget(e,t,{
            wrapS: ClampToEdgeWrapping,
            wrapT: ClampToEdgeWrapping,
            magFilter: r ? NearestFilter : LinearFilter,
            minFilter: r ? NearestFilter : LinearFilter,
            type: n ? this.floatType : UnsignedByteType,
            anisotropy: 0,
            encoding: LinearEncoding,
            depthBuffer: !1,
            stencilBuffer: !1,
            samples: o
        })
    }
    clearMultisampleRenderTargetState(e) {
        if (e = e || this.renderer.getRenderTarget(),
        e && e.samples > 0) {
            const t = this.renderer.properties.get(e);
            let r = this.renderer.getContext();
            r.bindFramebuffer(r.READ_FRAMEBUFFER, t.__webglMultisampledFramebuffer),
            r.bindFramebuffer(r.DRAW_FRAMEBUFFER, t.__webglFramebuffer);
            const n = e.width
              , o = e.height;
            let l = r.COLOR_BUFFER_BIT;
            e.depthBuffer && (l |= r.DEPTH_BUFFER_BIT),
            e.stencilBuffer && (l |= r.STENCIL_BUFFER_BIT),
            r.blitFramebuffer(0, 0, n, o, 0, 0, n, o, l, r.NEAREST),
            r.bindFramebuffer(r.FRAMEBUFFER, t.__webglMultisampledFramebuffer)
        }
    }
}
const fboHelper = new FboHelper;
class Task {
    constructor(e) {
        Array.isArray(e) ? this.run = this.createMultiCallbackFunc(e) : this.run = this.createCallbackFunc(e)
    }
    run() {}
    createMultiCallbackFunc(e) {
        let t = [];
        for (let r = 0; r < e.length; r++)
            t.push(this.createCallbackFunc(e[r]));
        return function() {
            for (let r = 0; r < t.length; r++)
                t[r]()
        }
    }
    createCallbackFunc(e) {
        let t;
        return e.isRawShaderMaterial || e.isShaderMaterial ? t = this.createShaderMaterialFunc(e) : e.isObject3D ? t = this.createCompileSceneFunc(e) : e.isTexture ? t = this.createInitTextureFunc(e) : t = e,
        t
    }
    createShaderMaterialFunc(e) {
        return function() {
            fboHelper._tri.material = e,
            properties.renderer.compile(fboHelper._tri, properties.camera)
        }
    }
    createCompileSceneFunc(e) {
        return function() {
            e.traverse(r => {
                r._tmpVisible = r.visible,
                r.visible = !0
            }
            );
            let t = e.visible;
            e.visible = !0,
            properties.renderer.compile(e, properties.camera),
            e.traverse(r => {
                r.visible = r._tmpVisible
            }
            ),
            e.visible = t
        }
    }
    createInitTextureFunc(e) {
        return function() {
            properties.renderer.initTexture(e)
        }
    }
}
class TaskManager {
    percent = 1;
    taskList = [];
    _activeTaskList = [];
    _activeTaskIndex = 0;
    _needsStart = !1;
    onCompleted = new MinSignal$2;
    start() {
        this._needsStart = !0,
        this.percent = 0
    }
    _start() {
        this._needsStart = !1,
        this._activeTaskList = this.taskList.splice(0, this.taskList.length),
        this._activeTaskIndex = 0
    }
    add(e) {
        settings.SKIP_ANIMATION || this.taskList.push(new Task(e))
    }
    update() {
        if (this._needsStart && this._start(),
        this._activeTaskList.length) {
            let e = this._activeTaskList[this._activeTaskIndex];
            e && (this._activeTaskIndex++,
            this.percent = this._activeTaskIndex / this._activeTaskList.length,
            e.run())
        } else {
            let e = this.percent;
            this.percent = 1,
            e < 1 && this.onCompleted.dispatch()
        }
    }
}
const taskManager = new TaskManager;
class Page {
    domContainer;
    route = null;
    time = 0;
    showDuration = 1;
    hideDuration = 1;
    showRatio = 0;
    hideRatio = 0;
    _showPageTween;
    _hidePageTween;
    isActive = !1;
    hasInitialized = !1;
    hasExtraPages = !0;
    hasEndVisual = !0;
    endVisualColor = properties.blueColorHex;
    endVisualUseTextured = !1;
    endSectionActiveThreshold = .9;
    useGenericTransition = !0;
    isFirstShown = !1;
    bypassShowingLoading = !1;
    preUfxContainer = new Object3D;
    postUfxContainer = new Object3D;
    onShowStarted = new MinSignal$2;
    onShowCompleted = new MinSignal$2;
    onHideStarted = new MinSignal$2;
    onHideCompleted = new MinSignal$2;
    constructor() {
        this._showPageTween = new Tween(this),
        this._hidePageTween = new Tween(this)
    }
    get activeRatio() {
        return this.showRatio * (1 - this.hideRatio)
    }
    hasProject(e) {
        return !1
    }
    get isScrollTarget() {
        return pagesManager.scrollTargetPage === this
    }
    preInit(e) {}
    preInitContent(e) {}
    init(e) {
        taskManager.add(this.preUfxContainer),
        taskManager.add(this.postUfxContainer)
    }
    initContent(e) {}
    show(e, t, r) {
        this._showPageTween.kill(),
        this._showPageTween.onComplete = r,
        this.hideRatio = 0,
        this._showPageTween.fromTo(this.showDuration, {
            showRatio: 0
        }, {
            showRatio: 1
        })
    }
    hide(e, t, r) {
        this._hidePageTween && this._hidePageTween.kill(),
        this._hidePageTween.onComplete = r,
        this._hidePageTween.fromTo(this.hideDuration, {
            hideRatio: 0
        }, {
            hideRatio: 1
        })
    }
    resize(e, t) {}
    update(e) {}
}
let self$1;
class Ease {
    quadIn(e) {
        return e * e
    }
    quadOut(e) {
        return e * (2 - e)
    }
    quadOutIn(e) {
        return e < .5 ? self$1.quadOut(e + e) * .5 : self$1.quadIn(e + e - 1) * .5 + .5
    }
    quadInOut(e) {
        return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
    }
    cubicIn(e) {
        return e * e * e
    }
    cubicOut(e) {
        return --e * e * e + 1
    }
    cubicOutIn(e) {
        return e < .5 ? self$1.cubicOut(e + e) * .5 : self$1.cubicIn(e + e - 1) * .5 + .5
    }
    cubicInOut(e) {
        return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
    }
    quartIn(e) {
        return e * e * e * e
    }
    quartOut(e) {
        return 1 - --e * e * e * e
    }
    quartOutIn(e) {
        return e < .5 ? self$1.quartOut(e + e) * .5 : self$1.quartIn(e + e - 1) * .5 + .5
    }
    quartInOut(e) {
        return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
    }
    quintIn(e) {
        return e * e * e * e * e
    }
    quintOut(e) {
        return --e * e * e * e * e + 1
    }
    quintOutIn(e) {
        return e < .5 ? self$1.quintOut(e + e) * .5 : self$1.quintIn(e + e - 1) * .5 + .5
    }
    quintInOut(e) {
        return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
    }
    sineIn(e) {
        return 1 - Math.cos(e * Math.PI / 2)
    }
    sineOut(e) {
        return Math.sin(e * Math.PI / 2)
    }
    sineOutIn(e) {
        return e < .5 ? self$1.sineOut(e + e) * .5 : self$1.sineIn(e + e - 1) * .5 + .5
    }
    sineInOut(e) {
        return .5 * (1 - Math.cos(Math.PI * e))
    }
    expoIn(e) {
        return e === 0 ? 0 : Math.pow(1024, e - 1)
    }
    expoOut(e) {
        return e === 1 ? 1 : 1 - Math.pow(2, -10 * e)
    }
    expoOutIn(e) {
        return e < .5 ? self$1.expoOut(e + e) * .5 : self$1.expoIn(e + e - 1) * .5 + .5
    }
    expoInOut(e) {
        return e === 0 ? 0 : e === 1 ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (-Math.pow(2, -10 * (e - 1)) + 2)
    }
    circIn(e) {
        return 1 - Math.sqrt(1 - e * e)
    }
    circOut(e) {
        return Math.sqrt(1 - --e * e)
    }
    circOutIn(e) {
        return e < .5 ? self$1.circOut(e + e) * .5 : self$1.circIn(e + e - 1) * .5 + .5
    }
    circInOut(e) {
        return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
    }
    elasticIn(e) {
        let t, r = .1, n = .4;
        return e === 0 ? 0 : e === 1 ? 1 : (!r || r < 1 ? (r = 1,
        t = n / 4) : t = n * Math.asin(1 / r) / (2 * Math.PI),
        -(r * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * 2 * Math.PI / n)))
    }
    elasticOut(e) {
        let t, r = .1, n = .4;
        return e === 0 ? 0 : e === 1 ? 1 : (!r || r < 1 ? (r = 1,
        t = n / 4) : t = n * Math.asin(1 / r) / (2 * Math.PI),
        r * Math.pow(2, -10 * e) * Math.sin((e - t) * 2 * Math.PI / n) + 1)
    }
    elasticOutIn(e) {
        return e < .5 ? self$1.elasticOut(e + e) * .5 : self$1.elasticIn(e + e - 1) * .5 + .5
    }
    elasticInOut(e) {
        let t, r = .1, n = .4;
        return e === 0 ? 0 : e === 1 ? 1 : (!r || r < 1 ? (r = 1,
        t = n / 4) : t = n * Math.asin(1 / r) / (2 * Math.PI),
        (e *= 2) < 1 ? -.5 * r * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * 2 * Math.PI / n) : r * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - t) * 2 * Math.PI / n) * .5 + 1)
    }
    backIn(e) {
        let t = 1.70158;
        return e * e * ((t + 1) * e - t)
    }
    backOut(e) {
        let t = 1.70158;
        return --e * e * ((t + 1) * e + t) + 1
    }
    backOutIn(e) {
        return e < .5 ? self$1.backOut(e + e) * .5 : self$1.backIn(e + e - 1) * .5 + .5
    }
    backInOut(e) {
        let t = 2.5949095;
        return (e *= 2) < 1 ? .5 * e * e * ((t + 1) * e - t) : .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
    }
    bounceIn(e) {
        return 1 - self$1.bounceOut(1 - e)
    }
    bounceOut(e) {
        return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
    }
    bounceOutIn(e) {
        return e < .5 ? self$1.bounceOut(e + e) * .5 : self$1.bounceIn(e + e - 1) * .5 + .5
    }
    bounceInOut(e) {
        return e < .5 ? self$1.bounceIn(e * 2) * .5 : self$1.bounceOut(e * 2 - 1) * .5 + .5
    }
    lusion(e) {
        return self$1.cubicBezier(e, .35, 0, 0, 1)
    }
    cubicBezier(e, t, r, n, o) {
        if (e <= 0)
            return 0;
        if (e >= 1)
            return 1;
        if (t === r && n === o)
            return e;
        const l = (B, D, q, V) => 1 / (3 * D * B * B + 2 * q * B + V)
          , c = (B, D, q, V, J) => D * (B * B * B) + q * (B * B) + V * B + J
          , u = (B, D, q, V, J) => {
            let U = B * B;
            return D * (U * B) + q * U + V * B + J
        }
        ;
        let f = 0, p = 0, g = t, v = r, _ = n, w = o, S = 1, b = 1, C = S - 3 * _ + 3 * g - f, R = 3 * _ - 6 * g + 3 * f, T = 3 * g - 3 * f, M = f, P = b - 3 * w + 3 * v - p, I = 3 * w - 6 * v + 3 * p, k = 3 * v - 3 * p, A = p, O = e, W, Q, H;
        for (W = 0; W < 100; W++)
            Q = c(O, C, R, T, M),
            H = l(O, C, R, T),
            H === 1 / 0 && (H = e),
            O -= (Q - e) * H,
            O = Math.min(Math.max(O, 0), 1);
        return u(O, P, I, k, A)
    }
}
self$1 = new Ease;
const ease = self$1
  , vert$l = `#define GLSLIFY 1
attribute vec3 daoN;attribute vec3 daoP;attribute float ao;attribute float thickness;attribute vec3 SN;uniform vec3 u_lightPosition;uniform vec4 u_selfPositionRadius;uniform vec4 u_selfRotation;uniform float u_time;varying vec3 v_viewPosition;varying vec3 v_worldPosition;varying vec3 v_viewNormal;varying vec3 v_smoothViewNormal;varying vec2 v_uv;varying vec3 v_localPosition;varying float v_ao;varying float v_thickness;varying float v_selfShadow;vec3 qrotate(vec3 v,vec4 q){return v+2.*cross(q.xyz,cross(q.xyz,v)+q.w*v);}void main(){v_localPosition=position;vec4 mvPosition=modelViewMatrix*vec4(position,1.);gl_Position=projectionMatrix*mvPosition;vec3 worldPosition=(modelMatrix*vec4(position,1.)).xyz;vec4 invertedQuat=vec4(-u_selfRotation.xyz,u_selfRotation.w);vec3 L=(u_lightPosition-worldPosition)/u_selfPositionRadius.w;L=normalize(qrotate(L,invertedQuat));vec3 dao=mix(daoN,daoP,sign(L)*.5+.5);vec3 absDir=abs(L);float selfShadow=dot(absDir,dao)/(absDir.x+absDir.y+absDir.z);selfShadow=min(pow(selfShadow*3.,0.3)*1.45,1.);v_worldPosition=worldPosition;v_viewNormal=normalMatrix*normal;v_smoothViewNormal=normalMatrix*SN;v_viewPosition=-mvPosition.xyz;v_uv=uv;v_ao=ao;v_thickness=thickness;v_selfShadow=selfShadow;}`
  , frag$p = `#define GLSLIFY 1
varying vec3 v_viewNormal;varying vec3 v_smoothViewNormal;varying vec3 v_viewPosition;varying vec3 v_worldPosition;varying vec2 v_uv;varying vec3 v_localPosition;varying float v_ao;varying float v_selfShadow;uniform vec4 u_nearPositionRadiusList[NEIGHBOUR_COUNT];uniform vec4 u_nearRotationList[NEIGHBOUR_COUNT];uniform vec3 u_nearColorList[NEIGHBOUR_COUNT];uniform vec2 u_nearTransparencyLumaList[NEIGHBOUR_COUNT];uniform float u_roughness;uniform vec3 u_bgColor;uniform vec3 u_color;uniform float u_time;uniform mat4 projectionMatrix;uniform sampler2D u_matcap;uniform vec3 u_lightPosition;const float PI=3.14159265359;const float RECIPROCAL_PI=0.31830988618;
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
varying float v_thickness;
#include <textureBicubic>
#include <getBlueNoise>
#ifdef IS_SEMITRANSPARENT_BACK
uniform sampler2D u_sceneTexture;
#endif
#ifdef IS_SEMITRANSPARENT
uniform sampler2D u_sceneTexture;uniform sampler2D u_blurredTextures[4];uniform vec2 u_blurredTextureSizes[4];vec4 lodSample(vec2 uv,float lod){lod=clamp(lod,1.,3.999);float lodFloor=floor(lod);float lodFract=lod-lodFloor;vec4 mapFrom;vec4 mapTo;if(lodFloor<1.5){mapFrom=textureBicubic(u_blurredTextures[0],uv,u_blurredTextureSizes[0]);mapTo=textureBicubic(u_blurredTextures[1],uv,u_blurredTextureSizes[1]);}else if(lodFloor<2.5){mapFrom=textureBicubic(u_blurredTextures[1],uv,u_blurredTextureSizes[1]);mapTo=textureBicubic(u_blurredTextures[2],uv,u_blurredTextureSizes[2]);}else{mapFrom=textureBicubic(u_blurredTextures[2],uv,u_blurredTextureSizes[2]);mapTo=textureBicubic(u_blurredTextures[3],uv,u_blurredTextureSizes[3]);}return mix(mapFrom,mapTo,lodFract);}
#endif
uniform float u_sss;uniform vec3 u_sssColor;vec3 qrotate(vec3 v,vec4 q){return v+2.*cross(q.xyz,cross(q.xyz,v)+q.w*v);}float cylIntersect(in vec3 ro,in vec3 rd,in vec3 a,in vec3 b,float ra){vec3 ba=b-a;vec3 oc=ro-a;float baba=dot(ba,ba);float bard=dot(ba,rd);float baoc=dot(ba,oc);float k2=baba-bard*bard;float k1=baba*dot(oc,rd)-baoc*bard;float k0=baba*dot(oc,oc)-baoc*baoc-ra*ra*baba;float h=k1*k1-k2*k0;if(h>=0.){h=sqrt(h);float t=(-k1-h)/k2;float y=baoc+t*bard;if(y>0.0&&y<baba)return t;t=(((y<0.0)? 0.0 : baba)-baoc)/bard;if(abs(k1+k2*t)<h){return t;}}return 200.;}bool centerSphereHitTest(in vec3 ro,in vec3 rd,in float r){float b=dot(ro,rd);float c=dot(ro,ro)-r*r;return b*b-c>=0.0;}vec3 getCrossAoShadowIntersect(in vec3 p,in vec3 n,in vec3 l,in vec3 refl,in vec4 objPosRadius,in vec4 quaternion,in float intersectDist){float ao=1.0;float shadow=1.0;float intersect=100.0;float R=0.666667*objPosRadius.w;float r=0.333333*objPosRadius.w;vec3 centerPos=objPosRadius.xyz;vec3 invertedPosOffset=-objPosRadius.xyz;vec4 invertedQuat=vec4(-quaternion.xyz,quaternion.w);p=qrotate(p+invertedPosOffset,invertedQuat);l=normalize(qrotate(l+invertedPosOffset,invertedQuat));n=qrotate(n,invertedQuat);refl=qrotate(refl,invertedQuat);vec3 ro=p,pa=vec3(-R),pb=vec3(R);float k=1.;vec3 ba=pb-pa;vec3 oa=ro-pa;vec3 oaX=vec3(oa.x,ro.y,ro.z);vec3 oaY=vec3(ro.x,oa.y,ro.z);vec3 oaZ=vec3(ro.x,ro.y,oa.z);vec3 baba=ba*ba;vec3 oaba=oa*ba;vec3 h3=clamp(oaba/baba,vec3(0.),vec3(1.));vec3 odX=oaX-vec3(h3.x*ba.x,0.,0.);vec3 odY=oaY-vec3(0.,h3.y*ba.y,0.);vec3 odZ=oaZ-vec3(0.,0.,h3.z*ba.z);vec3 dl3=vec3(length(odX),length(odY),length(odZ));vec3 o3=vec3(1.)-saturate(vec3(dot(-odX,n),dot(-odY,n),dot(-odZ,n))*r*r/(dl3*dl3*dl3));o3=sqrt(o3*o3*o3);ao=o3.x*o3.y*o3.z;vec3 oad=vec3(dot(oaX,l),dot(oaY,l),dot(oaZ,l));vec3 dba=l*ba;vec3 thDiv=1./(baba-dba*dba);vec3 thX3=max((-oad*baba+dba*oaba)*thDiv,vec3(0.0001));vec3 thY3=saturate((oaba-oad*dba)*thDiv);vec3 pp=pa+ba*thY3;vec3 qqX=ro+l*thX3.x;vec3 qqY=ro+l*thX3.y;vec3 qqZ=ro+l*thX3.z;vec3 dd=vec3(length(vec3(pp.x,0.,0.)-qqX),length(vec3(0.,pp.y,0.)-qqY),length(vec3(0.,0.,pp.z)-qqZ))-r;vec3 s=saturate(k*dd/thX3+0.5);s=s*s*(3.0-2.0*s);shadow=s.x*s.y*s.z;vec3 a;vec3 b;r*=0.9;if((intersectDist+2.05>length(p)-objPosRadius.w)&&centerSphereHitTest(ro,refl,objPosRadius.w*1.1)){a=vec3(-objPosRadius.w,0.0,0.0);b=vec3(objPosRadius.w,0.0,0.0);intersect=min(intersect,cylIntersect(p,refl,a,b,r));a=vec3(0.0,-objPosRadius.w,0.0);b=vec3(0.0,objPosRadius.w,0.0);intersect=min(intersect,cylIntersect(p,refl,a,b,r));a=vec3(0.0,0.0,-objPosRadius.w);b=vec3(0.0,0.0,objPosRadius.w);intersect=min(intersect,cylIntersect(p,refl,a,b,r));}return vec3(ao,shadow,intersect);}vec2 getUvFromPos(vec3 v){vec4 ndcPos=projectionMatrix*viewMatrix*vec4(v,1.0);vec2 refractionCoords=ndcPos.xy/ndcPos.w;refractionCoords+=1.0;refractionCoords/=2.0;return refractionCoords;}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}vec3 filmicToneMapping(vec3 color){color=max(vec3(0.),color-vec3(0.004));color=(color*(6.2*color+.5))/(color*(6.2*color+1.7)+0.06);return color;}vec3 hueShift(vec3 color,float hue){const vec3 k=vec3(0.57735,0.57735,0.57735);float cosAngle=cos(hue);return vec3(color*cosAngle+cross(k,color)*sin(hue)+k*dot(k,color)*(1.0-cosAngle));}vec3 hue2RGBSmooth(in float hue){vec3 rgb=clamp(abs(mod(hue*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);return rgb*rgb*(3.0-2.0*rgb);}void main(){vec3 blueNoise=getBlueNoise(gl_FragCoord.xy+vec2(3.,9.));vec3 blueNoise2=getBlueNoise(gl_FragCoord.xy+vec2(56.,39.));float faceDirection=gl_FrontFacing ? 1.0 :-1.0;vec3 viewNormal=faceDirection*normalize(v_viewNormal);vec3 smoothViewNormal=faceDirection*normalize(v_smoothViewNormal);vec3 V=normalize(cameraPosition-v_worldPosition);vec3 N=inverseTransformDirection(viewNormal,viewMatrix);vec3 SN=inverseTransformDirection(smoothViewNormal,viewMatrix);float roughness=min(0.9,u_roughness+dot(vec3(1.0),fwidth((viewNormal))));vec3 reflectView=reflect(-V,N);vec3 reflectViewBN=normalize(reflectView+(blueNoise-.5)*(roughness>0.5 ? 0.5 : 0.01));vec3 worldToLight=u_lightPosition-v_worldPosition;vec3 L=normalize(worldToLight);float NdV=clamp(abs(dot(N,V)),0.001,1.0);float NdL=clamp(dot(N,L),0.001,1.0);vec3 gi=vec3(1.0);vec4 reflections=vec4(0.,0.,0.,100.);float ao=1.0;float shadow=1.0;float alpha=0.0;vec3 albedo=vec3(1.0);for(int i=0;i<NEIGHBOUR_COUNT;i++){vec3 nearColor=u_nearColorList[i];vec2 nearTransparencyLuma=u_nearTransparencyLumaList[i].xy;vec3 aoShadowIntersect=getCrossAoShadowIntersect(v_worldPosition,N,worldToLight,reflectViewBN,u_nearPositionRadiusList[i],u_nearRotationList[i],reflections.w);float _ao=aoShadowIntersect.r;_ao=saturate(_ao+0.5*nearTransparencyLuma.x);ao*=_ao;shadow*=aoShadowIntersect.g;gi+=(1.0-0.9*nearTransparencyLuma.y)*nearColor*3.0*min(1.,(1.0-_ao*_ao)/0.7);float neighNearFarDist=aoShadowIntersect.b;if(neighNearFarDist<reflections.w&&neighNearFarDist>0.0001){reflections=vec4(vec3((1.0-0.5*nearTransparencyLuma.x)*nearColor),neighNearFarDist);}}reflections.rgb*=1./((0.2+roughness*0.8)*reflections.w*10.+4.);reflections=reflections*ao*v_ao;gi/=float(NEIGHBOUR_COUNT);
#if defined(IS_SEMITRANSPARENT) || defined(IS_SEMITRANSPARENT_BACK)
float ior=2.4;
#ifdef IS_SEMITRANSPARENT
vec3 refractionVector=refract(-V,SN,1.0/ior);vec2 refractionCoords=getUvFromPos(v_worldPosition+refractionVector*0.3);float lod=2.5+v_thickness;vec4 blur=lodSample(refractionCoords,lod);albedo=blur.rgb*(0.75+u_color*0.4);albedo=albedo*0.8+(0.125+0.2*v_selfShadow*v_ao)*u_color;
#else
vec3 refractionVector=refract(-V,-N,ior);vec2 refractionCoords=getUvFromPos(v_worldPosition+refractionVector*ao*0.5);albedo=texture2D(u_sceneTexture,refractionCoords).rgb;albedo=albedo*0.5+(0.05+0.2*v_selfShadow*v_ao)*u_color;
#endif
#endif
albedo*=u_color;vec3 viewDir=normalize(v_viewPosition);vec3 x=normalize(vec3(viewDir.z,0.0,-viewDir.x));vec3 y=cross(viewDir,x);
#ifdef IS_SEMITRANSPARENT
vec2 uvPerturbed=vec2(dot(x,smoothViewNormal),dot(y,smoothViewNormal))*0.5+0.5;
#else
vec2 uvPerturbed=vec2(dot(x,viewNormal),dot(y,viewNormal))*0.5+0.5;
#endif
vec3 matcapMap=texture2D(u_matcap,uvPerturbed).rgb;vec3 matcapDiff=vec3(matcapMap.r);vec3 matcapSpec=vec3(roughness>.5 ? matcapMap.g : matcapMap.b);reflections.rgb*=0.75+0.25*shadow*v_selfShadow;matcapDiff=0.25+0.75*matcapDiff;matcapSpec=matcapSpec;shadow=0.6+0.4*shadow;float selfShadow=v_selfShadow;vec3 color;
#if defined(IS_SEMITRANSPARENT) || defined(IS_SEMITRANSPARENT_BACK)
float fresnel=(1.0-clamp(abs(dot(normalize(N+SN),V)),0.001,1.0))*(1.-v_thickness);color=albedo;color+=0.15*matcapDiff;color+=fresnel*albedo*0.5;
#ifdef IS_SEMITRANSPARENT
color+=reflections.rgb;color+=hue2RGBSmooth(viewNormal.z*v_ao*1.5)*pow(1.-v_thickness*0.75,2.)*max(vec3(0.),1.-matcapDiff)*0.2*dot(albedo,vec3(0.299,0.587,0.114));
#endif
color*=(selfShadow*0.35+0.65);color*=(ao*shadow*0.75+0.25);;
#else
color=albedo*matcapDiff+matcapSpec;color+=reflections.rgb;color*=ao;color+=gi;color*=selfShadow;color*=shadow;
#endif
gl_FragColor.rgb=color;gl_FragColor.a=max(0.,dot(color,vec3(0.299,0.587,0.114))*1.5-1.);gl_FragColor.rgb=filmicToneMapping(pow(gl_FragColor.rgb,vec3(2.2)));}`;
class Stage3D extends Scene {
    wasActive = null;
    isActive = null;
    constructor(e={}) {
        super(),
        Object.assign(this, {
            defaultCameraPosition: new Vector3(0,0,5),
            defaultLookAtPosition: new Vector3(0,0,0),
            properties: {}
        }, e)
    }
    preInit() {}
    init() {}
    resize(e, t) {}
    syncProperties(e) {}
    update(e) {}
}
const blur9VaryingVertexShader = `#define GLSLIFY 1
attribute vec3 position;uniform vec2 u_delta;varying vec2 v_uv[9];void main(){vec2 uv=position.xy*0.5+0.5;v_uv[0]=uv;vec2 delta=u_delta;v_uv[1]=uv-delta;v_uv[2]=uv+delta;delta+=u_delta;v_uv[3]=uv-delta;v_uv[4]=uv+delta;delta+=u_delta;v_uv[5]=uv-delta;v_uv[6]=uv+delta;delta+=u_delta;v_uv[7]=uv-delta;v_uv[8]=uv+delta;gl_Position=vec4(position,1.0);}`
  , blur9VaryingFragmentShader = `#define GLSLIFY 1
uniform sampler2D u_texture;varying vec2 v_uv[9];void main(){vec4 color=texture2D(u_texture,v_uv[0])*0.1633;color+=texture2D(u_texture,v_uv[1])*0.1531;color+=texture2D(u_texture,v_uv[2])*0.1531;color+=texture2D(u_texture,v_uv[3])*0.12245;color+=texture2D(u_texture,v_uv[4])*0.12245;color+=texture2D(u_texture,v_uv[5])*0.0918;color+=texture2D(u_texture,v_uv[6])*0.0918;color+=texture2D(u_texture,v_uv[7])*0.051;color+=texture2D(u_texture,v_uv[8])*0.051;gl_FragColor=color;}`
  , blur9FragmentShader = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec2 u_delta;varying vec2 v_uv;void main(){vec4 color=texture2D(u_texture,v_uv)*0.1633;vec2 delta=u_delta;color+=texture2D(u_texture,v_uv-delta)*0.1531;color+=texture2D(u_texture,v_uv+delta)*0.1531;delta+=u_delta;color+=texture2D(u_texture,v_uv-delta)*0.12245;color+=texture2D(u_texture,v_uv+delta)*0.12245;delta+=u_delta;color+=texture2D(u_texture,v_uv-delta)*0.0918;color+=texture2D(u_texture,v_uv+delta)*0.0918;delta+=u_delta;color+=texture2D(u_texture,v_uv-delta)*0.051;color+=texture2D(u_texture,v_uv+delta)*0.051;gl_FragColor=color;}`;
class Blur {
    material = null;
    getBlur9Material() {
        let e = fboHelper.MAX_VARYING_VECTORS > 8;
        return this.blur9Material || (this.blur9Material = new RawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_delta: {
                    value: new Vector2
                }
            },
            vertexShader: e ? fboHelper.precisionPrefix + blur9VaryingVertexShader : fboHelper.vertexShader,
            fragmentShader: fboHelper.precisionPrefix + (e ? blur9VaryingFragmentShader : blur9FragmentShader),
            depthWrite: !1,
            depthTest: !1
        })),
        this.blur9Material
    }
    blur(e, t, r, n, o, l) {
        let c = .25
          , u = Math.ceil(r.width * t) || 0
          , f = Math.ceil(r.height * t) || 0;
        this.material || (this.material = this.getBlur9Material()),
        n || console.warn("You have to pass intermediateRenderTarget to blur"),
        (u !== n.width || f !== n.height) && n.setSize(u, f),
        o ? l || o.setSize(r.width, r.height) : o = r,
        this.material.uniforms.u_texture.value = r.texture || r,
        this.material.uniforms.u_delta.value.set(e / u * c, 0),
        fboHelper.render(this.material, n),
        this.material.uniforms.u_texture.value = n.texture || n,
        this.material.uniforms.u_delta.value.set(0, e / f * c),
        fboHelper.render(this.material, o)
    }
}
const blur = new Blur;
class ShaderHelper {
    glslifyStrip(e) {
        return e.replace(/#define\sGLSLIFY\s./, "")
    }
    addChunk(e, t) {
        ShaderChunk[e] = this.glslifyStrip(t)
    }
    _wrapInclude(e) {
        return "#include <" + e + ">"
    }
    insertBefore(e, t, r, n) {
        const o = n ? this._wrapInclude(t) : t;
        return e.replace(t, this.glslifyStrip(r) + `
` + o)
    }
    insertAfter(e, t, r, n) {
        const o = n ? this._wrapInclude(t) : t;
        return e.replace(o, o + `
` + this.glslifyStrip(r) + `
`)
    }
    replace(e, t, r, n) {
        const o = n ? this._wrapInclude(t) : t;
        return e.replace(o, `
` + this.glslifyStrip(r) + `
`)
    }
}
const shaderHelper = new ShaderHelper
  , getBlueNoiseShader = `#define GLSLIFY 1
uniform sampler2D u_blueNoiseTexture;uniform vec2 u_blueNoiseTexelSize;uniform vec2 u_blueNoiseCoordOffset;vec3 getBlueNoise(vec2 coord){return texture2D(u_blueNoiseTexture,coord*u_blueNoiseTexelSize+u_blueNoiseCoordOffset).rgb;}vec3 getStaticBlueNoise(vec2 coord){return texture2D(u_blueNoiseTexture,coord*u_blueNoiseTexelSize).rgb;}`;
class BlueNoise {
    sharedUniforms = {
        u_blueNoiseTexture: {
            value: null
        },
        u_blueNoiseLinearTexture: {
            value: null
        },
        u_blueNoiseTexelSize: {
            value: null
        },
        u_blueNoiseCoordOffset: {
            value: new Vector2
        }
    };
    TEXTURE_SIZE = 128;
    preInit() {
        let e = new Texture;
        e.generateMipmaps = !1,
        e.minFilter = e.magFilter = LinearFilter,
        e.wrapS = e.wrapT = RepeatWrapping;
        let t = new Texture(properties.loader.add(settings.TEXTURE_PATH + "LDR_RGB1_0.png", {
            weight: 55,
            onLoad: function() {
                t.needsUpdate = !0,
                e.needsUpdate = !0
            }
        }).content);
        e.image = t.image,
        t.generateMipmaps = !1,
        t.minFilter = t.magFilter = NearestFilter,
        t.wrapS = t.wrapT = RepeatWrapping,
        this.sharedUniforms.u_blueNoiseTexture.value = t,
        this.sharedUniforms.u_blueNoiseLinearTexture.value = e,
        this.sharedUniforms.u_blueNoiseTexelSize.value = new Vector2(1 / this.TEXTURE_SIZE,1 / this.TEXTURE_SIZE),
        shaderHelper.addChunk("getBlueNoise", getBlueNoiseShader)
    }
    update(e) {
        this.sharedUniforms.u_blueNoiseCoordOffset.value.set(Math.random(), Math.random())
    }
}
const blueNoise = new BlueNoise
  , COLORS$1 = settings.BALLOON_COLOR ? ["#" + settings.BALLOON_COLOR] : ["#061dfb", "#ADFF00", "#f6000e", "#7e09f5", "#ffc000"]
  , colorIndex = Math.floor(Math.random() * COLORS$1.length)
  , fancyColor = COLORS$1[colorIndex]
  , _c$1 = new Color(fancyColor);
_c$1.offsetHSL(0, 0, .5);
let SOFT_PLASTIC, HARD_PLASTIC, GLASS, STONE;
SOFT_PLASTIC = HARD_PLASTIC = GLASS = STONE = {
    density: 1,
    friction: 2,
    restitution: .8
};
let sphereData = [{
    color: fancyColor,
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !0,
    isBlackWhite: !1,
    radius: 1,
    ...SOFT_PLASTIC
}, {
    color: fancyColor,
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !0,
    isBlackWhite: !1,
    radius: 1,
    ...SOFT_PLASTIC
}, {
    color: fancyColor,
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !1,
    isColored: !0,
    isBlackWhite: !1,
    radius: 1,
    ...HARD_PLASTIC
}, {
    color: "#ffffff",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...SOFT_PLASTIC
}, {
    color: "#ffffff",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...SOFT_PLASTIC
}, {
    color: "#ffffff",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...SOFT_PLASTIC
}, {
    color: "#ffffff",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !1,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...HARD_PLASTIC
}, {
    color: "#111",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...STONE
}, {
    color: "#111",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...STONE
}, {
    color: "#111",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...STONE
}, {
    color: "#111",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !1,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...HARD_PLASTIC
}, {
    color: fancyColor,
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !0,
    isBlackWhite: !1,
    radius: 1,
    ...SOFT_PLASTIC
}, {
    color: fancyColor,
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !0,
    isBlackWhite: !1,
    radius: 1,
    ...SOFT_PLASTIC
}, {
    color: fancyColor,
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !1,
    isColored: !0,
    isBlackWhite: !1,
    radius: 1,
    ...HARD_PLASTIC
}, {
    color: "#ffffff",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...SOFT_PLASTIC
}, {
    color: "#ffffff",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...SOFT_PLASTIC
}, {
    color: "#ffffff",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...SOFT_PLASTIC
}, {
    color: "#ffffff",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !1,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...HARD_PLASTIC
}, {
    color: "#111",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...STONE
}, {
    color: "#111",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...STONE
}, {
    color: "#111",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !0,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...STONE
}, {
    color: "#111",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !1,
    isRough: !1,
    isColored: !1,
    isBlackWhite: !1,
    radius: 1,
    ...HARD_PLASTIC
}];
browser$1.isMobile || sphereData.push({
    color: "#fff",
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !0,
    isRough: !0,
    isColored: !1,
    isBlackWhite: !0,
    radius: 1,
    ...GLASS
}, {
    color: "#" + _c$1.getHexString(),
    sss: 0,
    sssColor: "#111",
    isSemitransparent: !0,
    isRough: !0,
    isColored: !0,
    isBlackWhite: !1,
    radius: 1,
    ...GLASS
});
const SPHERES_DATA = sphereData
  , vert$k = `#define GLSLIFY 1
uniform vec2 u_clipScale;uniform vec2 u_clipOffset;varying vec2 v_uv;void main(){vec3 pos=position;vec3 absPos=abs(position);if(max(absPos.x,absPos.y)<0.9){pos.xy=pos.xy*u_clipScale+u_clipOffset;pos*=2.;}gl_Position=vec4(pos,1.0);v_uv=vec2(pos.x,pos.y)*0.5+0.5;}`
  , frag$o = `#define GLSLIFY 1
uniform vec3 u_color0;uniform vec3 u_color1;uniform vec3 u_colorPaint;uniform float u_aspect;uniform vec2 u_smooth;uniform vec2 u_resolution;uniform float u_activeRatio;uniform sampler2D u_screenPaintTexture;varying vec2 v_uv;
#include <getBlueNoise>
void main(){vec3 noise=getBlueNoise(gl_FragCoord.xy);vec2 q=vec2(v_uv-0.5);q.x*=u_aspect;float dst=length(q);dst=smoothstep(u_smooth.x,u_smooth.y,dst);vec3 color=mix(u_color0,u_color1,0.925+0.075*dst);color+=noise*0.004;gl_FragColor.rgb=color;gl_FragColor.a=0.0;}`
  , frag$n = `#define GLSLIFY 1
uniform sampler2D u_lowPaintTexture;uniform sampler2D u_prevPaintTexture;uniform vec2 u_paintTexelSize;uniform vec2 u_scrollOffset;uniform vec4 u_drawFrom;uniform vec4 u_drawTo;uniform float u_pushStrength;uniform vec3 u_dissipations;uniform vec2 u_vel;varying vec2 v_uv;vec2 sdSegment(in vec2 p,in vec2 a,in vec2 b){vec2 pa=p-a,ba=b-a;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return vec2(length(pa-ba*h),h);}
#ifdef USE_NOISE
uniform float u_curlScale;uniform float u_curlStrength;vec2 hash(vec2 p){vec3 p3=fract(vec3(p.xyx)*vec3(.1031,.1030,.0973));p3+=dot(p3,p3.yzx+33.33);return fract((p3.xx+p3.yz)*p3.zy)*2.0-1.0;}vec3 noised(in vec2 p){vec2 i=floor(p);vec2 f=fract(p);vec2 u=f*f*f*(f*(f*6.0-15.0)+10.0);vec2 du=30.0*f*f*(f*(f-2.0)+1.0);vec2 ga=hash(i+vec2(0.0,0.0));vec2 gb=hash(i+vec2(1.0,0.0));vec2 gc=hash(i+vec2(0.0,1.0));vec2 gd=hash(i+vec2(1.0,1.0));float va=dot(ga,f-vec2(0.0,0.0));float vb=dot(gb,f-vec2(1.0,0.0));float vc=dot(gc,f-vec2(0.0,1.0));float vd=dot(gd,f-vec2(1.0,1.0));return vec3(va+u.x*(vb-va)+u.y*(vc-va)+u.x*u.y*(va-vb-vc+vd),ga+u.x*(gb-ga)+u.y*(gc-ga)+u.x*u.y*(ga-gb-gc+gd)+du*(u.yx*(va-vb-vc+vd)+vec2(vb,vc)-va));}
#endif
void main(){vec2 res=sdSegment(gl_FragCoord.xy,u_drawFrom.xy,u_drawTo.xy);vec2 radiusWeight=mix(u_drawFrom.zw,u_drawTo.zw,res.y);float d=1.0-smoothstep(-0.01,radiusWeight.x,res.x);vec4 lowData=texture2D(u_lowPaintTexture,v_uv-u_scrollOffset);vec2 velInv=(0.5-lowData.xy)*u_pushStrength;
#ifdef USE_NOISE
vec3 noise3=noised(gl_FragCoord.xy*u_curlScale*(1.0-lowData.xy));vec2 noise=noised(gl_FragCoord.xy*u_curlScale*(2.0-lowData.xy*(0.5+noise3.x)+noise3.yz*0.1)).yz;velInv+=noise*(lowData.z+lowData.w)*u_curlStrength;
#endif
vec4 data=texture2D(u_prevPaintTexture,v_uv-u_scrollOffset+velInv*u_paintTexelSize);data.xy-=0.5;vec4 delta=(u_dissipations.xxyz-1.0)*data;vec2 newVel=u_vel*d;delta+=vec4(newVel,radiusWeight.yy*d);delta.zw=sign(delta.zw)*max(vec2(0.004),abs(delta.zw));data+=delta;data.xy+=0.5;gl_FragColor=clamp(data,vec4(0.0),vec4(1.0));}`;
let _v$4 = new Vector2;
class ScreenPaint {
    _lowRenderTarget;
    _lowBlurRenderTarget;
    _prevPaintRenderTarget;
    _currPaintRenderTarget;
    _material;
    _material2;
    _distortionMaterial;
    _fromDrawData;
    _toDrawData;
    drawEnabled = !0;
    needsMouseDown = !1;
    enabled = !0;
    minRadius = 0;
    maxRadius = 100;
    radiusDistanceRange = 100;
    pushStrength = 25;
    accelerationDissipation = .8;
    velocityDissipation = .985;
    weight1Dissipation = .985;
    weight2Dissipation = .5;
    useNoise = !1;
    curlScale = .1;
    curlStrength = 5;
    _prevUseNoise = null;
    sharedUniforms = {
        u_paintTexelSize: {
            value: new Vector2
        },
        u_paintTextureSize: {
            value: new Vector2
        },
        u_prevPaintTexture: {
            value: null
        },
        u_currPaintTexture: {
            value: null
        },
        u_lowPaintTexture: {
            value: null
        }
    };
    init() {
        this._lowRenderTarget = fboHelper.createRenderTarget(1, 1),
        this._lowBlurRenderTarget = fboHelper.createRenderTarget(1, 1),
        this._prevPaintRenderTarget = fboHelper.createRenderTarget(1, 1),
        this._currPaintRenderTarget = fboHelper.createRenderTarget(1, 1),
        this.sharedUniforms.u_lowPaintTexture.value = this._lowRenderTarget.texture,
        this._material = fboHelper.createRawShaderMaterial({
            uniforms: {
                u_lowPaintTexture: {
                    value: this._lowRenderTarget.texture
                },
                u_prevPaintTexture: this.sharedUniforms.u_prevPaintTexture,
                u_paintTexelSize: this.sharedUniforms.u_paintTexelSize,
                u_drawFrom: {
                    value: this._fromDrawData = new Vector4(0,0,0,0)
                },
                u_drawTo: {
                    value: this._toDrawData = new Vector4(0,0,0,0)
                },
                u_pushStrength: {
                    value: 0
                },
                u_curlScale: {
                    value: 0
                },
                u_curlStrength: {
                    value: 0
                },
                u_vel: {
                    value: new Vector2
                },
                u_dissipations: {
                    value: new Vector3
                },
                u_scrollOffset: {
                    value: new Vector2
                }
            },
            fragmentShader: frag$n
        })
    }
    resize(e, t) {
        let r = e >> 2
          , n = t >> 2
          , o = e >> 3
          , l = t >> 3;
        (r !== this._currPaintRenderTarget.width || n !== this._currPaintRenderTarget.height) && (this._currPaintRenderTarget.setSize(r, n),
        this._prevPaintRenderTarget.setSize(r, n),
        this._lowRenderTarget.setSize(o, l),
        this._lowBlurRenderTarget.setSize(o, l),
        this.sharedUniforms.u_paintTexelSize.value.set(1 / r, 1 / n),
        this.sharedUniforms.u_paintTextureSize.value.set(r, n),
        this.clear())
    }
    clear = () => {
        fboHelper.clearColor(.5, .5, 0, 0, this._lowRenderTarget),
        fboHelper.clearColor(.5, .5, 0, 0, this._lowBlurRenderTarget),
        fboHelper.clearColor(.5, .5, 0, 0, this._currPaintRenderTarget),
        this._material.uniforms.u_vel.value.set(0, 0)
    }
    ;
    update(e) {
        if (!this.enabled)
            return;
        this.useNoise !== this._prevUseNoise && (this._material.defines.USE_NOISE = this.useNoise,
        this._material.needsUpdate = !0,
        this._prevUseNoise = this.useNoise);
        let t = this._currPaintRenderTarget.width
          , r = this._currPaintRenderTarget.height
          , n = this._prevPaintRenderTarget;
        this._prevPaintRenderTarget = this._currPaintRenderTarget,
        this._currPaintRenderTarget = n,
        this.sharedUniforms.u_prevPaintTexture.value = this._prevPaintRenderTarget.texture,
        this.sharedUniforms.u_currPaintTexture.value = this._currPaintRenderTarget.texture;
        let o = scrollManager.scrollViewDelta * properties.screenPaintOffsetRatio
          , l = scrollManager.isVertical ? 0 : o
          , c = scrollManager.isVertical ? o : 0;
        _v$4.copy(input.mousePixelXY),
        _v$4.x += l * properties.viewportWidth * 3,
        _v$4.y += c * properties.viewportHeight * 3;
        let u = _v$4.distanceTo(input.prevMousePixelXY)
          , f = math.fit(u, 0, this.radiusDistanceRange, this.minRadius, this.maxRadius);
        Math.abs(scrollManager.scrollViewDelta) == 0 && (!input.hadMoved || !this.drawEnabled || (this.needsMouseDown || browser$1.isMobile) && (!input.isDown || !input.wasDown)) && (f = 0),
        f = f / properties.viewportHeight * r,
        this._material.uniforms.u_pushStrength.value = this.pushStrength,
        this._material.uniforms.u_curlScale.value = this.curlScale,
        this._material.uniforms.u_curlStrength.value = this.curlStrength,
        this._material.uniforms.u_dissipations.value.set(this.velocityDissipation, this.weight1Dissipation, this.weight2Dissipation),
        this._fromDrawData.copy(this._toDrawData),
        _v$4.copy(input.mouseXY),
        _v$4.x += l,
        _v$4.y += c,
        this._toDrawData.set((_v$4.x + 1) * t / 2, (_v$4.y + 1) * r / 2, f, 1),
        _v$4.set(this._toDrawData.x - this._fromDrawData.x, this._toDrawData.y - this._fromDrawData.y).multiplyScalar(e * .8),
        this._material.uniforms.u_vel.value.multiplyScalar(this.accelerationDissipation).add(_v$4),
        this._material.uniforms.u_scrollOffset.value.y = l,
        this._material.uniforms.u_scrollOffset.value.y = c,
        fboHelper.render(this._material, this._currPaintRenderTarget),
        fboHelper.copy(this._currPaintRenderTarget.texture, this._lowRenderTarget),
        blur.blur(8, 1, this._lowRenderTarget, this._lowBlurRenderTarget)
    }
}
const screenPaint = new ScreenPaint;
class HomeBalloonsBackground {
    container = new Object3D;
    mesh = null;
    activeRatio = 0;
    clipOffset = new Vector2;
    clipScale = new Vector2(1,1);
    constructor() {}
    preInit() {}
    init() {
        let e = new BufferGeometry;
        e.setAttribute("position", new BufferAttribute(new Float32Array([.5, -.5, 0, .5, .5, 0, -.5, .5, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0, -1, -1, 0, -.5, -.5, 0, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1]),3)),
        e.setIndex(new BufferAttribute(new Uint16Array([3, 2, 7, 8, 9, 11, 11, 10, 8, 0, 5, 7, 0, 1, 5, 1, 4, 5, 1, 2, 4, 2, 3, 4, 5, 6, 7, 6, 3, 7]),1)),
        this.mesh = new Mesh(e,new ShaderMaterial({
            uniforms: Object.assign({
                u_color0: {
                    value: new Color("#141515")
                },
                u_color1: {
                    value: new Color("#141515")
                },
                u_colorPaint: {
                    value: new Color("#1a2ffb")
                },
                u_aspect: {
                    value: 1
                },
                u_smooth: {
                    value: new Vector2(0,1)
                },
                u_clipScale: {
                    value: this.clipScale
                },
                u_clipOffset: {
                    value: this.clipOffset
                },
                u_time: {
                    value: 0
                },
                u_activeRatio: {
                    value: 0
                },
                u_resolution: {
                    value: new Vector2
                },
                u_screenPaintTexture: screenPaint.sharedUniforms.u_currPaintTexture
            }, blueNoise.sharedUniforms),
            vertexShader: vert$k,
            fragmentShader: frag$o,
            side: BackSide
        })),
        this.mesh.material.defines.NEIGHBOUR_COUNT = homeBalloons.NEIGHBOUR_COUNT + 1,
        this.mesh.frustumCulled = !1,
        this.mesh.renderOrder = -1,
        this.container.add(this.mesh)
    }
    resize(e, t) {}
    update(e) {
        this.mesh && (this.mesh.material.uniforms.u_activeRatio.value = this.activeRatio,
        this.mesh.material.uniforms.u_time.value += .2 * e,
        this.mesh.material.uniforms.u_aspect.value = properties.width / properties.height,
        this.mesh.material.uniforms.u_resolution.value.copy(properties.sharedUniforms.u_resolution.value),
        this.mesh.material.uniforms.u_color0.value.set(COLORS$1[properties.balloonsColorIndex]))
    }
}
const homeBalloonsBackground = new HomeBalloonsBackground;
let random = math.getSeedRandomFn("balloonBody-25");
const GRAVITY_FACTOR = 40;
class HomeBalloonsBody {
    position0 = new Vector3;
    velocity0 = new Vector3;
    position = new Vector3;
    velocity = new Vector3;
    gravityVel = new Vector3;
    gravityAcc = new Vector3;
    gravityForce = new Vector3;
    angularVelocity = new Vector3;
    torque = new Vector3;
    quaternion = new Quaternion;
    radius = 1;
    mass = 1;
    volume = 1;
    density = 1;
    friction = 1;
    frictionTot = 0;
    restitution = 1;
    inertia = 0;
    constructor(e=1, t=1, r=.5, n=.5, o=!1) {
        this.position0.set((random() - .5) * 12, (random() - .5) * 12, o ? 7 + random() : (random() - .5) * 6),
        this.velocity0.copy(this.position0).multiplyScalar(-2),
        this.position.copy(this.position0),
        this.velocity.copy(this.velocity0),
        this.radius = 1.05 * e,
        this.density = t,
        this.friction = r,
        this.restitution = n,
        this.volume = Math.PI * this.radius * 1.333333,
        this.mass = this.volume * this.radius * this.radius * this.density,
        this.inertia = this.mass * this.radius * this.radius * .4,
        this.reset()
    }
    reset() {
        this.position.copy(this.position0),
        this.velocity.copy(this.velocity0)
    }
    applyImpulse() {
        this.gravityForce.copy(this.position).negate().multiplyScalar(10),
        this.gravityAcc.copy(this.gravityForce),
        this.gravityForce.set(Math.random() - .5, Math.random() - .5, Math.random() - .5).multiplyScalar(80),
        this.gravityAcc.add(this.gravityForce).multiplyScalar(1 / this.mass),
        this.velocity.negate(),
        this.velocity.add(this.gravityAcc)
    }
    updateGravity(e) {
        this.gravityForce.copy(this.position).negate().multiplyScalar(GRAVITY_FACTOR),
        this.gravityAcc.copy(this.gravityForce).multiplyScalar(1 / this.mass),
        this.gravityAcc.multiplyScalar(1 / (1 + this.frictionTot)),
        this.velocity.addScaledVector(this.gravityAcc, e),
        this.frictionTot *= .5
    }
    update(e) {
        this.position.addScaledVector(this.velocity, e),
        this.velocity.multiplyScalar(Math.pow(.2, e))
    }
}
const _mouse = new Vector3
  , _mousePrev = new Vector3
  , _vel = new Vector3
  , _pos = new Vector3
  , _v0$3 = new Vector3
  , _v1$6 = new Vector3
  , _p1$1 = new Vector3
  , _normal = new Vector3
  , _q$2 = new Quaternion
  , _mousePushForce = new Vector3
  , _mouseBA = new Vector3;
class HomeBalloonsPhysics {
    MOUSE_RADIUS = .025;
    MOUSE_INFLUENCE = .1;
    MOUSE_PUSH_FORCE = .12;
    bodies = [];
    isActive = !0;
    initWorld() {
        for (let e = 0; e < homeBalloons.NUM_BALLOONS; e++) {
            const t = homeBalloons.balloonList[e]
              , {radius: r, density: n, friction: o, restitution: l, isSemitransparent: c} = t
              , u = new HomeBalloonsBody(r,n,o,l,c);
            this.bodies.push(u)
        }
    }
    reset() {
        for (let e = 0; e < this.bodies.length; e++)
            this.bodies[e].reset()
    }
    update(e) {
        if (!this.isActive)
            return;
        _p1$1.set(input.mouseXY.x, input.mouseXY.y, .5),
        _p1$1.unproject(properties.camera),
        _p1$1.sub(properties.camera.position).normalize();
        const r = (0 - properties.camera.position.z) / _p1$1.z;
        _p1$1.multiplyScalar(r),
        _mouse.copy(properties.camera.position).add(_p1$1),
        _mousePushForce.copy(_mouse).sub(_mousePrev).multiplyScalar(this.MOUSE_PUSH_FORCE / e),
        _mouseBA.copy(_mouse).sub(properties.camera.position);
        let n = _mouseBA.lengthSq();
        _mousePrev.copy(_mouse);
        for (let o = 0; o < this.bodies.length; o++) {
            const l = this.bodies[o];
            l.updateGravity(e),
            _vel.copy(l.velocity),
            _pos.copy(l.position);
            for (let p = o + 1; p < this.bodies.length; p++) {
                const g = this.bodies[p];
                _v1$6.copy(g.velocity),
                _p1$1.copy(g.position),
                _normal.copy(_pos).sub(_p1$1);
                const v = _normal.length()
                  , _ = l.radius + g.radius;
                if (v < _) {
                    const w = Math.sqrt(l.friction * g.friction, 2);
                    l.frictionTot += w,
                    g.frictionTot += w,
                    _normal.normalize(),
                    _normal.multiplyScalar(.5 * (v - _)),
                    _pos.sub(_normal),
                    _p1$1.add(_normal),
                    _normal.normalize();
                    const S = _vel.dot(_normal)
                      , b = _v1$6.dot(_normal)
                      , C = l.mass
                      , R = g.mass
                      , T = l.restitution
                      , M = g.restitution
                      , P = (C * S + R * b - R * (S - b) * T) / (C + R)
                      , I = (C * S + R * b - C * (b - S) * M) / (C + R);
                    _vel.addScaledVector(_normal, (P - S) / (1 + w)),
                    _v1$6.addScaledVector(_normal, (I - b) / (1 + w)),
                    g.position.copy(_p1$1),
                    g.velocity.copy(_v1$6)
                }
            }
            _v0$3.copy(_pos).sub(properties.camera.position);
            let c = _v0$3.dot(_mouseBA) / n;
            c = _v0$3.sub(_v1$6.copy(_mouseBA).multiplyScalar(c)).length() - l.radius - this.MOUSE_RADIUS,
            0 > c && (_v0$3.copy(_pos).sub(properties.camera.position).cross(_mouseBA).normalize(),
            _v1$6.copy(_mouseBA).cross(_v0$3).normalize(),
            _pos.sub(_v1$6.multiplyScalar(this.MOUSE_INFLUENCE * c)),
            _v1$6.multiplyScalar(-this.MOUSE_PUSH_FORCE / e),
            _vel.add(_v1$6),
            _vel.add(_mousePushForce));
            let u = _pos.length();
            if (u > 0) {
                _v0$3.set(1, 1, 1).normalize();
                let p = 1 - Math.abs(_v0$3.dot(_v1$6.copy(_pos).normalize()));
                p *= e * math.fit(u, 0, 2, 0, 1) * .5,
                p *= o % 2 * 2 - 1,
                _q$2.setFromAxisAngle(_v0$3, p),
                _v1$6.copy(_pos).applyQuaternion(_q$2).sub(_v0$3.copy(_pos)),
                _vel.add(_v1$6)
            }
            _v0$3.cross(_vel);
            let f = _v0$3.length();
            f /= l.inertia,
            f > 0 && (_v0$3.normalize(),
            _q$2.setFromAxisAngle(_v0$3, f * e),
            l.quaternion.premultiply(_q$2)),
            l.position.copy(_pos),
            l.velocity.copy(_vel),
            l.update(e)
        }
    }
}
const homeBalloonsPhysics = new HomeBalloonsPhysics;
let _v$3 = new Vector3
  , _color = new Color
  , _blackWhiteToggle = 0;
class HomeBalloons extends Stage3D {
    NUM_BALLOONS = 0;
    NEIGHBOUR_COUNT = -1;
    container = new Object3D;
    balloonList = [];
    _sortedBalloonList;
    instancedPositionRadiusAttribute;
    instancedPositionRadiusArray;
    instancedNearPositionRadiusAttributes = [];
    instancedNearPositionRadiusArrays = [];
    ratio = 0;
    cacheRT = null;
    cacheRTBlur0 = null;
    cacheRTBlur1 = null;
    cacheRTBlur2 = null;
    cacheRTBlur3 = null;
    sharedUniforms = {
        u_blurredTextures: {
            value: []
        },
        u_blurredTextureSizes: {
            value: []
        },
        u_matcap: {
            value: null
        },
        u_lightPosition: {
            value: new Vector3(10,10,5)
        }
    };
    isReady = !1;
    lockedIndex = -1;
    changeHomeHeroColorSignal = new MinSignal$2;
    constructor() {
        super({
            properties: {
                defaultCameraPosition: new Vector3(0,0,0),
                defaultLookAtPosition: new Vector3(0,0,0),
                cameraFov: 25,
                clearAlpha: 0
            }
        }),
        this.NUM_BALLOONS = SPHERES_DATA.length,
        this.cacheRT = fboHelper.createRenderTarget(1, 1),
        this.cacheInterRT0 = fboHelper.createRenderTarget(1, 1),
        this.cacheInterRT1 = fboHelper.createRenderTarget(1, 1),
        this.cacheInterRT2 = fboHelper.createRenderTarget(1, 1),
        this.cacheInterRT3 = fboHelper.createRenderTarget(1, 1),
        this.cacheRTBlur0 = fboHelper.createRenderTarget(1, 1),
        this.cacheRTBlur1 = fboHelper.createRenderTarget(1, 1),
        this.cacheRTBlur2 = fboHelper.createRenderTarget(1, 1),
        this.cacheRTBlur3 = fboHelper.createRenderTarget(1, 1),
        this.sharedUniforms.u_blurredTextures.value.push(this.cacheRTBlur0.texture),
        this.sharedUniforms.u_blurredTextures.value.push(this.cacheRTBlur1.texture),
        this.sharedUniforms.u_blurredTextures.value.push(this.cacheRTBlur2.texture),
        this.sharedUniforms.u_blurredTextures.value.push(this.cacheRTBlur3.texture),
        this.sharedUniforms.u_blurredTextureSizes.value.push(new Vector2),
        this.sharedUniforms.u_blurredTextureSizes.value.push(new Vector2),
        this.sharedUniforms.u_blurredTextureSizes.value.push(new Vector2),
        this.sharedUniforms.u_blurredTextureSizes.value.push(new Vector2)
    }
    preInit() {
        properties.loader.add(settings.MODEL_PATH + "home/" + (browser$1.isMobile ? "cross_ld" : "cross") + ".buf", {
            onLoad: e => {
                this.geometry = e
            }
        }),
        properties.loader.add(`${settings.TEXTURE_PATH}home/${browser$1.isMobile ? "matcap_ld" : "matcap"}.exr`, {
            onLoad: e => {
                e.minFilter = LinearFilter,
                this.sharedUniforms.u_matcap.value = e
            }
        }),
        homeBalloonsBackground.preInit(),
        this.changeHomeHeroColorSignal.add( () => {
            properties.balloonsColorIndex += 1,
            properties.balloonsColorIndex = math.mod(properties.balloonsColorIndex, COLORS$1.length),
            _blackWhiteToggle = 1 - _blackWhiteToggle,
            homeBalloonsPhysics.bodies.forEach(e => e.applyImpulse())
        }
        )
    }
    init() {
        let e = math.getSeedRandomFn("balloon24");
        this.NEIGHBOUR_COUNT = this.NUM_BALLOONS - 1;
        for (let t = 0; t < this.NUM_BALLOONS; t++) {
            let r = SPHERES_DATA[t]
              , {sssColor: n, name: o, color: l, isColored: c, sss: u, isSemitransparent: f, isRough: p, radius: g, density: v, friction: _, restitution: w, isBlackWhite: S} = r
              , b = this.geometry
              , C = new Vector4
              , R = Object.assign({
                u_color: {
                    value: new Color
                },
                u_bgColor: {
                    value: new Color
                },
                u_sssColor: {
                    value: new Color
                },
                u_matcap: this.sharedUniforms.u_matcap,
                u_lightPosition: this.sharedUniforms.u_lightPosition,
                u_sss: {
                    value: 0
                },
                u_roughness: {
                    value: p ? .8 : .1
                },
                u_selfPositionRadius: {
                    value: C
                },
                u_selfRotation: {
                    value: new Quaternion
                },
                u_nearPositionRadiusList: {
                    value: []
                },
                u_nearRotationList: {
                    value: []
                },
                u_nearColorList: {
                    value: []
                },
                u_nearTransparencyLumaList: {
                    value: []
                },
                u_time: properties.sharedUniforms.u_time
            }, blueNoise.sharedUniforms)
              , T = new Mesh(b,new ShaderMaterial({
                uniforms: R,
                vertexShader: vert$l,
                fragmentShader: frag$p
            }));
            T.material.defines.NEIGHBOUR_COUNT = this.NEIGHBOUR_COUNT,
            T.material.extensions.derivatives = !0,
            T.frustumCulled = !1;
            for (let P = 0; P < this.NEIGHBOUR_COUNT; P++)
                T.material.uniforms.u_nearPositionRadiusList.value[P] = new Vector4,
                T.material.uniforms.u_nearRotationList.value[P] = new Quaternion,
                T.material.uniforms.u_nearColorList.value[P] = new Color,
                T.material.uniforms.u_nearTransparencyLumaList.value[P] = new Vector2;
            T.position.set(e() * 2, e() * 2 - 1, e() * 2 - 1),
            T.scale.setScalar(g),
            C.w = g,
            this.add(T);
            let M = {
                name: o,
                mesh: T,
                radius: g,
                distance2: 0,
                distanceFromCamera: 0,
                selfPositionRadius: C,
                color: l,
                sss: u,
                isRough: p,
                isSemitransparent: f,
                sssColor: n,
                density: v,
                friction: _,
                restitution: w,
                isColored: c,
                isBlackWhite: S
            };
            if (f) {
                T.onBeforeRender = this.onBeforeRenderFront.bind(this),
                T.material.uniforms.u_sceneTexture = {
                    value: this.cacheRT.texture
                },
                T.material.uniforms.u_blurredTextures = this.sharedUniforms.u_blurredTextures,
                T.material.uniforms.u_blurredTextureSizes = this.sharedUniforms.u_blurredTextureSizes,
                T.material.defines.IS_SEMITRANSPARENT = !0;
                let P = T.clone();
                P.material = new ShaderMaterial({
                    uniforms: Object.assign({
                        u_sceneTexture: T.material.uniforms.u_sceneTexture
                    }, R),
                    vertexShader: vert$l,
                    fragmentShader: frag$p,
                    side: 1
                }),
                P.onBeforeRender = this.onBeforeRenderBack.bind(this),
                P.material.defines.NEIGHBOUR_COUNT = this.NEIGHBOUR_COUNT,
                P.material.defines.IS_SEMITRANSPARENT_BACK = !0,
                P.material.extensions.derivatives = !0,
                this.add(P),
                M.meshBack = P
            }
            this.balloonList.push(M)
        }
        this._sortedBalloonList = this.balloonList.slice(0),
        homeBalloonsBackground.init(),
        this.add(homeBalloonsBackground.container),
        homeBalloonsPhysics.initWorld(),
        taskManager.add(this),
        this.isReady = !0
    }
    onBeforeRenderFront() {
        let e = fboHelper.renderer
          , t = e.getRenderTarget();
        fboHelper.clearMultisampleRenderTargetState(),
        fboHelper.copy(t.texture, this.cacheRT),
        blur.blur(6, .5, this.cacheRT, this.cacheInterRT0, this.cacheRTBlur0, !0),
        blur.blur(6, .5, this.cacheRTBlur0, this.cacheInterRT1, this.cacheRTBlur1, !0),
        blur.blur(6, .5, this.cacheRTBlur1, this.cacheInterRT2, this.cacheRTBlur2, !0),
        blur.blur(6, .5, this.cacheRTBlur2, this.cacheInterRT3, this.cacheRTBlur3, !0),
        this.sharedUniforms.u_blurredTextureSizes.value[0].set(this.cacheRTBlur0.width, this.cacheRTBlur0.height),
        this.sharedUniforms.u_blurredTextureSizes.value[1].set(this.cacheRTBlur1.width, this.cacheRTBlur1.height),
        this.sharedUniforms.u_blurredTextureSizes.value[2].set(this.cacheRTBlur2.width, this.cacheRTBlur2.height),
        this.sharedUniforms.u_blurredTextureSizes.value[3].set(this.cacheRTBlur3.width, this.cacheRTBlur3.height),
        e.setRenderTarget(t)
    }
    onBeforeRenderBack() {
        let e = fboHelper.renderer
          , t = e.getRenderTarget();
        fboHelper.clearMultisampleRenderTargetState(),
        fboHelper.copy(t.texture, this.cacheRT),
        e.setRenderTarget(t)
    }
    resize(e, t) {
        this.cacheRT.setSize(e, t);
        let r = e >> 1
          , n = t >> 1;
        this.cacheRTBlur0.setSize(r, n),
        r = r >> 1,
        n = n >> 1,
        this.cacheRTBlur1.setSize(r, n),
        r = r >> 1,
        n = n >> 1,
        this.cacheRTBlur2.setSize(r, n),
        r = r >> 1,
        n = n >> 1,
        this.cacheRTBlur3.setSize(r, n),
        homeBalloonsBackground.resize(r, n)
    }
    _sortDist2(e, t) {
        return e.distance2 - t.distance2
    }
    syncProperties(e) {
        this.properties.defaultCameraPosition.z = math.fit(homePage.time, .3, 2, 25, 17.5, ease.backOut),
        this.properties.cameraDollyZoomFovOffset = math.fit(homePage.time, .3, 3, 100, 0, ease.backOut)
    }
    updateColor() {
        for (let e = 0; e < this.NUM_BALLOONS; e++) {
            const t = this.balloonList[e];
            if (t.isColored) {
                const r = COLORS$1[properties.balloonsColorIndex];
                t.isSemitransparent ? (_color.set(r),
                _color.offsetHSL(0, 0, .3),
                t.color = "#" + _color.getHexString()) : t.color = r
            } else
                t.isBlackWhite && (t.color = _blackWhiteToggle ? "#888" : "#eee")
        }
    }
    updateUniforms() {
        for (let e = 0; e < this.NUM_BALLOONS; e++) {
            let t = this.balloonList[e]
              , {isSemitransparent: r, color: n, sss: o, sssColor: l} = t;
            t.mesh.material.uniforms.u_bgColor.value.copy(properties.bgColor),
            t.mesh.material.uniforms.u_color.value.set(n),
            t.mesh.material.uniforms.u_sss.value = o,
            t.mesh.material.uniforms.u_sssColor.value.set(l),
            r && (t.meshBack.material.uniforms.u_bgColor.value.copy(properties.bgColor),
            t.meshBack.material.uniforms.u_color.value.set(n),
            t.meshBack.material.uniforms.u_sss.value = o,
            t.meshBack.material.uniforms.u_sssColor.value.set(l))
        }
    }
    updateSorting() {
        for (let e = 0; e < this.NUM_BALLOONS; e++) {
            let t = this.balloonList[e];
            for (let r = 0; r < this.NUM_BALLOONS; r++) {
                let n = this._sortedBalloonList[r];
                t == n ? n.distance2 = 0 : n.distance2 = t.mesh.position.distanceToSquared(n.mesh.position)
            }
            this._sortedBalloonList.sort(this._sortDist2),
            t.mesh.material.uniforms.u_selfRotation.value.copy(t.mesh.quaternion);
            for (let r = 0; r < this.NEIGHBOUR_COUNT; r++) {
                let n = this._sortedBalloonList[r + 1];
                t.mesh.material.uniforms.u_nearPositionRadiusList.value[r].set(n.mesh.position.x, n.mesh.position.y, n.mesh.position.z, n.mesh.scale.x),
                t.mesh.material.uniforms.u_nearRotationList.value[r].copy(n.mesh.quaternion),
                _color.set(n.color),
                t.mesh.material.uniforms.u_nearColorList.value[r].copy(_color),
                t.mesh.material.uniforms.u_nearTransparencyLumaList.value[r].set(n.isSemitransparent ? 1 : 0, _color.r * .299 + _color.g * .587 + _color.b * .114)
            }
            t.mesh.getWorldPosition(_v$3),
            _v$3.applyMatrix4(properties.camera.matrixWorldInverse),
            t.distanceFromCamera = -_v$3.z
        }
    }
    updateRenderOrder() {
        this._sortedBalloonList.sort( (r, n) => r.distanceFromCamera < n.distanceFromCamera ? 1 : -1);
        let e = [-1];
        for (let r = 0; r < this.NUM_BALLOONS; r++)
            this._sortedBalloonList[r].isSemitransparent && e.push(r);
        e.push(this.NUM_BALLOONS);
        let t = 0;
        for (let r = 0; r < this.NUM_BALLOONS; r++) {
            let n = this._sortedBalloonList[r];
            n.isSemitransparent ? (n.mesh.renderOrder = r * 3 + 2,
            n.meshBack.renderOrder = r * 3,
            t++) : n.mesh.renderOrder = (e[t + 1] - (r - e[t])) * 3 + 2
        }
    }
    updateTransformations() {
        for (let e = 0; e < this.NUM_BALLOONS; e++) {
            const t = this.balloonList[e]
              , r = homeBalloonsPhysics.bodies[e];
            t.mesh.position.copy(r.position),
            t.mesh.quaternion.copy(r.quaternion),
            t.selfPositionRadius.x = t.mesh.position.x,
            t.selfPositionRadius.y = t.mesh.position.y,
            t.selfPositionRadius.z = t.mesh.position.z,
            t.isSemitransparent && (t.meshBack.position.copy(t.mesh.position),
            t.meshBack.rotation.copy(t.mesh.rotation))
        }
    }
    update(e) {
        if (this.isReady) {
            if (homeBalloonsBackground.update(e),
            homeBalloonsPhysics.update(e),
            this.lockedIndex > -1) {
                let t = this.balloonList[this.lockedIndex];
                t.mesh.position.set(0, 0, 3),
                t.meshBack && t.meshBack.position.copy(t.mesh.position),
                t.mesh.rotation.set(properties.time, properties.time * 1.5, 0)
            }
            this.updateTransformations(),
            this.updateColor(),
            this.updateUniforms(),
            this.updateSorting(),
            this.updateRenderOrder()
        }
    }
}
const homeBalloons = new HomeBalloons;
class Visuals {
    defaultStage3D = new Stage3D;
    currentStage3D = null;
    stage3DList = [];
    preInit() {}
    init() {}
    start() {}
    resize(e, t) {}
    deactivateAll() {
        for (let e = 0; e < this.stage3DList.length; e++) {
            let t = this.stage3DList[e];
            t.isActive = !1
        }
    }
    syncProperties(e) {
        this.currentStage3D = this.defaultStage3D;
        for (let t = 0; t < this.stage3DList.length; t++) {
            let r = this.stage3DList[t];
            if (r.isActive === !0) {
                this.currentStage3D = r,
                r.syncProperties(e);
                for (let n in r.properties)
                    properties[n] = r.properties[n]
            } else
                r.isActive = !1
        }
    }
    update(e) {
        this.currentStage3D.update(e),
        this.currentStage3D.visible = !0;
        for (let t = 0; t < this.stage3DList.length; t++) {
            let r = this.stage3DList[t];
            r.wasActive = r.isActive
        }
    }
}
const visuals = new Visuals
  , frameVert = `#define GLSLIFY 1
attribute vec3 position;varying vec2 v_uv;uniform vec2 u_viewportResolution;uniform vec2 u_domXY;uniform vec2 u_domWH;void main(){v_uv=position.xy*0.5+0.5;v_uv.y=1.0-v_uv.y;v_uv=(v_uv*u_viewportResolution-u_domXY-u_domWH*0.5);v_uv=(v_uv+u_domWH*0.5)/u_domWH;gl_Position=vec4(position,1.0);}`
  , frameFrag = `#define GLSLIFY 1
uniform vec3 u_bgColor;uniform vec2 u_aspect;uniform vec2 u_domWH;uniform float u_globalRadius;varying vec2 v_uv;float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}float sdRoundedBox(in vec2 p,in vec2 b,in float r){vec2 q=abs(p)-b+r;return min(max(q.x,q.y),0.0)+length(max(q,0.0))-r;}float getRoundedCornerMask(vec2 uv,vec2 size,float radius,float ratio){vec2 halfSize=size*0.5;float maxDist=length(halfSize);float minSize=min(halfSize.x,halfSize.y);float maxSize=max(halfSize.x,halfSize.y);float t=ratio*maxDist;radius=mix(minSize*linearStep(0.,minSize,t),radius,linearStep(maxSize,maxDist,t));halfSize=min(halfSize,vec2(t));float d=sdRoundedBox((uv-.5)*size,halfSize,radius);return smoothstep(0.,0.-fwidth(d),d);}void main(){float mask=1.-getRoundedCornerMask(v_uv,u_domWH,u_globalRadius,1.0);gl_FragColor.rgb=u_bgColor;gl_FragColor.a=mask;}`;
(function() {
    function a() {
        for (var r = arguments.length, n = 0; n < r; n++) {
            var o = n < 0 || arguments.length <= n ? void 0 : arguments[n];
            o.nodeType === 1 || o.nodeType === 11 ? this.appendChild(o) : this.appendChild(document.createTextNode(String(o)))
        }
    }
    function e() {
        for (; this.lastChild; )
            this.removeChild(this.lastChild);
        arguments.length && this.append.apply(this, arguments)
    }
    function t() {
        for (var r = this.parentNode, n = arguments.length, o = new Array(n), l = 0; l < n; l++)
            o[l] = arguments[l];
        var c = o.length;
        if (r)
            for (c || r.removeChild(this); c--; ) {
                var u = o[c];
                typeof u != "object" ? u = this.ownerDocument.createTextNode(u) : u.parentNode && u.parentNode.removeChild(u),
                c ? r.insertBefore(this.previousSibling, u) : r.replaceChild(u, this)
            }
    }
    typeof Element < "u" && (Element.prototype.append || (Element.prototype.append = a,
    DocumentFragment.prototype.append = a),
    Element.prototype.replaceChildren || (Element.prototype.replaceChildren = e,
    DocumentFragment.prototype.replaceChildren = e),
    Element.prototype.replaceWith || (Element.prototype.replaceWith = t,
    DocumentFragment.prototype.replaceWith = t))
}
)();
function _classCallCheck$1(a, e) {
    if (!(a instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function _defineProperties$1(a, e) {
    for (var t = 0; t < e.length; t++) {
        var r = e[t];
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        "value"in r && (r.writable = !0),
        Object.defineProperty(a, r.key, r)
    }
}
function _createClass$1(a, e, t) {
    return e && _defineProperties$1(a.prototype, e),
    t && _defineProperties$1(a, t),
    a
}
function _defineProperty$1(a, e, t) {
    return e in a ? Object.defineProperty(a, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : a[e] = t,
    a
}
function ownKeys$1(a, e) {
    var t = Object.keys(a);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(a);
        e && (r = r.filter(function(n) {
            return Object.getOwnPropertyDescriptor(a, n).enumerable
        })),
        t.push.apply(t, r)
    }
    return t
}
function _objectSpread2$1(a) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? ownKeys$1(Object(t), !0).forEach(function(r) {
            _defineProperty$1(a, r, t[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r) {
            Object.defineProperty(a, r, Object.getOwnPropertyDescriptor(t, r))
        })
    }
    return a
}
function _slicedToArray(a, e) {
    return _arrayWithHoles(a) || _iterableToArrayLimit(a, e) || _unsupportedIterableToArray(a, e) || _nonIterableRest()
}
function _toConsumableArray(a) {
    return _arrayWithoutHoles(a) || _iterableToArray(a) || _unsupportedIterableToArray(a) || _nonIterableSpread()
}
function _arrayWithoutHoles(a) {
    if (Array.isArray(a))
        return _arrayLikeToArray(a)
}
function _arrayWithHoles(a) {
    if (Array.isArray(a))
        return a
}
function _iterableToArray(a) {
    if (typeof Symbol < "u" && Symbol.iterator in Object(a))
        return Array.from(a)
}
function _iterableToArrayLimit(a, e) {
    if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(a)))) {
        var t = []
          , r = !0
          , n = !1
          , o = void 0;
        try {
            for (var l = a[Symbol.iterator](), c; !(r = (c = l.next()).done) && (t.push(c.value),
            !(e && t.length === e)); r = !0)
                ;
        } catch (u) {
            n = !0,
            o = u
        } finally {
            try {
                !r && l.return != null && l.return()
            } finally {
                if (n)
                    throw o
            }
        }
        return t
    }
}
function _unsupportedIterableToArray(a, e) {
    if (a) {
        if (typeof a == "string")
            return _arrayLikeToArray(a, e);
        var t = Object.prototype.toString.call(a).slice(8, -1);
        if (t === "Object" && a.constructor && (t = a.constructor.name),
        t === "Map" || t === "Set")
            return Array.from(a);
        if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
            return _arrayLikeToArray(a, e)
    }
}
function _arrayLikeToArray(a, e) {
    (e == null || e > a.length) && (e = a.length);
    for (var t = 0, r = new Array(e); t < e; t++)
        r[t] = a[t];
    return r
}
function _nonIterableSpread() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function _nonIterableRest() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function extend(a, e) {
    return Object.getOwnPropertyNames(Object(a)).reduce(function(t, r) {
        var n = Object.getOwnPropertyDescriptor(Object(a), r)
          , o = Object.getOwnPropertyDescriptor(Object(e), r);
        return Object.defineProperty(t, r, o || n)
    }, {})
}
function isString(a) {
    return typeof a == "string"
}
function isArray(a) {
    return Array.isArray(a)
}
function parseSettings() {
    var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = extend(a), t;
    return e.types !== void 0 ? t = e.types : e.split !== void 0 && (t = e.split),
    t !== void 0 && (e.types = (isString(t) || isArray(t) ? String(t) : "").split(",").map(function(r) {
        return String(r).trim()
    }).filter(function(r) {
        return /((line)|(word)|(char))/i.test(r)
    })),
    (e.absolute || e.position) && (e.absolute = e.absolute || /absolute/.test(a.position)),
    e
}
function parseTypes(a) {
    var e = isString(a) || isArray(a) ? String(a) : "";
    return {
        none: !e,
        lines: /line/i.test(e),
        words: /word/i.test(e),
        chars: /char/i.test(e)
    }
}
function isObject(a) {
    return a !== null && typeof a == "object"
}
function isNode$1(a) {
    return isObject(a) && /^(1|3|11)$/.test(a.nodeType)
}
function isLength(a) {
    return typeof a == "number" && a > -1 && a % 1 === 0
}
function isArrayLike(a) {
    return isObject(a) && isLength(a.length)
}
function toArray(a) {
    return isArray(a) ? a : a == null ? [] : isArrayLike(a) ? Array.prototype.slice.call(a) : [a]
}
function getTargetElements(a) {
    var e = a;
    return isString(a) && (/^(#[a-z]\w+)$/.test(a.trim()) ? e = document.getElementById(a.trim().slice(1)) : e = document.querySelectorAll(a)),
    toArray(e).reduce(function(t, r) {
        return [].concat(_toConsumableArray(t), _toConsumableArray(toArray(r).filter(isNode$1)))
    }, [])
}
var entries = Object.entries
  , expando = "_splittype"
  , cache = {}
  , uid = 0;
function set(a, e, t) {
    if (!isObject(a))
        return console.warn("[data.set] owner is not an object"),
        null;
    var r = a[expando] || (a[expando] = ++uid)
      , n = cache[r] || (cache[r] = {});
    return t === void 0 ? e && Object.getPrototypeOf(e) === Object.prototype && (cache[r] = _objectSpread2$1(_objectSpread2$1({}, n), e)) : e !== void 0 && (n[e] = t),
    t
}
function get(a, e) {
    var t = isObject(a) ? a[expando] : null
      , r = t && cache[t] || {};
    return e === void 0 ? r : r[e]
}
function remove(a) {
    var e = a && a[expando];
    e && (delete a[e],
    delete cache[e])
}
function clear() {
    Object.keys(cache).forEach(function(a) {
        delete cache[a]
    })
}
function cleanup() {
    entries(cache).forEach(function(a) {
        var e = _slicedToArray(a, 2)
          , t = e[0]
          , r = e[1]
          , n = r.isRoot
          , o = r.isSplit;
        (!n || !o) && (cache[t] = null,
        delete cache[t])
    })
}
function toWords(a) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " "
      , t = a ? String(a) : "";
    return t.trim().replace(/\s+/g, " ").split(e)
}
var rsAstralRange = "\\ud800-\\udfff"
  , rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23"
  , rsComboSymbolsRange = "\\u20d0-\\u20f0"
  , rsVarRange = "\\ufe0e\\ufe0f"
  , rsAstral = "[".concat(rsAstralRange, "]")
  , rsCombo = "[".concat(rsComboMarksRange).concat(rsComboSymbolsRange, "]")
  , rsFitz = "\\ud83c[\\udffb-\\udfff]"
  , rsModifier = "(?:".concat(rsCombo, "|").concat(rsFitz, ")")
  , rsNonAstral = "[^".concat(rsAstralRange, "]")
  , rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}"
  , rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]"
  , rsZWJ = "\\u200d"
  , reOptMod = "".concat(rsModifier, "?")
  , rsOptVar = "[".concat(rsVarRange, "]?")
  , rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*"
  , rsSeq = rsOptVar + reOptMod + rsOptJoin
  , rsSymbol = "(?:".concat(["".concat(rsNonAstral).concat(rsCombo, "?"), rsCombo, rsRegional, rsSurrPair, rsAstral].join("|"), `
)`)
  , reUnicode = RegExp("".concat(rsFitz, "(?=").concat(rsFitz, ")|").concat(rsSymbol).concat(rsSeq), "g")
  , unicodeRange = [rsZWJ, rsAstralRange, rsComboMarksRange, rsComboSymbolsRange, rsVarRange]
  , reHasUnicode = RegExp("[".concat(unicodeRange.join(""), "]"));
function asciiToArray(a) {
    return a.split("")
}
function hasUnicode(a) {
    return reHasUnicode.test(a)
}
function unicodeToArray(a) {
    return a.match(reUnicode) || []
}
function stringToArray(a) {
    return hasUnicode(a) ? unicodeToArray(a) : asciiToArray(a)
}
function toString(a) {
    return a == null ? "" : String(a)
}
function toChars(a) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return a = toString(a),
    a && isString(a) && !e && hasUnicode(a) ? stringToArray(a) : a.split(e)
}
function createElement(a, e) {
    var t = document.createElement(a);
    return e && Object.keys(e).forEach(function(r) {
        var n = e[r]
          , o = isString(n) ? n.trim() : n;
        o === null || o === "" || (r === "children" ? t.append.apply(t, _toConsumableArray(toArray(o))) : t.setAttribute(r, o))
    }),
    t
}
var defaults = {
    splitClass: "",
    lineClass: "line",
    wordClass: "word",
    charClass: "char",
    types: ["lines", "words", "chars"],
    absolute: !1,
    tagName: "div"
};
function splitWordsAndChars(a, e) {
    e = extend(defaults, e);
    var t = parseTypes(e.types)
      , r = e.tagName
      , n = a.nodeValue
      , o = document.createDocumentFragment()
      , l = []
      , c = [];
    return /^\s/.test(n) && o.append(" "),
    l = toWords(n).reduce(function(u, f, p, g) {
        var v, _;
        return t.chars && (_ = toChars(f).map(function(w) {
            var S = createElement(r, {
                class: "".concat(e.splitClass, " ").concat(e.charClass),
                style: "display: inline-block;",
                children: w
            });
            return set(S, "isChar", !0),
            c = [].concat(_toConsumableArray(c), [S]),
            S
        })),
        t.words || t.lines ? (v = createElement(r, {
            class: "".concat(e.wordClass, " ").concat(e.splitClass),
            style: "display: inline-block; ".concat(t.words && e.absolute ? "position: relative;" : ""),
            children: t.chars ? _ : f
        }),
        set(v, {
            isWord: !0,
            isWordStart: !0,
            isWordEnd: !0
        }),
        o.appendChild(v)) : _.forEach(function(w) {
            o.appendChild(w)
        }),
        p < g.length - 1 && o.append(" "),
        t.words ? u.concat(v) : u
    }, []),
    /\s$/.test(n) && o.append(" "),
    a.replaceWith(o),
    {
        words: l,
        chars: c
    }
}
function split(a, e) {
    var t = a.nodeType
      , r = {
        words: [],
        chars: []
    };
    if (!/(1|3|11)/.test(t))
        return r;
    if (t === 3 && /\S/.test(a.nodeValue))
        return splitWordsAndChars(a, e);
    var n = toArray(a.childNodes);
    if (n.length && (set(a, "isSplit", !0),
    !get(a).isRoot)) {
        a.style.display = "inline-block",
        a.style.position = "relative";
        var o = a.nextSibling
          , l = a.previousSibling
          , c = a.textContent || ""
          , u = o ? o.textContent : " "
          , f = l ? l.textContent : " ";
        set(a, {
            isWordEnd: /\s$/.test(c) || /^\s/.test(u),
            isWordStart: /^\s/.test(c) || /\s$/.test(f)
        })
    }
    return n.reduce(function(p, g) {
        var v = split(g, e)
          , _ = v.words
          , w = v.chars;
        return {
            words: [].concat(_toConsumableArray(p.words), _toConsumableArray(_)),
            chars: [].concat(_toConsumableArray(p.chars), _toConsumableArray(w))
        }
    }, r)
}
function getPosition(a, e, t, r) {
    if (!t.absolute)
        return {
            top: e ? a.offsetTop : null
        };
    var n = a.offsetParent
      , o = _slicedToArray(r, 2)
      , l = o[0]
      , c = o[1]
      , u = 0
      , f = 0;
    if (n && n !== document.body) {
        var p = n.getBoundingClientRect();
        u = p.x + l,
        f = p.y + c
    }
    var g = a.getBoundingClientRect()
      , v = g.width
      , _ = g.height
      , w = g.x
      , S = g.y
      , b = S + c - f
      , C = w + l - u;
    return {
        width: v,
        height: _,
        top: b,
        left: C
    }
}
function unSplitWords(a) {
    get(a).isWord ? (remove(a),
    a.replaceWith.apply(a, _toConsumableArray(a.childNodes))) : toArray(a.children).forEach(function(e) {
        return unSplitWords(e)
    })
}
var createFragment = function a() {
    return document.createDocumentFragment()
};
function repositionAfterSplit(a, e, t) {
    var r = parseTypes(e.types), n = e.tagName, o = a.getElementsByTagName("*"), l = [], c = [], u = null, f, p, g, v = [], _ = a.parentElement, w = a.nextElementSibling, S = createFragment(), b = window.getComputedStyle(a), C = b.textAlign, R = parseFloat(b.fontSize), T = R * .2;
    return e.absolute && (g = {
        left: a.offsetLeft,
        top: a.offsetTop,
        width: a.offsetWidth
    },
    p = a.offsetWidth,
    f = a.offsetHeight,
    set(a, {
        cssWidth: a.style.width,
        cssHeight: a.style.height
    })),
    toArray(o).forEach(function(M) {
        var P = M.parentElement === a
          , I = getPosition(M, P, e, t)
          , k = I.width
          , A = I.height
          , O = I.top
          , W = I.left;
        /^br$/i.test(M.nodeName) || (r.lines && P && ((u === null || O - u >= T) && (u = O,
        l.push(c = [])),
        c.push(M)),
        e.absolute && set(M, {
            top: O,
            left: W,
            width: k,
            height: A
        }))
    }),
    _ && _.removeChild(a),
    r.lines && (v = l.map(function(M) {
        var P = createElement(n, {
            class: "".concat(e.splitClass, " ").concat(e.lineClass),
            style: "display: block; text-align: ".concat(C, "; width: 100%;")
        });
        set(P, "isLine", !0);
        var I = {
            height: 0,
            top: 1e4
        };
        return S.appendChild(P),
        M.forEach(function(k, A, O) {
            var W = get(k)
              , Q = W.isWordEnd
              , H = W.top
              , B = W.height
              , D = O[A + 1];
            I.height = Math.max(I.height, B),
            I.top = Math.min(I.top, H),
            P.appendChild(k),
            Q && get(D).isWordStart && P.append(" ")
        }),
        e.absolute && set(P, {
            height: I.height,
            top: I.top
        }),
        P
    }),
    r.words || unSplitWords(S),
    a.replaceChildren(S)),
    e.absolute && (a.style.width = "".concat(a.style.width || p, "px"),
    a.style.height = "".concat(f, "px"),
    toArray(o).forEach(function(M) {
        var P = get(M)
          , I = P.isLine
          , k = P.top
          , A = P.left
          , O = P.width
          , W = P.height
          , Q = get(M.parentElement)
          , H = !I && Q.isLine;
        M.style.top = "".concat(H ? k - Q.top : k, "px"),
        M.style.left = I ? "".concat(g.left, "px") : "".concat(A - (H ? g.left : 0), "px"),
        M.style.height = "".concat(W, "px"),
        M.style.width = I ? "".concat(g.width, "px") : "".concat(O, "px"),
        M.style.position = "absolute"
    })),
    _ && (w ? _.insertBefore(a, w) : _.appendChild(a)),
    v
}
var _defaults = extend(defaults, {})
  , SplitType = function() {
    _createClass$1(a, null, [{
        key: "clearData",
        value: function() {
            clear()
        }
    }, {
        key: "setDefaults",
        value: function(t) {
            return _defaults = extend(_defaults, parseSettings(t)),
            defaults
        }
    }, {
        key: "revert",
        value: function(t) {
            getTargetElements(t).forEach(function(r) {
                var n = get(r)
                  , o = n.isSplit
                  , l = n.html
                  , c = n.cssWidth
                  , u = n.cssHeight;
                o && (r.innerHTML = l,
                r.style.width = c || "",
                r.style.height = u || "",
                remove(r))
            })
        }
    }, {
        key: "create",
        value: function(t, r) {
            return new a(t,r)
        }
    }, {
        key: "data",
        get: function() {
            return cache
        }
    }, {
        key: "defaults",
        get: function() {
            return _defaults
        },
        set: function(t) {
            _defaults = extend(_defaults, parseSettings(t))
        }
    }]);
    function a(e, t) {
        _classCallCheck$1(this, a),
        this.isSplit = !1,
        this.settings = extend(_defaults, parseSettings(t)),
        this.elements = getTargetElements(e),
        this.split()
    }
    return _createClass$1(a, [{
        key: "split",
        value: function(t) {
            var r = this;
            this.revert(),
            this.elements.forEach(function(l) {
                set(l, "html", l.innerHTML)
            }),
            this.lines = [],
            this.words = [],
            this.chars = [];
            var n = [window.pageXOffset, window.pageYOffset];
            t !== void 0 && (this.settings = extend(this.settings, parseSettings(t)));
            var o = parseTypes(this.settings.types);
            o.none || (this.elements.forEach(function(l) {
                set(l, "isRoot", !0);
                var c = split(l, r.settings)
                  , u = c.words
                  , f = c.chars;
                r.words = [].concat(_toConsumableArray(r.words), _toConsumableArray(u)),
                r.chars = [].concat(_toConsumableArray(r.chars), _toConsumableArray(f))
            }),
            this.elements.forEach(function(l) {
                if (o.lines || r.settings.absolute) {
                    var c = repositionAfterSplit(l, r.settings, n);
                    r.lines = [].concat(_toConsumableArray(r.lines), _toConsumableArray(c))
                }
            }),
            this.isSplit = !0,
            window.scrollTo(n[0], n[1]),
            cleanup())
        }
    }, {
        key: "revert",
        value: function() {
            this.isSplit && (this.lines = null,
            this.words = null,
            this.chars = null,
            this.isSplit = !1),
            a.revert(this.elements)
        }
    }]),
    a
}();
const AUDIO_DATA = {
    ui: [{
        id: "hover_[3]",
        ext: ".ogg",
        isLoopable: !1,
        isPositional: !1,
        isPreload: !0,
        isElem: !1,
        isSfx: !0,
        volume: 1
    }, {
        id: "click_[2]",
        ext: ".ogg",
        isLoopable: !1,
        isPositional: !1,
        isPreload: !0,
        isElem: !1,
        isSfx: !0,
        volume: 1
    }, {
        id: "focus_[3]",
        ext: ".ogg",
        isLoopable: !1,
        isPositional: !1,
        isPreload: !0,
        isElem: !1,
        isSfx: !0,
        volume: .4
    }, {
        id: "glass_broken",
        ext: ".ogg",
        isLoopable: !1,
        isPositional: !1,
        isPreload: !0,
        isElem: !1,
        isSfx: !0,
        volume: 1
    }, {
        id: "page_[2]",
        ext: ".ogg",
        isLoopable: !1,
        isPositional: !1,
        isPreload: !0,
        isElem: !1,
        isSfx: !0,
        volume: 1
    }],
    music: [{
        id: "generic",
        ext: ".ogg",
        isLoopable: !0,
        isPositional: !1,
        isPreload: !1,
        isElem: !0,
        needsFilter: !1,
        isSfx: !1,
        volume: 1
    }, {
        id: "cinematic_0",
        ext: ".ogg",
        isLoopable: !0,
        isPositional: !1,
        isPreload: !1,
        isElem: !0,
        needsFilter: !0,
        isSfx: !1,
        volume: 1
    }, {
        id: "cinematic_2",
        ext: ".ogg",
        isLoopable: !0,
        isPositional: !1,
        isPreload: !1,
        isElem: !0,
        needsFilter: !0,
        isSfx: !1,
        volume: 1
    }, {
        id: "cinematic_3",
        ext: ".ogg",
        isLoopable: !0,
        isPositional: !1,
        isPreload: !1,
        isElem: !0,
        needsFilter: !0,
        isSfx: !1,
        volume: 1
    }, {
        id: "generic_end",
        ext: ".ogg",
        isLoopable: !0,
        isPositional: !1,
        isPreload: !1,
        isElem: !0,
        needsFilter: !1,
        isSfx: !1,
        volume: 1
    }]
};
class AudioGroup {
    id = "";
    children = [];
    volume = 1;
    init(e) {
        Object.assign(this, e)
    }
    update(e) {
        e *= this.volume,
        this.children.forEach(t => {
            t.setFinalVolume(e)
        }
        )
    }
    add(e) {
        this.children.includes(e) || this.children.push(e)
    }
    remove(e) {
        this.children.includes(e) && this.children.splice(this.children.indexOf(e), 1)
    }
    play() {
        this.children.forEach(e => e.play())
    }
    stop() {
        this.children.forEach(e => e.stop())
    }
}
const LOW_PASS_FREQ = 300
  , MAX_FREQ = 22050;
class AudioItem {
    autoplay = !1;
    elem = null;
    id = "";
    url = "";
    fileSize = 100;
    isMutable = !1;
    isPositional = !1;
    isLoopable = !1;
    isPreload = !0;
    onInitialized = new MinSignal$2;
    onEnded = new MinSignal$2;
    onPlayed = new MinSignal$2;
    volume = 1;
    audioObject = null;
    hasInitialized = !1;
    container = null;
    refDistance = 1;
    _buffer = null;
    _originalOnEnd = null;
    needsFilter = !1;
    fadeTime = 0;
    fadeDuration = 1;
    isFadingIn = !1;
    isFadingOut = !1;
    isSfx = !1;
    preInit(e) {
        Object.assign(this, e),
        this.isPositional && (this.container = new Object3D)
    }
    init(e) {
        if (this.hasInitialized !== !0) {
            if (this.hasInitialized = !0,
            this.audioObject = this.isPositional ? new PositionalAudio(e) : new Audio$1(e),
            this.isPositional && this.container.add(this.audioObject),
            this._originalOnEnd = this.audioObject.onEnded.bind(this.audioObject),
            this.audioObject.onEnded = this.onEnd.bind(this),
            this.isPositional && this.setRefDistance(this.refDistance),
            this.isElem && !this.elem && (this.elem = document.createElement("audio"),
            settings.LOCAL_AUDIO_PATH !== settings.AUDIO_PATH && (this.elem.crossOrigin = "anonymous"),
            this.elem.src = this.url),
            this.needsFilter) {
                const t = this.audioObject.context;
                this.biquadFilter = t.createBiquadFilter(),
                this.biquadFilter.type = "lowpass",
                this.biquadFilter.frequency.value = MAX_FREQ,
                this.audioObject.setFilter(this.biquadFilter)
            }
            this.elem ? (this.elem.loop = this.isLoopable,
            this.audioObject.setMediaElementSource(this.elem),
            this.elem.addEventListener("ended", this.onEnd.bind(this)),
            this.autoplay && this.play()) : (this.audioObject.setLoop(this.isLoopable),
            this._buffer && this.decodeAudioData()),
            this.onInitialized.dispatch(this)
        }
    }
    load(e) {
        if (this.elem)
            this.elem.src = this.url;
        else {
            const t = this.isPreload ? "add" : "load";
            properties.loader[t](this.url, {
                weight: this.fileSize,
                type: "xhr",
                responseType: "arraybuffer",
                hasLoading: !0,
                onLoad: r => {
                    this._buffer = r,
                    this.hasInitialized && this.decodeAudioData(),
                    e && e()
                }
            })
        }
    }
    setFinalVolume(e) {
        this.audioObject?.setVolume(e * this.volume)
    }
    activateFilter() {
        if (this.needsFilter && this.biquadFilter) {
            const e = this.audioObject.context;
            this.biquadFilter.frequency.linearRampToValueAtTime(LOW_PASS_FREQ, e.currentTime + .5)
        }
    }
    deactivateFilter() {
        if (this.needsFilter && this.biquadFilter) {
            const e = this.audioObject.context;
            this.biquadFilter.frequency.linearRampToValueAtTime(MAX_FREQ, e.currentTime + .5)
        }
    }
    setFilterFrequency(e=MAX_FREQ) {
        this.needsFilter && this.biquadFilter && (this.audioObject.context,
        this.biquadFilter.frequency.value = e)
    }
    setFilterFrequencyViaRatio(e=1) {
        this.setFilterFrequency(math.fit(e, 0, 1, MAX_FREQ, LOW_PASS_FREQ, ease.expoOut))
    }
    setPositionObjectParent(e) {
        this.hasInitialized ? e ? e.add(this.audioObject) : this.audioObject.parent && this.audioObject.parent.remove(this.audioObject) : this.positionObjectParent = e
    }
    decodeAudioData() {
        const e = this._buffer.slice(0);
        AudioContext.getContext().decodeAudioData(e, r => {
            this.audioObject.setBuffer(r),
            this.autoplay && this.play()
        }
        )
    }
    onEnd() {
        this._originalOnEnd && this._originalOnEnd(),
        this.onEnded.dispatch(this)
    }
    play() {
        this.isSfx || (this.autoplay = !0),
        this.audioObject && !this.audioObject.isPlaying && (this.elem ? (this.elem.play(),
        this.elem.currentTime = .01,
        this.audioObject.isPlaying = !0) : this.audioObject.play(),
        this.onPlayed.dispatch(this))
    }
    stop() {
        this.autoplay = !1,
        this.audioObject && this.audioObject.isPlaying && (this.elem ? (this.elem.pause(),
        this.audioObject.isPlaying = !1) : this.audioObject.stop(),
        this.onEnded.dispatch(this))
    }
    setRefDistance(e) {
        this.refDistance = e,
        this.isPositional && this.audioObject && this.audioObject.setRefDistance(this.refDistance)
    }
    setFadeIn(e=1) {
        this.fadeTime = 0,
        this.fadeDuration = e,
        this.isFadingIn = !0,
        this.isFadingOut = !1,
        this.play()
    }
    setFadeOut(e=1) {
        this.fadeTime = e,
        this.fadeDuration = e,
        this.isFadingIn = !1,
        this.isFadingOut = !0
    }
    update(e) {
        if (!this.isFadingOut && !this.isFadingIn)
            return;
        this.isFadingOut && (this.fadeTime -= e),
        this.isFadingIn && (this.fadeTime += e);
        const t = math.saturate(this.fadeTime / this.fadeDuration);
        this.volume = t,
        this.isFadingOut && t === 0 && (this.stop(),
        this.isFadingOut = !1),
        this.isFadingIn && t === 1 && (this.isFadingIn = !1)
    }
}
class GlobalAudios {
    hasInit = !1;
    constructor() {}
    init() {
        this.domRightTalkBtn = document.getElementById("header-right-talk-btn"),
        this.domRightSoundBtn = document.getElementById("header-right-sound-btn"),
        this.domRightMenuBtn = document.getElementById("header-right-menu-btn"),
        this.domHeaderProjectBack = document.getElementById("header-center-project-back-btn"),
        this.domMenuLabLink = document.getElementById("header-menu-labs"),
        this.domEndSectionTitleLink = document.getElementById("end-section-title-link"),
        this.domFooterBottomUp = document.getElementById("footer-bottom-up"),
        this.domFooterEnquiresLink = document.getElementById("footer-enquires-link"),
        this.domFooterBusinessLink = document.getElementById("footer-business-link"),
        this.domFooterBottomLabs = document.getElementById("footer-bottom-labs"),
        this.domMenuLinks = Array.from(document.querySelectorAll("#header-menu-links .header-menu-link")),
        this.domFooterSocialsLinks = Array.from(document.querySelectorAll(".footer-socials-line-wrapper")),
        audios.addHoverClickEvents(this.domRightTalkBtn),
        audios.addHoverClickEvents(this.domRightSoundBtn),
        audios.addHoverClickEvents(this.domRightMenuBtn),
        audios.addHoverClickEvents(this.domHeaderProjectBack),
        audios.addHoverClickEvents(this.domMenuLabLink),
        audios.addHoverClickEvents(this.domEndSectionTitleLink),
        audios.addHoverClickEvents(this.domFooterBottomUp),
        audios.addHoverClickEvents(this.domFooterEnquiresLink),
        audios.addHoverClickEvents(this.domFooterBusinessLink),
        audios.addHoverClickEvents(this.domFooterBottomLabs),
        this.domMenuLinks.forEach(e => audios.addHoverClickEvents(e)),
        this.domFooterSocialsLinks.forEach(e => audios.addHoverClickEvents(e)),
        this.hasInit = !0
    }
    update() {}
}
const globalAudios = new GlobalAudios;
let SKIP_AUDIO = !settings.USE_AUDIO;
class Audios {
    groups = {};
    items = {};
    isActive = !0;
    volume = 0;
    listener = null;
    _boundOnBodyClick = null;
    _onBodyClicked = new MinSignal$2;
    _onRolloverCount = -1;
    _onClickCount = -1;
    _onFocusCount = -1;
    prevBgMusicId = null;
    currBgMusicId = null;
    wasActive = !1;
    _counts = {};
    _maxes = {};
    preInit() {
        if (!SKIP_AUDIO) {
            this._boundOnBodyClick = () => this._onBodyClick(),
            input.onDowned.add(this._boundOnBodyClick);
            for (let e in AUDIO_DATA) {
                let t = new AudioGroup
                  , r = AUDIO_DATA[e];
                t.init({
                    id: e,
                    volume: 1
                }),
                this.groups[e] = t;
                let n = r.length;
                for (; n--; ) {
                    let o = r[n]
                      , l = this._parseCountText(o.id)
                      , c = l.text;
                    if (l.count > 0) {
                        for (let u = 1; u < l.count; u++) {
                            let f = Object.assign({}, o);
                            f.id = l.text + "_" + u,
                            r.push(f)
                        }
                        this._counts[c] = -1,
                        this._maxes[c] = l.count,
                        o.id = l.text + "_0"
                    }
                }
                r.forEach(o => {
                    let l = new AudioItem
                      , c = o.id
                      , u = c + o.ext;
                    o.url = settings.AUDIO_PATH + u,
                    l.preInit(o),
                    l.load( () => {}
                    ),
                    this.items[c] = l,
                    this.groups[e].add(l)
                }
                )
            }
        }
    }
    _parseCountText(e) {
        let t = 0;
        return e.replace(/(.+)_\[(\d)\]/, (r, n, o, l) => {
            e = n,
            t = parseInt(o, 10)
        }
        ),
        {
            text: e,
            count: t
        }
    }
    init() {
        SKIP_AUDIO || (this.getListener(e => {
            for (let t in this.items)
                this.items[t].init(e)
        }
        ),
        globalAudios.init())
    }
    on() {
        this.isActive = !0
    }
    off() {
        this.isActive = !1
    }
    toggle() {
        this.isActive = !this.isActive
    }
    pause() {
        this.wasActive = this.isActive
    }
    resume() {}
    getListener(e) {
        SKIP_AUDIO || (this.listener ? e(this.listener) : this._onBodyClicked.add(e))
    }
    _onBodyClick() {
        SKIP_AUDIO || (input.onDowned.remove(this._boundOnBodyClick),
        this.listener = new AudioListener,
        this._onBodyClicked.dispatch(this.listener),
        properties.camera.add(this.listener))
    }
    addHoverClickEvents(e) {
        SKIP_AUDIO || (this.addHoverEvent(e),
        this.addClickEvent(e))
    }
    addHoverEvent(e, t="hover") {
        SKIP_AUDIO || e.addEventListener("mouseenter", () => {
            this.countPlay(t)
        }
        )
    }
    addClickEvent(e, t="click") {
        SKIP_AUDIO || input.onClicked.add( () => {
            input.hasThroughElem(e, t) && this.countPlay(t)
        }
        )
    }
    countPlay(e) {
        if (SKIP_AUDIO)
            return;
        let t = this._counts[e]
          , r = this._maxes[e];
        t = this._counts[e] = (t + 1) % r,
        this.items[e + "_" + t].play()
    }
    fadeBgMusic(e, t=1, r=void 0) {
        SKIP_AUDIO || this.currBgMusicId !== e && (this.prevBgMusicId = this.currBgMusicId,
        this.currBgMusicId = e,
        r === void 0 && (r = t),
        this.items[this.prevBgMusicId]?.setFadeOut(r),
        this.items[this.currBgMusicId]?.setFadeIn(t))
    }
    update(e) {
        if (!SKIP_AUDIO && (globalAudios.update(e),
        this.listener)) {
            this.volume = math.saturate(this.volume + (this.isActive ? 1 : -1) * e);
            for (let t in this.items)
                this.items[t].update(e);
            for (let t in this.groups)
                this.groups[t].update(this.volume)
        }
    }
}
const audios = new Audios;
class HomeHeroSection {
    domContainer;
    domHomeTitle;
    sectionDomRange;
    preInit(e) {
        this.domContainer = e.querySelector("#home-hero"),
        this.domVisualContainer = e.querySelector("#home-hero-visual-container"),
        this.domHomeTitle = e.querySelector("#home-hero-title"),
        this.domHomeScroll = e.querySelector("#home-hero-scroll"),
        this.domHomeCrosses = Array.from(e.querySelectorAll(".home-hero-scroll-container-cross")),
        this.domHomeScroll = e.querySelector("#home-hero-scroll"),
        this.domHomeScroll._animating = !1,
        this.domHomeScroll._time = 0,
        visuals.stage3DList.push(homeBalloons),
        homeBalloons.preInit(),
        this.frameMesh = new Mesh(fboHelper.triGeom,fboHelper.createRawShaderMaterial({
            uniforms: Object.assign({
                u_viewportResolution: properties.sharedUniforms.u_viewportResolution,
                u_domXY: {
                    value: new Vector2
                },
                u_domWH: {
                    value: new Vector2
                },
                u_bgColor: properties.sharedUniforms.u_bgColor,
                u_globalRadius: properties.sharedUniforms.u_globalRadius
            }),
            vertexShader: frameVert,
            fragmentShader: frameFrag,
            blending: NormalBlending,
            depthTest: !1,
            depthWrite: !1,
            derivatives: !0,
            transparent: !0,
            side: 2
        })),
        this.frameMesh.material.extensions.derivatives = !0,
        homePage.preUfxContainer.add(this.frameMesh),
        this.frameMesh.visible = !1,
        this.frameMesh.renderOrder = -1e3
    }
    init() {
        input.onClicked.add( () => {
            input.hasThroughElem(this.domVisualContainer, "click") && (audios.countPlay("click"),
            homeBalloons.changeHomeHeroColorSignal.dispatch())
        }
        ),
        homeBalloons.init()
    }
    initEvent() {
        window.addEventListener("wheel", this._onWheel.bind(this), {
            once: !0
        })
    }
    resize(e, t) {
        let r = scrollManager.getDomRange(this.domContainer)
          , n = r.isActive;
        homeBalloons.ratio = math.fit(r.ratio, 0, 1, 1, 0) * (n ? 1 : 0);
        let o = new SplitType(this.domHomeTitle,{
            types: "lines, words"
        });
        for (let l = 0; l < o.lines.length; l++) {
            let c = o.lines[l];
            c.style.position = "relative",
            c.style.overflow = "hidden"
        }
        this.domHomeTitle._words = o.words,
        o = new SplitType(this.domHomeScroll,{
            types: "words"
        }),
        this.domHomeScroll._words = o.words,
        properties.hasInitialized && homeBalloons.resize(properties.width, properties.height)
    }
    _updateUi(e) {
        scrollManager.scrollPixel,
        math.fit(this.sectionDomRange.ratio, .3, .7, 0, 1, ease.cubcInOut);
        let t = Math.max(0, homePage.time - 1);
        for (let r = 0; r < this.domHomeTitle._words.length; r++) {
            let n = this.domHomeTitle._words[r]
              , o = t - r / 20;
            n.style.transform = `translate3d(0, ${math.fit(o, 0, 1, 1.7, 0, ease.lusion)}em, 0) rotate(${math.fit(o, 0, .7, 15, 0, ease.lusion)}deg)`
        }
        for (let r = 0; r < this.domHomeCrosses.length; r++) {
            let n = this.domHomeCrosses[r]
              , o = math.fit(t - .2 - r / 10, 0, .6, 0, 1, ease.lusion)
              , l = math.fit(t - .2 - r / 10, 0, .6, 0, 180, ease.lusion);
            n.style.transform = `scale(${o}) rotate(${l}deg)`
        }
        for (let r = 0; r < this.domHomeScroll._words.length; r++) {
            let n = this.domHomeScroll._words[r]
              , o = math.fit(t - .23 - r / 10, 0, .6, .8, 1, ease.lusion)
              , l = math.fit(t - .23 - r / 10, 0, .6, 0, 1, ease.lusion);
            n.style.opacity = l,
            n.style.transform = `scale(${o})`
        }
    }
    _onWheel() {
        this.domHomeScroll._animating = !0
    }
    update(e) {
        this.sectionDomRange = scrollManager.getDomRange(this.domContainer);
        let t = this.sectionDomRange.isActive
          , r = scrollManager.getDomRange(this.domVisualContainer)
          , n = this.frameMesh.material.uniforms;
        if (n.u_domXY.value.set(r.screenX, r.screenY),
        n.u_domWH.value.set(r.width, r.height),
        homeBalloons.ratio = math.fit(this.sectionDomRange.ratio, 0, 1, 1, 0) * (t ? 1 : 0),
        homeBalloons.isActive = homeBalloons.ratio > 0,
        this.frameMesh.visible = t,
        t) {
            homeBalloons.properties.cameraViewportOffsetY = -(r.screenY + r.height * .5 - properties.viewportHeight * .5);
            let o = r.width / r.height
              , l = math.fit(o, 2.2, 2 / 3, 18, 30);
            homeBalloons.properties.cameraFov = l,
            homeBalloonsBackground.clipScale.set((r.width + 2) / properties.viewportWidth, (r.height + 2) / properties.viewportHeight),
            homeBalloonsBackground.clipOffset.set(-1 / properties.viewportWidth, (homeBalloons.properties.cameraViewportOffsetY - 1) / properties.viewportHeight)
        }
        t && properties.hasStarted && this._updateUi(e, this.sectionDomRange)
    }
    hide() {
        this._reset()
    }
    _reset() {
        this.domHomeScroll._animating = !1,
        this.domHomeScroll._time = 0;
        for (let e = 0; e < this.domHomeTitle._words.length; e++) {
            let t = this.domHomeTitle._words[e];
            t.style.transform = "translate3d(0, 100%, 0)"
        }
    }
}
const homeHeroSection = new HomeHeroSection
  , ufxVert = `#define GLSLIFY 1
uniform vec3 u_position;uniform vec4 u_quaternion;uniform vec3 u_scale;uniform vec2 u_domXY;uniform vec2 u_domWH;uniform vec2 u_domPivot;uniform vec4 u_domPadding;vec3 qrotate(vec4 q,vec3 v){return v+2.*cross(q.xyz,cross(q.xyz,v)+q.w*v);}vec3 getBasePosition(in vec3 pos){vec3 basePos=vec3((pos.xy)*u_domWH-u_domPivot,pos.z);basePos.xy+=mix(-u_domPadding.xz,u_domPadding.yw,pos.xy);return basePos;}vec3 getScreenPosition(in vec3 basePos){vec3 screenPos=qrotate(u_quaternion,basePos*u_scale)+vec3(u_domPivot.xy,0.);screenPos=(screenPos+vec3(u_domXY.xy,0.)+u_position)*vec3(1.,-1.,1.);return screenPos;}vec2 padUv(in vec2 uv){vec2 paddedUv=uv+mix(-u_domPadding.xz,u_domPadding.yw,uv)/u_domWH;paddedUv.y=1.-paddedUv.y;return paddedUv;}`
  , quadVert = `#define GLSLIFY 1
#include <ufxVert>
varying vec2 v_uv;void main(){vec3 basePos=getBasePosition(position);vec3 screenPos=getScreenPosition(basePos);gl_Position=projectionMatrix*modelViewMatrix*vec4(screenPos,1.0);v_uv=padUv(uv);}`
  , quadFrag = `#define GLSLIFY 1
uniform sampler2D u_bgTexture;uniform vec2 u_resolution;uniform sampler2D u_texture;varying vec2 v_uv;void main(){vec2 bgUv=gl_FragCoord.xy/u_resolution;vec4 bgColor=texture2D(u_bgTexture,bgUv);float imagePaddingThreshold=max(abs(v_uv.x-.5),abs(v_uv.y-.5));float imageAlpha=smoothstep(0.5,0.5-fwidth(imagePaddingThreshold),imagePaddingThreshold);vec4 image=texture2D(u_texture,v_uv);image.a*=imageAlpha;gl_FragColor.rgb=mix(bgColor.rgb,image.rgb,image.a);gl_FragColor.a=image.a;}`;
ShaderChunk.ufxVert = ufxVert;
new Vector3;
new Vector3;
new Matrix4;
class UfxMesh extends Mesh {
    pivot = new Vector2;
    paddingL = 0;
    paddingR = 0;
    paddingT = 0;
    paddingB = 0;
    refDom;
    requireBg;
    tick = 0;
    _domX = 0;
    _domY = 0;
    _domWidth = 0;
    _domHeight = 0;
    _capturedOffsetX = 0;
    _capturedOffsetY = 0;
    constructor(e={}) {
        let t = e.geometry || new PlaneGeometry(1,1,e.segX || 1,e.segY || 1).translate(.5, .5, 0);
        t.computeBoundingBox(),
        super(t, e.material),
        this.refDom = e.refDom,
        this.pivot = e.pivot || new Vector2(.5,.5),
        this.matrixAutoUpdate = !1,
        this.frustumCulled = !1,
        this.requireBg = e.requireBg === !0,
        this.paddingL = e.paddingL || 0,
        this.paddingR = e.paddingR || 0,
        this.paddingT = e.paddingT || 0,
        this.paddingB = e.paddingB || 0,
        this._initMaterial(e),
        this.onBeforeRender = this._onBeforeRender.bind(this)
    }
    _onBeforeRender() {
        if (this.requireBg) {
            let e = fboHelper.renderer
              , t = e.getRenderTarget();
            fboHelper.clearMultisampleRenderTargetState(),
            fboHelper.copy(properties.postprocessing.sceneTexture, properties.postprocessing.fromRenderTarget),
            e.setRenderTarget(t)
        }
    }
    _initMaterial(e) {
        this.material != e.material && (this.material = new ShaderMaterial({
            vertexShader: e.vertexShader || quadVert,
            fragmentShader: e.fragmentShader || quadFrag
        }),
        this.material.side = DoubleSide,
        this.material.transparent = !0);
        for (let r in e)
            this.material[r] !== void 0 && (this.material[r] = e[r]);
        this.material.extensions.derivatives = !0;
        let t = this.material.uniforms;
        t && (t.u_position = {
            value: this.position
        },
        t.u_quaternion = {
            value: this.quaternion
        },
        t.u_scale = {
            value: this.scale
        },
        t.u_domXY = {
            value: new Vector2
        },
        t.u_domWH = {
            value: new Vector2
        },
        t.u_domPivot = {
            value: new Vector2
        },
        t.u_domPadding = {
            value: new Vector4
        },
        t.u_bgTexture = properties.postprocessing.sharedUniforms.u_fromTexture,
        t.u_resolution = properties.postprocessing.sharedUniforms.u_resolution,
        t.u_viewportResolution = properties.sharedUniforms.u_viewportResolution)
    }
    syncDom(e=0, t=0) {
        if (this.refDom) {
            let r = this.refDom.getBoundingClientRect();
            this.syncRect(r.left, r.top, Math.ceil(r.width), Math.ceil(r.height), e, t)
        } else
            console.warn("refDom is missing")
    }
    syncRect(e, t, r, n, o=0, l=0) {
        this._domX = e,
        this._domY = t,
        this._domWidth = Math.ceil(r),
        this._domHeight = Math.ceil(n),
        this.material.uniforms.u_domWH.value.set(this._domWidth, this._domHeight),
        this._capturedOffsetY = o,
        this._capturedOffsetX = l
    }
    testViewport(e=0, t=0) {
        let r = this._domX - this._capturedOffsetX + t
          , n = r + this._domWidth
          , o = this._domY - this._capturedOffsetY + e
          , l = o + this._domHeight;
        return o < properties.viewportHeight && l > 0 && r < properties.viewportWidth && n > 0
    }
    update(e=0, t=0) {
        let r = this.material.uniforms;
        r.u_domXY.value.set(this._domX - this._capturedOffsetX + t, this._domY - this._capturedOffsetY + e),
        r.u_domPivot.value.set(this._domWidth * this.pivot.x, this._domHeight * this.pivot.y),
        r.u_domPadding.value.set(this.paddingL, this.paddingR, this.paddingT, this.paddingB),
        this.tick++
    }
}
const videoVert = `#define GLSLIFY 1
uniform vec3 u_position;uniform vec4 u_quaternion;uniform vec3 u_scale;uniform vec2 u_domXYFrom;uniform vec2 u_domWHFrom;uniform vec2 u_domXY;uniform vec2 u_domWH;uniform vec2 u_domPivot;uniform vec4 u_domPadding;uniform float u_showRatio;varying vec2 v_uv;varying vec2 v_domWH;varying float v_showRatio;varying float v_deltaRatio;vec3 qrotate(vec4 q,vec3 v){return v+2.*cross(q.xyz,cross(q.xyz,v)+q.w*v);}vec3 getBasePosition(in vec3 pos,in vec2 domWH){vec3 basePos=vec3((pos.xy)*domWH-u_domPivot,pos.z);basePos.xy+=mix(-u_domPadding.xz,u_domPadding.yw,pos.xy);return basePos;}float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}vec3 getScreenPosition(in vec3 basePos,in vec2 domXY){vec3 screenPos=qrotate(u_quaternion,basePos*u_scale)+vec3(u_domPivot.xy,0.);screenPos=(screenPos+vec3(domXY,0.)+u_position)*vec3(1.,-1.,1.);return screenPos;}float cubicBezier(float p0,float p1,float p2,float p3,float t){float c=(p1-p0)*3.;float b=(p2-p1)*3.-c;float a=p3-p0-c-b;float t2=t*t;float t3=t2*t;return a*t3+b*t2+c*t+p0;}float easeOutBack(float t){return cubicBezier(0.,1.3,1.1,1.,t);}void main(){float placementWeight=1.-(pow(position.x*position.x,0.75)+pow(1.-position.y,1.5))/2.;v_showRatio=(smoothstep(placementWeight*0.3,0.7+placementWeight*0.3,u_showRatio));vec2 domXY=mix(u_domXYFrom,u_domXY,v_showRatio);vec2 domWH=mix(u_domWHFrom,u_domWH,v_showRatio);domXY.x+=mix(domWH.x,0.,cos(v_showRatio*3.1415926*2.)*0.5+0.5)*0.1;vec3 basePos=getBasePosition(position,domWH);float rot=(smoothstep(0.,1.,v_showRatio)-v_showRatio)*-0.5;vec3 rotBasePos=qrotate(vec4(0.,0.,sin(rot),cos(rot)),basePos);vec3 screenPos=getScreenPosition(rotBasePos,domXY);gl_Position=projectionMatrix*modelViewMatrix*vec4(screenPos,1.0);v_uv=vec2(uv.x,1.-uv.y);v_domWH=domWH;}`
  , videoFrag = `#define GLSLIFY 1
uniform sampler2D u_screenPaintTexture;uniform vec2 u_resolution;uniform vec3 u_color;uniform sampler2D u_texture;uniform vec2 u_textureSize;uniform float u_time;uniform vec2 u_radialCenter;uniform float u_showRatio;uniform float u_globalRadius;uniform float u_aspectScale;varying vec2 v_uv;varying vec2 v_domWH;varying float v_showRatio;
#include <getBlueNoise>
float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}float sdRoundedBox(in vec2 p,in vec2 b,in float r){vec2 q=abs(p)-b+r;return min(max(q.x,q.y),0.0)+length(max(q,0.0))-r;}float getRoundedCornerMask(vec2 uv,vec2 size,float radius,float ratio){vec2 halfSize=size*0.5;float maxDist=length(halfSize);float minSize=min(halfSize.x,halfSize.y);float maxSize=max(halfSize.x,halfSize.y);float t=ratio*maxDist;radius=mix(minSize*linearStep(0.,minSize,t),radius,linearStep(maxSize,maxDist,t));halfSize=min(halfSize,vec2(t));float d=sdRoundedBox((uv-.5)*v_domWH,halfSize,radius);return smoothstep(0.,0.-fwidth(d),d);}void main(){vec3 noise=getBlueNoise(gl_FragCoord.xy+vec2(6.,25.));float imageAlpha=getRoundedCornerMask(v_uv,v_domWH,u_globalRadius,1.0);vec2 baseUv=v_uv;float toRadialCenterDist=length((baseUv-u_radialCenter)*vec2(v_domWH.x/v_domWH.y,1.));baseUv.y=(baseUv.y-.5)*mix(1.,u_aspectScale,v_showRatio)+0.5;vec3 color=texture2D(u_texture,baseUv).rgb;vec3 tintedColor=max(u_color,vec3(dot(color,vec3(0.299,0.587,0.114))));gl_FragColor=vec4(mix(tintedColor,color,v_showRatio),imageAlpha);}`
  , vert$j = `#define GLSLIFY 1
attribute vec3 CP;attribute float Cd;varying float v_cd;varying float v_lineRatio;varying float v_s;uniform float u_scrollY;uniform vec2 u_viewportResolution;uniform vec2 u_aspect;uniform vec2 u_margin;uniform float u_radius;void main(){vec3 pos=vec3(CP.xy+position.xy*u_radius,0.0);gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.0);v_cd=Cd;v_lineRatio=position.z;v_s=CP.z;}`
  , frag$m = `#define GLSLIFY 1
varying float v_cd;varying float v_lineRatio;varying float v_s;uniform float u_showRatio;uniform float u_hideRatio;uniform vec3 u_colorBg;uniform vec3 u_color0;uniform vec3 u_color1;uniform float u_aoThreshold;float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}vec3 hsv2rgb(in vec3 c){vec3 rgb=clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);rgb=rgb*rgb*(3.0-2.0*rgb);return c.z*mix(vec3(1.0),rgb,c.y);}vec3 rgb2hsv(vec3 c){vec4 K=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.0*d+e)),d/(q.x+e),q.x);}vec3 lerpHSV(in vec3 a,in vec3 b,in float x){float hue=(mod(mod((b.x-a.x),1.)+1.5,1.)-0.5)*x+a.x;return vec3(hue,mix(a.yz,b.yz,x));}void main(){float ao=0.9+0.1*v_cd;float aoRatio=linearStep(u_aoThreshold-0.02,u_aoThreshold+0.02,u_showRatio);if(step(u_showRatio,v_lineRatio)>0.5)discard;float mixRatio=1.0-pow(1.0-clamp(v_lineRatio,0.0,1.0),2.0);gl_FragColor.rgb=hsv2rgb(lerpHSV(rgb2hsv(u_color1),rgb2hsv(u_color0),mixRatio));gl_FragColor.rgb*=min(1.0,ao+1.0-aoRatio);float alpha=abs(v_s-.5);gl_FragColor.a=linearStep(0.5,0.5-fwidth(alpha),alpha);}`
  , lineEndVert = `#define GLSLIFY 1
uniform vec3 u_color0;uniform vec3 u_color1;uniform float u_mixRatio;uniform float u_ao;vec3 hsv2rgb(in vec3 c){vec3 rgb=clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);rgb=rgb*rgb*(3.0-2.0*rgb);return c.z*mix(vec3(1.0),rgb,c.y);}vec3 rgb2hsv(vec3 c){vec4 K=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.0*d+e)),d/(q.x+e),q.x);}vec3 lerpHSV(in vec3 a,in vec3 b,in float x){float hue=(mod(mod((b.x-a.x),1.)+1.5,1.)-0.5)*x+a.x;return vec3(hue,mix(a.yz,b.yz,x));}varying vec3 v_color;varying vec2 v_uv;void main(){v_color=u_ao*hsv2rgb(lerpHSV(rgb2hsv(u_color1),rgb2hsv(u_color0),u_mixRatio));v_uv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`
  , lineEndFrag = `#define GLSLIFY 1
varying vec3 v_color;varying vec2 v_uv;void main(){float d=length(v_uv-.5)*2.;gl_FragColor.rgb=v_color;gl_FragColor.a=smoothstep(1.,1.-fwidth(d),d);}`
  , _v0$2 = new Vector3
  , _v1$5 = new Vector3
  , _box = new Box3
  , LINES_DATA_LIST = [{
    fileName: "line_reel",
    aoThreshold: .555,
    margin: {
        x: -.05,
        y: -.8
    },
    scrollToRatioFactors: [.4, 1.3],
    boxMin: new Vector3(-.0112049,-.0141946,0),
    boxMax: new Vector3(1.01357,.718671,0),
    color0: "#5a90ff",
    color1: "#2a38ee"
}, {
    fileName: "line_goal",
    aoThreshold: 1e-4,
    margin: {
        x: .2,
        y: -.6
    },
    scrollToRatioFactors: [1.2, 2],
    boxMin: new Vector3(-.0180006,-.00963629,0),
    boxMax: new Vector3(1.01777,.850395,0),
    color0: "#94fffb",
    color1: "#1285dc"
}, {
    fileName: "line_capability",
    aoThreshold: 1e-4,
    margin: {
        x: 0,
        y: -1.15
    },
    scrollToRatioFactors: [0, 2],
    boxMin: new Vector3(-.0165916,-.0152524,0),
    boxMax: new Vector3(1.018,1.08872,0),
    color0: "#fff",
    color1: "#bbb"
}, {
    fileName: "line_office",
    aoThreshold: 1e-4,
    margin: {
        x: 0,
        y: -2.2
    },
    boxMin: new Vector3(-.0131718,-.0141192,0),
    boxMax: new Vector3(1.01767,1.2037,0),
    scrollToRatioFactors: [-2, 1.85],
    color0: "#fff",
    color1: "#bbb"
}];
class Line {
    container = new Object3D;
    innerContainer = new Object3D;
    geometry = new BufferGeometry;
    mesh = null;
    lineId = 0;
    aoThreshold = .47;
    radius = .008;
    lineData = null;
    constructor(e=0) {
        this.lineId = e,
        this.lineData = LINES_DATA_LIST[this.lineId]
    }
    preInit() {
        this.container.add(this.innerContainer),
        properties.loader.add(settings.MODEL_PATH + "lines/" + this.lineData.fileName + ".buf", {
            onLoad: e => this.geometry = e
        })
    }
    init() {
        this.mesh = new Mesh(this.geometry,new ShaderMaterial({
            uniforms: {
                u_showRatio: {
                    value: 0
                },
                u_aoThreshold: {
                    value: this.lineData.aoThreshold
                },
                u_colorBg: {
                    value: new Color
                },
                u_color0: {
                    value: new Color(this.lineData.color0)
                },
                u_color1: {
                    value: new Color(this.lineData.color1)
                },
                u_scrollY: {
                    value: 0
                },
                u_radius: {
                    value: 0
                },
                u_aspect: {
                    value: new Vector2
                },
                u_margin: {
                    value: new Vector2(this.lineData.margin.x,this.lineData.margin.y)
                },
                u_viewportResolution: properties.sharedUniforms.u_viewportResolution
            },
            vertexShader: vert$j,
            fragmentShader: frag$m,
            depthTest: !1,
            transparent: !0
        })),
        this.mesh.frustumCulled = !1,
        this.mesh.material.defines.IS_LINE = !0,
        this.mesh.material.extensions.derivatives = !0,
        this.box = new Box3().setFromObject(this.mesh),
        this.innerContainer.add(this.mesh),
        this.circle = new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({
            uniforms: {
                u_color0: {
                    value: new Color(this.lineData.color0)
                },
                u_color1: {
                    value: new Color(this.lineData.color1)
                },
                u_ao: {
                    value: 1
                },
                u_mixRatio: {
                    value: 0
                }
            },
            vertexShader: lineEndVert,
            fragmentShader: lineEndFrag,
            side: 2,
            depthTest: !1,
            transparent: !0
        })),
        this.circle.material.extensions.derivatives = !0,
        this.circle.frustumCulled = !1,
        this.innerContainer.add(this.circle);
        const {array: e, count: t} = this.geometry.attributes.position;
        this.lineRatioArray = new Float32Array(this.geometry.attributes.position.count);
        for (let r = 0; r < t; r++)
            this.lineRatioArray[r] = e[r * 3 + 2]
    }
    resize(e, t) {
        const r = t / Math.sqrt(e * e + t * t);
        this.mesh.material.uniforms.u_aspect.value.set(e / t * r, r)
    }
    update(e, t, r=0) {
        let n = this.radius * math.fit(properties.viewportWidth, 540, 1920, 2, 1)
          , o = math.saturate(-(t.screenY - this.lineData.scrollToRatioFactors[0] * properties.viewportHeight) / (this.lineData.scrollToRatioFactors[1] * properties.viewportHeight));
        o = ease.quadInOut(o);
        const l = t.screenY + r;
        let c = properties.viewportWidth / this.mesh.material.uniforms.u_aspect.value.x
          , u = properties.viewportHeight / this.mesh.material.uniforms.u_aspect.value.y;
        this.mesh.material.uniforms.u_showRatio.value = math.saturate(o),
        this.mesh.material.uniforms.u_scrollY.value = -l,
        this.mesh.material.uniforms.u_colorBg.value.copy(properties.bgColor),
        this.mesh.material.uniforms.u_radius.value = n,
        this.innerContainer.position.x = this.lineData.margin.x * c,
        this.innerContainer.position.y = this.lineData.margin.y * u - l,
        this.innerContainer.scale.x = c,
        this.innerContainer.scale.y = u,
        this.container.visible = !1,
        this.container.parent && (this.container.parent.updateMatrixWorld(!0),
        _box.min.copy(this.lineData.boxMin),
        _box.max.copy(this.lineData.boxMax),
        _box.applyMatrix4(this.innerContainer.matrixWorld),
        this.container.visible = _box.max.y > -properties.viewportHeight && _box.min.y < 0);
        const {array: f, count: p} = this.geometry.attributes.CP
          , {array: g} = this.geometry.attributes.position;
        let v = 0
          , _ = 0;
        for (let M = 0; M < p; M++)
            o >= this.lineRatioArray[M] && (v = M,
            M === p - 1 ? _ = 0 : _ = (o - this.lineRatioArray[M]) / (this.lineRatioArray[M + 1] - this.lineRatioArray[M]));
        const w = v
          , S = Math.min(v + 1, p - 1);
        _v0$2.fromArray(f, v * 3),
        _v1$5.fromArray(f, Math.min(p - 1, v + 1) * 3),
        _v0$2.lerp(_v1$5, _);
        const b = this.geometry.attributes.Cd.array;
        let C = math.lerp(b[w], b[S], _);
        C = .9 + .1 * C;
        const R = math.linearStep(this.lineData.aoThreshold - .02, this.lineData.aoThreshold + .02, o);
        this.circle.position.copy(_v0$2),
        this.circle.scale.set(n, n, 1),
        this.circle.material.uniforms.u_ao.value = Math.min(1, C + 1 - R);
        let T = math.lerp(g[w * 3 + 2], g[S * 3 + 2], _);
        T = 1 - Math.pow(1 - math.clamp(T, 0, 1), 2),
        this.circle.material.uniforms.u_mixRatio.value = T
    }
}
/*! @vimeo/player v2.24.0 | (c) 2024 Vimeo | MIT License | https://github.com/vimeo/player.js */
function ownKeys(a, e) {
    var t = Object.keys(a);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(a);
        e && (r = r.filter(function(n) {
            return Object.getOwnPropertyDescriptor(a, n).enumerable
        })),
        t.push.apply(t, r)
    }
    return t
}
function _objectSpread2(a) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(a, r, t[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(a, r, Object.getOwnPropertyDescriptor(t, r))
        })
    }
    return a
}
function _regeneratorRuntime() {
    _regeneratorRuntime = function() {
        return a
    }
    ;
    var a = {}
      , e = Object.prototype
      , t = e.hasOwnProperty
      , r = Object.defineProperty || function(H, B, D) {
        H[B] = D.value
    }
      , n = typeof Symbol == "function" ? Symbol : {}
      , o = n.iterator || "@@iterator"
      , l = n.asyncIterator || "@@asyncIterator"
      , c = n.toStringTag || "@@toStringTag";
    function u(H, B, D) {
        return Object.defineProperty(H, B, {
            value: D,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }),
        H[B]
    }
    try {
        u({}, "")
    } catch {
        u = function(B, D, q) {
            return B[D] = q
        }
    }
    function f(H, B, D, q) {
        var V = B && B.prototype instanceof v ? B : v
          , J = Object.create(V.prototype)
          , U = new O(q || []);
        return r(J, "_invoke", {
            value: P(H, D, U)
        }),
        J
    }
    function p(H, B, D) {
        try {
            return {
                type: "normal",
                arg: H.call(B, D)
            }
        } catch (q) {
            return {
                type: "throw",
                arg: q
            }
        }
    }
    a.wrap = f;
    var g = {};
    function v() {}
    function _() {}
    function w() {}
    var S = {};
    u(S, o, function() {
        return this
    });
    var b = Object.getPrototypeOf
      , C = b && b(b(W([])));
    C && C !== e && t.call(C, o) && (S = C);
    var R = w.prototype = v.prototype = Object.create(S);
    function T(H) {
        ["next", "throw", "return"].forEach(function(B) {
            u(H, B, function(D) {
                return this._invoke(B, D)
            })
        })
    }
    function M(H, B) {
        function D(V, J, U, ce) {
            var ee = p(H[V], H, J);
            if (ee.type !== "throw") {
                var ne = ee.arg
                  , ae = ne.value;
                return ae && typeof ae == "object" && t.call(ae, "__await") ? B.resolve(ae.__await).then(function(ve) {
                    D("next", ve, U, ce)
                }, function(ve) {
                    D("throw", ve, U, ce)
                }) : B.resolve(ae).then(function(ve) {
                    ne.value = ve,
                    U(ne)
                }, function(ve) {
                    return D("throw", ve, U, ce)
                })
            }
            ce(ee.arg)
        }
        var q;
        r(this, "_invoke", {
            value: function(V, J) {
                function U() {
                    return new B(function(ce, ee) {
                        D(V, J, ce, ee)
                    }
                    )
                }
                return q = q ? q.then(U, U) : U()
            }
        })
    }
    function P(H, B, D) {
        var q = "suspendedStart";
        return function(V, J) {
            if (q === "executing")
                throw new Error("Generator is already running");
            if (q === "completed") {
                if (V === "throw")
                    throw J;
                return Q()
            }
            for (D.method = V,
            D.arg = J; ; ) {
                var U = D.delegate;
                if (U) {
                    var ce = I(U, D);
                    if (ce) {
                        if (ce === g)
                            continue;
                        return ce
                    }
                }
                if (D.method === "next")
                    D.sent = D._sent = D.arg;
                else if (D.method === "throw") {
                    if (q === "suspendedStart")
                        throw q = "completed",
                        D.arg;
                    D.dispatchException(D.arg)
                } else
                    D.method === "return" && D.abrupt("return", D.arg);
                q = "executing";
                var ee = p(H, B, D);
                if (ee.type === "normal") {
                    if (q = D.done ? "completed" : "suspendedYield",
                    ee.arg === g)
                        continue;
                    return {
                        value: ee.arg,
                        done: D.done
                    }
                }
                ee.type === "throw" && (q = "completed",
                D.method = "throw",
                D.arg = ee.arg)
            }
        }
    }
    function I(H, B) {
        var D = B.method
          , q = H.iterator[D];
        if (q === void 0)
            return B.delegate = null,
            D === "throw" && H.iterator.return && (B.method = "return",
            B.arg = void 0,
            I(H, B),
            B.method === "throw") || D !== "return" && (B.method = "throw",
            B.arg = new TypeError("The iterator does not provide a '" + D + "' method")),
            g;
        var V = p(q, H.iterator, B.arg);
        if (V.type === "throw")
            return B.method = "throw",
            B.arg = V.arg,
            B.delegate = null,
            g;
        var J = V.arg;
        return J ? J.done ? (B[H.resultName] = J.value,
        B.next = H.nextLoc,
        B.method !== "return" && (B.method = "next",
        B.arg = void 0),
        B.delegate = null,
        g) : J : (B.method = "throw",
        B.arg = new TypeError("iterator result is not an object"),
        B.delegate = null,
        g)
    }
    function k(H) {
        var B = {
            tryLoc: H[0]
        };
        1 in H && (B.catchLoc = H[1]),
        2 in H && (B.finallyLoc = H[2],
        B.afterLoc = H[3]),
        this.tryEntries.push(B)
    }
    function A(H) {
        var B = H.completion || {};
        B.type = "normal",
        delete B.arg,
        H.completion = B
    }
    function O(H) {
        this.tryEntries = [{
            tryLoc: "root"
        }],
        H.forEach(k, this),
        this.reset(!0)
    }
    function W(H) {
        if (H) {
            var B = H[o];
            if (B)
                return B.call(H);
            if (typeof H.next == "function")
                return H;
            if (!isNaN(H.length)) {
                var D = -1
                  , q = function V() {
                    for (; ++D < H.length; )
                        if (t.call(H, D))
                            return V.value = H[D],
                            V.done = !1,
                            V;
                    return V.value = void 0,
                    V.done = !0,
                    V
                };
                return q.next = q
            }
        }
        return {
            next: Q
        }
    }
    function Q() {
        return {
            value: void 0,
            done: !0
        }
    }
    return _.prototype = w,
    r(R, "constructor", {
        value: w,
        configurable: !0
    }),
    r(w, "constructor", {
        value: _,
        configurable: !0
    }),
    _.displayName = u(w, c, "GeneratorFunction"),
    a.isGeneratorFunction = function(H) {
        var B = typeof H == "function" && H.constructor;
        return !!B && (B === _ || (B.displayName || B.name) === "GeneratorFunction")
    }
    ,
    a.mark = function(H) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(H, w) : (H.__proto__ = w,
        u(H, c, "GeneratorFunction")),
        H.prototype = Object.create(R),
        H
    }
    ,
    a.awrap = function(H) {
        return {
            __await: H
        }
    }
    ,
    T(M.prototype),
    u(M.prototype, l, function() {
        return this
    }),
    a.AsyncIterator = M,
    a.async = function(H, B, D, q, V) {
        V === void 0 && (V = Promise);
        var J = new M(f(H, B, D, q),V);
        return a.isGeneratorFunction(B) ? J : J.next().then(function(U) {
            return U.done ? U.value : J.next()
        })
    }
    ,
    T(R),
    u(R, c, "Generator"),
    u(R, o, function() {
        return this
    }),
    u(R, "toString", function() {
        return "[object Generator]"
    }),
    a.keys = function(H) {
        var B = Object(H)
          , D = [];
        for (var q in B)
            D.push(q);
        return D.reverse(),
        function V() {
            for (; D.length; ) {
                var J = D.pop();
                if (J in B)
                    return V.value = J,
                    V.done = !1,
                    V
            }
            return V.done = !0,
            V
        }
    }
    ,
    a.values = W,
    O.prototype = {
        constructor: O,
        reset: function(H) {
            if (this.prev = 0,
            this.next = 0,
            this.sent = this._sent = void 0,
            this.done = !1,
            this.delegate = null,
            this.method = "next",
            this.arg = void 0,
            this.tryEntries.forEach(A),
            !H)
                for (var B in this)
                    B.charAt(0) === "t" && t.call(this, B) && !isNaN(+B.slice(1)) && (this[B] = void 0)
        },
        stop: function() {
            this.done = !0;
            var H = this.tryEntries[0].completion;
            if (H.type === "throw")
                throw H.arg;
            return this.rval
        },
        dispatchException: function(H) {
            if (this.done)
                throw H;
            var B = this;
            function D(ee, ne) {
                return J.type = "throw",
                J.arg = H,
                B.next = ee,
                ne && (B.method = "next",
                B.arg = void 0),
                !!ne
            }
            for (var q = this.tryEntries.length - 1; q >= 0; --q) {
                var V = this.tryEntries[q]
                  , J = V.completion;
                if (V.tryLoc === "root")
                    return D("end");
                if (V.tryLoc <= this.prev) {
                    var U = t.call(V, "catchLoc")
                      , ce = t.call(V, "finallyLoc");
                    if (U && ce) {
                        if (this.prev < V.catchLoc)
                            return D(V.catchLoc, !0);
                        if (this.prev < V.finallyLoc)
                            return D(V.finallyLoc)
                    } else if (U) {
                        if (this.prev < V.catchLoc)
                            return D(V.catchLoc, !0)
                    } else {
                        if (!ce)
                            throw new Error("try statement without catch or finally");
                        if (this.prev < V.finallyLoc)
                            return D(V.finallyLoc)
                    }
                }
            }
        },
        abrupt: function(H, B) {
            for (var D = this.tryEntries.length - 1; D >= 0; --D) {
                var q = this.tryEntries[D];
                if (q.tryLoc <= this.prev && t.call(q, "finallyLoc") && this.prev < q.finallyLoc) {
                    var V = q;
                    break
                }
            }
            V && (H === "break" || H === "continue") && V.tryLoc <= B && B <= V.finallyLoc && (V = null);
            var J = V ? V.completion : {};
            return J.type = H,
            J.arg = B,
            V ? (this.method = "next",
            this.next = V.finallyLoc,
            g) : this.complete(J)
        },
        complete: function(H, B) {
            if (H.type === "throw")
                throw H.arg;
            return H.type === "break" || H.type === "continue" ? this.next = H.arg : H.type === "return" ? (this.rval = this.arg = H.arg,
            this.method = "return",
            this.next = "end") : H.type === "normal" && B && (this.next = B),
            g
        },
        finish: function(H) {
            for (var B = this.tryEntries.length - 1; B >= 0; --B) {
                var D = this.tryEntries[B];
                if (D.finallyLoc === H)
                    return this.complete(D.completion, D.afterLoc),
                    A(D),
                    g
            }
        },
        catch: function(H) {
            for (var B = this.tryEntries.length - 1; B >= 0; --B) {
                var D = this.tryEntries[B];
                if (D.tryLoc === H) {
                    var q = D.completion;
                    if (q.type === "throw") {
                        var V = q.arg;
                        A(D)
                    }
                    return V
                }
            }
            throw new Error("illegal catch attempt")
        },
        delegateYield: function(H, B, D) {
            return this.delegate = {
                iterator: W(H),
                resultName: B,
                nextLoc: D
            },
            this.method === "next" && (this.arg = void 0),
            g
        }
    },
    a
}
function asyncGeneratorStep(a, e, t, r, n, o, l) {
    try {
        var c = a[o](l)
          , u = c.value
    } catch (f) {
        t(f);
        return
    }
    c.done ? e(u) : Promise.resolve(u).then(r, n)
}
function _asyncToGenerator(a) {
    return function() {
        var e = this
          , t = arguments;
        return new Promise(function(r, n) {
            var o = a.apply(e, t);
            function l(u) {
                asyncGeneratorStep(o, r, n, l, c, "next", u)
            }
            function c(u) {
                asyncGeneratorStep(o, r, n, l, c, "throw", u)
            }
            l(void 0)
        }
        )
    }
}
function _classCallCheck(a, e) {
    if (!(a instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function _defineProperties(a, e) {
    for (var t = 0; t < e.length; t++) {
        var r = e[t];
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        "value"in r && (r.writable = !0),
        Object.defineProperty(a, _toPropertyKey(r.key), r)
    }
}
function _createClass(a, e, t) {
    return e && _defineProperties(a.prototype, e),
    t && _defineProperties(a, t),
    Object.defineProperty(a, "prototype", {
        writable: !1
    }),
    a
}
function _defineProperty(a, e, t) {
    return e = _toPropertyKey(e),
    e in a ? Object.defineProperty(a, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : a[e] = t,
    a
}
function _inherits(a, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function");
    a.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: a,
            writable: !0,
            configurable: !0
        }
    }),
    Object.defineProperty(a, "prototype", {
        writable: !1
    }),
    e && _setPrototypeOf(a, e)
}
function _getPrototypeOf(a) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t)
    }
    ,
    _getPrototypeOf(a)
}
function _setPrototypeOf(a, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
        return r.__proto__ = n,
        r
    }
    ,
    _setPrototypeOf(a, e)
}
function _isNativeReflectConstruct() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
    if (typeof Proxy == "function")
        return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
        !0
    } catch {
        return !1
    }
}
function _construct(a, e, t) {
    return _isNativeReflectConstruct() ? _construct = Reflect.construct.bind() : _construct = function(n, o, l) {
        var c = [null];
        c.push.apply(c, o);
        var u = Function.bind.apply(n, c)
          , f = new u;
        return l && _setPrototypeOf(f, l.prototype),
        f
    }
    ,
    _construct.apply(null, arguments)
}
function _isNativeFunction(a) {
    return Function.toString.call(a).indexOf("[native code]") !== -1
}
function _wrapNativeSuper(a) {
    var e = typeof Map == "function" ? new Map : void 0;
    return _wrapNativeSuper = function(r) {
        if (r === null || !_isNativeFunction(r))
            return r;
        if (typeof r != "function")
            throw new TypeError("Super expression must either be null or a function");
        if (typeof e < "u") {
            if (e.has(r))
                return e.get(r);
            e.set(r, n)
        }
        function n() {
            return _construct(r, arguments, _getPrototypeOf(this).constructor)
        }
        return n.prototype = Object.create(r.prototype, {
            constructor: {
                value: n,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        _setPrototypeOf(n, r)
    }
    ,
    _wrapNativeSuper(a)
}
function _assertThisInitialized(a) {
    if (a === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return a
}
function _possibleConstructorReturn(a, e) {
    if (e && (typeof e == "object" || typeof e == "function"))
        return e;
    if (e !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(a)
}
function _createSuper(a) {
    var e = _isNativeReflectConstruct();
    return function() {
        var r = _getPrototypeOf(a), n;
        if (e) {
            var o = _getPrototypeOf(this).constructor;
            n = Reflect.construct(r, arguments, o)
        } else
            n = r.apply(this, arguments);
        return _possibleConstructorReturn(this, n)
    }
}
function _toPrimitive(a, e) {
    if (typeof a != "object" || a === null)
        return a;
    var t = a[Symbol.toPrimitive];
    if (t !== void 0) {
        var r = t.call(a, e || "default");
        if (typeof r != "object")
            return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(a)
}
function _toPropertyKey(a) {
    var e = _toPrimitive(a, "string");
    return typeof e == "symbol" ? e : String(e)
}
var isNode = typeof global < "u" && {}.toString.call(global) === "[object global]";
function getMethodName(a, e) {
    return a.indexOf(e.toLowerCase()) === 0 ? a : "".concat(e.toLowerCase()).concat(a.substr(0, 1).toUpperCase()).concat(a.substr(1))
}
function isDomElement(a) {
    return !!(a && a.nodeType === 1 && "nodeName"in a && a.ownerDocument && a.ownerDocument.defaultView)
}
function isInteger(a) {
    return !isNaN(parseFloat(a)) && isFinite(a) && Math.floor(a) == a
}
function isVimeoUrl(a) {
    return /^(https?:)?\/\/((((player|www)\.)?vimeo\.com)|((player\.)?[a-zA-Z0-9-]+\.(videoji\.(hk|cn)|vimeo\.work)))(?=$|\/)/.test(a)
}
function isVimeoEmbed(a) {
    var e = /^https:\/\/player\.((vimeo\.com)|([a-zA-Z0-9-]+\.(videoji\.(hk|cn)|vimeo\.work)))\/video\/\d+/;
    return e.test(a)
}
function getOembedDomain(a) {
    for (var e = (a || "").match(/^(?:https?:)?(?:\/\/)?([^/?]+)/), t = (e && e[1] || "").replace("player.", ""), r = [".videoji.hk", ".vimeo.work", ".videoji.cn"], n = 0, o = r; n < o.length; n++) {
        var l = o[n];
        if (t.endsWith(l))
            return t
    }
    return "vimeo.com"
}
function getVimeoUrl() {
    var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
      , e = a.id
      , t = a.url
      , r = e || t;
    if (!r)
        throw new Error("An id or url must be passed, either in an options object or as a data-vimeo-id or data-vimeo-url attribute.");
    if (isInteger(r))
        return "https://vimeo.com/".concat(r);
    if (isVimeoUrl(r))
        return r.replace("http:", "https:");
    throw e ? new TypeError("".concat(e, " is not a valid video id.")) : new TypeError("".concat(r, " is not a vimeo.com url."))
}
var subscribe = function a(e, t, r) {
    var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "addEventListener"
      , o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "removeEventListener"
      , l = typeof t == "string" ? [t] : t;
    return l.forEach(function(c) {
        e[n](c, r)
    }),
    {
        cancel: function() {
            return l.forEach(function(u) {
                return e[o](u, r)
            })
        }
    }
}
  , arrayIndexOfSupport = typeof Array.prototype.indexOf < "u"
  , postMessageSupport = typeof window < "u" && typeof window.postMessage < "u";
if (!isNode && (!arrayIndexOfSupport || !postMessageSupport))
    throw new Error("Sorry, the Vimeo Player API is not available in this browser.");
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function createCommonjsModule(a, e) {
    return e = {
        exports: {}
    },
    a(e, e.exports),
    e.exports
}
/*!
 * weakmap-polyfill v2.0.4 - ECMAScript6 WeakMap polyfill
 * https://github.com/polygonplanet/weakmap-polyfill
 * Copyright (c) 2015-2021 polygonplanet <polygon.planet.aqua@gmail.com>
 * @license MIT
 */
(function(a) {
    if (a.WeakMap)
        return;
    var e = Object.prototype.hasOwnProperty
      , t = Object.defineProperty && function() {
        try {
            return Object.defineProperty({}, "x", {
                value: 1
            }).x === 1
        } catch {}
    }()
      , r = function(o, l, c) {
        t ? Object.defineProperty(o, l, {
            configurable: !0,
            writable: !0,
            value: c
        }) : o[l] = c
    };
    a.WeakMap = function() {
        function o() {
            if (this === void 0)
                throw new TypeError("Constructor WeakMap requires 'new'");
            if (r(this, "_id", c("_WeakMap")),
            arguments.length > 0)
                throw new TypeError("WeakMap iterable is not supported")
        }
        r(o.prototype, "delete", function(f) {
            if (l(this, "delete"),
            !n(f))
                return !1;
            var p = f[this._id];
            return p && p[0] === f ? (delete f[this._id],
            !0) : !1
        }),
        r(o.prototype, "get", function(f) {
            if (l(this, "get"),
            !!n(f)) {
                var p = f[this._id];
                if (p && p[0] === f)
                    return p[1]
            }
        }),
        r(o.prototype, "has", function(f) {
            if (l(this, "has"),
            !n(f))
                return !1;
            var p = f[this._id];
            return !!(p && p[0] === f)
        }),
        r(o.prototype, "set", function(f, p) {
            if (l(this, "set"),
            !n(f))
                throw new TypeError("Invalid value used as weak map key");
            var g = f[this._id];
            return g && g[0] === f ? (g[1] = p,
            this) : (r(f, this._id, [f, p]),
            this)
        });
        function l(f, p) {
            if (!n(f) || !e.call(f, "_id"))
                throw new TypeError(p + " method called on incompatible receiver " + typeof f)
        }
        function c(f) {
            return f + "_" + u() + "." + u()
        }
        function u() {
            return Math.random().toString().substring(2)
        }
        return r(o, "_polyfill", !0),
        o
    }();
    function n(o) {
        return Object(o) === o
    }
}
)(typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : commonjsGlobal);
var npo_src = createCommonjsModule(function(a) {
    /*! Native Promise Only
    v0.8.1 (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
*/
    (function(t, r, n) {
        r[t] = r[t] || n(),
        a.exports && (a.exports = r[t])
    }
    )("Promise", commonjsGlobal, function() {
        var t, r, n, o = Object.prototype.toString, l = typeof setImmediate < "u" ? function(T) {
            return setImmediate(T)
        }
        : setTimeout;
        try {
            Object.defineProperty({}, "x", {}),
            t = function(T, M, P, I) {
                return Object.defineProperty(T, M, {
                    value: P,
                    writable: !0,
                    configurable: I !== !1
                })
            }
        } catch {
            t = function(M, P, I) {
                return M[P] = I,
                M
            }
        }
        n = function() {
            var T, M, P;
            function I(k, A) {
                this.fn = k,
                this.self = A,
                this.next = void 0
            }
            return {
                add: function(A, O) {
                    P = new I(A,O),
                    M ? M.next = P : T = P,
                    M = P,
                    P = void 0
                },
                drain: function() {
                    var A = T;
                    for (T = M = r = void 0; A; )
                        A.fn.call(A.self),
                        A = A.next
                }
            }
        }();
        function c(R, T) {
            n.add(R, T),
            r || (r = l(n.drain))
        }
        function u(R) {
            var T, M = typeof R;
            return R != null && (M == "object" || M == "function") && (T = R.then),
            typeof T == "function" ? T : !1
        }
        function f() {
            for (var R = 0; R < this.chain.length; R++)
                p(this, this.state === 1 ? this.chain[R].success : this.chain[R].failure, this.chain[R]);
            this.chain.length = 0
        }
        function p(R, T, M) {
            var P, I;
            try {
                T === !1 ? M.reject(R.msg) : (T === !0 ? P = R.msg : P = T.call(void 0, R.msg),
                P === M.promise ? M.reject(TypeError("Promise-chain cycle")) : (I = u(P)) ? I.call(P, M.resolve, M.reject) : M.resolve(P))
            } catch (k) {
                M.reject(k)
            }
        }
        function g(R) {
            var T, M = this;
            if (!M.triggered) {
                M.triggered = !0,
                M.def && (M = M.def);
                try {
                    (T = u(R)) ? c(function() {
                        var P = new w(M);
                        try {
                            T.call(R, function() {
                                g.apply(P, arguments)
                            }, function() {
                                v.apply(P, arguments)
                            })
                        } catch (I) {
                            v.call(P, I)
                        }
                    }) : (M.msg = R,
                    M.state = 1,
                    M.chain.length > 0 && c(f, M))
                } catch (P) {
                    v.call(new w(M), P)
                }
            }
        }
        function v(R) {
            var T = this;
            T.triggered || (T.triggered = !0,
            T.def && (T = T.def),
            T.msg = R,
            T.state = 2,
            T.chain.length > 0 && c(f, T))
        }
        function _(R, T, M, P) {
            for (var I = 0; I < T.length; I++)
                (function(A) {
                    R.resolve(T[A]).then(function(W) {
                        M(A, W)
                    }, P)
                }
                )(I)
        }
        function w(R) {
            this.def = R,
            this.triggered = !1
        }
        function S(R) {
            this.promise = R,
            this.state = 0,
            this.triggered = !1,
            this.chain = [],
            this.msg = void 0
        }
        function b(R) {
            if (typeof R != "function")
                throw TypeError("Not a function");
            if (this.__NPO__ !== 0)
                throw TypeError("Not a promise");
            this.__NPO__ = 1;
            var T = new S(this);
            this.then = function(P, I) {
                var k = {
                    success: typeof P == "function" ? P : !0,
                    failure: typeof I == "function" ? I : !1
                };
                return k.promise = new this.constructor(function(O, W) {
                    if (typeof O != "function" || typeof W != "function")
                        throw TypeError("Not a function");
                    k.resolve = O,
                    k.reject = W
                }
                ),
                T.chain.push(k),
                T.state !== 0 && c(f, T),
                k.promise
            }
            ,
            this.catch = function(P) {
                return this.then(void 0, P)
            }
            ;
            try {
                R.call(void 0, function(P) {
                    g.call(T, P)
                }, function(P) {
                    v.call(T, P)
                })
            } catch (M) {
                v.call(T, M)
            }
        }
        var C = t({}, "constructor", b, !1);
        return b.prototype = C,
        t(C, "__NPO__", 0, !1),
        t(b, "resolve", function(T) {
            var M = this;
            return T && typeof T == "object" && T.__NPO__ === 1 ? T : new M(function(I, k) {
                if (typeof I != "function" || typeof k != "function")
                    throw TypeError("Not a function");
                I(T)
            }
            )
        }),
        t(b, "reject", function(T) {
            return new this(function(P, I) {
                if (typeof P != "function" || typeof I != "function")
                    throw TypeError("Not a function");
                I(T)
            }
            )
        }),
        t(b, "all", function(T) {
            var M = this;
            return o.call(T) != "[object Array]" ? M.reject(TypeError("Not an array")) : T.length === 0 ? M.resolve([]) : new M(function(I, k) {
                if (typeof I != "function" || typeof k != "function")
                    throw TypeError("Not a function");
                var A = T.length
                  , O = Array(A)
                  , W = 0;
                _(M, T, function(H, B) {
                    O[H] = B,
                    ++W === A && I(O)
                }, k)
            }
            )
        }),
        t(b, "race", function(T) {
            var M = this;
            return o.call(T) != "[object Array]" ? M.reject(TypeError("Not an array")) : new M(function(I, k) {
                if (typeof I != "function" || typeof k != "function")
                    throw TypeError("Not a function");
                _(M, T, function(O, W) {
                    I(W)
                }, k)
            }
            )
        }),
        b
    })
})
  , callbackMap = new WeakMap;
function storeCallback(a, e, t) {
    var r = callbackMap.get(a.element) || {};
    e in r || (r[e] = []),
    r[e].push(t),
    callbackMap.set(a.element, r)
}
function getCallbacks(a, e) {
    var t = callbackMap.get(a.element) || {};
    return t[e] || []
}
function removeCallback(a, e, t) {
    var r = callbackMap.get(a.element) || {};
    if (!r[e])
        return !0;
    if (!t)
        return r[e] = [],
        callbackMap.set(a.element, r),
        !0;
    var n = r[e].indexOf(t);
    return n !== -1 && r[e].splice(n, 1),
    callbackMap.set(a.element, r),
    r[e] && r[e].length === 0
}
function shiftCallbacks(a, e) {
    var t = getCallbacks(a, e);
    if (t.length < 1)
        return !1;
    var r = t.shift();
    return removeCallback(a, e, r),
    r
}
function swapCallbacks(a, e) {
    var t = callbackMap.get(a);
    callbackMap.set(e, t),
    callbackMap.delete(a)
}
function parseMessageData(a) {
    if (typeof a == "string")
        try {
            a = JSON.parse(a)
        } catch (e) {
            return console.warn(e),
            {}
        }
    return a
}
function postMessage(a, e, t) {
    if (!(!a.element.contentWindow || !a.element.contentWindow.postMessage)) {
        var r = {
            method: e
        };
        t !== void 0 && (r.value = t);
        var n = parseFloat(navigator.userAgent.toLowerCase().replace(/^.*msie (\d+).*$/, "$1"));
        n >= 8 && n < 10 && (r = JSON.stringify(r)),
        a.element.contentWindow.postMessage(r, a.origin)
    }
}
function processData(a, e) {
    e = parseMessageData(e);
    var t = [], r;
    if (e.event) {
        if (e.event === "error") {
            var n = getCallbacks(a, e.data.method);
            n.forEach(function(l) {
                var c = new Error(e.data.message);
                c.name = e.data.name,
                l.reject(c),
                removeCallback(a, e.data.method, l)
            })
        }
        t = getCallbacks(a, "event:".concat(e.event)),
        r = e.data
    } else if (e.method) {
        var o = shiftCallbacks(a, e.method);
        o && (t.push(o),
        r = e.value)
    }
    t.forEach(function(l) {
        try {
            if (typeof l == "function") {
                l.call(a, r);
                return
            }
            l.resolve(r)
        } catch {}
    })
}
var oEmbedParameters = ["airplay", "audio_tracks", "autopause", "autoplay", "background", "byline", "cc", "chapter_id", "chapters", "chromecast", "color", "colors", "controls", "dnt", "end_time", "fullscreen", "height", "id", "interactive_params", "keyboard", "loop", "maxheight", "maxwidth", "muted", "play_button_position", "playsinline", "portrait", "progress_bar", "quality_selector", "responsive", "speed", "start_time", "texttrack", "title", "transcript", "transparent", "unmute_button", "url", "vimeo_logo", "volume", "watch_full_video", "width"];
function getOEmbedParameters(a) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return oEmbedParameters.reduce(function(t, r) {
        var n = a.getAttribute("data-vimeo-".concat(r));
        return (n || n === "") && (t[r] = n === "" ? 1 : n),
        t
    }, e)
}
function createEmbed(a, e) {
    var t = a.html;
    if (!e)
        throw new TypeError("An element must be provided");
    if (e.getAttribute("data-vimeo-initialized") !== null)
        return e.querySelector("iframe");
    var r = document.createElement("div");
    return r.innerHTML = t,
    e.appendChild(r.firstChild),
    e.setAttribute("data-vimeo-initialized", "true"),
    e.querySelector("iframe")
}
function getOEmbedData(a) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , t = arguments.length > 2 ? arguments[2] : void 0;
    return new Promise(function(r, n) {
        if (!isVimeoUrl(a))
            throw new TypeError("".concat(a, " is not a vimeo.com url."));
        var o = getOembedDomain(a)
          , l = "https://".concat(o, "/api/oembed.json?url=").concat(encodeURIComponent(a));
        for (var c in e)
            e.hasOwnProperty(c) && (l += "&".concat(c, "=").concat(encodeURIComponent(e[c])));
        var u = "XDomainRequest"in window ? new XDomainRequest : new XMLHttpRequest;
        u.open("GET", l, !0),
        u.onload = function() {
            if (u.status === 404) {
                n(new Error("".concat(a, " was not found.")));
                return
            }
            if (u.status === 403) {
                n(new Error("".concat(a, " is not embeddable.")));
                return
            }
            try {
                var f = JSON.parse(u.responseText);
                if (f.domain_status_code === 403) {
                    createEmbed(f, t),
                    n(new Error("".concat(a, " is not embeddable.")));
                    return
                }
                r(f)
            } catch (p) {
                n(p)
            }
        }
        ,
        u.onerror = function() {
            var f = u.status ? " (".concat(u.status, ")") : "";
            n(new Error("There was an error fetching the embed code from Vimeo".concat(f, ".")))
        }
        ,
        u.send()
    }
    )
}
function initializeEmbeds() {
    var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document
      , e = [].slice.call(a.querySelectorAll("[data-vimeo-id], [data-vimeo-url]"))
      , t = function(n) {
        "console"in window && console.error && console.error("There was an error creating an embed: ".concat(n))
    };
    e.forEach(function(r) {
        try {
            if (r.getAttribute("data-vimeo-defer") !== null)
                return;
            var n = getOEmbedParameters(r)
              , o = getVimeoUrl(n);
            getOEmbedData(o, n, r).then(function(l) {
                return createEmbed(l, r)
            }).catch(t)
        } catch (l) {
            t(l)
        }
    })
}
function resizeEmbeds() {
    var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
    if (!window.VimeoPlayerResizeEmbeds_) {
        window.VimeoPlayerResizeEmbeds_ = !0;
        var e = function(r) {
            if (isVimeoUrl(r.origin) && !(!r.data || r.data.event !== "spacechange")) {
                for (var n = a.querySelectorAll("iframe"), o = 0; o < n.length; o++)
                    if (n[o].contentWindow === r.source) {
                        var l = n[o].parentElement;
                        l.style.paddingBottom = "".concat(r.data.data[0].bottom, "px");
                        break
                    }
            }
        };
        window.addEventListener("message", e)
    }
}
function initAppendVideoMetadata() {
    var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
    if (!window.VimeoSeoMetadataAppended) {
        window.VimeoSeoMetadataAppended = !0;
        var e = function(r) {
            if (isVimeoUrl(r.origin)) {
                var n = parseMessageData(r.data);
                if (!(!n || n.event !== "ready"))
                    for (var o = a.querySelectorAll("iframe"), l = 0; l < o.length; l++) {
                        var c = o[l]
                          , u = c.contentWindow === r.source;
                        if (isVimeoEmbed(c.src) && u) {
                            var f = new Player(c);
                            f.callMethod("appendVideoMetadata", window.location.href)
                        }
                    }
            }
        };
        window.addEventListener("message", e)
    }
}
function checkUrlTimeParam() {
    var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
    if (!window.VimeoCheckedUrlTimeParam) {
        window.VimeoCheckedUrlTimeParam = !0;
        var e = function(n) {
            "console"in window && console.error && console.error("There was an error getting video Id: ".concat(n))
        }
          , t = function(n) {
            if (isVimeoUrl(n.origin)) {
                var o = parseMessageData(n.data);
                if (!(!o || o.event !== "ready"))
                    for (var l = a.querySelectorAll("iframe"), c = function() {
                        var p = l[u]
                          , g = p.contentWindow === n.source;
                        if (isVimeoEmbed(p.src) && g) {
                            var v = new Player(p);
                            v.getVideoId().then(function(_) {
                                var w = new RegExp("[?&]vimeo_t_".concat(_, "=([^&#]*)")).exec(window.location.href);
                                if (w && w[1]) {
                                    var S = decodeURI(w[1]);
                                    v.setCurrentTime(S)
                                }
                            }).catch(e)
                        }
                    }, u = 0; u < l.length; u++)
                        c()
            }
        };
        window.addEventListener("message", t)
    }
}
function initializeScreenfull() {
    var a = function() {
        for (var r, n = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"], ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]], o = 0, l = n.length, c = {}; o < l; o++)
            if (r = n[o],
            r && r[1]in document) {
                for (o = 0; o < r.length; o++)
                    c[n[0][o]] = r[o];
                return c
            }
        return !1
    }()
      , e = {
        fullscreenchange: a.fullscreenchange,
        fullscreenerror: a.fullscreenerror
    }
      , t = {
        request: function(n) {
            return new Promise(function(o, l) {
                var c = function f() {
                    t.off("fullscreenchange", f),
                    o()
                };
                t.on("fullscreenchange", c),
                n = n || document.documentElement;
                var u = n[a.requestFullscreen]();
                u instanceof Promise && u.then(c).catch(l)
            }
            )
        },
        exit: function() {
            return new Promise(function(n, o) {
                if (!t.isFullscreen) {
                    n();
                    return
                }
                var l = function u() {
                    t.off("fullscreenchange", u),
                    n()
                };
                t.on("fullscreenchange", l);
                var c = document[a.exitFullscreen]();
                c instanceof Promise && c.then(l).catch(o)
            }
            )
        },
        on: function(n, o) {
            var l = e[n];
            l && document.addEventListener(l, o)
        },
        off: function(n, o) {
            var l = e[n];
            l && document.removeEventListener(l, o)
        }
    };
    return Object.defineProperties(t, {
        isFullscreen: {
            get: function() {
                return !!document[a.fullscreenElement]
            }
        },
        element: {
            enumerable: !0,
            get: function() {
                return document[a.fullscreenElement]
            }
        },
        isEnabled: {
            enumerable: !0,
            get: function() {
                return !!document[a.fullscreenEnabled]
            }
        }
    }),
    t
}
var defaultOptions = {
    role: "viewer",
    autoPlayMuted: !0,
    allowedDrift: .3,
    maxAllowedDrift: 1,
    minCheckInterval: .1,
    maxRateAdjustment: .2,
    maxTimeToCatchUp: 1
}
  , TimingSrcConnector = function(a) {
    _inherits(t, a);
    var e = _createSuper(t);
    function t(r, n) {
        var o, l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, c = arguments.length > 3 ? arguments[3] : void 0;
        return _classCallCheck(this, t),
        o = e.call(this),
        _defineProperty(_assertThisInitialized(o), "logger", void 0),
        _defineProperty(_assertThisInitialized(o), "speedAdjustment", 0),
        _defineProperty(_assertThisInitialized(o), "adjustSpeed", function() {
            var u = _asyncToGenerator(_regeneratorRuntime().mark(function f(p, g) {
                var v;
                return _regeneratorRuntime().wrap(function(w) {
                    for (; ; )
                        switch (w.prev = w.next) {
                        case 0:
                            if (o.speedAdjustment !== g) {
                                w.next = 2;
                                break
                            }
                            return w.abrupt("return");
                        case 2:
                            return w.next = 4,
                            p.getPlaybackRate();
                        case 4:
                            return w.t0 = w.sent,
                            w.t1 = o.speedAdjustment,
                            w.t2 = w.t0 - w.t1,
                            w.t3 = g,
                            v = w.t2 + w.t3,
                            o.log("New playbackRate:  ".concat(v)),
                            w.next = 12,
                            p.setPlaybackRate(v);
                        case 12:
                            o.speedAdjustment = g;
                        case 13:
                        case "end":
                            return w.stop()
                        }
                }, f)
            }));
            return function(f, p) {
                return u.apply(this, arguments)
            }
        }()),
        o.logger = c,
        o.init(n, r, _objectSpread2(_objectSpread2({}, defaultOptions), l)),
        o
    }
    return _createClass(t, [{
        key: "disconnect",
        value: function() {
            this.dispatchEvent(new Event("disconnect"))
        }
    }, {
        key: "init",
        value: function() {
            var r = _asyncToGenerator(_regeneratorRuntime().mark(function o(l, c, u) {
                var f = this, p, g, v;
                return _regeneratorRuntime().wrap(function(w) {
                    for (; ; )
                        switch (w.prev = w.next) {
                        case 0:
                            return w.next = 2,
                            this.waitForTOReadyState(l, "open");
                        case 2:
                            if (u.role !== "viewer") {
                                w.next = 10;
                                break
                            }
                            return w.next = 5,
                            this.updatePlayer(l, c, u);
                        case 5:
                            p = subscribe(l, "change", function() {
                                return f.updatePlayer(l, c, u)
                            }),
                            g = this.maintainPlaybackPosition(l, c, u),
                            this.addEventListener("disconnect", function() {
                                g.cancel(),
                                p.cancel()
                            }),
                            w.next = 14;
                            break;
                        case 10:
                            return w.next = 12,
                            this.updateTimingObject(l, c);
                        case 12:
                            v = subscribe(c, ["seeked", "play", "pause", "ratechange"], function() {
                                return f.updateTimingObject(l, c)
                            }, "on", "off"),
                            this.addEventListener("disconnect", function() {
                                return v.cancel()
                            });
                        case 14:
                        case "end":
                            return w.stop()
                        }
                }, o, this)
            }));
            function n(o, l, c) {
                return r.apply(this, arguments)
            }
            return n
        }()
    }, {
        key: "updateTimingObject",
        value: function() {
            var r = _asyncToGenerator(_regeneratorRuntime().mark(function o(l, c) {
                return _regeneratorRuntime().wrap(function(f) {
                    for (; ; )
                        switch (f.prev = f.next) {
                        case 0:
                            return f.t0 = l,
                            f.next = 3,
                            c.getCurrentTime();
                        case 3:
                            return f.t1 = f.sent,
                            f.next = 6,
                            c.getPaused();
                        case 6:
                            if (!f.sent) {
                                f.next = 10;
                                break
                            }
                            f.t2 = 0,
                            f.next = 13;
                            break;
                        case 10:
                            return f.next = 12,
                            c.getPlaybackRate();
                        case 12:
                            f.t2 = f.sent;
                        case 13:
                            f.t3 = f.t2,
                            f.t4 = {
                                position: f.t1,
                                velocity: f.t3
                            },
                            f.t0.update.call(f.t0, f.t4);
                        case 16:
                        case "end":
                            return f.stop()
                        }
                }, o)
            }));
            function n(o, l) {
                return r.apply(this, arguments)
            }
            return n
        }()
    }, {
        key: "updatePlayer",
        value: function() {
            var r = _asyncToGenerator(_regeneratorRuntime().mark(function o(l, c, u) {
                var f, p, g;
                return _regeneratorRuntime().wrap(function(_) {
                    for (; ; )
                        switch (_.prev = _.next) {
                        case 0:
                            if (f = l.query(),
                            p = f.position,
                            g = f.velocity,
                            typeof p == "number" && c.setCurrentTime(p),
                            typeof g != "number") {
                                _.next = 25;
                                break
                            }
                            if (g !== 0) {
                                _.next = 11;
                                break
                            }
                            return _.next = 6,
                            c.getPaused();
                        case 6:
                            if (_.t0 = _.sent,
                            _.t0 !== !1) {
                                _.next = 9;
                                break
                            }
                            c.pause();
                        case 9:
                            _.next = 25;
                            break;
                        case 11:
                            if (!(g > 0)) {
                                _.next = 25;
                                break
                            }
                            return _.next = 14,
                            c.getPaused();
                        case 14:
                            if (_.t1 = _.sent,
                            _.t1 !== !0) {
                                _.next = 19;
                                break
                            }
                            return _.next = 18,
                            c.play().catch(function() {
                                var w = _asyncToGenerator(_regeneratorRuntime().mark(function S(b) {
                                    return _regeneratorRuntime().wrap(function(R) {
                                        for (; ; )
                                            switch (R.prev = R.next) {
                                            case 0:
                                                if (!(b.name === "NotAllowedError" && u.autoPlayMuted)) {
                                                    R.next = 5;
                                                    break
                                                }
                                                return R.next = 3,
                                                c.setMuted(!0);
                                            case 3:
                                                return R.next = 5,
                                                c.play().catch(function(T) {
                                                    return console.error("Couldn't play the video from TimingSrcConnector. Error:", T)
                                                });
                                            case 5:
                                            case "end":
                                                return R.stop()
                                            }
                                    }, S)
                                }));
                                return function(S) {
                                    return w.apply(this, arguments)
                                }
                            }());
                        case 18:
                            this.updatePlayer(l, c, u);
                        case 19:
                            return _.next = 21,
                            c.getPlaybackRate();
                        case 21:
                            if (_.t2 = _.sent,
                            _.t3 = g,
                            _.t2 === _.t3) {
                                _.next = 25;
                                break
                            }
                            c.setPlaybackRate(g);
                        case 25:
                        case "end":
                            return _.stop()
                        }
                }, o, this)
            }));
            function n(o, l, c) {
                return r.apply(this, arguments)
            }
            return n
        }()
    }, {
        key: "maintainPlaybackPosition",
        value: function(n, o, l) {
            var c = this
              , u = l.allowedDrift
              , f = l.maxAllowedDrift
              , p = l.minCheckInterval
              , g = l.maxRateAdjustment
              , v = l.maxTimeToCatchUp
              , _ = Math.min(v, Math.max(p, f)) * 1e3
              , w = function() {
                var b = _asyncToGenerator(_regeneratorRuntime().mark(function C() {
                    var R, T, M, P, I;
                    return _regeneratorRuntime().wrap(function(A) {
                        for (; ; )
                            switch (A.prev = A.next) {
                            case 0:
                                if (A.t0 = n.query().velocity === 0,
                                A.t0) {
                                    A.next = 6;
                                    break
                                }
                                return A.next = 4,
                                o.getPaused();
                            case 4:
                                A.t1 = A.sent,
                                A.t0 = A.t1 === !0;
                            case 6:
                                if (!A.t0) {
                                    A.next = 8;
                                    break
                                }
                                return A.abrupt("return");
                            case 8:
                                return A.t2 = n.query().position,
                                A.next = 11,
                                o.getCurrentTime();
                            case 11:
                                if (A.t3 = A.sent,
                                R = A.t2 - A.t3,
                                T = Math.abs(R),
                                c.log("Drift: ".concat(R)),
                                !(T > f)) {
                                    A.next = 22;
                                    break
                                }
                                return A.next = 18,
                                c.adjustSpeed(o, 0);
                            case 18:
                                o.setCurrentTime(n.query().position),
                                c.log("Resync by currentTime"),
                                A.next = 29;
                                break;
                            case 22:
                                if (!(T > u)) {
                                    A.next = 29;
                                    break
                                }
                                return M = T / v,
                                P = g,
                                I = M < P ? (P - M) / 2 : P,
                                A.next = 28,
                                c.adjustSpeed(o, I * Math.sign(R));
                            case 28:
                                c.log("Resync by playbackRate");
                            case 29:
                            case "end":
                                return A.stop()
                            }
                    }, C)
                }));
                return function() {
                    return b.apply(this, arguments)
                }
            }()
              , S = setInterval(function() {
                return w()
            }, _);
            return {
                cancel: function() {
                    return clearInterval(S)
                }
            }
        }
    }, {
        key: "log",
        value: function(n) {
            var o;
            (o = this.logger) === null || o === void 0 || o.call(this, "TimingSrcConnector: ".concat(n))
        }
    }, {
        key: "waitForTOReadyState",
        value: function(n, o) {
            return new Promise(function(l) {
                var c = function u() {
                    n.readyState === o ? l() : n.addEventListener("readystatechange", u, {
                        once: !0
                    })
                };
                c()
            }
            )
        }
    }]),
    t
}(_wrapNativeSuper(EventTarget))
  , playerMap = new WeakMap
  , readyMap = new WeakMap
  , screenfull = {}
  , Player = function() {
    function a(e) {
        var t = this
          , r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (_classCallCheck(this, a),
        window.jQuery && e instanceof jQuery && (e.length > 1 && window.console && console.warn && console.warn("A jQuery object with multiple elements was passed, using the first element."),
        e = e[0]),
        typeof document < "u" && typeof e == "string" && (e = document.getElementById(e)),
        !isDomElement(e))
            throw new TypeError("You must pass either a valid element or a valid id.");
        if (e.nodeName !== "IFRAME") {
            var n = e.querySelector("iframe");
            n && (e = n)
        }
        if (e.nodeName === "IFRAME" && !isVimeoUrl(e.getAttribute("src") || ""))
            throw new Error("The player element passed isnt a Vimeo embed.");
        if (playerMap.has(e))
            return playerMap.get(e);
        this._window = e.ownerDocument.defaultView,
        this.element = e,
        this.origin = "*";
        var o = new npo_src(function(c, u) {
            if (t._onMessage = function(g) {
                if (!(!isVimeoUrl(g.origin) || t.element.contentWindow !== g.source)) {
                    t.origin === "*" && (t.origin = g.origin);
                    var v = parseMessageData(g.data)
                      , _ = v && v.event === "error"
                      , w = _ && v.data && v.data.method === "ready";
                    if (w) {
                        var S = new Error(v.data.message);
                        S.name = v.data.name,
                        u(S);
                        return
                    }
                    var b = v && v.event === "ready"
                      , C = v && v.method === "ping";
                    if (b || C) {
                        t.element.setAttribute("data-ready", "true"),
                        c();
                        return
                    }
                    processData(t, v)
                }
            }
            ,
            t._window.addEventListener("message", t._onMessage),
            t.element.nodeName !== "IFRAME") {
                var f = getOEmbedParameters(e, r)
                  , p = getVimeoUrl(f);
                getOEmbedData(p, f, e).then(function(g) {
                    var v = createEmbed(g, e);
                    return t.element = v,
                    t._originalElement = e,
                    swapCallbacks(e, v),
                    playerMap.set(t.element, t),
                    g
                }).catch(u)
            }
        }
        );
        if (readyMap.set(this, o),
        playerMap.set(this.element, this),
        this.element.nodeName === "IFRAME" && postMessage(this, "ping"),
        screenfull.isEnabled) {
            var l = function() {
                return screenfull.exit()
            };
            this.fullscreenchangeHandler = function() {
                screenfull.isFullscreen ? storeCallback(t, "event:exitFullscreen", l) : removeCallback(t, "event:exitFullscreen", l),
                t.ready().then(function() {
                    postMessage(t, "fullscreenchange", screenfull.isFullscreen)
                })
            }
            ,
            screenfull.on("fullscreenchange", this.fullscreenchangeHandler)
        }
        return this
    }
    return _createClass(a, [{
        key: "callMethod",
        value: function(t) {
            var r = this
              , n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return new npo_src(function(o, l) {
                return r.ready().then(function() {
                    storeCallback(r, t, {
                        resolve: o,
                        reject: l
                    }),
                    postMessage(r, t, n)
                }).catch(l)
            }
            )
        }
    }, {
        key: "get",
        value: function(t) {
            var r = this;
            return new npo_src(function(n, o) {
                return t = getMethodName(t, "get"),
                r.ready().then(function() {
                    storeCallback(r, t, {
                        resolve: n,
                        reject: o
                    }),
                    postMessage(r, t)
                }).catch(o)
            }
            )
        }
    }, {
        key: "set",
        value: function(t, r) {
            var n = this;
            return new npo_src(function(o, l) {
                if (t = getMethodName(t, "set"),
                r == null)
                    throw new TypeError("There must be a value to set.");
                return n.ready().then(function() {
                    storeCallback(n, t, {
                        resolve: o,
                        reject: l
                    }),
                    postMessage(n, t, r)
                }).catch(l)
            }
            )
        }
    }, {
        key: "on",
        value: function(t, r) {
            if (!t)
                throw new TypeError("You must pass an event name.");
            if (!r)
                throw new TypeError("You must pass a callback function.");
            if (typeof r != "function")
                throw new TypeError("The callback must be a function.");
            var n = getCallbacks(this, "event:".concat(t));
            n.length === 0 && this.callMethod("addEventListener", t).catch(function() {}),
            storeCallback(this, "event:".concat(t), r)
        }
    }, {
        key: "off",
        value: function(t, r) {
            if (!t)
                throw new TypeError("You must pass an event name.");
            if (r && typeof r != "function")
                throw new TypeError("The callback must be a function.");
            var n = removeCallback(this, "event:".concat(t), r);
            n && this.callMethod("removeEventListener", t).catch(function(o) {})
        }
    }, {
        key: "loadVideo",
        value: function(t) {
            return this.callMethod("loadVideo", t)
        }
    }, {
        key: "ready",
        value: function() {
            var t = readyMap.get(this) || new npo_src(function(r, n) {
                n(new Error("Unknown player. Probably unloaded."))
            }
            );
            return npo_src.resolve(t)
        }
    }, {
        key: "addCuePoint",
        value: function(t) {
            var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return this.callMethod("addCuePoint", {
                time: t,
                data: r
            })
        }
    }, {
        key: "removeCuePoint",
        value: function(t) {
            return this.callMethod("removeCuePoint", t)
        }
    }, {
        key: "enableTextTrack",
        value: function(t, r) {
            if (!t)
                throw new TypeError("You must pass a language.");
            return this.callMethod("enableTextTrack", {
                language: t,
                kind: r
            })
        }
    }, {
        key: "disableTextTrack",
        value: function() {
            return this.callMethod("disableTextTrack")
        }
    }, {
        key: "pause",
        value: function() {
            return this.callMethod("pause")
        }
    }, {
        key: "play",
        value: function() {
            return this.callMethod("play")
        }
    }, {
        key: "requestFullscreen",
        value: function() {
            return screenfull.isEnabled ? screenfull.request(this.element) : this.callMethod("requestFullscreen")
        }
    }, {
        key: "exitFullscreen",
        value: function() {
            return screenfull.isEnabled ? screenfull.exit() : this.callMethod("exitFullscreen")
        }
    }, {
        key: "getFullscreen",
        value: function() {
            return screenfull.isEnabled ? npo_src.resolve(screenfull.isFullscreen) : this.get("fullscreen")
        }
    }, {
        key: "requestPictureInPicture",
        value: function() {
            return this.callMethod("requestPictureInPicture")
        }
    }, {
        key: "exitPictureInPicture",
        value: function() {
            return this.callMethod("exitPictureInPicture")
        }
    }, {
        key: "getPictureInPicture",
        value: function() {
            return this.get("pictureInPicture")
        }
    }, {
        key: "remotePlaybackPrompt",
        value: function() {
            return this.callMethod("remotePlaybackPrompt")
        }
    }, {
        key: "unload",
        value: function() {
            return this.callMethod("unload")
        }
    }, {
        key: "destroy",
        value: function() {
            var t = this;
            return new npo_src(function(r) {
                if (readyMap.delete(t),
                playerMap.delete(t.element),
                t._originalElement && (playerMap.delete(t._originalElement),
                t._originalElement.removeAttribute("data-vimeo-initialized")),
                t.element && t.element.nodeName === "IFRAME" && t.element.parentNode && (t.element.parentNode.parentNode && t._originalElement && t._originalElement !== t.element.parentNode ? t.element.parentNode.parentNode.removeChild(t.element.parentNode) : t.element.parentNode.removeChild(t.element)),
                t.element && t.element.nodeName === "DIV" && t.element.parentNode) {
                    t.element.removeAttribute("data-vimeo-initialized");
                    var n = t.element.querySelector("iframe");
                    n && n.parentNode && (n.parentNode.parentNode && t._originalElement && t._originalElement !== n.parentNode ? n.parentNode.parentNode.removeChild(n.parentNode) : n.parentNode.removeChild(n))
                }
                t._window.removeEventListener("message", t._onMessage),
                screenfull.isEnabled && screenfull.off("fullscreenchange", t.fullscreenchangeHandler),
                r()
            }
            )
        }
    }, {
        key: "getAutopause",
        value: function() {
            return this.get("autopause")
        }
    }, {
        key: "setAutopause",
        value: function(t) {
            return this.set("autopause", t)
        }
    }, {
        key: "getBuffered",
        value: function() {
            return this.get("buffered")
        }
    }, {
        key: "getCameraProps",
        value: function() {
            return this.get("cameraProps")
        }
    }, {
        key: "setCameraProps",
        value: function(t) {
            return this.set("cameraProps", t)
        }
    }, {
        key: "getChapters",
        value: function() {
            return this.get("chapters")
        }
    }, {
        key: "getCurrentChapter",
        value: function() {
            return this.get("currentChapter")
        }
    }, {
        key: "getColor",
        value: function() {
            return this.get("color")
        }
    }, {
        key: "getColors",
        value: function() {
            return npo_src.all([this.get("colorOne"), this.get("colorTwo"), this.get("colorThree"), this.get("colorFour")])
        }
    }, {
        key: "setColor",
        value: function(t) {
            return this.set("color", t)
        }
    }, {
        key: "setColors",
        value: function(t) {
            if (!Array.isArray(t))
                return new npo_src(function(o, l) {
                    return l(new TypeError("Argument must be an array."))
                }
                );
            var r = new npo_src(function(o) {
                return o(null)
            }
            )
              , n = [t[0] ? this.set("colorOne", t[0]) : r, t[1] ? this.set("colorTwo", t[1]) : r, t[2] ? this.set("colorThree", t[2]) : r, t[3] ? this.set("colorFour", t[3]) : r];
            return npo_src.all(n)
        }
    }, {
        key: "getCuePoints",
        value: function() {
            return this.get("cuePoints")
        }
    }, {
        key: "getCurrentTime",
        value: function() {
            return this.get("currentTime")
        }
    }, {
        key: "setCurrentTime",
        value: function(t) {
            return this.set("currentTime", t)
        }
    }, {
        key: "getDuration",
        value: function() {
            return this.get("duration")
        }
    }, {
        key: "getEnded",
        value: function() {
            return this.get("ended")
        }
    }, {
        key: "getLoop",
        value: function() {
            return this.get("loop")
        }
    }, {
        key: "setLoop",
        value: function(t) {
            return this.set("loop", t)
        }
    }, {
        key: "setMuted",
        value: function(t) {
            return this.set("muted", t)
        }
    }, {
        key: "getMuted",
        value: function() {
            return this.get("muted")
        }
    }, {
        key: "getPaused",
        value: function() {
            return this.get("paused")
        }
    }, {
        key: "getPlaybackRate",
        value: function() {
            return this.get("playbackRate")
        }
    }, {
        key: "setPlaybackRate",
        value: function(t) {
            return this.set("playbackRate", t)
        }
    }, {
        key: "getPlayed",
        value: function() {
            return this.get("played")
        }
    }, {
        key: "getQualities",
        value: function() {
            return this.get("qualities")
        }
    }, {
        key: "getQuality",
        value: function() {
            return this.get("quality")
        }
    }, {
        key: "setQuality",
        value: function(t) {
            return this.set("quality", t)
        }
    }, {
        key: "getRemotePlaybackAvailability",
        value: function() {
            return this.get("remotePlaybackAvailability")
        }
    }, {
        key: "getRemotePlaybackState",
        value: function() {
            return this.get("remotePlaybackState")
        }
    }, {
        key: "getSeekable",
        value: function() {
            return this.get("seekable")
        }
    }, {
        key: "getSeeking",
        value: function() {
            return this.get("seeking")
        }
    }, {
        key: "getTextTracks",
        value: function() {
            return this.get("textTracks")
        }
    }, {
        key: "getVideoEmbedCode",
        value: function() {
            return this.get("videoEmbedCode")
        }
    }, {
        key: "getVideoId",
        value: function() {
            return this.get("videoId")
        }
    }, {
        key: "getVideoTitle",
        value: function() {
            return this.get("videoTitle")
        }
    }, {
        key: "getVideoWidth",
        value: function() {
            return this.get("videoWidth")
        }
    }, {
        key: "getVideoHeight",
        value: function() {
            return this.get("videoHeight")
        }
    }, {
        key: "getVideoUrl",
        value: function() {
            return this.get("videoUrl")
        }
    }, {
        key: "getVolume",
        value: function() {
            return this.get("volume")
        }
    }, {
        key: "setVolume",
        value: function(t) {
            return this.set("volume", t)
        }
    }, {
        key: "setTimingSrc",
        value: function() {
            var e = _asyncToGenerator(_regeneratorRuntime().mark(function r(n, o) {
                var l = this, c;
                return _regeneratorRuntime().wrap(function(f) {
                    for (; ; )
                        switch (f.prev = f.next) {
                        case 0:
                            if (n) {
                                f.next = 2;
                                break
                            }
                            throw new TypeError("A Timing Object must be provided.");
                        case 2:
                            return f.next = 4,
                            this.ready();
                        case 4:
                            return c = new TimingSrcConnector(this,n,o),
                            postMessage(this, "notifyTimingObjectConnect"),
                            c.addEventListener("disconnect", function() {
                                return postMessage(l, "notifyTimingObjectDisconnect")
                            }),
                            f.abrupt("return", c);
                        case 8:
                        case "end":
                            return f.stop()
                        }
                }, r, this)
            }));
            function t(r, n) {
                return e.apply(this, arguments)
            }
            return t
        }()
    }]),
    a
}();
isNode || (screenfull = initializeScreenfull(),
initializeEmbeds(),
resizeEmbeds(),
initAppendVideoMetadata(),
checkUrlTimeParam());
const VIDEO_LIST = {
    MAIN_VIDEO_REEL: 761102167,
    TEST: 76979871
};
class VideoOverlay {
    domVideoContainer;
    domVideoCursor;
    domVideoCursorSvg;
    isOpened = !1;
    openedRatio = 0;
    domVideoCursorDirection = -1;
    domVideoCursorActive = !1;
    domVideoCursorActiveRatio = 0;
    domVideoCursorRotateRatio = 0;
    domVideoCursorExtraRotationMotion = new SecondOrderDynamics(0,1,.8,1.2);
    hoverScaleFactor = 1;
    isVideoMuted = !1;
    isControlsHover = !1;
    isVideoPlaying = !1;
    isVideoReady = !1;
    videoPercentageWatched = 0;
    videoDuration = 0;
    videoWidth = 1920;
    videoHeight = 1080;
    hasInitalited = !1;
    isProjectPage = !1;
    preInit() {
        if (this.hasInitalited)
            return;
        this.domVideoContainer = document.querySelector("#video-overlay"),
        this.domVideoCursor = document.querySelector("#video-overlay-cursor"),
        this.domVideoCursorSvg = document.querySelector("#video-overlay-cursor-svg"),
        this.domVimeoEntryPoint = document.querySelector("#video-overlay__vimeo-video"),
        this.domVideoPlayBtn = document.querySelector("#video-overlay__play-btn"),
        this.domVideoMuteBtn = document.querySelector("#video-overlay__mute-btn"),
        this.domVideoProgress = document.querySelector("#video-overlay__progress-container"),
        this.domVideoProgressActive = document.querySelector("#video-overlay__progress-active"),
        this.domMobileCloseButton = document.querySelector("#video-overlay__mobile-close-btn"),
        this.domVideoProgress.onmouseenter = () => this.isControlsHover = !0,
        this.domVideoProgress.onmouseleave = () => this.isControlsHover = !1,
        this.domVideoPlayBtn.onmouseenter = () => this.isControlsHover = !0,
        this.domVideoPlayBtn.onmouseleave = () => this.isControlsHover = !1,
        this.domVideoMuteBtn.onmouseenter = () => this.isControlsHover = !0,
        this.domVideoMuteBtn.onmouseleave = () => this.isControlsHover = !1;
        const e = {
            id: VIDEO_LIST.MAIN_VIDEO_REEL,
            width: "100%",
            height: "100%",
            responsive: !0,
            title: !1,
            controls: !1,
            byline: !1,
            end_screen: {
                type: "empty"
            }
        };
        this.videoPlayer = new Player("video-overlay__vimeo-video",e),
        this.videoPlayer.element.style.pointerEvents = "none",
        this.videoPlayer.setCurrentTime(0),
        this.videoPlayer.getVideoWidth().then(t => this.videoWidth = t),
        this.videoPlayer.getVideoHeight().then(t => this.videoHeight = t),
        this.videoPlayer.getDuration().then(t => this.videoDuration = t),
        this.videoPlayer.on("ended", function(t) {
            this.close()
        }),
        this.domVideoContainer.addEventListener("click", () => {
            properties.width > 812 && this.close()
        }
        ),
        this.domMobileCloseButton.addEventListener("click", () => {
            this.close()
        }
        ),
        this.videoPlayer.on("ended", () => {
            this.close()
        }
        ),
        this.videoPlayer.on("ended", () => {}
        ),
        this.videoPlayer.on("timeupdate", t => {
            this.videoPercentageWatched = t.percent,
            this.domVideoProgressActive.style.width = `${t.percent * 100}%`,
            t.percent > .996 && this.close()
        }
        ),
        this.domVideoPlayBtn.onclick = t => {
            t.stopPropagation(),
            this.isVideoPlaying ? (this.videoPlayer.pause(),
            this.isVideoPlaying = !1) : (this.videoPlayer.play(),
            this.isVideoPlaying = !0),
            this.domVideoPlayBtn.innerHTML = this.isVideoPlaying ? "Play" : "Pause"
        }
        ,
        this.domVideoMuteBtn.onclick = t => {
            t.stopPropagation(),
            this.isVideoMuted ? (this.videoPlayer.setVolume(1),
            this.isVideoMuted = !1) : (this.videoPlayer.setVolume(0),
            this.isVideoMuted = !0),
            this.domVideoMuteBtn.innerHTML = this.isVideoMuted ? "Unmute" : "Mute"
        }
        ,
        this.domVideoProgress.onclick = t => {
            t.stopPropagation(),
            this.domVideoProgressBCR.width === 0 && (this.domVideoProgressBCR = this.domVideoProgress.getBoundingClientRect());
            const r = (t.clientX - this.domVideoProgressBCR.x) / this.domVideoProgressBCR.width;
            this.videoPlayer.pause(),
            this.videoPlayer.setCurrentTime(this.videoDuration * r).then( () => {
                this.videoPlayer.play()
            }
            ).catch(n => {
                this.videoPlayer.play()
            }
            )
        }
        ,
        this.hasInitalited = !0
    }
    initAndPlayVideo(e=VIDEO_LIST.MAIN_VIDEO_REEL, t=!1) {
        this.isProjectPage = t,
        this.isVideoReady = !1,
        this.videoPlayer.loadVideo(e).then( () => {
            this.videoPlayer.setCurrentTime(0),
            this.videoPlayer.getVideoWidth().then(r => this.videoWidth = r),
            this.videoPlayer.getVideoHeight().then(r => this.videoHeight = r),
            this.videoPlayer.getDuration().then(r => this.videoDuration = r),
            this.isVideoReady = !0,
            this.open()
        }
        )
    }
    init() {
        this.domVideoContainer.style.opacity = 0,
        this.domVideoContainer.style.display = "none"
    }
    resize() {
        if (!this.hasInitalited)
            return;
        const e = this.domVideoContainer.style.display;
        this.domVideoContainer.style.display = "block";
        const t = properties.viewportWidth / properties.viewportHeight
          , r = this.videoWidth / this.videoHeight;
        if (this.isProjectPage) {
            this.domVimeoEntryPoint.classList.add("is-project-view"),
            this.domVideoContainer.classList.add("is-project-view"),
            this.domVimeoEntryPoint.style.removeProperty("width"),
            this.domVimeoEntryPoint.style.removeProperty("height"),
            this.domVimeoEntryPoint.style.transform = "translateZ(0)";
            const o = this.domVimeoEntryPoint.getBoundingClientRect().width / r;
            this.domVimeoEntryPoint.style.bottom = this.domVimeoEntryPoint.style.top = .5 * (properties.viewportHeight - o) + "px",
            this.videoPlayer.element.style.width = "100%",
            this.videoPlayer.element.style.height = "100%"
        } else {
            this.domVimeoEntryPoint.classList.remove("is-project-view"),
            this.domVideoContainer.classList.remove("is-project-view");
            const n = Math.max(1, t / r);
            this.domVimeoEntryPoint.style.width = `${properties.viewportWidth}px`,
            this.domVimeoEntryPoint.style.height = `${properties.viewportHeight}px`,
            this.domVimeoEntryPoint.style.transform = `scale(${n})`,
            this.videoPlayer.element.style.width = `${properties.viewportWidth}px`,
            this.videoPlayer.element.style.height = `${properties.viewportHeight}px`
        }
        this.domVideoProgressBCR = this.domVideoProgress.getBoundingClientRect(),
        this.domVideoContainer.style.display = e
    }
    update(e) {
        if (!this.hasInitalited || (this.openedRatio = math.saturate(this.openedRatio + 2 * (this.isOpened ? e : -e)),
        this.domVideoContainer.style.opacity = ease.quadInOut(this.openedRatio),
        this.domVideoContainer.style.display = this.openedRatio > 0 ? "block" : "none",
        settings.USE_AUDIO && (audios.groups.music.volume = 1 - this.openedRatio),
        this.needsReset && this.openedRatio === 0 && (this.needsReset = !1),
        this.openedRatio === 0))
            return;
        let t = input.easedMouseDynamics.default.value.x
          , r = input.easedMouseDynamics.default.value.y
          , n = (t * .5 + .5) * properties.viewportWidth
          , o = (.5 - r * .5) * properties.viewportHeight;
        if (properties.useMobileLayout)
            this.domVideoCursor.style.display = "none";
        else {
            this.domVideoCursorActiveRatio = math.saturate(this.domVideoCursorActiveRatio + e * 1.5),
            this.domVideoCursorDirection = n > 0 ? 1 : -1,
            this.hoverScaleFactor = math.saturate(this.hoverScaleFactor + 4 * e * (this.isControlsHover ? -1 : 1)),
            this.domVideoCursor.style.display = "flex";
            let l = n
              , c = o
              , u = math.fit(this.hoverScaleFactor, 0, 1, .2, 1) * Math.min(2.5, input.easedMouseDynamics.default.valueVel.length() / 5 + 1) * ease.backOut(this.domVideoCursorActiveRatio) * math.fit(this.openedRatio, .5, 1, 0, 1, ease.lusion);
            this.domVideoCursor.style.transform = `translate3d(${l}px, ${c}px,0) translate3d(-50%, -50%, 0) scale(${u})`,
            this.domVideoCursorRotateRatio = math.saturate(this.domVideoCursorRotateRatio + (this.domVideoCursorDirection > 0 ? e * 3 : e * -3)),
            this.domVideoCursorExtraRotationMotion.update(e, math.clamp(input.easedMouseDynamics.default.valueVel.y * -this.domVideoCursorDirection, -1, 1));
            let f = ease.backInOut(this.domVideoCursorRotateRatio);
            this.domVideoCursorSvg.style.transform = `scale(${ease.quadInOut(this.hoverScaleFactor)}) rotate(${f * 180 + this.domVideoCursorExtraRotationMotion.value * 75}deg)`
        }
    }
    open() {
        this.isOpened = !0,
        setTimeout( () => {
            this.videoPlayer.play().then( () => {
                this.resize(),
                this.isVideoPlaying = !0
            }
            )
        }
        , 500)
    }
    close() {
        this.isVideoReady && (this.isOpened = !1,
        this.videoPlayer.pause().then( () => {
            this.videoPlayer.setCurrentTime(0).then( () => {}
            ),
            this.needsReset = !0,
            this.isVideoPlaying = !1,
            this.isProjectPage = !1
        }
        ))
    }
}
const videoOverlay = new VideoOverlay;
class HomeReelSection {
    domContainer;
    domTitle;
    domTitleLine1;
    domDesc;
    domTopContainer;
    domBottomContainer;
    domTopPlayButton;
    domReelContainer;
    domVideoPlaceholder;
    videoPlaceholderHeight = 0;
    ufxMesh;
    ufxShowRatio = 0;
    ufxMeshRadialCenter = new Vector2(.5,.5);
    isUfxMeshHover = !1;
    ROLLUP_ANIMATION_INTERVAL = 2;
    currRollupTime = 0;
    prevRollupTime = 0;
    hoverRatio = 0;
    geometry = null;
    _needsReset = !0;
    isVerticalVideo = !1;
    showVideoPlaceholderButton = !1;
    preInit(e) {
        this.domContainer = e.querySelector("#home-reel"),
        this.domTitle = e.querySelector("#home-reel-title"),
        this.domTitle._time = 0,
        this.domTitle._animating = !1,
        this.domTitleInner = e.querySelector("#home-reel-title-inner"),
        this.domTitleLine1 = e.querySelector("#home-reel-title-line-1"),
        this.domContent = e.querySelector("#home-reel-content"),
        this.domDescription = e.querySelector("#home-reel-desc"),
        this.domDescription._time = 0,
        this.domDescription._animating = !1,
        this.domBtn = e.querySelector("#home-reel-cta"),
        this.domBtn._ratio = 0,
        this.domBtn._animating = !1,
        this.domThumb = e.querySelector("#home-reel-thumb"),
        this.domReelContainer = e.querySelector("#home-reel-container"),
        this.domReelContainerInner = e.querySelector("#home-reel-container-inner"),
        this.domVideoContainer = e.querySelector("#home-reel-video-container"),
        this.domVideoContainerDecorationTop = e.querySelector("#home-reel-video-container-top"),
        this.domVideoContainerDecorationTop._crosses = Array.from(this.domVideoContainerDecorationTop.querySelectorAll(".home-reel-video-container-cross")),
        this.domVideoContainerDecorationTop._svgWrapper = this.domVideoContainerDecorationTop.querySelector(".home-reel-video-container-svg-wrapper"),
        this.domVideoContainerDecorationTop._svgs = Array.from(this.domVideoContainerDecorationTop.querySelectorAll("svg")),
        this.domVideoContainerDecorationTop._animating = !1,
        this.domVideoContainerDecorationTop._time = 0,
        this.domVideoContainerDecorationBottom = e.querySelector("#home-reel-video-container-bottom"),
        this.domVideoContainerDecorationBottom._crosses = Array.from(this.domVideoContainerDecorationBottom.querySelectorAll(".home-reel-video-container-cross")),
        this.domVideoContainerDecorationBottom._svgWrapper = this.domVideoContainerDecorationBottom.querySelector(".home-reel-video-container-svg-wrapper"),
        this.domVideoContainerDecorationBottom._svgs = Array.from(this.domVideoContainerDecorationBottom.querySelectorAll("svg")),
        this.domVideoContainerDecorationBottom._animating = !1,
        this.domVideoContainerDecorationBottom._time = 0,
        this.domVideoPlaceholder = e.querySelector("#home-reel-video-placeholder"),
        this.domVideoTitle = e.querySelector("#home-reel-video-title"),
        this.domVideoTitle._animating = !1,
        this.domVideoTitle._time = 0,
        this.domVideoTitle._showAnimating = !1,
        this.domVideoTitle._showTime = 0,
        this.domVideoContainerDecoration = e.querySelector("#home-reel-video-container-decoration"),
        this.domTopContainer = e.querySelector("#home-reel-decoration-top-container"),
        this.domBottomContainer = e.querySelector("#home-reel-decoration-bottom-container"),
        this.domVideoButton = e.querySelector("#home-reel-video-watch-btn"),
        this.domVideoButton._active = !1,
        this.domVideoButton._ratio = 0,
        this.domVideoButton._time = 0,
        this.domVideoButton._hover = !1,
        this.domVideoButton._hoverRatio = 0,
        this.domVideoButton._hoverRatio2 = 0,
        this.domVideoButton._hoverRatio3 = 0,
        this.domVideoButton._hoverTime = 0,
        this.isVerticalVideo = properties.viewportWidth <= 560,
        this.video = document.createElement("video"),
        this.video.muted = !0,
        settings.LOCAL_TEXTURE_PATH !== settings.TEXTURE_PATH && (this.video.crossOrigin = "anonymous"),
        this.video.muted = !0,
        this.video.src = settings.TEXTURE_PATH + (this.isVerticalVideo ? "reel/mobile.mp4" : "reel/desktop.mp4"),
        this.video.loop = !0,
        this.video.load(),
        this.videoTexture = new VideoTexture(this.video),
        this.ufxMeshThumb = new UfxMesh({
            refDom: this.domThumb
        }),
        this.ufxMesh = new UfxMesh({
            refDom: this.domReelContainerInner,
            segX: 32,
            segY: 32,
            uniforms: Object.assign({
                u_screenPaintTexture: screenPaint.sharedUniforms.u_currPaintTexture,
                u_resolution: properties.sharedUniforms.u_resolution,
                u_texture: {
                    value: this.videoTexture
                },
                u_radialCenter: {
                    value: this.ufxMeshRadialCenter
                },
                u_color: {
                    value: new Color(1716219)
                },
                u_showRatio: {
                    value: 0
                },
                u_aspectScale: {
                    value: 1
                },
                u_time: properties.sharedUniforms.u_time,
                u_domXYFrom: this.ufxMeshThumb.material.uniforms.u_domXY,
                u_domWHFrom: this.ufxMeshThumb.material.uniforms.u_domWH,
                u_globalRadius: properties.sharedUniforms.u_globalRadius
            }, blueNoise.sharedUniforms),
            vertexShader: videoVert,
            fragmentShader: videoFrag,
            depthTest: !1,
            depthWrite: !1,
            side: 2
        }),
        this.ufxMesh.renderOrder = 1e3,
        homePage.preUfxContainer.add(this.ufxMesh),
        videoOverlay.preInit(),
        this.lineVisual = new Line(0),
        this.lineVisual.preInit(),
        this.domVideoPlaceholder.addEventListener("mouseenter", this._onVideoMeshMouseEnter.bind(this)),
        this.domVideoPlaceholder.addEventListener("mouseleave", this._onVideoMeshMouseLeave.bind(this)),
        this.domVideoButton.addEventListener("mouseenter", this._onDomVideoButtonMouseenter.bind(this)),
        this.domVideoButton.addEventListener("mouseleave", this._onDomVideoButtonMouseleave.bind(this)),
        input.onClicked.add( () => {
            input.hasThroughElem(this.domVideoButton, "click") && this._onDomVideoButtonClick()
        }
        )
    }
    init() {
        this.lineVisual.init(),
        this.lineVisual.mesh.material.transparent = !0,
        this.lineVisual.circle.material.transparent = !0,
        this.lineVisual.mesh.renderOrder = 200,
        this.lineVisual.circle.renderOrder = 200,
        videoOverlay.init(),
        homePage.onHideStarted.add(this._onPageHideStarted.bind(this))
    }
    _onPageHideStarted() {
        this.video.paused || this.video.pause(),
        this.domDescription.style.transform = "translate3d(0, 0, 0)"
    }
    resize(e, t) {
        let r = e <= 560;
        this._splitText();
        let n = this.domVideoContainer.getBoundingClientRect().width, o, l = 0, c = 1;
        if (r)
            o = n / 3 * 4;
        else {
            let u = document.getElementById("header-container").getBoundingClientRect().bottom
              , f = properties.viewportHeight - u
              , p = Math.abs(parseFloat(window.getComputedStyle(this.domVideoContainerDecoration).top) * 3) / 2;
            f -= p * 2,
            o = Math.min(f, n / 2),
            l = -properties.viewportHeight * .5 + f * .5 + u + p,
            c = o / (n / 1920 * 960)
        }
        this.domVideoContainer.style.height = o + "px",
        this.domVideoContainer.style.marginTop = l + "px",
        scrollManager.resize(properties.viewportWidth, properties.viewportHeight),
        this.ufxMeshThumb.syncDom(-scrollManager.scrollPixel),
        this.ufxMesh.syncDom(-scrollManager.scrollPixel),
        this.ufxMesh.material.uniforms.u_aspectScale.value = c,
        this.lineVisual.resize(e, t),
        this.domVideoButton._width = 12 * parseFloat(getComputedStyle(document.documentElement).fontSize),
        this.videoPlaceholderHeight = this.domVideoPlaceholder.getBoundingClientRect().height,
        this.domTitleLine1._paddingLeft = Number(getComputedStyle(this.domTitleLine1).paddingLeft.split("px")[0]),
        this.domVideoContainer.style.transform = "translateZ(0)",
        this.domVideoContainerDecorationTop._svgWrapper._width = this.domVideoContainerDecorationTop._svgWrapper.getBoundingClientRect().width,
        this.isVerticalVideo !== r && (this.isVerticalVideo = r,
        this.video.src = settings.TEXTURE_PATH + (this.isVerticalVideo ? "reel/mobile.mp4" : "reel/desktop.mp4"))
    }
    update(e) {
        let t = scrollManager.getDomRange(this.domContainer)
          , r = t.isActive;
        this.lineVisual.update(e, t);
        let n = properties.viewportWidth <= 812
          , o = scrollManager.getDomRange(this.domReelContainer)
          , l = scrollManager.getDomRange(this.domReelContainerInner)
          , c = n ? 0 : scrollManager.getEaseInOutOffset(scrollManager.scrollPixel - o.top + (properties.viewportHeight - l.height) * .5, properties.viewportHeight, 1, 0)
          , u = scrollManager.getDomRange(this.domThumb)
          , f = n ? l.isActive : u.showScreenOffset > 0 && l.hideScreenOffset < 1;
        if (homePage.preUfxContainer.add(this.lineVisual.container),
        homePage.preUfxContainer.add(this.lineVisual.container),
        f ? this.domVideoContainer.classList.add("--is-visible") : this.domVideoContainer.classList.remove("--is-visible"),
        f) {
            let p = u.top - (properties.viewportHeight - u.height) * .5
              , g = o.top - (properties.viewportHeight - o.height) * .5
              , v = Math.max(0, u.showScreenOffset * properties.viewportHeight - properties.viewportHeight * .5 - u.height * .5);
            this.ufxMeshThumb.update(-scrollManager.scrollPixel + v),
            this.ufxMesh.update(-scrollManager.scrollPixel + c),
            this.ufxMesh.visible = !0,
            this.ufxMesh.visible = r,
            this.hoverRatio = math.saturate(this.hoverRatio + 4 * e * (this.isUfxMeshHover ? 1 : -1));
            let _ = input.mousePixelXY.x
              , w = input.mousePixelXY.y + scrollManager.scrollPixel
              , S = this.ufxMesh._domX
              , b = this.ufxMesh._domY - this.ufxMesh._capturedOffsetY
              , C = this.ufxMesh._domWidth
              , R = this.ufxMesh._domHeight;
            this.ufxMeshRadialCenter.set((_ - S) / C, 1 - (w - b) / R);
            let T = math.fit(scrollManager.scrollPixel, p, g, 0, 1);
            this.videoPlaceholderRatio = T,
            this.showVideoPlaceholderButton = T > .9,
            this.ufxMesh.material.uniforms.u_showRatio.value = n ? 1 : T,
            T === 1 ? (this.domVideoTitle._animating = !0,
            this.domVideoTitle._showAnimating = !0) : (this.domVideoTitle._showAnimating = !1,
            this.domVideoTitle._animating = !1),
            this.domVideoContainer.style.transform = `translate3d(0,${c}px,0)`,
            !properties.useMobileLayout && T % 1 > 0 && (properties.autoScrollSpeed = input.lastScrollYDirection),
            this.video.paused && this.video.play()
        } else
            this.ufxMesh.visible = !1,
            this.video.paused || this.video.pause();
        t.screenRatio === -1 && this._reset(),
        r ? this._updateUI(e, o, t) : this._needsReset = !0
    }
    _updateUI(e, t, r) {
        let n = scrollManager.getDomRange(this.domTitle)
          , o = scrollManager.getDomRange(this.domContent);
        if (this.domTitle._time = math.clamp(this.domTitle._time + (this.domTitle._animating ? e : -e), 0, 2),
        this.domDescription._time = math.clamp(this.domDescription._time + (this.domDescription._animating ? e : -e), 0, 2),
        this.domBtn._ratio = math.saturate(this.domBtn._ratio + (this.domBtn._animating ? e : -e)),
        this.videoPlaceholderRatio !== 1 && (this.domVideoButton._hover = !1),
        this.domVideoButton._ratio = math.fit(this.videoPlaceholderRatio, .3, 1, 0, 1),
        this.domVideoButton._active = this.domVideoButton._ratio === 1,
        this.domVideoButton._time = math.clamp(this.domVideoButton._time + (t.screenRatio > -1 ? e : -e), 0, 1 / 0),
        this.domVideoButton._hoverRatio = math.saturate(this.domVideoButton._hoverRatio + (this.domVideoButton._hover ? e : -e)),
        this.domVideoButton._hoverRatio2 = math.saturate(this.domVideoButton._hoverRatio2 + (this.domVideoButton._hover ? e * 1.5 : -e * 1.5)),
        this.domVideoButton._hoverRatio3 = math.saturate(this.domVideoButton._hoverRatio3 + (this.domVideoButton._hover ? e * 3 : -e * 3)),
        this.domVideoButton._hoverTime = math.clamp(this.domVideoButton._hoverTime + (this.domVideoButton._hover ? e * 2 : -e * 0), 0, 1 / 0),
        this.domVideoContainerDecorationTop._time = math.clamp(this.domVideoContainerDecorationTop._time + (this.domVideoContainerDecorationTop._animating ? e : -e * 2), 0, 1.4),
        this.domVideoContainerDecorationBottom._time = math.clamp(this.domVideoContainerDecorationBottom._time + (this.domVideoContainerDecorationBottom._animating ? e : -e * 2), 0, 1.4),
        !properties.useMobileLayout) {
            this.domVideoButton.style.opacity = ease.expoInOut(this.domVideoButton._ratio),
            this.domVideoButton.style.transform = `scale(${ease.expoInOut(this.domVideoButton._ratio) + .1 * ease.expoInOut(this.domVideoButton._hoverRatio3)})`,
            this.domVideoButton.style.display = this.domVideoButton._ratio > 0 ? "flex" : "none",
            this.domVideoButton._ratio === 1 ? (this.domVideoContainerDecorationTop._animating = !0,
            this.domVideoContainerDecorationBottom._animating = !0) : (this.domVideoContainerDecorationTop._animating = !1,
            this.domVideoContainerDecorationBottom._animating = !1);
            for (let f = 0; f < this.domVideoContainerDecorationTop._crosses.length; f++) {
                let p = this.domVideoContainerDecorationTop._crosses[f]
                  , g = math.fit(this.domVideoContainerDecorationTop._time - f / 10, 0, .6, 0, 1, ease.lusion)
                  , v = math.fit(this.domVideoContainerDecorationTop._time - f / 10, 0, .6, 0, 180, ease.lusion)
                  , _ = math.fit(this.domVideoButton._hoverRatio2 - f / 10, 0, .7, 0, 1, ease.expoInOut);
                p.style.transform = `translate3d(0, ${_}em, 0) scale(${g}) rotate(${v}deg)`
            }
            for (let f = 0; f < this.domVideoContainerDecorationBottom._crosses.length; f++) {
                let p = this.domVideoContainerDecorationBottom._crosses[f]
                  , g = math.fit(this.domVideoContainerDecorationBottom._time - f / 10, 0, .6, 0, 1, ease.lusion)
                  , v = math.fit(this.domVideoContainerDecorationBottom._time - f / 10, 0, .6, 0, 180, ease.lusion)
                  , _ = math.fit(this.domVideoButton._hoverRatio2 - f / 10, 0, .7, 0, 1, ease.expoInOut);
                p.style.transform = `translate3d(0, ${_}em, 0) scale(${g}) rotate(${v}deg)`
            }
        }
        for (let f = 0; f < this.domVideoContainerDecorationTop._svgs.length; f++) {
            let p = this.domVideoContainerDecorationTop._svgs[f]
              , g = properties.viewportWidth >= settings.MOBILE_WIDTH ? math.fit(this.domVideoButton._hoverRatio2 - f / 25, .2, 1, 1.2, 0, ease.expoInOut) : 0;
            p.style.transform = `translate3d(0, ${g}em, 0)`
        }
        for (let f = 0; f < this.domVideoContainerDecorationBottom._svgs.length; f++) {
            let p = this.domVideoContainerDecorationBottom._svgs[f]
              , g = properties.viewportWidth >= settings.MOBILE_WIDTH ? math.fit(this.domVideoButton._hoverRatio2 - f / 25, .2, 1, 1.2, 0, ease.expoInOut) : 0;
            p.style.transform = `translate3d(0, ${g}em, 0)`
        }
        let l = properties.viewportWidth < settings.MOBILE_WIDTH ? this.domVideoButton._time : this.domVideoButton._hoverTime
          , c = math.fit(l % 15, 0, 15, 0, -this.domVideoContainerDecorationTop._svgWrapper._width / 2);
        this.domVideoContainerDecorationTop._svgWrapper.style.transform = `translate3d(${c}px, 0, 0)`,
        c = math.fit(l % 15, 0, 15, -this.domVideoContainerDecorationTop._svgWrapper._width / 2, 0),
        this.domVideoContainerDecorationBottom._svgWrapper.style.transform = `translate3d(${c}px, 0, 0)`;
        let u = properties.viewportHeight * .1;
        if (this.domTitleInner.style.transform = "translateZ(0)",
        n.screenRatio > -1) {
            if (this.domTitle._animating = !0,
            !properties.useMobileLayout) {
                this.domVideoTitle._time = math.clamp(this.domVideoTitle._time + (this.domVideoTitle._animating ? e : -e), 0, 1 / 0),
                this.domVideoTitle._showTime = math.saturate(this.domVideoTitle._showTime + (this.domVideoTitle._showAnimating ? e : -e)),
                this.domVideoTitle._hoverTime = math.saturate(this.domVideoTitle._hoverTime + (this.domVideoTitle._hover && this.domVideoTitle._time > 1 ? e * 1.5 : -e * 1.5)),
                this.currRollupTime = this.domVideoTitle._time % this.ROLLUP_ANIMATION_INTERVAL;
                for (let p = 0; p < this.domVideoTitle._splitted.words.length; p++) {
                    let g = this.domVideoTitle._splitted.words[p];
                    this.prevRollupTime - this.currRollupTime > this.ROLLUP_ANIMATION_INTERVAL - 1 && (g._randCharIndex = Math.round(Math.random() * (g._chars.length - 1)));
                    for (let v = 0; v < g._chars.length; v++) {
                        let _ = g._chars[v]
                          , w = math.fit(this.domVideoTitle._showTime - p / 4 - v / 20, 0, .6, 200, 0, ease.lusion);
                        v === g._randCharIndex && (w += math.fit(this.currRollupTime - p / 10, .5, 1.3, 0, -100, ease.lusion)),
                        _._wrapper.style.transform = `translate3d(0, ${w}%, 0)`
                    }
                }
                for (let p = 0, g = this.domTitle._splitted.words.length; p < g; p++) {
                    let v = this.domTitle._splitted.words[p], _, w;
                    p < 2 ? (_ = math.fit(this.domTitle._time - Math.abs(2 - p) / 10, .5, 1.2, -this.domTitleLine1._paddingLeft, 0, ease.lusion),
                    w = math.fit(this.domTitle._time - p / 10, 0, 1, 100, 0, ease.lusion)) : (_ = 0,
                    w = math.fit(this.domTitle._time - p / 10, 0, 1, -100, 0, ease.lusion)),
                    v.style.transform = `translate3d(${_}px, ${w}%, 0)`
                }
            }
            let f = n.showScreenOffset * -u * .5;
            this.domTitleInner.style.transform = "translate3d(0," + f + "px,0)",
            this.prevRollupTime = this.currRollupTime
        }
        if (o.screenRatio > -1) {
            let f = o.showScreenOffset * -u * 1.5;
            this.domDescription.style.transform = "translate3d(0," + f + "px,0)",
            this.domDescription._animating = !0,
            properties.useMobileLayout || this.domDescription._splitted.words.forEach( (g, v) => {
                let _ = math.fit(this.domDescription._time - v / 100, 0, 1, .1, 1, ease.expoOut)
                  , w = math.fit(this.domDescription._time - v / 100, 0, 1, 100, 0, ease.expoOut);
                g.style.opacity = _,
                g.style.transform = `translate3d(0, ${w}%, 0)`
            }
            ),
            this.domBtn._animating = !0;
            let p = o.showScreenOffset * -u * 1.25;
            properties.viewportWidth >= 812 ? (this.domBtn.style.transform = `translateY(${p}px)translate3d(0, ${math.fit(this.domBtn._ratio, 0, 1, 150, 0, ease.lusion)}%, 0) rotate(${math.fit(this.domBtn._ratio, 0, 1, 10, 0, ease.lusion)}deg)`,
            this.domBtn.style.opacity = ease.lusion(this.domBtn._ratio)) : this.domBtn.style.transform = `translateY(${p}px)`
        }
    }
    _onDomVideoButtonClick() {
        videoOverlay.initAndPlayVideo(VIDEO_LIST.MAIN_VIDEO_REEL)
    }
    _onDomVideoButtonMouseenter() {
        this.domVideoButton._hover = !0,
        this.domVideoContainerDecorationBottom.classList.add("--is-active"),
        this.domVideoContainerDecorationTop.classList.add("--is-active")
    }
    _onDomVideoButtonMouseleave() {
        this.domVideoButton._hover = !1,
        this.domVideoContainerDecorationBottom.classList.remove("--is-active"),
        this.domVideoContainerDecorationTop.classList.remove("--is-active")
    }
    _onVideoMeshMouseEnter() {
        this.isUfxMeshHover = !0
    }
    _onVideoMeshMouseLeave() {
        this.isUfxMeshHover = !1
    }
    _splitText() {
        if (properties.viewportWidth >= 812) {
            this.domDescription._splitted = new SplitType(this.domDescription,{
                types: "words"
            }),
            this.domTitle._splitted = new SplitType(this.domTitleInner,{
                types: "words"
            }),
            this.domTitleLine1 = document.getElementById("home-reel-title-line-1"),
            this.domVideoTitle._splitted = new SplitType(this.domVideoTitle,{
                types: "words",
                wordClass: "home-reel-video-title-word"
            });
            for (let e = 0; e < this.domVideoTitle._splitted.words.length; e++) {
                let t = this.domVideoTitle._splitted.words[e]
                  , r = new SplitType(t,{
                    types: "chars"
                });
                t._chars = r.chars;
                for (let n = 0; n < t._chars.length; n++) {
                    let o = t._chars[n]
                      , l = o.cloneNode(!0)
                      , c = document.createElement("div");
                    c.classList.add("char-wrapper"),
                    c.style.display = "inline-block",
                    o._wrapper = c,
                    c.append(o),
                    c.append(l),
                    t.append(c)
                }
            }
        }
    }
    _reset() {
        if (this.domDescription._splitted) {
            if (this._needsReset = !1,
            this.domTitle._time = 0,
            this.domTitle._animating = !1,
            this.domDescription._time = 0,
            this.domDescription._animating = !1,
            this.domVideoButton._active = !1,
            this.domVideoButton._ratio = 0,
            this.domVideoButton._hover = !1,
            this.domVideoButton._hoverTime = 0,
            this.domVideoButton._hoverRatio = 0,
            this.domVideoButton._hoverRatio2 = 0,
            this.domVideoButton._hoverRatio3 = 0,
            this.domBtn._animating = !1,
            this.domBtn._ratio = 0,
            this.domVideoContainerDecorationTop._animating = !1,
            this.domVideoContainerDecorationTop._time = 0,
            properties.useMobileLayout)
                this.domDescription._splitted && this.domDescription._splitted.revert(),
                this.domTitle._splitted && this.domTitle._splitted.revert();
            else {
                this.domDescription._splitted.words.forEach(e => {
                    e.style.transform = "translate3d(0, 100%, 0)",
                    e.style.opacity = 0
                }
                ),
                this.domTitle._splitted.words.forEach(e => {
                    e.style.transform = "translate3d(0, 100%, 0)"
                }
                );
                for (let e = 0; e < this.domVideoTitle._splitted.words.length; e++) {
                    let t = this.domVideoTitle._splitted.words[e];
                    for (let r = 0; r < t._chars.length; r++) {
                        let n = t._chars[r];
                        n._wrapper.style.transform = "translate3d(0, 0, 0)",
                        n.style.transform = "translate3d(0, 0, 0)"
                    }
                }
            }
            this.domVideoTitle._animating = !1,
            this.domVideoTitle._time = 0,
            this.domVideoTitle._showAnimating = !1,
            this.domVideoTitle._showTime = 0
        }
    }
}
const homeReelSection = new HomeReelSection;
let wrapper = document.createElement("div");
class DomHelper {
    clone(e) {
        wrapper.innerHTML = e.outerHTML;
        let t = wrapper.firstChild;
        return wrapper.removeChild(t),
        t
    }
    _collapseWhiteSpace(e) {
        return e.trim().replace(/\s+/g, " ")
    }
    getLinesFromText(e) {
        let t = e.childNodes
          , r = [];
        for (let n = 0, o = t.length; n < o; n++) {
            let l = t[n];
            l.nodeType == 3 && r.push.apply(r, this.getLinesFromTextNode(l))
        }
        return r
    }
    getLinesFromTextNode(e) {
        if (e.nodeType !== 3)
            throw new Error("Lines can only be extracted from text nodes.");
        e.textContent = this._collapseWhiteSpace(e.textContent);
        for (var t = e.textContent, r = document.createRange(), n = [], o = [], l = 0; l < t.length; l++) {
            r.setStart(e, 0),
            r.setEnd(e, l + 1);
            var c = r.getClientRects().length - 1;
            n[c] || n.push(o = []),
            o.push(t.charAt(l))
        }
        return n = n.map(u => this._collapseWhiteSpace(u.join(""))),
        n
    }
}
const domHelper = new DomHelper
  , vert$i = `#define GLSLIFY 1
#include <ufxVert>
varying vec2 v_uv;void main(){vec3 basePos=getBasePosition(position);vec3 screenPos=getScreenPosition(basePos);gl_Position=projectionMatrix*modelViewMatrix*vec4(screenPos,1.0);v_uv=padUv(uv);}`
  , frag$l = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform sampler2D u_depthTexture;uniform vec3 u_colorBg;uniform float u_showRatio;uniform float u_activeRatio;uniform vec2 u_textureSize;uniform vec2 u_domWH;uniform vec2 u_shiftXY;uniform vec3 u_focusPos;uniform float u_time;uniform float u_zoomRatio;uniform float u_dofRangeOffset;uniform float u_saturation;uniform float u_brightness;uniform float u_borderRatio;uniform float u_rippleStrength;uniform vec2 u_resolution;uniform float u_globalRadius;varying vec2 v_uv;
#include <getBlueNoise>
float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}float sdRoundedBox(in vec2 p,in vec2 b,in float r){vec2 q=abs(p)-b+r;return min(max(q.x,q.y),0.0)+length(max(q,0.0))-r;}float getRoundedCornerMask(vec2 uv,vec2 size,float radius,float ratio){vec2 halfSize=size*0.5;float maxDist=length(halfSize);float minSize=min(halfSize.x,halfSize.y);float maxSize=max(halfSize.x,halfSize.y);float t=ratio*maxDist;radius=mix(minSize*linearStep(0.,minSize,t),radius,linearStep(maxSize,maxDist,t));halfSize=min(halfSize,vec2(t));float d=sdRoundedBox((uv-.5)*u_domWH,halfSize,radius);return smoothstep(0.,0.-fwidth(d),d);}void main(){vec2 screenUv=gl_FragCoord.xy/u_resolution;vec2 baseUv=v_uv;baseUv.x-=(screenUv.x-0.5)*(1.-sin((screenUv.y)*3.141592))*u_rippleStrength;float radiusRatio=1.;vec3 noise=getBlueNoise(gl_FragCoord.xy+vec2(5.,28.));float imageAlpha=getRoundedCornerMask(baseUv,u_domWH*mix(0.7,1.,u_showRatio),u_globalRadius,radiusRatio);vec2 toUvSpace=1./(u_textureSize*max(u_domWH.x/u_textureSize.x,u_domWH.y/u_textureSize.y));float borderThickenss=(u_domWH.y*0.08+5.)*u_borderRatio-5.;vec2 uv=baseUv-.5;uv*=u_domWH*mix(0.75,1.,u_showRatio);uv*=mix(0.975,1.,u_zoomRatio);float zMultiplier=u_domWH.y*(.15+u_activeRatio*15.);vec3 pos=vec3(uv,-zMultiplier);float cameraDepth=u_domWH.y*mix(10.,5.,u_zoomRatio);vec3 rayOri=vec3(u_focusPos.xy,cameraDepth);float dist=length(pos-rayOri);vec3 rayDir=(pos-rayOri)/dist;float skipDist=cameraDepth/-rayDir.z;dist-=skipDist;float stepDist=dist/float(PARALLAX_SAMPLES);vec3 rayStep=rayDir*stepDist;vec3 rayPos=rayOri+rayDir*(skipDist+stepDist*noise.x);for(int i=0;i<PARALLAX_SAMPLES;i++){float currZ=-texture2D(u_depthTexture,rayPos.xy*toUvSpace+.5).r*zMultiplier;if(currZ>rayPos.z){break;}rayPos+=rayStep;dist+=stepDist;}uv=rayPos.xy;uv*=toUvSpace;uv+=u_shiftXY*0.015;float depth=texture2D(u_depthTexture,uv+.5).r;vec3 color=vec3(0.0);float PI=3.1415926;float blurriness=mix(0.0,0.01,u_zoomRatio)*linearStep(0.0,0.5,abs(depth-u_focusPos.z)+u_dofRangeOffset);float angle=PI*2.*noise.y;float textureAspectInv=u_textureSize.y/u_textureSize.x;float numSampleInv=1./float(BLUR_SAMPLES);for(int i=0;i<BLUR_SAMPLES;i++){float fI=float(i);float r=sqrt((fI+0.5)*numSampleInv)*blurriness;angle+=10.16640738;vec2 uvOffset=r*vec2(cos(angle)*textureAspectInv,sin(angle));vec4 image=texture2D(u_texture,uv+uvOffset+.5);color+=image.rgb;}color*=numSampleInv;float luma=dot(color,vec3(0.299,0.587,0.114));color=mix(vec3(luma),color,1.0+u_saturation);color+=u_brightness;float fogThickness=0.75;color=mix(color,u_colorBg,linearStep(0.0,fogThickness,u_activeRatio*(1.+fogThickness*2.)-fogThickness-(1.0-depth)));gl_FragColor=vec4(color,imageAlpha);}`;
let TEXT_STAGGER = 20
  , LETTER_PER_SECOND = 40
  , MAX_RAND_LETTER_COUNT = 5;
class ProjectItem {
    static hoverDom = null;
    constructor(e, t, r, n) {
        this.list = e,
        this.id = t,
        this.dom = r,
        this.index = n,
        this.isHover = !1,
        this.hoverRatio = 0,
        this.hoverThresholds = [0, .2, .3],
        this.focusZ = .5,
        this.parallaxStrength = 1,
        this.activeRatio = 0,
        this.showTime = 0,
        this.isHoverDom = !1,
        this.domMain = this.dom.querySelector(".project-item-main"),
        this.domFooterLine1 = this.dom.querySelector(".project-item-line-1"),
        this.domFooterLine2 = this.dom.querySelector(".project-item-line-2-inner"),
        this.domFooterLine2Icon = this.dom.querySelector(".project-item-line-2-icon"),
        this.domFooterLine2List = [],
        this.domFooterLine1Text = this.domFooterLine1.textContent,
        this.domFooterLine1Time = 0,
        this.domFooterLine2Text = this.domFooterLine2.textContent,
        this.domFooterLine2Time = 0,
        this.domFooterLine2HoverRatio = 0;
        let o = settings.USE_WEBGL2 ? LinearMipmapLinearFilter : LinearFilter
          , l = properties.loader.load(settings.PROJECT_PATH + this.id + "/home.webp", {
            type: "texture",
            minFilter: o
        }).content
          , c = properties.loader.load(settings.PROJECT_PATH + this.id + "/home_depth.webp", {
            type: "texture",
            minFilter: LinearFilter
        }).content;
        this.focusPosMotion = new SecondOrderDynamics(new Vector3,1,.6,2),
        this.focusPos = this.focusPosMotion.value,
        this.shiftXYTarget = new Vector2,
        this.shiftXY = new Vector2,
        this.zoomMotion = new SecondOrderDynamics(1,2.2,.7,3),
        this.dofRangeOffsetRatio = 0,
        this.borderMotion = new SecondOrderDynamics(0,2.5,.5,2);
        let u = n % 2 ? 1 : -1;
        this.ufxMesh = new UfxMesh({
            refDom: this.domMain,
            paddingL: u > 0 ? 0 : 1e3,
            paddingR: u < 0 ? 0 : 1e3,
            uniforms: Object.assign({
                u_side: {
                    value: u
                },
                u_sideMargin: {
                    value: 1
                },
                u_texture: {
                    value: l
                },
                u_depthTexture: {
                    value: c
                },
                u_textureSize: {
                    value: l.size
                },
                u_focusPos: {
                    value: this.focusPos
                },
                u_shiftXY: {
                    value: this.shiftXY
                },
                u_deltaOffset: {
                    value: new Vector2
                },
                u_zoomRatio: this.zoomMotion,
                u_dofRangeOffset: {
                    value: 0
                },
                u_dofStrength: {
                    value: 1
                },
                u_saturation: {
                    value: -1
                },
                u_brightness: {
                    value: 0
                },
                u_colorBg: {
                    value: new Color(r.dataset.colorBg)
                },
                u_activeRatio: {
                    value: 0
                },
                u_showRatio: {
                    value: 0
                },
                u_borderRatio: {
                    value: 0
                },
                u_rippleStrength: {
                    value: 0
                },
                u_time: properties.sharedUniforms.u_time,
                u_globalRadius: properties.sharedUniforms.u_globalRadius
            }, blueNoise.sharedUniforms),
            depthTest: !1,
            depthWrite: !1,
            vertexShader: vert$i,
            fragmentShader: frag$l
        }),
        this.ufxMesh.material.defines.PARALLAX_SAMPLES = 12,
        this.ufxMesh.material.defines.BLUR_SAMPLES = 6,
        this.ufxMesh.renderOrder = 10,
        this.domMain.addEventListener("mouseenter", this._onMouseEnter.bind(this)),
        this.domMain.addEventListener("mouseleave", this._onMouseLeave.bind(this))
    }
    _onMouseEnter() {
        pagesManager.isIdle && this.list.zoomRatio == 0 && (this.isHover = !0,
        audios.countPlay("focus"))
    }
    _onMouseLeave() {
        this.isHover = !1
    }
    syncDom() {
        this.ufxMesh.syncDom(-scrollManager.scrollPixel)
    }
    _findIndexFromThresholds(e) {
        for (let t = 0; t < this.hoverThresholds.length; t++)
            if (e < this.hoverThresholds[t])
                return t;
        return this.hoverThresholds.length
    }
    update(e) {
        let t = scrollManager.getDomRange(this.dom);
        if (t.ratio > -1 && t.ratio < 1) {
            this.ufxMesh.update(-scrollManager.scrollPixel),
            this.domFooterLine2HoverRatio = math.saturate(this.domFooterLine2HoverRatio + (this.isHoverDom ? 1 : -1) * e * 2.5),
            this.domFooterLine1Time += e;
            let r = this.domFooterLine1Text
              , n = Math.min(r.length, Math.floor(LETTER_PER_SECOND * this.domFooterLine1Time) - MAX_RAND_LETTER_COUNT)
              , o = Math.min(r.length, Math.floor(LETTER_PER_SECOND * this.domFooterLine1Time))
              , l = "";
            for (let c = 0; c < n; c++)
                l += r[c];
            for (let c = 0; c < o - n; c++)
                l += String.fromCharCode(33 + ~~(Math.random() * 93));
            if (this.domFooterLine1.textContent = l,
            this.domFooterLine2Time += e * .8,
            properties.useMobileLayout)
                this.domFooterLine2List.forEach( (c, u) => {
                    c.style.transform = "translate3d(1.5em, 0, 0)";
                    let f = math.saturate(this.domFooterLine2HoverRatio - Math.abs(u - this.domFooterLine2List.length - 1) / 100)
                      , p = math.fit(f, 0, 1, 0, 1.5, ease.lusion);
                    c.style.transform += `translateX(${p}em)`
                }
                ),
                this.domFooterLine2Icon.style.transform = "translateX(1em)";
            else {
                this.domFooterLine2List.forEach( (u, f) => {
                    let p = math.fit(f, 0, this.domFooterLine2List.length - 1, Math.PI / 2, 3 * Math.PI / 2)
                      , g = math.saturate(this.domFooterLine2Time - Math.cos(p) / TEXT_STAGGER)
                      , v = math.fit(g, 0, 1, 500, 0, ease.expoInOut)
                      , _ = math.saturate(this.domFooterLine2HoverRatio - Math.abs(f - this.domFooterLine2List.length - 1) / 100)
                      , w = math.fit(_, 0, 1, 0, 1.5, ease.lusion);
                    u.style.transform = `translate3d(${w}em, -${v}%, 0)`
                }
                );
                let c = math.fit(this.domFooterLine2HoverRatio, .3, 1, 0, 1, ease.lusion);
                this.domFooterLine2Icon.style.transform = `translateX(${c}em)`
            }
            if (this.showTime += e,
            this.ufxMesh.testViewport(-scrollManager.scrollPixel)) {
                this.ufxMesh.visible = !0;
                let c = input.mousePixelXY.x
                  , u = input.mousePixelXY.y + scrollManager.scrollPixel
                  , f = this.ufxMesh._domX
                  , p = this.ufxMesh._domY - this.ufxMesh._capturedOffsetY
                  , g = this.ufxMesh._domWidth
                  , v = this.ufxMesh._domHeight
                  , _ = this.hoverRatio;
                if (this.hoverRatio = math.clamp(this.hoverRatio + (this.isHover ? 1 : -1) * e, 0, 1),
                _ < this.hoverRatio) {
                    let T = this._findIndexFromThresholds(_)
                      , M = this._findIndexFromThresholds(this.hoverRatio);
                    M != T && this.shiftXYTarget.set(Math.random() - .5, Math.random() - .5).normalize().multiplyScalar(math.fit(this.hoverRatio, 0, .6, 1, 0)),
                    M == this.hoverThresholds.length && this.shiftXYTarget.multiplyScalar(.5)
                } else
                    this.shiftXYTarget.multiplyScalar(.95);
                this.shiftXY.lerp(this.shiftXYTarget, .2);
                let w = this.focusPosMotion.target
                  , S = this.list.zoomRatio
                  , b = this.activeRatio = this.id == this.list.selectedId ? S : Math.min(this.activeRatio, S);
                if (this.isHover && b == 0) {
                    let T = this.parallaxStrength
                      , M = this.hoverRatio > 0 ? math.fit(this.hoverRatio, 0, .3, 1, 0) * v * .75 : 0;
                    w.x = (c - f - g * .5 + Math.cos(properties.time * 20) * M) / g * -v * T,
                    w.y = (u - p - v * .5 - Math.sin(properties.time * 30) * M) / v * v * T,
                    w.z = this.focusZ
                } else
                    w.x = 0,
                    w.y = 0,
                    w.z = b > 0 ? this.focusZ : -1;
                this.zoomMotion.target = this.isHover || b > 0 ? 1 : 0,
                this.dofRangeOffsetRatio = math.clamp(this.dofRangeOffsetRatio + (this.isHover ? .75 : -1) * e, 0, 1),
                this.ufxMesh.material.uniforms.u_dofRangeOffset.value = math.mix(0, -.5, this.dofRangeOffsetRatio),
                this.ufxMesh.material.uniforms.u_saturation.value = 0,
                this.ufxMesh.material.uniforms.u_brightness.value = 0;
                let C = math.fit(this.showTime, 0, 1.5, 0, 1, ease.expoOut);
                this.ufxMesh.material.uniforms.u_showRatio.value = C,
                this.ufxMesh.material.uniforms.u_activeRatio.value = b * b;
                let R = math.fit(this.showTime, 0, 2, 0, 1, ease.expoOut);
                this.ufxMesh.position.x = (1 - R) * (this.index % 2 - .5) * -properties.viewportWidth * .1,
                this.ufxMesh.rotation.z = (1 - R) * (this.index % 2 - .5) * .1,
                this.borderMotion.target = this.isHover && b == 0 ? 1 : 0,
                this.borderMotion.update(e),
                this.ufxMesh.material.uniforms.u_borderRatio.value = 0,
                this.ufxMesh.material.uniforms.u_rippleStrength.value = Math.min(.15, scrollManager.easedScrollStrength * .5),
                this.focusPosMotion.update(e),
                this.zoomMotion.update(e)
            } else
                this.ufxMesh.visible = !1
        } else
            this.ufxMesh.visible = !1,
            this.showTime = 0,
            this.domFooterLine1Time = 0,
            this.domFooterLine2Time = 0,
            this.domFooterLine2.style.removeProperty("will-change")
    }
    preloadImage() {}
}
class ProjectItemList {
    selectedId = null;
    page = null;
    zoomRatio = 0;
    projectItems = {};
    projectItemList = [];
    ufxContainer = new Object3D;
    ufxPivotContainer = new Object3D;
    constructor(e, t) {
        this.page = e,
        this.ufxContainer.add(this.ufxPivotContainer),
        e.postUfxContainer.add(this.ufxContainer);
        let r = t.querySelectorAll(".project-item");
        for (let n = 0; n < r.length; n++) {
            let o = r[n]
              , l = o.dataset.id
              , c = this.projectItems[l] = this.projectItemList[n] = new ProjectItem(this,l,o,n);
            properties.useMobileLayout || (c.dom.addEventListener("mouseenter", this._onDomItemMouseEnter.bind(this)),
            c.dom.addEventListener("mouseleave", this._onDomItemMouseLeave.bind(this))),
            this.ufxPivotContainer.add(c.ufxMesh);
            let u = c.domFooterLine2.textContent.split("");
            c.domFooterLine2.textContent = "",
            u.forEach(f => {
                let p = document.createElement("div");
                if (p.classList.add("project-item-line-2-inner-list"),
                p.style.display = "flex",
                p.style.flexDirection = "column",
                p.style.transform = "translateY(-400%)",
                c.domFooterLine2List.push(p),
                f === " ")
                    p.style.width = "0.3em";
                else
                    for (let g = 0; g < 4; g++) {
                        let v = document.createElement("span");
                        v.textContent = f,
                        p.appendChild(v)
                    }
                c.domFooterLine2.appendChild(p)
            }
            )
        }
    }
    hasProject(e) {
        return !!this.projectItems[e]
    }
    getProjectItemTop(e) {
        let t = this.projectItems[e];
        return t ? scrollManager.getDomRange(t.dom)._top : 0
    }
    _onDomItemMouseEnter(e) {
        let t = this.projectItemList.filter(r => r.dom === e.target)[0];
        t.isHoverDom = !0,
        ProjectItem.hoverDom = t
    }
    _onDomItemMouseLeave(e) {
        let t = this.projectItemList.filter(r => r.dom === e.target)[0];
        t.isHoverDom = !1,
        ProjectItem.hoverDom = null
    }
    resize = (e, t) => {
        this.needsSyncUfx = !0,
        this.ufxPivotContainer.position.set(-e * .5, t * .5, 0),
        this.ufxContainer.position.set(e * .5, -t * .5, 0)
    }
    ;
    update(e) {
        if (this.needsSyncUfx) {
            this.needsSyncUfx = !1;
            for (let u = 0; u < this.projectItemList.length; u++)
                this.projectItemList[u].syncDom()
        }
        let t = 0
          , r = 0
          , n = 0
          , o = 0
          , l = 1
          , c = this.projectItems[this.selectedId];
        if (c) {
            let u = ease.cubicInOut(this.zoomRatio)
              , f = Math.max(properties.viewportWidth / c.ufxMesh._domWidth, properties.viewportHeight / c.ufxMesh._domHeight);
            l *= math.mix(1, f * 1.2, u);
            let p = properties.viewportWidth * .5 - c.ufxMesh._domX - c.ufxMesh._domWidth * .5
              , g = properties.viewportHeight * .5 - c.ufxMesh._domY - c.ufxMesh._domHeight * .5 + scrollManager.scrollPixel + c.ufxMesh._capturedOffsetY;
            t += p,
            r -= g,
            t -= p * (1 - u) / l,
            r += g * (1 - u) / l,
            n += u * .3 * p / properties.viewportWidth,
            o -= u * .3 * p / properties.viewportWidth
        }
        t -= properties.viewportWidth * .5,
        r += properties.viewportHeight * .5,
        this.ufxPivotContainer.position.set(t, r, 0),
        this.ufxContainer.rotation.y = n,
        this.ufxContainer.rotation.z = o,
        this.ufxContainer.scale.setScalar(l);
        for (let u = 0; u < this.projectItemList.length; u++)
            this.projectItemList[u].update(e)
    }
}
class HomeFeaturedSection {
    domContainer;
    domTitle;
    domDisclaimer;
    domCta;
    projectItemList;
    time = 0;
    _needsReset = !0;
    preInit(e) {
        this.domContainer = e.querySelector("#home-featured"),
        this.projectItemList = new ProjectItemList(homePage,e.querySelector(".project-list")),
        this.domItems = e.querySelectorAll(".project-item"),
        this.domTitle = e.querySelector("#home-featured-title"),
        this.domTitle._time = 0,
        this.domTitle._animating = !1,
        this.domDisclaimer = e.querySelector("#home-featured-disclaimer"),
        this.domDisclaimer._time = 0,
        this.domDisclaimer._animating = !1,
        this.domCta = e.querySelector("#home-featured-cta"),
        this.domCta._time = 0,
        this.domCta._animating = !1
    }
    init() {}
    resize(e, t) {
        this._splitText(),
        this.projectItemList.resize(e, t)
    }
    update(e) {
        if (scrollManager.getDomRange(this.domContainer).isActive) {
            this._needsReset && this._reset();
            let r = scrollManager.getDomRange(this.domTitle)
              , n = scrollManager.getDomRange(this.domDisclaimer)
              , o = scrollManager.getDomRange(this.domCta);
            this.domTitle._time = math.clamp(this.domTitle._time + (this.domTitle._animating ? e : -e), 0, 2),
            this.domDisclaimer._time = math.clamp(this.domDisclaimer._time + (this.domDisclaimer._animating ? e : -e), 0, 2),
            this.domCta._time = math.clamp(this.domCta._time + (this.domCta._animating ? e : -e), 0, 1),
            r.screenRatio > -1 && (this.domTitle._animating = !0,
            properties.useMobileLayout || this.domTitle._splitted.chars.forEach( (l, c) => {
                let u = math.fit(this.domTitle._time * 1.5 - c / 20, 0, 1, 1, 0, ease.lusion)
                  , f = math.fit(this.domTitle._time * 1.5 - c / 20, 0, 1, 10, 0, ease.lusion);
                l.style.transform = `translate3d(0, ${u}em, 0) rotate(${f}deg)`
            }
            )),
            n.screenRatio > -1 && (this.domDisclaimer._animating = !0,
            properties.useMobileLayout || this.domDisclaimer._splitted.lines.forEach( (l, c) => {
                let u = math.fit(this.domDisclaimer._time * 1 - c / 20, 0, 1, 100, 0, ease.lusion);
                l.style.transform = `translate3d(0, ${u}%, 0)`
            }
            )),
            o.screenRatio > -1 && (properties.useMobileLayout ? (this.domCta.style.transform = "translate3d(0, 0, 0) rotate(0deg)",
            this.domCta.style.opacity = 1) : (this.domCta._animating = !0,
            this.domCta.style.transform = `translate3d(0, ${math.fit(this.domCta._time, 0, 1, 150, 0, ease.lusion)}%, 0) rotate(${math.fit(this.domCta._time, 0, 1, 10, 0, ease.lusion)}deg)`,
            this.domCta.style.opacity = ease.lusion(this.domCta._time)))
        } else
            this._needsReset = !0;
        this.projectItemList.zoomRatio = math.fit(homePage.activeRatio, 0, .75, 1, 0),
        this.projectItemList.update(e)
    }
    _reset() {
        this.domTitle._splitted && (this._needsReset = !1,
        this.domTitle._time = 0,
        this.domTitle._animating = !1,
        this.domDisclaimer._time = 0,
        this.domDisclaimer._animating = !1,
        this.domCta._time = 0,
        this.domCta._animating = !1,
        properties.useMobileLayout || (this.domDisclaimer._splitted.lines.forEach(e => {
            e.style.transform = "translate3d(0, 100%, 0)"
        }
        ),
        this.domTitle._splitted.chars.forEach(e => {
            e.style.transform = "translate3d(0, 100%, 0)"
        }
        )))
    }
    _splitText() {
        properties.useMobileLayout ? (this.domTitle._splitted && this.domTitle._splitted.revert(),
        this.domDisclaimer._splitted && this.domDisclaimer._splitted.revert()) : (this.domTitle._splitted = new SplitType(this.domTitle,{
            types: "words, chars"
        }),
        this.domDisclaimer._splitted = new SplitType(this.domDisclaimer,{
            types: "lines"
        }),
        this.domDisclaimer._splitted.lines.forEach(e => {
            let t = document.createElement("div");
            t.style.position = "relative",
            t.style.overflow = "hidden",
            t.append(e),
            this.domDisclaimer.append(t)
        }
        ))
    }
}
const homeFeaturedSection = new HomeFeaturedSection
  , channelMixerFrag = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec4 u_channelMixerR;uniform vec4 u_channelMixerG;uniform vec4 u_channelMixerB;uniform vec4 u_channelMixerA;varying vec2 v_uv;void main(){vec4 color=texture2D(u_texture,v_uv);gl_FragColor=vec4(dot(color,u_channelMixerR),dot(color,u_channelMixerG),dot(color,u_channelMixerB),dot(color,u_channelMixerA));}`;
class TextureHelper {
    blackTexture;
    whiteTexture;
    transparentTexture;
    channelMixerMaterial;
    init() {
        this.blackTexture = this._createPixelTexture([0, 0, 0, 255]),
        this.whiteTexture = this._createPixelTexture([255, 255, 255, 255]),
        this.transparentTexture = this._createPixelTexture([0, 0, 0, 0])
    }
    _createPixelTexture(e) {
        return fboHelper.createDataTexture(new Uint8Array(e), 1, 1, !1, !0)
    }
    mixChannels(e, t, r=-1, n=-1, o=-1, l=-1) {
        this.channelMixerMaterial || (this.channelMixerMaterial = new RawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_channelMixerR: {
                    value: new Vector4
                },
                u_channelMixerG: {
                    value: new Vector4
                },
                u_channelMixerB: {
                    value: new Vector4
                },
                u_channelMixerA: {
                    value: new Vector4
                }
            },
            vertexShader: fboHelper.vertexShader,
            fragmentShader: fboHelper.precisionPrefix + channelMixerFrag,
            blending: CustomBlending,
            blendEquation: AddEquation,
            blendDst: OneFactor,
            blendSrc: OneFactor,
            blendEquationAlpha: AddEquation,
            blendDstAlpha: OneFactor,
            blendSrcAlpha: OneFactor
        })),
        this.channelMixerMaterial.uniforms.u_texture.value = e,
        this.channelMixerMaterial.uniforms.u_channelMixerR.value.set(+(r % 4 == 0), +(r % 4 == 1), +(r % 4 == 2), +(r % 4 == 3)).multiplyScalar(r < 0 ? 0 : 1),
        this.channelMixerMaterial.uniforms.u_channelMixerG.value.set(+(n % 4 == 0), +(n % 4 == 1), +(n % 4 == 2), +(n % 4 == 3)).multiplyScalar(n < 0 ? 0 : 1),
        this.channelMixerMaterial.uniforms.u_channelMixerB.value.set(+(o % 4 == 0), +(o % 4 == 1), +(o % 4 == 2), +(o % 4 == 3)).multiplyScalar(o < 0 ? 0 : 1),
        this.channelMixerMaterial.uniforms.u_channelMixerA.value.set(+(l % 4 == 0), +(l % 4 == 1), +(l % 4 == 2), +(l % 4 == 3)).multiplyScalar(l < 0 ? 0 : 1);
        let c = fboHelper.getColorState();
        fboHelper.renderer.autoClear = !1,
        fboHelper.render(this.channelMixerMaterial, t),
        fboHelper.setColorState(c)
    }
}
const textureHelper = new TextureHelper;
class Simple1DNoise {
    static MAX_VERTICES = 512;
    static MAX_VERTICES_MASK = Simple1DNoise.MAX_VERTICES - 1;
    _scale = 1;
    _amplitude = 1;
    _r = [];
    constructor(e) {
        let t = e ? math.getSeedRandomFn(e) : Math.random;
        for (let r = 0; r < Simple1DNoise.MAX_VERTICES; ++r)
            this._r.push(t() - .5)
    }
    getVal(e) {
        const t = e * this._scale
          , r = Math.floor(t)
          , n = t - r
          , o = n * n * (3 - 2 * n)
          , l = r & Simple1DNoise.MAX_VERTICES_MASK
          , c = l + 1 & Simple1DNoise.MAX_VERTICES_MASK;
        return math.mix(this._r[l], this._r[c], o) * this._amplitude
    }
    getFbm(e, t) {
        let r = 0
          , n = .5;
        for (let o = 0; o < t; o++)
            r += n * this.getVal(e),
            e *= 2,
            n *= .5;
        return r
    }
    get amplitude() {
        return this._amplitude
    }
    set amplitude(e) {
        this._amplitude = e
    }
    get scale() {
        return this._scale
    }
    set scale(e) {
        this._scale = e
    }
}
const _v$2 = new Vector3;
class BrownianMotion {
    _position = new Vector3;
    _rotation = new Quaternion;
    _euler = new Euler;
    _scale = new Vector3(1,1,1);
    _matrix = new Matrix4;
    _enablePositionNoise = !0;
    _enableRotationNoise = !0;
    _positionFrequency = .25;
    _rotationFrequency = .25;
    _positionAmplitude = .3;
    _rotationAmplitude = .003;
    _positionScale = new Vector3(1,1,1);
    _rotationScale = new Vector3(1,1,0);
    _positionFractalLevel = 3;
    _rotationFractalLevel = 3;
    _times = new Float32Array(6);
    _noise = new Simple1DNoise;
    static FBM_NORM = 1 / .75;
    constructor() {
        this.rehash()
    }
    rehash() {
        for (let e = 0; e < 6; e++)
            this._times[e] = Math.random() * -1e4
    }
    update(e) {
        const t = e === void 0 ? 16.666666666666668 : e;
        if (this._enablePositionNoise) {
            for (let r = 0; r < 3; r++)
                this._times[r] += this._positionFrequency * t;
            _v$2.set(this._noise.getFbm(this._times[0], this._positionFractalLevel), this._noise.getFbm(this._times[1], this._positionFractalLevel), this._noise.getFbm(this._times[2], this._positionFractalLevel)),
            _v$2.multiply(this._positionScale),
            _v$2.multiplyScalar(this._positionAmplitude * BrownianMotion.FBM_NORM),
            this._position.copy(_v$2)
        }
        if (this._enableRotationNoise) {
            for (let r = 0; r < 3; r++)
                this._times[r + 3] += this._rotationFrequency * t;
            _v$2.set(this._noise.getFbm(this._times[3], this._rotationFractalLevel), this._noise.getFbm(this._times[4], this._rotationFractalLevel), this._noise.getFbm(this._times[5], this._rotationFractalLevel)),
            _v$2.multiply(this._rotationScale),
            _v$2.multiplyScalar(this._rotationAmplitude * BrownianMotion.FBM_NORM),
            this._euler.set(_v$2.x, _v$2.y, _v$2.z),
            this._rotation.setFromEuler(this._euler)
        }
        this._matrix.compose(this._position, this._rotation, this._scale)
    }
    get positionAmplitude() {
        return this._positionAmplitude
    }
    set positionAmplitude(e) {
        this._positionAmplitude = e
    }
    get positionFrequency() {
        return this._positionFrequency
    }
    set positionFrequency(e) {
        this._positionFrequency = e
    }
    get rotationAmplitude() {
        return this._rotationAmplitude
    }
    set rotationAmplitude(e) {
        this._rotationAmplitude = e
    }
    get rotationFrequency() {
        return this._rotationFrequency
    }
    set rotationFrequency(e) {
        this._rotationFrequency = e
    }
    get matrix() {
        return this._matrix
    }
    set matrix(e) {
        this._matrix = e
    }
}
const vert$h = `#define GLSLIFY 1
attribute float ao;attribute float areaRatio;attribute float cluster;attribute float height;attribute vec3 center;attribute vec3 instancePos;attribute vec3 instanceGridIds;attribute vec3 instanceAxis;attribute vec4 tangent;uniform float u_time;uniform float u_showRatio;uniform float u_offsetZ;varying vec3 v_worldPosition;varying vec4 v_worldTangent;varying vec3 v_worldNormal;varying float v_ao;varying float v_opacity;varying float v_emission;varying vec2 v_uv;varying vec4 v_rands;varying float v_depth;
#define PI 3.14159265359
vec3 qrotate(vec4 q,vec3 v){return v+2.*cross(q.xyz,cross(q.xyz,v)+q.w*v);}vec4 quaternion(vec3 axis,float angle){float halfAngle=angle*0.5;return vec4(axis*sin(halfAngle),cos(halfAngle));}float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}vec4 hash44(vec4 p4){p4=fract(p4*vec4(.1031,.1030,.0973,.1099));p4+=dot(p4,p4.wzxy+33.33);return fract((p4.xxyz+p4.yzzw)*p4.zywx);}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}
#include <goalBlackTunnelTransform>
void main(){vec3 pos=position;vec3 nor=normal;vec3 tang=tangent.xyz;
#ifdef IS_HD
float blockId=floor(pos.x+0.5);
#else
float blockId=0.;
#endif
vec4 q;vec3 offsetInstanceGridIds=instanceGridIds;offsetInstanceGridIds.z-=floor(u_offsetZ/float(GRID_SIZE))*2.;vec4 instanceRand1s=hash44(floor(vec4(offsetInstanceGridIds+.5,blockId+cluster)));v_rands=hash44(floor(vec4(offsetInstanceGridIds+.5,100.0)));float showRatio=u_showRatio;showRatio*=1.-step(10.5,instanceGridIds.z)*mod(u_offsetZ/float(GRID_SIZE),1.);
#ifdef IS_HD
pos=mix(center,pos,showRatio);
#else
pos.xy*=showRatio*showRatio;pos.z*=showRatio;
#endif
#ifdef IS_HD
pos.x-=blockId;float blockOffset=sin(u_time*2.+cos(u_time*4.+0.2+offsetInstanceGridIds.z))*0.15*instanceRand1s.y;float heightRatio=1.;pos.y=pos.y*height*heightRatio+(0.025+blockOffset);float variation=floor(instanceRand1s.x*8.);q=quaternion(vec3(0.,0.,variation>3.5 ?-1. : 1.),(mod(blockId,4.)+mod(variation,4.))*PI*0.5);pos=qrotate(q,pos);nor=qrotate(q,nor);tang=qrotate(q,tang);
#endif
q=quaternion(instanceAxis,PI*0.5);pos=qrotate(q,pos)*float(GRID_SIZE)+instancePos;nor=qrotate(q,nor);tang=qrotate(q,tang);pos.z+=mod(u_offsetZ,float(GRID_SIZE));v_depth=-pos.z;pos=goalBlackTunnelTransform(pos);
#ifdef IS_HD
v_ao=ao;v_emission=areaRatio<0.25 ? sin(pos.z*0.25-u_time)*0.5+0.5 : 0.;
#else
v_ao=1.;v_emission=0.;
#endif
v_opacity=linearStep(57.,30.,length(pos.xy))*linearStep(5.+100.,5.+100.-20.,cameraPosition.z-pos.z);v_worldPosition=(modelMatrix*vec4(pos,1.0)).xyz;v_worldTangent=vec4(inverseTransformDirection(normalMatrix*tang,viewMatrix),tangent.w);v_worldNormal=inverseTransformDirection(normalMatrix*nor,viewMatrix);v_uv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.0);}`
  , frag$k = `#define GLSLIFY 1
uniform sampler2D u_feedbackTexture;uniform sampler2D u_greebleArmbTexture;uniform sampler2D u_greebleNormalTexture;uniform vec2 u_resolution;uniform float u_outRatio;uniform vec3 u_outBloomFromToStrength;uniform vec3 u_color1;uniform vec3 u_color2;varying vec3 v_worldPosition;varying vec4 v_worldTangent;varying vec3 v_worldNormal;varying vec4 v_rands;varying float v_ao;varying float v_opacity;varying float v_emission;varying float v_depth;varying vec2 v_uv;float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main(){vec2 screenUv=gl_FragCoord.xy/u_resolution;float faceDirection=gl_FrontFacing ? 1.0 :-1.0;vec3 worldNormal=normalize(v_worldNormal)*faceDirection;vec3 worldTangent=normalize(v_worldTangent.xyz)*faceDirection;vec3 worldBinormal=normalize(cross(worldNormal,worldTangent))*-v_worldTangent.w;worldTangent=normalize(cross(worldBinormal,worldNormal));vec3 tangentSpaceNormal=normalize(texture2D(u_greebleNormalTexture,v_uv).xyz-.5);worldNormal=normalize(tangentSpaceNormal.x*worldTangent+tangentSpaceNormal.y*worldBinormal+tangentSpaceNormal.z*worldNormal);vec4 armb=texture2D(u_greebleArmbTexture,v_uv);float ao=v_ao*armb.r;float roughness=armb.g;float metalness=armb.b;float albedo=armb.a;vec3 lightPos=vec3(0.0,-0.0,-100.0);vec3 toLight=normalize(lightPos-v_worldPosition);float diffuse=(dot(worldNormal,toLight)*0.5+0.5);
#ifdef IS_HD
float feedbackMultiplier=2.5;
#else
float feedbackMultiplier=2.0;
#endif
vec3 color1=u_color1;vec3 color2=u_color2;vec3 baseColor=0.5+mix(color1,color2,v_rands.x)*1.2;vec3 emissiveColor=mix(color1,color2,v_rands.y)*3.5;diffuse*=(0.5+texture2D(u_feedbackTexture,screenUv+worldNormal.xy*0.02).r*feedbackMultiplier);gl_FragColor.rgb=baseColor*vec3(ao*0.75*diffuse)+emissiveColor*v_emission;gl_FragColor.rgb*=v_opacity;float endBloomStrength=linearStep(u_outBloomFromToStrength.x,u_outBloomFromToStrength.y,v_depth)*u_outBloomFromToStrength.z;float bloomScale=linearStep(5.0,20.0,v_depth)*(1.0-linearStep(15.0,25.0,length(v_worldPosition.xy)));gl_FragColor.a=bloomScale*max(0.,dot(gl_FragColor.rgb,vec3(.299,.587,.114))*2.5-1.)+endBloomStrength*0.75;gl_FragColor.rgb+=endBloomStrength*(0.35+gl_FragColor.rgb*0.65);}`
  , goalBlackTunnelTransformShader = `#define GLSLIFY 1
uniform float u_blackTunnelTransformRatio;vec3 goalBlackTunnelTransform(vec3 pos){float t=u_blackTunnelTransformRatio*6.2831853;float zWeight=pos.z*0.025;float angle=t*zWeight*zWeight*sign(zWeight);float sa=sin(angle);float ca=cos(angle);mat2 m2=mat2(ca,-sa,sa,ca);pos.xy=m2*pos.xy;pos.z+=t*1.;pos=pos.xzy;float rad=20.;pos/=rad;vec3 a=pos;vec2 pq=vec2(-1.,.5)*t;float ada=dot(a,a);vec4 b=vec4(2.*a,ada-1.)/(1.+ada);vec4 pq_cs=vec4(cos(pq),sin(pq)).xzyw;vec2 np1=vec2(-1.,1.);vec4 c=(b.xxyy*np1.yxyy*pq_cs+b.zzww*np1.yyxy*pq_cs.yxwz).xzyw;pos=c.xyz/(1.-c.w);pos=pos.xzy;return pos*rad;}`;
class PostEffect {
    sharedUniforms = {};
    enabled = !0;
    material = null;
    renderOrder = 0;
    _hasShownWarning = !1;
    init(e) {
        Object.assign(this, e)
    }
    needsRender() {
        return !0
    }
    warn(e) {
        this._hasShownWarning || (console.warn(e),
        this._hasShownWarning = !0)
    }
    setPostprocessing(e) {}
    render(e, t=!1) {
        this.material.uniforms.u_texture && (this.material.uniforms.u_texture.value = e.fromTexture),
        fboHelper.render(this.material, t ? null : e.toRenderTarget),
        e.swap()
    }
}
const fragmentShader$4 = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform sampler2D u_depthTexture;uniform mat4 u_projectionViewInverseMatrix;uniform mat4 u_prevProjectionViewMatrix;uniform vec2 u_aspect;uniform float u_amount;varying vec2 v_uv;
#include <getBlueNoise>
void main(){vec3 bnoise=getBlueNoise(gl_FragCoord.xy);float depth=texture2D(u_depthTexture,v_uv+bnoise.yz*0.01*u_aspect).r;vec4 ndc=vec4(v_uv.xy*2.0-1.0,depth,1.0);vec4 worldPos=u_projectionViewInverseMatrix*ndc;vec4 prevPos=u_prevProjectionViewMatrix*worldPos;prevPos/=prevPos.w;prevPos.xy=prevPos.xy*0.5+0.5;vec2 velocity=(prevPos.xy-v_uv)/16.0*u_amount;vec2 uv=v_uv+bnoise.xy*velocity;vec4 color=vec4(0.0);float weightSum=0.0;float weight=1.0;float weightFalloff=1.0;for(int i=0;i<16;i++){color+=texture2D(u_texture,uv)*weight;uv+=velocity;weightSum+=weight;weight*=weightFalloff;}gl_FragColor=color/weightSum;}`;
class GoalTunnelEfx extends PostEffect {
    needsSync = !0;
    amount = 1;
    _position = null;
    _quaternion = null;
    _scale = null;
    _q = null;
    projectionMatrix = null;
    prevProjectionMatrix = null;
    projectionViewMatrix = null;
    prevProjectionViewMatrix = null;
    projectionViewInverseMatrix = null;
    offsetPostion = null;
    offsetRotation = null;
    offsetScale = null;
    isActive = !1;
    init(e) {
        Object.assign(this, e),
        super.init(),
        this._position = new Vector3,
        this._quaternion = new Quaternion,
        this._scale = new Vector3(1,1,1),
        this._q = new Quaternion,
        this.offsetPostion = new Vector3(0,0,0),
        this.offsetRotation = new Euler(0,0,0),
        this.offsetScale = new Vector3(1,1,1),
        this.projectionViewMatrix = new Matrix4,
        this.prevProjectionViewMatrix = new Matrix4,
        this.projectionViewInverseMatrix = new Matrix4,
        this.finalPrevMatrix = new Matrix4,
        this.extraTransformMatrix = new Matrix4,
        this.material = fboHelper.createRawShaderMaterial({
            uniforms: Object.assign({
                u_time: properties.sharedUniforms.u_time,
                u_texture: {
                    value: null
                },
                u_depthTexture: {
                    value: null
                },
                u_amount: {
                    value: 1
                },
                u_aspect: properties.postprocessing.sharedUniforms.u_aspect,
                u_projectionViewInverseMatrix: {
                    value: this.projectionViewInverseMatrix
                },
                u_prevProjectionViewMatrix: {
                    value: this.finalPrevMatrix
                }
            }, blueNoise.sharedUniforms),
            fragmentShader: fragmentShader$4
        })
    }
    needsRender(e) {
        let t = this.amount > 0;
        return this.needsSync = !t,
        t && this.isActive
    }
    syncCamera(e) {
        this.needsSync = !0,
        e && (e.matrixWorldInverse.decompose(this._position, this._quaternion, this._scale),
        this.projectionViewMatrix.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
        this.projectionViewInverseMatrix.copy(this.projectionViewMatrix).invert()),
        this.prevProjectionViewMatrix.copy(this.projectionViewMatrix)
    }
    render(e, t=!1) {
        let r = e.camera;
        this.material.uniforms.u_depthTexture = e.sharedUniforms.u_sceneDepthTexture,
        this.material.uniforms.u_amount.value = this.amount,
        this.needsSync || e.hasSizeChanged ? (this.syncCamera(r),
        this.needsSync = !1) : this.prevProjectionViewMatrix.copy(this.projectionViewMatrix),
        this.projectionViewMatrix.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        this.projectionViewInverseMatrix.copy(this.projectionViewMatrix).invert(),
        this.extraTransformMatrix.compose(this.offsetPostion, this._q.setFromEuler(this.offsetRotation), this.offsetScale).invert(),
        this.finalPrevMatrix.copy(this.prevProjectionViewMatrix),
        this.finalPrevMatrix.multiply(this.extraTransformMatrix),
        super.render(e, t)
    }
}
const goalTunnelEfx = new GoalTunnelEfx
  , _c1$3 = new Color
  , _c2$2 = new Color
  , COLOR_1 = ["#0d2b27", "#ba0000", "#00b5a6", "#0099ff"]
  , COLOR_2 = ["#8c8c8c", "#008e6b", "#7e7f05", "#ff0000"];
class GoalBlackTunnel {
    container = new Object3D;
    GRID_SIZE = 20;
    textures = {};
    feedbackRenderTarget = null;
    _structureGeometries = {};
    _baseGeometries = {};
    sharedUniforms = {
        u_blackTunnelTransformRatio: {
            value: 0
        },
        u_showRatio: {
            value: 1
        },
        u_outBloomFromToStrength: {
            value: new Vector3(0,70,0)
        },
        u_offsetZ: {
            value: 0
        },
        u_feedbackTexture: {
            value: null
        },
        u_greebleArmbTexture: {
            value: null
        },
        u_greebleNormalTexture: {
            value: null
        },
        u_color1: {
            value: new Color
        },
        u_color2: {
            value: new Color
        }
    };
    textureTypeList = ["arm", "base", "nor"];
    timeBasedPulseTime = 0;
    timeBasedLinearTime = 0;
    preInit() {
        let e = ["ld", "hd"];
        shaderHelper.addChunk("goalBlackTunnelTransform", goalBlackTunnelTransformShader),
        this.feedbackRenderTarget = fboHelper.createRenderTarget(1, 1),
        this.feedbackRenderTarget.texture.wrapS = this.feedbackRenderTarget.texture.wrapT = MirroredRepeatWrapping,
        this.sharedUniforms.u_feedbackTexture.value = this.feedbackRenderTarget.texture;
        for (let t = 0; t < e.length; t++) {
            let r = e[t];
            properties.loader.add(settings.MODEL_PATH + "tunnels/grid_structure_" + r + ".buf", {
                onLoad: this._onGeometryLoad.bind(this, r, "structure")
            }),
            properties.loader.add(settings.MODEL_PATH + "tunnels/grid_base_" + r + ".buf", {
                onLoad: this._onGeometryLoad.bind(this, r, "base")
            })
        }
        for (let t = 0; t < this.textureTypeList.length; t++) {
            let r = this.textureTypeList[t];
            properties.loader.add(settings.TEXTURE_PATH + "tunnels/grids/greeble_" + r + ".webp", {
                type: "texture",
                onLoad: this._onGreebleTextureLoad.bind(this, r)
            })
        }
    }
    _onGeometryLoad(e, t, r) {
        t == "structure" ? this._structureGeometries[e] = r : this._baseGeometries[e] = r;
        let n = this._baseGeometries[e]
          , o = this._structureGeometries[e];
        if (n && o) {
            let l = new InstancedBufferGeometry;
            for (let f in n.attributes)
                l.attributes[f] = n.attributes[f];
            l.index = n.index,
            l.setAttribute("instancePos", new InstancedBufferAttribute(o.attributes.position.array,3)),
            l.setAttribute("instanceGridIds", new InstancedBufferAttribute(o.attributes.gridIds.array,3)),
            l.setAttribute("instanceAxis", new InstancedBufferAttribute(o.attributes.rotAxis.array,3));
            let c = Object.assign({
                u_time: goalTunnels.sharedUniforms.u_tunnelTime,
                u_resolution: properties.sharedUniforms.u_resolution
            }, this.sharedUniforms)
              , u = new Mesh(l,new ShaderMaterial({
                uniforms: c,
                vertexShader: vert$h,
                fragmentShader: frag$k,
                side: DoubleSide
            }));
            u.material.defines.GRID_SIZE = this.GRID_SIZE,
            u.material.defines.IS_HD = e == "hd",
            u.frustumCulled = !1,
            e == "hd" ? (u.onAfterRender = this._onAfterRender.bind(this),
            u.renderOrder = 2) : u.renderOrder = 1,
            this.container.add(u)
        }
    }
    _onAfterRender() {
        let e = fboHelper.getColorState()
          , t = fboHelper.renderer.getRenderTarget();
        fboHelper.clearMultisampleRenderTargetState(t),
        fboHelper.copy(t.texture, this.feedbackRenderTarget),
        fboHelper.renderer.setRenderTarget(t),
        fboHelper.setColorState(e)
    }
    _onGreebleTextureLoad(e, t) {
        if (this.textures[e] = t,
        t.wrapS = t.wrapT = RepeatWrapping,
        e == "arm" || e == "base") {
            let r = this.textures.arm
              , n = this.textures.base;
            if (r && n) {
                let o = fboHelper.createRenderTarget(r.image.width, r.image.height, !1, !1);
                o.texture.wrapS = o.texture.wrapT = RepeatWrapping,
                this.textures.arm = this.textures.base = null,
                fboHelper.copy(textureHelper.transparentTexture, o),
                textureHelper.mixChannels(r, o, 0, 1, 2, -1),
                textureHelper.mixChannels(n, o, -1, -1, -1, 0),
                r.dispose(),
                n.dispose(),
                this.sharedUniforms.u_greebleArmbTexture.value = o.texture
            }
        } else
            this.sharedUniforms.u_greebleNormalTexture.value = t
    }
    init() {}
    resize(e, t) {}
    update(e) {
        let t = 0
          , r = Math.floor(properties.width * .25)
          , n = Math.floor(properties.height * .25);
        (this.feedbackRenderTarget.width != r || this.feedbackRenderTarget.height != n) && (this.feedbackRenderTarget.setSize(r, n),
        fboHelper.clearColor(0, 0, 0, 1, this.feedbackRenderTarget));
        let o = -80 * math.cUnMix(.2, 0, goalTunnels.blackTunnelRatio);
        t += o - this.container.position.z,
        this.container.position.z = o,
        this.sharedUniforms.u_showRatio.value = goalTunnels.isBlackTunnelActive ? ease.expoIn(math.cUnMix(0, .1, goalTunnels.blackTunnelRatio)) : 0;
        let l = this.sharedUniforms.u_outBloomFromToStrength.value;
        l.z = math.fit(goalTunnels.blackTunnelRatio, .65, .75, 0, .2),
        l.z = math.fit(goalTunnels.blackTunnelRatio, .75, .85, l.z, .15),
        l.z = math.fit(goalTunnels.blackTunnelRatio, .85, 1, l.z, .15),
        l.x = math.fit(goalTunnels.blackTunnelRatio, .75, .85, 20, 60),
        l.x = math.fit(goalTunnels.blackTunnelRatio, .9, 1, l.x, 30);
        let c = math.fit(goalTunnels.blackTunnelRatio, .6, 1, 0, 1, ease.sineIn);
        this.sharedUniforms.u_blackTunnelTransformRatio.value = c;
        const u = (input.lastScrollYDirection < 0 ? -1 : 1) * goalTunnels.tunnelDeltaTime;
        this.timeBasedPulseTime += u * math.cUnMix(.1, .3, goalTunnels.blackTunnelRatio) * math.fit(c, 0, .25, 1, .5),
        this.timeBasedLinearTime += u * math.fit(c, 0, .25, 1.5, 1);
        let f = this.timeBasedPulseTime
          , p = Math.floor(f)
          , g = f - p
          , _ = (p + ease.cubicInOut(g)) * this.GRID_SIZE + this.timeBasedLinearTime * this.GRID_SIZE + goalTunnels.blackTunnelRatio * this.GRID_SIZE * 10;
        t += _ - this.sharedUniforms.u_offsetZ.value,
        this.sharedUniforms.u_offsetZ.value = _,
        goalTunnels.properties.cameraDollyZoomFovOffset = Math.sin(goalTunnels.blackTunnelRatio * 10 + properties.time * 1) * 7.5 * math.smoothstep(0, .2, goalTunnels.blackTunnelRatio);
        let w = COLOR_1.length * math.fit(goalTunnels.blackTunnelRatio, .2, 1, 0, 1)
          , S = Math.floor(w)
          , b = Math.min(Math.ceil(w), COLOR_1.length - 1)
          , C = w - S;
        _c1$3.set(COLOR_1[S]),
        _c2$2.set(COLOR_1[b]),
        _c1$3.lerp(_c2$2, C > .5 ? 1 : 0),
        this.sharedUniforms.u_color1.value.copy(_c1$3),
        _c1$3.set(COLOR_2[S]),
        _c2$2.set(COLOR_2[b]),
        _c1$3.lerp(_c2$2, C > .5 ? 1 : 0),
        this.sharedUniforms.u_color2.value.copy(_c1$3),
        goalTunnelEfx.offsetPostion.z = t * math.fit(goalTunnels.blackTunnelRatio, 0, .2, 0, 1),
        goalTunnelEfx.offsetRotation.z = t * c * .01,
        goalTunnelEfx.amount = 1
    }
}
const goalBlackTunnel = new GoalBlackTunnel
  , _changeEvent = {
    type: "change"
}
  , _startEvent = {
    type: "start"
}
  , _endEvent = {
    type: "end"
};
class OrbitControls extends EventDispatcher {
    constructor(e, t) {
        super(),
        t === void 0 && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),
        t === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),
        this.object = e,
        this.domElement = t,
        this.domElement.style.touchAction = "none",
        this.enabled = !0,
        this.target = new Vector3,
        this.minDistance = 0,
        this.maxDistance = 1 / 0,
        this.minZoom = 0,
        this.maxZoom = 1 / 0,
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.minAzimuthAngle = -1 / 0,
        this.maxAzimuthAngle = 1 / 0,
        this.enableDamping = !1,
        this.dampingFactor = .15,
        this.enableZoom = !1,
        this.zoomSpeed = 1,
        this.enableRotate = !0,
        this.rotateSpeed = 1,
        this.enablePan = !0,
        this.panSpeed = 1,
        this.screenSpacePanning = !0,
        this.keyPanSpeed = 7,
        this.autoRotate = !1,
        this.autoRotateSpeed = 2,
        this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        },
        this.mouseButtons = {
            LEFT: MOUSE.ROTATE,
            MIDDLE: MOUSE.DOLLY,
            RIGHT: MOUSE.PAN
        },
        this.touches = {
            ONE: TOUCH.ROTATE,
            TWO: TOUCH.DOLLY_PAN
        },
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object.zoom,
        this.scale = 1,
        this._domElementKeyEvents = null,
        this.getPolarAngle = function() {
            return c.phi
        }
        ,
        this.getAzimuthalAngle = function() {
            return c.theta
        }
        ,
        this.getDistance = function() {
            return this.object.position.distanceTo(this.target)
        }
        ,
        this.listenToKeyEvents = function(te) {
            te.addEventListener("keydown", He),
            this._domElementKeyEvents = te
        }
        ,
        this.saveState = function() {
            r.target0.copy(r.target),
            r.position0.copy(r.object.position),
            r.zoom0 = r.object.zoom
        }
        ,
        this.reset = function() {
            r.target.copy(r.target0),
            r.object.position.copy(r.position0),
            r.object.zoom = r.zoom0,
            r.scale = 1,
            r.object.updateProjectionMatrix(),
            r.dispatchEvent(_changeEvent),
            r.update(),
            o = n.NONE
        }
        ,
        this.update = function() {
            const te = new Vector3
              , be = new Quaternion().setFromUnitVectors(e.up, new Vector3(0,1,0))
              , xe = be.clone().invert()
              , ke = new Vector3
              , qe = new Quaternion
              , Ve = 2 * Math.PI;
            return function() {
                const Xe = r.object.position;
                te.copy(Xe).sub(r.target),
                te.applyQuaternion(be),
                c.setFromVector3(te),
                r.autoRotate && o === n.NONE && A(I()),
                r.enableDamping ? (c.theta += u.theta * r.dampingFactor,
                c.phi += u.phi * r.dampingFactor) : (c.theta += u.theta,
                c.phi += u.phi);
                let Qe = r.minAzimuthAngle
                  , tt = r.maxAzimuthAngle;
                isFinite(Qe) && isFinite(tt) && (Qe < -Math.PI ? Qe += Ve : Qe > Math.PI && (Qe -= Ve),
                tt < -Math.PI ? tt += Ve : tt > Math.PI && (tt -= Ve),
                Qe <= tt ? c.theta = Math.max(Qe, Math.min(tt, c.theta)) : c.theta = c.theta > (Qe + tt) / 2 ? Math.max(Qe, c.theta) : Math.min(tt, c.theta)),
                c.phi = Math.max(r.minPolarAngle, Math.min(r.maxPolarAngle, c.phi)),
                c.makeSafe();
                let nt = r.enableDamping ? (r.scale - 1) * r.dampingFactor + 1 : r.scale;
                return c.radius *= nt,
                c.radius = Math.max(r.minDistance, Math.min(r.maxDistance, c.radius)),
                r.enableDamping === !0 ? r.target.addScaledVector(f, r.dampingFactor) : r.target.add(f),
                te.setFromSpherical(c),
                te.applyQuaternion(xe),
                Xe.copy(r.target).add(te),
                r.object.lookAt(r.target),
                r.enableDamping === !0 ? (u.theta *= 1 - r.dampingFactor,
                u.phi *= 1 - r.dampingFactor,
                f.multiplyScalar(1 - r.dampingFactor)) : (u.set(0, 0, 0),
                f.set(0, 0, 0)),
                r.scale = r.scale / nt,
                p || ke.distanceToSquared(r.object.position) > l || 8 * (1 - qe.dot(r.object.quaternion)) > l ? (r.dispatchEvent(_changeEvent),
                ke.copy(r.object.position),
                qe.copy(r.object.quaternion),
                p = !1,
                !0) : !1
            }
        }(),
        this.dispose = function() {
            r.domElement.removeEventListener("contextmenu", z),
            r.domElement.removeEventListener("pointerdown", Te),
            r.domElement.removeEventListener("pointercancel", Ne),
            r.domElement.removeEventListener("wheel", Z),
            r.domElement.removeEventListener("pointermove", we),
            r.domElement.removeEventListener("pointerup", Ae),
            r._domElementKeyEvents !== null && r._domElementKeyEvents.removeEventListener("keydown", He)
        }
        ;
        const r = this
          , n = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        };
        let o = n.NONE;
        const l = 1e-6
          , c = new Spherical
          , u = new Spherical
          , f = new Vector3;
        let p = !1;
        const g = new Vector2
          , v = new Vector2
          , _ = new Vector2
          , w = new Vector2
          , S = new Vector2
          , b = new Vector2
          , C = new Vector2
          , R = new Vector2
          , T = new Vector2
          , M = []
          , P = {};
        function I() {
            return 2 * Math.PI / 60 / 60 * r.autoRotateSpeed
        }
        function k() {
            return Math.pow(.95, r.zoomSpeed)
        }
        function A(te) {
            u.theta -= te
        }
        function O(te) {
            u.phi -= te
        }
        const W = function() {
            const te = new Vector3;
            return function(xe, ke) {
                te.setFromMatrixColumn(ke, 0),
                te.multiplyScalar(-xe),
                f.add(te)
            }
        }()
          , Q = function() {
            const te = new Vector3;
            return function(xe, ke) {
                r.screenSpacePanning === !0 ? te.setFromMatrixColumn(ke, 1) : (te.setFromMatrixColumn(ke, 0),
                te.crossVectors(r.object.up, te)),
                te.multiplyScalar(xe),
                f.add(te)
            }
        }()
          , H = function() {
            const te = new Vector3;
            return function(xe, ke) {
                const qe = r.domElement;
                if (r.object.isPerspectiveCamera) {
                    const Ve = r.object.position;
                    te.copy(Ve).sub(r.target);
                    let Ge = te.length();
                    Ge *= Math.tan(r.object.fov / 2 * Math.PI / 180),
                    W(2 * xe * Ge / qe.clientHeight, r.object.matrix),
                    Q(2 * ke * Ge / qe.clientHeight, r.object.matrix)
                } else
                    r.object.isOrthographicCamera ? (W(xe * (r.object.right - r.object.left) / r.object.zoom / qe.clientWidth, r.object.matrix),
                    Q(ke * (r.object.top - r.object.bottom) / r.object.zoom / qe.clientHeight, r.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                    r.enablePan = !1)
            }
        }();
        function B(te) {
            r.object.isPerspectiveCamera ? r.scale /= te : r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom * te)),
            r.object.updateProjectionMatrix(),
            p = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            r.enableZoom = !1)
        }
        function D(te) {
            r.object.isPerspectiveCamera ? r.scale *= te : r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / te)),
            r.object.updateProjectionMatrix(),
            p = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            r.enableZoom = !1)
        }
        function q(te) {
            g.set(te.clientX, te.clientY)
        }
        function V(te) {
            C.set(te.clientX, te.clientY)
        }
        function J(te) {
            w.set(te.clientX, te.clientY)
        }
        function U(te) {
            v.set(te.clientX, te.clientY),
            _.subVectors(v, g).multiplyScalar(r.rotateSpeed);
            const be = r.domElement;
            A(2 * Math.PI * _.x / be.clientHeight),
            O(2 * Math.PI * _.y / be.clientHeight),
            g.copy(v),
            r.update()
        }
        function ce(te) {
            R.set(te.clientX, te.clientY),
            T.subVectors(R, C),
            T.y > 0 ? B(k()) : T.y < 0 && D(k()),
            C.copy(R),
            r.update()
        }
        function ee(te) {
            S.set(te.clientX, te.clientY),
            b.subVectors(S, w).multiplyScalar(r.panSpeed),
            H(b.x, b.y),
            w.copy(S),
            r.update()
        }
        function ne(te) {
            te.deltaY < 0 ? D(k()) : te.deltaY > 0 && B(k()),
            r.update()
        }
        function ae(te) {
            let be = !1;
            switch (te.code) {
            case r.keys.UP:
                H(0, r.keyPanSpeed),
                be = !0;
                break;
            case r.keys.BOTTOM:
                H(0, -r.keyPanSpeed),
                be = !0;
                break;
            case r.keys.LEFT:
                H(r.keyPanSpeed, 0),
                be = !0;
                break;
            case r.keys.RIGHT:
                H(-r.keyPanSpeed, 0),
                be = !0;
                break
            }
            be && (te.preventDefault(),
            r.update())
        }
        function ve() {
            if (M.length === 1)
                g.set(M[0].pageX, M[0].pageY);
            else {
                const te = .5 * (M[0].pageX + M[1].pageX)
                  , be = .5 * (M[0].pageY + M[1].pageY);
                g.set(te, be)
            }
        }
        function Y() {
            if (M.length === 1)
                w.set(M[0].pageX, M[0].pageY);
            else {
                const te = .5 * (M[0].pageX + M[1].pageX)
                  , be = .5 * (M[0].pageY + M[1].pageY);
                w.set(te, be)
            }
        }
        function $() {
            const te = M[0].pageX - M[1].pageX
              , be = M[0].pageY - M[1].pageY
              , xe = Math.sqrt(te * te + be * be);
            C.set(0, xe)
        }
        function L() {
            r.enableZoom && $(),
            r.enablePan && Y()
        }
        function N() {
            r.enableZoom && $(),
            r.enableRotate && ve()
        }
        function oe(te) {
            if (M.length == 1)
                v.set(te.pageX, te.pageY);
            else {
                const xe = ze(te)
                  , ke = .5 * (te.pageX + xe.x)
                  , qe = .5 * (te.pageY + xe.y);
                v.set(ke, qe)
            }
            _.subVectors(v, g).multiplyScalar(r.rotateSpeed);
            const be = r.domElement;
            A(2 * Math.PI * _.x / be.clientHeight),
            O(2 * Math.PI * _.y / be.clientHeight),
            g.copy(v)
        }
        function pe(te) {
            if (M.length === 1)
                S.set(te.pageX, te.pageY);
            else {
                const be = ze(te)
                  , xe = .5 * (te.pageX + be.x)
                  , ke = .5 * (te.pageY + be.y);
                S.set(xe, ke)
            }
            b.subVectors(S, w).multiplyScalar(r.panSpeed),
            H(b.x, b.y),
            w.copy(S)
        }
        function K(te) {
            const be = ze(te)
              , xe = te.pageX - be.x
              , ke = te.pageY - be.y
              , qe = Math.sqrt(xe * xe + ke * ke);
            R.set(0, qe),
            T.set(0, Math.pow(R.y / C.y, r.zoomSpeed)),
            B(T.y),
            C.copy(R)
        }
        function Se(te) {
            r.enableZoom && K(te),
            r.enablePan && pe(te)
        }
        function Ce(te) {
            r.enableZoom && K(te),
            r.enableRotate && oe(te)
        }
        function Te(te) {
            r.enabled !== !1 && (M.length === 0 && (r.domElement.setPointerCapture(te.pointerId),
            r.domElement.addEventListener("pointermove", we),
            r.domElement.addEventListener("pointerup", Ae)),
            ge(te),
            te.pointerType === "touch" ? Ke(te) : Ue(te))
        }
        function we(te) {
            r.enabled !== !1 && (te.pointerType === "touch" ? j(te) : le(te))
        }
        function Ae(te) {
            Ee(te),
            M.length === 0 && (r.domElement.releasePointerCapture(te.pointerId),
            r.domElement.removeEventListener("pointermove", we),
            r.domElement.removeEventListener("pointerup", Ae)),
            r.dispatchEvent(_endEvent),
            o = n.NONE
        }
        function Ne(te) {
            Ee(te)
        }
        function Ue(te) {
            let be;
            switch (te.button) {
            case 0:
                be = r.mouseButtons.LEFT;
                break;
            case 1:
                be = r.mouseButtons.MIDDLE;
                break;
            case 2:
                be = r.mouseButtons.RIGHT;
                break;
            default:
                be = -1
            }
            switch (be) {
            case MOUSE.DOLLY:
                if (r.enableZoom === !1)
                    return;
                V(te),
                o = n.DOLLY;
                break;
            case MOUSE.ROTATE:
                if (te.ctrlKey || te.metaKey || te.shiftKey) {
                    if (r.enablePan === !1)
                        return;
                    J(te),
                    o = n.PAN
                } else {
                    if (r.enableRotate === !1)
                        return;
                    q(te),
                    o = n.ROTATE
                }
                break;
            case MOUSE.PAN:
                if (te.ctrlKey || te.metaKey || te.shiftKey) {
                    if (r.enableRotate === !1)
                        return;
                    q(te),
                    o = n.ROTATE
                } else {
                    if (r.enablePan === !1)
                        return;
                    J(te),
                    o = n.PAN
                }
                break;
            default:
                o = n.NONE
            }
            o !== n.NONE && r.dispatchEvent(_startEvent)
        }
        function le(te) {
            if (r.enabled !== !1)
                switch (o) {
                case n.ROTATE:
                    if (r.enableRotate === !1)
                        return;
                    U(te);
                    break;
                case n.DOLLY:
                    if (r.enableZoom === !1)
                        return;
                    ce(te);
                    break;
                case n.PAN:
                    if (r.enablePan === !1)
                        return;
                    ee(te);
                    break
                }
        }
        function Z(te) {
            r.enabled === !1 || r.enableZoom === !1 || o !== n.NONE || (r.dispatchEvent(_startEvent),
            ne(te),
            r.dispatchEvent(_endEvent))
        }
        function He(te) {
            r.enabled === !1 || r.enablePan === !1 || ae(te)
        }
        function Ke(te) {
            switch (Oe(te),
            M.length) {
            case 1:
                switch (r.touches.ONE) {
                case TOUCH.ROTATE:
                    if (r.enableRotate === !1)
                        return;
                    ve(),
                    o = n.TOUCH_ROTATE;
                    break;
                case TOUCH.PAN:
                    if (r.enablePan === !1)
                        return;
                    Y(),
                    o = n.TOUCH_PAN;
                    break;
                default:
                    o = n.NONE
                }
                break;
            case 2:
                switch (r.touches.TWO) {
                case TOUCH.DOLLY_PAN:
                    if (r.enableZoom === !1 && r.enablePan === !1)
                        return;
                    L(),
                    o = n.TOUCH_DOLLY_PAN;
                    break;
                case TOUCH.DOLLY_ROTATE:
                    if (r.enableZoom === !1 && r.enableRotate === !1)
                        return;
                    N(),
                    o = n.TOUCH_DOLLY_ROTATE;
                    break;
                default:
                    o = n.NONE
                }
                break;
            default:
                o = n.NONE
            }
            o !== n.NONE && r.dispatchEvent(_startEvent)
        }
        function j(te) {
            switch (Oe(te),
            o) {
            case n.TOUCH_ROTATE:
                if (r.enableRotate === !1)
                    return;
                oe(te),
                r.update();
                break;
            case n.TOUCH_PAN:
                if (r.enablePan === !1)
                    return;
                pe(te),
                r.update();
                break;
            case n.TOUCH_DOLLY_PAN:
                if (r.enableZoom === !1 && r.enablePan === !1)
                    return;
                Se(te),
                r.update();
                break;
            case n.TOUCH_DOLLY_ROTATE:
                if (r.enableZoom === !1 && r.enableRotate === !1)
                    return;
                Ce(te),
                r.update();
                break;
            default:
                o = n.NONE
            }
        }
        function z(te) {
            r.enabled
        }
        function ge(te) {
            M.push(te)
        }
        function Ee(te) {
            delete P[te.pointerId];
            for (let be = 0; be < M.length; be++)
                if (M[be].pointerId == te.pointerId) {
                    M.splice(be, 1);
                    return
                }
        }
        function Oe(te) {
            let be = P[te.pointerId];
            be === void 0 && (be = new Vector2,
            P[te.pointerId] = be),
            be.set(te.pageX, te.pageY)
        }
        function ze(te) {
            const be = te.pointerId === M[0].pointerId ? M[1] : M[0];
            return P[be.pointerId]
        }
        r.domElement.addEventListener("contextmenu", z),
        r.domElement.addEventListener("pointerdown", Te),
        r.domElement.addEventListener("pointercancel", Ne),
        r.domElement.addEventListener("wheel", Z, {
            passive: !1
        }),
        this.update()
    }
}
class DeviceOrientationControls {
    object = null;
    enabled = !0;
    hasValue = !1;
    deviceOrientation = {};
    screenOrientation = 0;
    alphaOffset = 0;
    zee = new Vector3(0,0,1);
    euler = new Euler;
    q0 = new Quaternion;
    q1 = new Quaternion(-Math.sqrt(.5),0,0,Math.sqrt(.5));
    _onBoundDeviceOrientationChangeEvent;
    _onBoundScreenOrientationChangeEvent;
    constructor(e) {
        this.object = e,
        this.object.rotation.reorder("YXZ"),
        this._onBoundDeviceOrientationChangeEvent = this._onDeviceOrientationChangeEvent.bind(this),
        this._onBoundScreenOrientationChangeEvent = this._onScreenOrientationChangeEvent.bind(this),
        this.connect()
    }
    _onDeviceOrientationChangeEvent(e) {
        this.deviceOrientation = e
    }
    _onScreenOrientationChangeEvent() {
        this.screenOrientation = window.orientation || 0
    }
    setObjectQuaternion(e, t, r, n, o) {
        this.euler.set(r, t, -n, "YXZ"),
        e.setFromEuler(this.euler),
        e.multiply(this.q1),
        e.multiply(this.q0.setFromAxisAngle(this.zee, -o))
    }
    connect() {
        this._onBoundScreenOrientationChangeEvent(),
        window.DeviceOrientationEvent !== void 0 && typeof window.DeviceOrientationEvent.requestPermission == "function" ? window.DeviceOrientationEvent.requestPermission().then(e => {
            e == "granted" && (window.addEventListener("orientationchange", this._onBoundScreenOrientationChangeEvent, !1),
            window.addEventListener("deviceorientation", this._onBoundDeviceOrientationChangeEvent, !1))
        }
        ).catch(function(e) {}) : (window.addEventListener("orientationchange", this._onBoundScreenOrientationChangeEvent, !1),
        window.addEventListener("deviceorientation", this._onBoundDeviceOrientationChangeEvent, !1)),
        this.enabled = !0
    }
    disconnect() {
        window.removeEventListener("orientationchange", this._onBoundScreenOrientationChangeEvent, !1),
        window.removeEventListener("deviceorientation", this._onBoundDeviceOrientationChangeEvent, !1),
        this.enabled = !1
    }
    update() {
        if (this.enabled === !1)
            return;
        let e = this.deviceOrientation;
        if (e) {
            let t = e.alpha ? MathUtils$1.degToRad(e.alpha) + this.alphaOffset : 0
              , r = e.beta ? MathUtils$1.degToRad(e.beta) : 0
              , n = e.gamma ? MathUtils$1.degToRad(e.gamma) : 0
              , o = this.screenOrientation ? MathUtils$1.degToRad(this.screenOrientation) : 0;
            this.setObjectQuaternion(this.object.quaternion, t, r, n, o),
            this.hasValue = this.hasValue || e.alpha && e.beta && e.gamma
        }
    }
    dispose() {
        this.disconnect()
    }
}
class CameraControls {
    useOrbitControls = !1;
    preInit(e) {
        if (this.DEFAULT_CAMERA_POSITION = new Vector3(0,0,5),
        this.DEFAULT_LOOKAT_POSITION = new Vector3(0,0,0),
        this._brownianMotion = null,
        this._orbitControls = null,
        this._orbitCamera = null,
        this._deviceOrientationControls = null,
        this._baseDeviceControlQuaternion = null,
        this._targetDeviceControlQuaternion = null,
        this._deviceOrientationCamera = null,
        this._hasDeviceOrientationControlValues = !1,
        this._q = new Quaternion,
        this._e = new Euler,
        this._v1 = new Vector3,
        this._v2 = new Vector3,
        this._camera = properties.camera,
        this._deviceOrientationEuler = new Euler,
        this._camera.position.copy(this.DEFAULT_CAMERA_POSITION),
        this._brownianMotion = new BrownianMotion,
        this.useOrbitControls === !0 && (this._orbitCamera = this._camera.clone(),
        this._orbitControls = new OrbitControls(this._orbitCamera,document.documentElement),
        this._orbitControls.enableDamping = !0,
        this._orbitControls.target0.copy(this.DEFAULT_LOOKAT_POSITION),
        this._orbitControls.reset()),
        browser$1.isMobile) {
            this._deviceOrientationCamera = new Camera,
            this._baseDeviceControlQuaternion = new Quaternion,
            this._targetDeviceControlQuaternion = new Quaternion;
            let t = () => {
                this._deviceOrientationControls = new DeviceOrientationControls(this._deviceOrientationCamera),
                this._deviceOrientationControls.connect()
            }
            ;
            browser$1.isIOS ? properties.onFirstClicked.addOnce(t) : t()
        }
    }
    init() {}
    resize(e, t) {}
    update(e) {
        let t = this._camera;
        this.DEFAULT_CAMERA_POSITION.copy(properties.defaultCameraPosition),
        this.DEFAULT_LOOKAT_POSITION.copy(properties.defaultLookAtPosition),
        t.near = properties.cameraNear,
        t.far = properties.cameraFar,
        t.matrix.identity(),
        t.matrix.decompose(t.position, t.quaternion, t.scale),
        t.position.copy(this.DEFAULT_CAMERA_POSITION),
        t.lookAt(this.DEFAULT_LOOKAT_POSITION),
        browser$1.isMobile && this._deviceOrientationControls && this._deviceOrientationControls.update(),
        this.useOrbitControls === !0 && (this._orbitControls.update(),
        this._orbitCamera.updateMatrix(),
        this._orbitCamera.matrix.decompose(t.position, t.quaternion, t.scale)),
        this._v1.set(0, 0, -1).applyQuaternion(t.quaternion),
        this.useOrbitControls === !0 ? this.cameraDistance = this._v2.copy(this._orbitControls.target).sub(t.position).dot(this._v1) : this.cameraDistance = this._v2.copy(this.DEFAULT_LOOKAT_POSITION).sub(t.position).dot(this._v1),
        properties.cameraUsePhysical ? (t.filmGauge = properties.cameraFilmGauge,
        t.setFocalLength(properties.cameraFocalLength)) : t.fov = properties.cameraFov;
        let r = t.fov;
        t.fov += properties.cameraDollyZoomFovOffset;
        let n = this.cameraDistance;
        if (n = n * Math.tan(r / 360 * Math.PI / 2) / Math.tan(t.fov / 360 * Math.PI / 2) - n,
        t.translateZ(n),
        t.setViewOffset(properties.viewportWidth, properties.viewportHeight, properties.cameraViewportOffsetX, properties.cameraViewportOffsetY, properties.viewportWidth, properties.viewportHeight),
        t.fov = r,
        this.cameraDistance += n,
        browser$1.isMobile)
            this._deviceOrientationControls && (this._deviceOrientationControls.update(),
            this._deviceOrientationControls.hasValue && (this._hasDeviceOrientationControlValues || (this._targetDeviceControlQuaternion.copy(this._deviceOrientationCamera.quaternion),
            this._baseDeviceControlQuaternion.copy(this._deviceOrientationCamera.quaternion)),
            this._targetDeviceControlQuaternion.slerp(this._deviceOrientationCamera.quaternion, .15),
            this._baseDeviceControlQuaternion.slerp(this._targetDeviceControlQuaternion, .15),
            this._q.copy(this._baseDeviceControlQuaternion).invert().multiply(this._targetDeviceControlQuaternion),
            this._deviceOrientationEuler.setFromQuaternion(this._q),
            this._hasDeviceOrientationControlValues = !0,
            t.quaternion.multiply(this._q)));
        else {
            t.translateZ(this.cameraDistance * -1);
            let o = math.clamp(input.mouseXY.y, -1, 1) * properties.cameraLookStrength
              , l = math.clamp(-input.mouseXY.x, -1, 1) * properties.cameraLookStrength;
            properties.cameraLookX += (o - properties.cameraLookX) * properties.cameraLookEaseDamp,
            properties.cameraLookY += (l - properties.cameraLookY) * properties.cameraLookEaseDamp,
            this._e.set(properties.cameraLookX, properties.cameraLookY, 0),
            this._q.setFromEuler(this._e),
            t.quaternion.multiply(this._q),
            t.translateZ(this.cameraDistance)
        }
        t.matrix.compose(t.position, t.quaternion, t.scale),
        this._brownianMotion.positionAmplitude = properties.cameraShakePositionStrength,
        this._brownianMotion.positionFrequency = properties.cameraShakePositionSpeed,
        this._brownianMotion.rotationAmplitude = properties.cameraShakeRotationStrength,
        this._brownianMotion.rotationFrequency = properties.cameraShakeRotationSpeed,
        this._brownianMotion.update(e),
        t.matrix.multiply(this._brownianMotion.matrix),
        t.matrix.decompose(t.position, t.quaternion, t.scale),
        this._v1.set(0, 0, -1).applyQuaternion(t.quaternion),
        this.useOrbitControls === !0 && (properties.cameraDistance = this._v2.copy(this._orbitControls.target).sub(t.position).dot(this._v1)),
        t.updateMatrixWorld(),
        properties.cameraDirection.set(0, 0, 1).applyMatrix4(t.matrixWorld).sub(this._v1.set(0, 0, 0).applyMatrix4(t.matrixWorld)).normalize()
    }
}
const cameraControls = new CameraControls
  , vert$g = `#define GLSLIFY 1
uniform float u_time;uniform sampler2D u_animationPositionTexture;uniform sampler2D u_animationOrientTexture;uniform vec2 u_animationTextureSize;uniform float u_loopLinearBlend;attribute vec2 boneIndices;attribute vec2 boneWeights;attribute vec4 tangent;attribute float ao;attribute vec3 instancePos;attribute vec4 instanceOrient;attribute vec3 instanceAnimationFrameFromToBlend1;attribute vec3 instanceAnimationFrameFromToBlend2;varying vec3 v_worldPosition;varying vec4 v_worldTangent;varying vec3 v_worldNormal;varying vec3 v_viewPosition;varying vec2 v_uv;varying float v_ao;
#define PI 3.14159265359
vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}vec3 qrotate(vec4 q,vec3 v){return v+2.*cross(q.xyz,cross(q.xyz,v)+q.w*v);}void computeTransform(inout vec3 pos,inout vec3 nor,inout vec3 tang,vec4 uvBone12){vec3 bonePos1=texture2D(u_animationPositionTexture,uvBone12.xy).xyz;vec3 bonePos2=texture2D(u_animationPositionTexture,uvBone12.zw).xyz;vec4 boneOrient1=texture2D(u_animationOrientTexture,uvBone12.xy);vec4 boneOrient2=texture2D(u_animationOrientTexture,uvBone12.zw);pos=(qrotate(boneOrient1,pos)+bonePos1)*boneWeights.x+(qrotate(boneOrient2,pos)+bonePos2)*boneWeights.y;nor=normalize(qrotate(boneOrient1,nor)*boneWeights.x+qrotate(boneOrient2,nor)*boneWeights.y);tang=normalize(qrotate(boneOrient1,tang)*boneWeights.x+qrotate(boneOrient2,tang)*boneWeights.y);}void computeFrameTransform(inout vec3 pos,inout vec3 nor,inout vec3 tang,vec3 instanceAnimationFrameFromToBlend){vec4 dataOffset=boneIndices.xyxy+instanceAnimationFrameFromToBlend.xxyy*float(BONE_COUNT)+0.5;vec4 fromUvsBone12=vec4(floor(mod(dataOffset.xy,u_animationTextureSize.x))+.5,floor(dataOffset.xy/u_animationTextureSize.x)+.5).xzyw/u_animationTextureSize.xyxy;vec4 toUvsBone12=vec4(floor(mod(dataOffset.zw,u_animationTextureSize.x))+.5,floor(dataOffset.zw/u_animationTextureSize.x)+.5).xzyw/u_animationTextureSize.xyxy;vec3 fromPos=pos;vec3 fromNor=nor;vec3 fromTang=tang.xyz;computeTransform(fromPos,fromTang,fromNor,fromUvsBone12);vec3 toPos=pos;vec3 toNor=nor;vec3 toTang=tang.xyz;computeTransform(toPos,toNor,toTang,toUvsBone12);pos=mix(fromPos,toPos,instanceAnimationFrameFromToBlend.z);nor=mix(fromNor,toNor,instanceAnimationFrameFromToBlend.z);tang=mix(fromTang,toTang,instanceAnimationFrameFromToBlend.z);}void main(){v_ao=ao;vec3 posLoop=position;vec3 norLoop=normal;vec3 tangLoop=tangent.xyz;computeFrameTransform(posLoop,norLoop,tangLoop,instanceAnimationFrameFromToBlend1);vec3 posLinear=position;vec3 norLinear=normal;vec3 tangLinear=tangent.xyz;computeFrameTransform(posLinear,norLinear,tangLinear,instanceAnimationFrameFromToBlend2);vec3 pos=mix(posLoop,posLinear,u_loopLinearBlend);vec3 nor=mix(norLoop,norLinear,u_loopLinearBlend);vec3 tang=mix(tangLoop,tangLinear,u_loopLinearBlend);pos=qrotate(instanceOrient,pos)+instancePos.xyz;nor=normalize(qrotate(instanceOrient,nor));tang=normalize(qrotate(instanceOrient,tang));vec4 mvPos=modelViewMatrix*vec4(pos,1.0);v_worldPosition=(modelMatrix*vec4(pos,1.0)).xyz;v_worldTangent=vec4(inverseTransformDirection(normalMatrix*tang,viewMatrix),tangent.w);v_worldNormal=inverseTransformDirection(normalMatrix*nor,viewMatrix);v_uv=uv;v_viewPosition=-mvPos.xyz;gl_Position=projectionMatrix*mvPos;}`
  , fragWhite = `#define GLSLIFY 1
uniform sampler2D u_matcapTexture;uniform float u_frameOutRatio;uniform float u_faceLedLight;uniform vec3 u_tintColor;uniform vec3 u_cardPosition;uniform vec3 u_sunPosition;uniform vec3 u_ambientColor;uniform vec3 u_faceLedColor;uniform sampler2D u_envTexture;
#include <astronautCommon_pars>
float getMetalShininess(vec3 viewDir,vec3 lightPosition,vec3 worldNormal,float roughness,float metalness){vec3 lightDir=normalize(lightPosition-v_worldPosition);vec3 H=normalize(viewDir+lightDir);float dotNL=max(0.,dot(worldNormal,lightDir));float dotNH=max(0.,dot(worldNormal,H));float alpha=max(0.01,roughness*roughness);float alphaSqr=alpha*alpha;float pi=3.14159;float denom=dotNH*dotNH*(alphaSqr-1.0)+1.0;float D=alphaSqr/(pi*denom*denom);float specular=metalness*D*5.0;return specular*dotNL;}vec2 boxIntersection(in vec3 ro,in vec3 rd,vec3 boxSize){vec3 m=1.0/rd;vec3 n=m*ro;vec3 k=abs(m)*boxSize;vec3 t1=-n-k;vec3 t2=-n+k;float tN=max(max(t1.x,t1.y),t1.z);float tF=min(min(t2.x,t2.y),t2.z);if(tN>tF||tF<0.0)return vec2(-1.0);return vec2(tN,tF);}void main(){
#include <astronautCommon>
mat4 frameInRotation=rotation3d(vec3(1.0,0.0,0.0),1.);vec3 viewDir=(vec4(normalize(v_worldPosition),1.0)*frameInRotation).xyz;vec3 x=normalize(vec3(viewDir.z,0.0,-viewDir.x));vec3 y=cross(viewDir,x);vec2 uv=vec2(dot(x,worldNormal),dot(y,worldNormal))*0.495+0.5;float zAxisShading=linearStep(-0.2,1.3,worldNormal.z)*(0.65+ao*0.35);float outOfFrameRatio=linearStep(0.35,1.0,u_frameOutRatio);vec3 sunPosition=u_sunPosition;vec3 L=normalize(sunPosition-v_worldPosition);float sunNdLRaw=dot(N,L);float sunNdL=saturate(sunNdLRaw);float matcapShading=0.5+0.5*(1.0-texture2D(u_matcapTexture,uv).r);float metalMask=1.0-metalness;vec3 color=vec3(matcapShading*albedo);color+=0.8*zAxisShading;color*=u_ambientColor*(0.85+sunNdL*0.5);color*=metalMask;color+=(0.5+0.5*outOfFrameRatio)*metalMask*(0.5*(0.4+0.2*ao+0.5*sunNdL)+0.1*sunNdL*sunNdL);color*=0.7+0.3*ao;color+=linearStep(0.,1.,-sunNdLRaw)*u_ambientColor*0.1;vec3 tunnelColor=color*0.75;vec2 dists=boxIntersection(v_worldPosition+vec3(0.,0.,u_whiteTunnelRatio*7.5*5.)+worldNormal*200.,-worldNormal,vec3(7.5,7.5,100.));float dist=200.-dists.x;vec3 hitPos=v_worldPosition+dist*worldNormal;tunnelColor+=vec3(1.)*(abs(worldNormal.x)*0.5+0.5)/dist*(0.25+0.75*ao)*(cos(u_whiteTunnelRatio*6.283185307179586*5.)*0.3+0.7)*3.5*(1.-metalness);color=mix(tunnelColor,color,outOfFrameRatio)*(0.7+armb.r*0.3);vec3 ledLightPos=u_cardPosition;vec3 ledLightDir=ledLightPos-v_worldPosition;float ledLightDist=length(ledLightDir);ledLightDir/=ledLightDist;float attenuationLed=1.0/(16.0*ledLightDist);color+=attenuationLed*u_faceLedLight*u_faceLedColor*getMetalShininess(V,u_cardPosition,N,(1.0-metalness),metalness);attenuationLed=1.0/(16.0*ledLightDist*ledLightDist);color+=0.5*u_faceLedLight*u_faceLedColor*albedo*attenuationLed*(0.5+0.5*saturate(dot(ledLightDir,N)));gl_FragColor.rgb=mix(u_bgColor,color,vec3(u_showRatio*0.8+0.2));
#ifndef IS_HELMET_GLASS
gl_FragColor.rgb+=outOfFrameRatio*max(worldNormal.z*2.*sunNdL,metalness)*texture2D(u_envTexture,1.2*(uv-0.5)+vec2(0.5,0.5)).rgb*0.75*v_ao;
#endif
gl_FragColor.rgb=min(vec3(1.),gl_FragColor.rgb+u_tintColor*(1.-u_frameOutRatio*0.3)*(0.4+gl_FragColor.b*0.6));gl_FragColor.rgb*=0.95+mix(u_tintColor,vec3(1.0),v_ao)*0.1;gl_FragColor.rgb*=mix(1.,metalMask*0.7+0.3,linearStep(0.8,1.,u_frameOutRatio));gl_FragColor.a=0.01;}`
  , fragCard = `#define GLSLIFY 1
uniform sampler2D u_cardTexture;uniform sampler2D u_cardLedTexture;uniform vec2 u_cardUvOffset;uniform vec2 u_cardTextureSize;uniform vec3 u_cardColor;uniform float u_cardOpacity;uniform float u_time;varying vec2 v_uv;void main(){vec2 uv=v_uv/u_cardTextureSize;vec4 texel=texture2D(u_cardTexture,uv+u_cardUvOffset);vec3 ledTexture=pow(texture2D(u_cardLedTexture,fract(v_uv*vec2(20.,15.))).rgb,vec3(2.2));float ledMask=dot(ledTexture,u_cardColor*texel.r);gl_FragColor.rgb=pow(ledTexture,vec3(1./2.2))*ledMask*2.5;gl_FragColor.a=texel.r*0.35;}`
  , fragBlack = `#define GLSLIFY 1
uniform sampler2D u_blackTunnelTexture;uniform sampler2D u_matcapTexture;uniform sampler2D u_envTexture;uniform float u_sunFactor;uniform vec3 u_sunPosition;uniform vec3 u_ambientColor;uniform vec3 u_sunFadeColor;uniform float u_blackTunnelRatio;uniform float u_offsetZ;uniform float u_frameIn;uniform float u_endRatio;
#ifdef IS_CLONE
uniform float u_alpha;
#endif
#include <astronautCommon_pars>
float sdBoxFrame(vec3 p,vec3 b,float e){p=abs(p)-b;vec3 q=abs(p+e)-e;return min(min(length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));}float getMetalShininess(vec3 viewDir,vec3 lightPosition,vec3 worldNormal,float roughness,float metalness){vec3 lightDir=normalize(lightPosition-v_worldPosition);vec3 H=normalize(viewDir+lightDir);float dotNL=max(0.,dot(worldNormal,lightDir));float dotNH=max(0.,dot(worldNormal,H));float alpha=max(0.01,roughness*roughness);float alphaSqr=alpha*alpha;float pi=3.14159;float denom=dotNH*dotNH*(alphaSqr-1.0)+1.0;float D=alphaSqr/(pi*denom*denom);float specular=metalness*D*5.0;return specular*dotNL;}void main(){
#include <astronautCommon>
vec2 uvDiff=cartesianToPolar(worldNormal);vec2 uvSpec=cartesianToPolar(reflection);vec3 blackTunnelEnvDiff=texture2D(u_blackTunnelTexture,0.25*uvDiff).rgb;vec3 blackTunnelEnvSpec=texture2D(u_blackTunnelTexture,0.25*uvSpec).rgb*(0.2+metalness*0.7)*2.;
#ifdef IS_CLONE
gl_FragColor.rgb=(blackTunnelEnvDiff*3.5*blackTunnelEnvDiff+blackTunnelEnvSpec*3.5)*v_ao*u_alpha*(0.5+fresnel*0.9);gl_FragColor.a=mix(max(gl_FragColor.r,max(gl_FragColor.g,gl_FragColor.b))*u_alpha,0.,u_endRatio);
#else
mat4 frameInRotation=rotation3d(vec3(1.0,0.0,0.0),0.2+1.*u_frameIn);vec3 viewDir=(vec4(normalize(v_worldPosition),1.0)*frameInRotation).xyz;vec3 x=normalize(vec3(viewDir.z,0.0,-viewDir.x));vec3 y=cross(viewDir,x);vec2 uv=vec2(dot(x,worldNormal),dot(y,worldNormal))*0.495+0.5;vec3 sunPosition=u_sunPosition;vec3 L=normalize(sunPosition-v_worldPosition);float sunNdLRaw=dot(N,L);float sunNdL=saturate(sunNdLRaw);float matcapShading=0.5+0.5*(1.0-texture2D(u_matcapTexture,uv).r);float zAxisShading=linearStep(-0.2,1.3,worldNormal.z)*(0.65+ao*0.35);float metalMask=1.0-metalness;float metalShininess=u_sunFactor*getMetalShininess(V,sunPosition,N,(1.0-0.9*metalness),0.4*metalness);vec3 color=vec3(matcapShading*albedo);color+=zAxisShading;color*=metalMask;color*=mix(u_ambientColor*(0.85+sunNdL*0.5),vec3(fresnel*2.),u_blackTunnelRatio*0.5);color+=linearStep(0.,10.0,metalShininess);color*=mix(0.5+0.5*ao,0.75+0.25*ao,u_blackTunnelRatio);color+=metalMask*u_sunFactor*(0.5*(0.4+0.2*ao+0.5*sunNdL)+0.1*sunNdL*sunNdL);color+=linearStep(0.,1.,-sunNdLRaw)*u_ambientColor*0.1;vec3 blackTunnelColor=(color*blackTunnelEnvSpec*(7.+metalness*10.)+albedo*blackTunnelEnvDiff*1.6)*(1.3-abs(reflection.z))*(0.5+ao*0.5);float GRID_SIZE=20.0;float offsetZ=mod(u_offsetZ,GRID_SIZE);vec3 ro=vec3(0.0,0.0,offsetZ);float t=0.0;vec3 relPos=v_worldPosition+worldNormal*3.+vec3(0.,0.,u_offsetZ);float repDist=GRID_SIZE-1.;vec3 relPosRep=mod(relPos+0.5*repDist,repDist)-0.5*repDist;float sdf=sdBoxFrame(relPosRep,vec3(GRID_SIZE-1.)*.5,1.);blackTunnelColor+=exp(-sdf*0.25)*blackTunnelEnvDiff*2.;gl_FragColor.rgb=color;gl_FragColor.rgb=mix(gl_FragColor.rgb,0.3*gl_FragColor.rgb+blackTunnelColor,clamp(u_blackTunnelRatio*2.-1.+ao,0.,1.));gl_FragColor.rgb=mix(u_bgColor,gl_FragColor.rgb,vec3(u_showRatio));gl_FragColor.rgb*=(0.3+armb.r*0.7);gl_FragColor.rgb+=max(worldNormal.z*2.*sunNdL,metalness)*texture2D(u_envTexture,1.2*(uv-0.5)+vec2(0.5,0.5)).rgb*0.75*v_ao*(1.-u_blackTunnelRatio);gl_FragColor.a=0.01+0.1*max(0.0,gl_FragColor.g-1.+metalness*0.2)*(0.5+metalness*1.5)+gl_FragColor.b*u_blackTunnelRatio*dot(vec3(0.299,0.587,0.114),blackTunnelColor)*5.;gl_FragColor.a+=metalShininess;gl_FragColor.a*=(0.5+fresnel*0.9);
#endif
}`
  , astronautCommon = `#define GLSLIFY 1
vec3 worldNormal=normalize(v_worldNormal);vec3 worldTangent=normalize(v_worldTangent.xyz);vec3 worldBinormal=normalize(cross(worldNormal,worldTangent))*-v_worldTangent.w;worldTangent=normalize(cross(worldBinormal,worldNormal));vec3 tangentSpaceNormal=normalize(texture2D(u_norTexture,v_uv).xyz-.5);worldNormal=normalize(tangentSpaceNormal.x*worldTangent+tangentSpaceNormal.y*worldBinormal+tangentSpaceNormal.z*worldNormal);vec4 armb=texture2D(u_armbTexture,v_uv);float ao=v_ao*armb.r;float roughness=armb.g;float metalness=armb.b;float albedo=armb.a;vec3 N=worldNormal;vec3 V=normalize(cameraPosition-v_worldPosition);vec3 reflection=normalize(reflect(-V,N));float NdV=clamp(abs(dot(N,V)),0.001,1.0);float fresnel=pow(1.0-NdV,5.0);`
  , astronautCommonPars = `#define GLSLIFY 1
uniform sampler2D u_armbTexture;uniform sampler2D u_norTexture;uniform float u_time;uniform vec3 u_bgColor;uniform float u_showRatio;
#ifdef IS_WHITE
uniform float u_whiteTunnelRatio;
#endif
varying vec3 v_worldPosition;varying vec4 v_worldTangent;varying vec3 v_worldNormal;varying vec2 v_uv;varying float v_ao;varying vec3 v_viewPosition;const float PI=3.14159265359;const float RECIPROCAL_PI=0.31830988618;const float RECIPROCAL_PI2=0.15915494;const float LN2=0.6931472;const float ENV_LODS=6.0;
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}vec2 cartesianToPolar(vec3 n){vec2 uv;uv.x=atan(n.z,n.x)*RECIPROCAL_PI2+0.5;uv.y=asin(n.y)*RECIPROCAL_PI+0.5;return uv;}mat4 rotation3d(vec3 axis,float angle){axis=normalize(axis);float s=sin(angle);float c=cos(angle);float oc=1.0-c;return mat4(oc*axis.x*axis.x+c,oc*axis.x*axis.y-axis.z*s,oc*axis.z*axis.x+axis.y*s,0.0,oc*axis.x*axis.y+axis.z*s,oc*axis.y*axis.y+c,oc*axis.y*axis.z-axis.x*s,0.0,oc*axis.z*axis.x-axis.y*s,oc*axis.y*axis.z+axis.x*s,oc*axis.z*axis.z+c,0.0,0.0,0.0,0.0,1.0);}`;
let _m0 = new Matrix4
  , _v0$1 = new Vector3
  , _v1$4 = new Vector3
  , _p0 = new Vector3
  , _p1 = new Vector3
  , _e0 = new Euler
  , _q0$1 = new Quaternion
  , _q1$2 = new Quaternion
  , _matrixWorld$1 = new Matrix4
  , _matrixWorldInverse$1 = new Matrix4
  , _projectionMatrix$1 = new Matrix4
  , _perspectiveCamera = new PerspectiveCamera;
class GoalTunnelAstronauts {
    container = new Object3D;
    materials = {};
    meshes = {};
    cloneMeshes = {};
    CLONES_COUNT = 4;
    TOTAL_COUNT = 5;
    transformObjectList = [];
    partIdList = ["helmet", "helmet_glass", "glove_shoes", "wearpack", "card"];
    textureTypeList = ["arm", "base", "nor"];
    textures = {};
    textureUniforms = {};
    extraCameraViewportOffsetX = 0;
    extraCameraViewportOffsetY = 0;
    instancePosAttribute;
    instanceOrientAttribute;
    instanceAnimationFrameFromToBlend1Attribute;
    instanceAnimationFrameFromToBlend2Attribute;
    instanceClonePosAttribute;
    instanceCloneOrientAttribute;
    instanceCloneAnimationFrameFromToBlend1Attribute;
    instanceCloneAnimationFrameFromToBlend2Attribute;
    _cameraNeedsSync = !1;
    sharedUniforms = {
        u_time: properties.sharedUniforms.u_time,
        u_animationPositionTexture: {
            value: null
        },
        u_animationOrientTexture: {
            value: null
        },
        u_animationTextureSize: {
            value: new Vector2(0,0)
        },
        u_frameCount: {
            value: null
        },
        u_lut: {
            value: null
        },
        u_bgColor: {
            value: new Color
        },
        u_showRatio: {
            value: 0
        },
        u_loopLinearBlend: {
            value: 0
        },
        u_ambientColor: {
            value: new Color("#566d80")
        }
    };
    whiteTunnelUniforms = {
        u_matcapTexture: {
            value: null
        },
        u_frameOutRatio: {
            value: 0
        },
        u_whiteTunnelRatio: {
            value: 0
        },
        u_faceLedLight: {
            value: 0
        },
        u_faceLedColor: {
            value: new Color("#aaaafb")
        },
        u_tintColor: {
            value: new Color
        },
        u_cardPosition: {
            value: new Vector3
        },
        u_sunPosition: {
            value: new Vector3(-20,0,22)
        },
        u_envTexture: {
            value: null
        }
    };
    blackTunnelUniforms = {
        u_matcapTexture: {
            value: null
        },
        u_frameIn: {
            value: 0
        },
        u_blackTunnelRatio: {
            value: 0
        },
        u_endRatio: {
            value: 0
        },
        u_blackTunnelTexture: {
            value: null
        },
        u_sunFactor: {
            value: 1
        },
        u_sunPosition: {
            value: new Vector3(-20,0,22)
        },
        u_blackTunnelTransformRatio: goalBlackTunnel.sharedUniforms.u_blackTunnelTransformRatio,
        u_envTexture: {
            value: null
        },
        u_offsetZ: goalBlackTunnel.sharedUniforms.u_offsetZ,
        u_sunFadeColor: {
            value: new Color("#bbb")
        }
    };
    cloneUniforms = {
        u_alpha: {
            value: 0
        }
    };
    BONE_COUNT = 53;
    frameCount = -1;
    showRatio = 1;
    clonesShowRatio = 0;
    cardNoise = new Simple1DNoise;
    renderTarget = null;
    interRenderTarget = null;
    textureSize = null;
    isCardActive = !1;
    cardTextureSize = new Vector2(5,23);
    cardTime = 0;
    preInit() {
        this.TOTAL_COUNT = this.CLONES_COUNT + 1,
        shaderHelper.addChunk("astronautCommon", astronautCommon),
        shaderHelper.addChunk("astronautCommon_pars", astronautCommonPars),
        this.camera = new PerspectiveCamera;
        for (let e = 0; e < this.TOTAL_COUNT; e++) {
            let t = new Object3D;
            t.position.set(Math.random(), Math.random(), Math.random()).subScalar(.5).normalize().multiplyScalar(4 * Math.pow(Math.random(), 1 / 3)),
            t.position.z += 15,
            t.rotation.set(Math.random() * Math.PI / 2, Math.random() * Math.PI / 2, Math.random() * Math.PI / 2),
            t.userData.timeShift = e === 0 ? 0 : 2 * Math.random(),
            t.userData.cloneTimeShift = Math.random(),
            t.userData.rotation = new Euler,
            t.userData.motion = new BrownianMotion,
            t.userData.motion._positionFrequency = .2,
            t.userData.motion._rotationFrequency = .6,
            t.userData.motion._positionAmplitude = 14,
            t.userData.motion._rotationAmplitude = 8.3,
            t.userData.positionDynamic = new SecondOrderDynamics(new Vector3,1,.65,1.3),
            t.userData.rotationDynamic = new SecondOrderDynamics(new Vector3,1,.85,1.1),
            t.userData.pauseLoopTime = 0,
            t.userData.animationTime = 0,
            t.userData.deltaTimeMultiplier = 1,
            this.transformObjectList.push(t)
        }
        this.instancePosAttribute = new InstancedBufferAttribute(new Float32Array(3),3),
        this.instancePosAttribute.usage = DynamicDrawUsage,
        this.instanceOrientAttribute = new InstancedBufferAttribute(new Float32Array(4),4),
        this.instanceOrientAttribute.usage = DynamicDrawUsage,
        this.instanceAnimationFrameFromToBlend1Attribute = new InstancedBufferAttribute(new Float32Array(3),3),
        this.instanceAnimationFrameFromToBlend1Attribute.usage = DynamicDrawUsage,
        this.instanceAnimationFrameFromToBlend2Attribute = new InstancedBufferAttribute(new Float32Array(3),3),
        this.instanceAnimationFrameFromToBlend2Attribute.usage = DynamicDrawUsage,
        this.instanceClonePosAttribute = new InstancedBufferAttribute(new Float32Array(this.CLONES_COUNT * 3),3),
        this.instanceClonePosAttribute.usage = DynamicDrawUsage,
        this.instanceCloneOrientAttribute = new InstancedBufferAttribute(new Float32Array(this.CLONES_COUNT * 4),4),
        this.instanceCloneOrientAttribute.usage = DynamicDrawUsage,
        this.instanceCloneAnimationFrameFromToBlend1Attribute = new InstancedBufferAttribute(new Float32Array(this.CLONES_COUNT * 3),3),
        this.instanceCloneAnimationFrameFromToBlend1Attribute.usage = DynamicDrawUsage,
        this.instanceCloneAnimationFrameFromToBlend2Attribute = new InstancedBufferAttribute(new Float32Array(this.CLONES_COUNT * 3),3),
        this.instanceCloneAnimationFrameFromToBlend2Attribute.usage = DynamicDrawUsage,
        this.textures.card = properties.loader.add(settings.TEXTURE_PATH + "tunnels/astronaut/face.png", {
            type: "texture",
            minFilter: NearestFilter
        }).content,
        this.textures.card.magFilter = NearestFilter,
        this.textures.led = this._initLedTexture();
        for (let e = 0; e < this.partIdList.length; e++) {
            let t = this.partIdList[e];
            this.textureUniforms[t + "_armb"] = {
                value: null
            },
            this.textureUniforms[t + "_nor"] = {
                value: null
            };
            for (let r = 0; r < this.textureTypeList.length; r++) {
                let n = this.textureTypeList[r];
                t != "helmet_glass" && t !== "card" && properties.loader.add(settings.TEXTURE_PATH + "tunnels/astronaut/astronaut_" + t + "_" + n + ".webp", {
                    type: "texture",
                    onLoad: this._onTextureLoad.bind(this, t, n)
                })
            }
            if (t === "card") {
                let r = new PlaneGeometry(.2,.15).translate(0, 1.68, .1);
                r.setAttribute("boneIndices", new BufferAttribute(new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]),2)),
                r.setAttribute("boneWeights", new BufferAttribute(new Float32Array([1, 0, 1, 0, 1, 0, 1, 0]),2)),
                r.setAttribute("tangent", new BufferAttribute(new Float32Array([0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1]),4)),
                this._onGeometryLoad("card", r)
            } else
                properties.loader.add(settings.MODEL_PATH + "tunnels/astronaut_" + t + ".buf", {
                    onLoad: r => {
                        this._onGeometryLoad(t, r, !0),
                        this._onGeometryLoad(t, r, !1)
                    }
                })
        }
        properties.loader.add(settings.MODEL_PATH + "tunnels/astronaut_in_animation.buf", {
            onLoad: e => this.inAnimation = e
        }),
        properties.loader.add(settings.MODEL_PATH + "tunnels/astronaut_out_animation.buf", {
            onLoad: e => this.outAnimation = e
        }),
        this.whiteTunnelUniforms.u_envTexture.value = this.blackTunnelUniforms.u_envTexture.value = properties.loader.add(settings.TEXTURE_PATH + "tunnels/earth.webp", {
            type: "texture",
            minFilter: LinearFilter
        }).content,
        this.blackTunnelUniforms.u_matcapTexture.value = this.whiteTunnelUniforms.u_matcapTexture.value = properties.loader.add(settings.TEXTURE_PATH + "tunnels/white_matcap.jpg", {
            type: "texture",
            minFilter: LinearFilter
        }).content,
        properties.loader.add(settings.MODEL_PATH + "tunnels/astronaut_animations.buf", {
            onLoad: e => {
                this._onAnimationLoad(e)
            }
        }),
        this.initGui()
    }
    _initLedTexture() {
        let e = document.createElement("canvas");
        e.width = e.height = 11;
        let t = e.getContext("2d");
        t.fillStyle = "#000",
        t.fillRect(0, 0, 11, 11),
        t.fillStyle = "#f00",
        t.fillRect(1, 1, 3, 9),
        t.fillStyle = "#0f0",
        t.fillRect(4, 1, 3, 9),
        t.fillStyle = "#00f",
        t.fillRect(7, 1, 3, 9);
        let r = new Texture(e);
        return r.needsUpdate = !0,
        r.minFilter = LinearFilter,
        r
    }
    initGui() {
        settings.LOOK_DEV_MODE
    }
    _onTextureLoad(e, t, r) {
        if (this.textures[e + "_" + t] = r,
        t == "arm" || t == "base") {
            let n = this.textures[e + "_arm"]
              , o = this.textures[e + "_base"];
            if (n && o) {
                let l = fboHelper.createRenderTarget(n.image.width, n.image.height, !1, !1);
                this.textures[e + "_arm"] = this.textures[e + "_base"] = null,
                fboHelper.copy(textureHelper.transparentTexture, l),
                textureHelper.mixChannels(n, l, 0, 1, 2, -1),
                textureHelper.mixChannels(o, l, -1, -1, -1, 0),
                n.dispose(),
                o.dispose(),
                this.textureUniforms[e + "_armb"].value = l.texture
            }
        } else
            this.textureUniforms[e + "_" + t].value = r
    }
    _onGeometryLoad(e, t, r) {
        let n = new InstancedBufferGeometry;
        for (let p in t.attributes)
            n.attributes[p] = t.attributes[p];
        let o = e;
        (e == "helmet_glass" || e == "card") && (o = "helmet"),
        n.index = t.index,
        n.setAttribute("instancePos", this[`instance${r ? "Clone" : ""}PosAttribute`]),
        n.setAttribute("instanceOrient", this[`instance${r ? "Clone" : ""}OrientAttribute`]),
        n.setAttribute("instanceAnimationFrameFromToBlend1", this[`instance${r ? "Clone" : ""}AnimationFrameFromToBlend1Attribute`]),
        n.setAttribute("instanceAnimationFrameFromToBlend2", this[`instance${r ? "Clone" : ""}AnimationFrameFromToBlend2Attribute`]);
        let l;
        if (!r) {
            const p = Object.assign({}, this.whiteTunnelUniforms, this.sharedUniforms);
            p.u_armbTexture = this.textureUniforms[o + "_armb"],
            p.u_norTexture = this.textureUniforms[o + "_nor"],
            l = new ShaderMaterial({
                uniforms: p,
                vertexShader: vert$g,
                fragmentShader: e == "card" ? fragCard : fragWhite,
                side: DoubleSide,
                transparent: !0,
                blending: NoBlending
            }),
            l.defines.BONE_COUNT = this.BONE_COUNT,
            l.defines.IS_WHITE = !0,
            l.name = "whiteTunnelMaterial",
            e == "helmet_glass" && (l.defines.IS_HELMET_GLASS = !0),
            e == "card" && (l.uniforms = Object.assign({
                u_cardLedTexture: {
                    value: this.textures.led
                },
                u_cardTexture: {
                    value: this.textures.card
                },
                u_cardColor: {
                    value: new Color("#ddddff")
                },
                u_cardUvOffset: {
                    value: new Vector2(0,0)
                },
                u_cardTextureSize: {
                    value: this.cardTextureSize
                },
                u_cardOpacity: {
                    value: 1
                }
            }, this.sharedUniforms),
            l.depthTest = !1,
            l.depthWrite = !1,
            l.blending = CustomBlending,
            l.blendEquation = AddEquation,
            l.blendSrc = OneFactor,
            l.blendDst = OneFactor,
            l.blendEquationAlpha = AddEquation,
            l.blendSrcAlpha = OneFactor,
            l.blendDstAlpha = OneFactor)
        }
        const c = Object.assign({}, this.blackTunnelUniforms, this.sharedUniforms, r ? this.cloneUniforms : {});
        c.u_armbTexture = this.textureUniforms[o + "_armb"],
        c.u_norTexture = this.textureUniforms[o + "_nor"];
        const u = new ShaderMaterial({
            uniforms: c,
            vertexShader: vert$g,
            fragmentShader: fragBlack,
            transparent: !0
        });
        r ? (u.blending = CustomBlending,
        u.blendEquation = AddEquation,
        u.blendSrc = OneFactor,
        u.blendDst = OneFactor,
        u.depthTest = !1,
        u.side = DoubleSide) : (u.blending = NoBlending,
        u.side = DoubleSide),
        u.defines.BONE_COUNT = this.BONE_COUNT,
        u.defines.IS_BLACK = !0,
        u.defines.IS_CLONE = r,
        u.name = "blackTunnelMaterial",
        l && taskManager.add(l),
        u && taskManager.add(u);
        const f = new Mesh(n,this.blackTunnelMaterial);
        r ? f.renderOrder = 1e3 : (f.onBeforeRender = this._onBeforeRender.bind(this),
        f.onAfterRender = this._onAfterRender.bind(this)),
        f.renderOrder = e == "card" ? 100 : 0,
        f.frustumCulled = !1,
        this.container.add(f),
        r ? (f.material = u,
        this.cloneMeshes[e] = f) : (this.meshes[e] = f,
        this.materials[e] = {
            white: l,
            black: u
        })
    }
    _onBeforeRender(e, t, r) {
        if (this.container.parent == homePage.preUfxContainer) {
            let n = cameraControls._camera;
            if (_matrixWorld$1.copy(r.matrixWorld),
            r.matrixWorld.copy(n.matrixWorld),
            _matrixWorldInverse$1.copy(r.matrixWorldInverse),
            r.matrixWorldInverse.copy(n.matrixWorldInverse),
            _projectionMatrix$1.copy(r.projectionMatrix),
            this._cameraNeedsSync && (this._cameraNeedsSync = !1,
            _perspectiveCamera.fov = n.fov,
            _perspectiveCamera.near = n.near,
            _perspectiveCamera.far = n.far,
            _perspectiveCamera.filmOffset = n.filmOffset,
            _perspectiveCamera.coordinateSystem = n.coordinateSystem,
            _perspectiveCamera.filmGauge = n.filmGauge,
            _perspectiveCamera.aspect = n.aspect,
            n.view)) {
                _perspectiveCamera.view = _perspectiveCamera.view || {};
                for (let o in n.view)
                    _perspectiveCamera.view[o] = n.view[o];
                _perspectiveCamera.view.offsetX += this.extraCameraViewportOffsetX,
                _perspectiveCamera.view.offsetY += this.extraCameraViewportOffsetY,
                _perspectiveCamera.updateProjectionMatrix()
            }
            r.projectionMatrix.copy(_perspectiveCamera.projectionMatrix)
        }
    }
    _onAfterRender(e, t, r) {
        this.container.parent == homePage.preUfxContainer && (r.matrixWorld.copy(_matrixWorld$1),
        r.matrixWorldInverse.copy(_matrixWorldInverse$1),
        r.projectionMatrix.copy(_projectionMatrix$1))
    }
    _onAnimationLoad(e) {
        let t = e.attributes.position.array
          , r = e.attributes.orient.array
          , n = t.length / 3;
        this.frameCount = n / this.BONE_COUNT;
        let o = Math.ceil(Math.sqrt(n))
          , l = Math.ceil(n / o)
          , c = o * l
          , u = new Float32Array(c * 4)
          , f = new Float32Array(c * 4);
        for (let p = 0, g = 0, v = 0; p < n; p++,
        g += 3,
        v += 4)
            u[v + 0] = t[g + 0],
            u[v + 1] = t[g + 1],
            u[v + 2] = t[g + 2],
            u[v + 3] = 1,
            f[v + 0] = r[v + 0],
            f[v + 1] = r[v + 1],
            f[v + 2] = r[v + 2],
            f[v + 3] = r[v + 3];
        this.sharedUniforms.u_animationPositionTexture.value = fboHelper.createDataTexture(u, o, l, !0, !0),
        this.sharedUniforms.u_animationPositionTexture.value.flipY = !1,
        this.sharedUniforms.u_animationOrientTexture.value = fboHelper.createDataTexture(f, o, l, !0, !0),
        this.sharedUniforms.u_animationOrientTexture.value.flipY = !1,
        this.sharedUniforms.u_animationTextureSize.value.set(o, l),
        this.sharedUniforms.u_frameCount.value = this.frameCount
    }
    init() {
        this.renderTarget = fboHelper.createRenderTarget(1, 1),
        this.interRenderTarget = fboHelper.createRenderTarget(1, 1)
    }
    resize(e, t) {
        if (!this.renderTarget)
            return;
        let r = .5;
        e = Math.ceil(e * r / 2) * 2,
        t = Math.ceil(t * r / 2) * 2,
        e = math.powerTwoFloor(e),
        t = math.powerTwoFloor(t),
        this.renderTarget.setSize(e, t),
        this.interRenderTarget.setSize(e, t)
    }
    updateTransforms(e) {
        const t = this.transformObjectList[0]
          , {whiteFrameRatio: r, whiteTunnelRatio: n, blackTitleRatio: o, isBlackTunnelActive: l, blackTunnelRatio: c, isBlackTitleActive: u, isWhiteTunnelActive: f, astronautDropRatio: p} = goalTunnels;
        for (let g = 0; g < this.TOTAL_COUNT; g++) {
            let v = this.transformObjectList[g];
            if (v.scale.setScalar(1),
            v.position.set(0, 0, 0),
            v.rotation.set(0, 0, 0),
            g === 0) {
                let _ = 100, w, S;
                f ? (w = this.outAnimation.attributes,
                n < 1 ? S = math.fit(n, 0, 1, 0, 79) : S = math.fit(p, 0, 1, 79, 99)) : (w = this.inAnimation.attributes,
                S = _ * ease.cubicIn(o));
                let b = w.position.array
                  , C = w.orient.array
                  , R = Math.min(Math.floor(S), _ - 1)
                  , T = Math.min(Math.ceil(S), _ - 1)
                  , M = S - R;
                _p0.fromArray(b, R * 3),
                _p1.fromArray(b, T * 3),
                _p0.lerp(_p1, M),
                v.position.copy(_p0),
                _q0$1.fromArray(C, R * 4),
                _q1$2.fromArray(C, T * 4),
                _q0$1.slerp(_q1$2, M),
                v.rotation.setFromQuaternion(_q0$1),
                v.position.y -= (properties.useMobileLayout ? 0 : .4) * ease.backInOut(p),
                v.updateMatrix();
                let P = v.userData.motion;
                if (P._positionFrequency = .2,
                P._rotationFrequency = .15,
                P._positionAmplitude = 0,
                P._rotationAmplitude = 0,
                l) {
                    let I = c;
                    P._positionFrequency = .2 + .5 * I,
                    P._rotationFrequency = .15,
                    P._positionAmplitude = 5 * I,
                    P._rotationAmplitude = 60 * I
                }
                f && (P._positionFrequency = math.fit(r, 0, .45, .5, .2),
                P._rotationFrequency = math.fit(r, 0, .45, .4, .15),
                P._positionAmplitude = math.fit(r, 0, .75, 5, 0),
                P._rotationAmplitude = math.fit(r, 0, .75, 15, 0)),
                P.update(e),
                v.userData.positionDynamic.update(e, P._position),
                _v0$1.copy(P._euler),
                v.userData.rotationDynamic.update(e, _v0$1),
                _e0.x = v.userData.rotationDynamic.value.x,
                _e0.y = v.userData.rotationDynamic.value.y,
                _e0.z = v.userData.rotationDynamic.value.z,
                v.userData.deltaTimeMultiplier = 1 + Math.min(3.5, v.userData.positionDynamic.valueVel.length() * .2 + v.userData.rotationDynamic.valueVel.length() * .2),
                _v1$4.set(1, 1, 1),
                P._matrix.compose(v.userData.positionDynamic.value, _q0$1.setFromEuler(_e0), _v1$4),
                _m0.copy(v.matrix),
                _m0.multiply(P._matrix),
                _m0.decompose(_v0$1, _q0$1, _v1$4)
            } else if (u || f)
                v.scale.setScalar(0),
                v.updateMatrix(),
                _m0.copy(v.matrix).decompose(_v0$1, _q0$1, _v1$4);
            else {
                v.position.copy(t.position),
                v.rotation.copy(t.rotation),
                v.updateMatrix(),
                v.userData.motion._positionFrequency = .2,
                v.userData.motion._rotationFrequency = .6,
                v.userData.motion._positionAmplitude = 12,
                v.userData.motion._rotationAmplitude = 10,
                v.userData.motion.update(e),
                _m0.copy(v.matrix),
                _m0.multiply(v.userData.motion._matrix),
                _m0.decompose(_v0$1, _q0$1, _v1$4),
                _v1$4.fromArray(this.instancePosAttribute.array, 0),
                _q1$2.fromArray(this.instanceOrientAttribute.array, 0);
                let _ = g / (this.CLONES_COUNT - 1)
                  , w = math.fit(this.clonesShowRatio, _ * .3, .7 + _ * .3, 1, 0, ease.sineInOut);
                _v0$1.lerp(_v1$4, w)
            }
            g === 0 ? (_v0$1.toArray(this.instancePosAttribute.array, 0),
            _q0$1.toArray(this.instanceOrientAttribute.array, 0)) : (_v0$1.toArray(this.instanceClonePosAttribute.array, (g - 1) * 3),
            _q0$1.toArray(this.instanceCloneOrientAttribute.array, (g - 1) * 4))
        }
        this.instancePosAttribute.needsUpdate = !0,
        this.instanceOrientAttribute.needsUpdate = !0,
        this.instanceClonePosAttribute.needsUpdate = !0,
        this.instanceCloneOrientAttribute.needsUpdate = !0
    }
    updateAnimation(e) {
        const {blackTitleRatio: t, astronautDropRatio: r, whiteFrameOutRatio: n} = goalTunnels;
        let o = !0, l, c, u, f, p, g = math.fit(r, 0, .1, 0, 1) * math.fit(r, .9, 1, 1, 0), v = math.fit(n + r, .9, 2, 90, 139, ease.quartIn);
        u = Math.floor(v),
        f = Math.ceil(v),
        p = v - u,
        this.sharedUniforms.u_loopLinearBlend.value = g;
        const _ = math.fit(r, .9, 1, 0, 1, ease.cubicIn);
        this.isCardActive = _ > 0;
        for (let w = 0; w < this.TOTAL_COUNT; w++) {
            const S = this.transformObjectList[w];
            let b = 1
              , C = this.materials.card.white.uniforms;
            if (r < .5)
                S.userData.pauseLoopTime = 0,
                b = math.smoothstep(-.3, 1, t) * .75,
                l = 0,
                c = 89,
                C.u_cardOpacity.value = 0;
            else {
                b = math.fit(r, .9, 1, 0, 1),
                l = 140,
                c = 287;
                let A = math.clamp(.5 + Math.max(0, this.cardNoise.getFbm(properties.time * 8, 3) + .5) * 4, 0, 2);
                C.u_cardOpacity.value = A * _,
                r < 1 ? (S.userData.pauseLoopTime = Math.max(0, S.userData.pauseLoopTime),
                o = !1) : S.userData.pauseLoopTime = 0
            }
            S.userData.pauseLoopTime == 0 && (S.userData.animationTime += e * b * S.userData.deltaTimeMultiplier),
            g == 1 && (S.userData.animationTime = 0);
            let R = S.userData.timeShift;
            w === 0 ? S.userData.cloneTimeShift = -1 : (S.userData.cloneTimeShift += .2 * e,
            S.userData.cloneTimeShift %= 1,
            R = math.mix(0, R, this.clonesShowRatio));
            let T = R + S.userData.animationTime
              , M = c - l + 1
              , P = T * 60 % M
              , I = Math.floor(P)
              , k = (I + 1) % M + l;
            I += l,
            k < I && (o || (k = I = l,
            S.userData.animationTime = -R,
            S.userData.pauseLoopTime = 1 / 0)),
            w === 0 ? (this.instanceAnimationFrameFromToBlend1Attribute.array[0] = I,
            this.instanceAnimationFrameFromToBlend1Attribute.array[1] = k,
            this.instanceAnimationFrameFromToBlend1Attribute.array[2] = P % 1,
            this.instanceAnimationFrameFromToBlend2Attribute.array[0] = u,
            this.instanceAnimationFrameFromToBlend2Attribute.array[1] = f,
            this.instanceAnimationFrameFromToBlend2Attribute.array[2] = p) : (this.instanceCloneAnimationFrameFromToBlend1Attribute.array[(w - 1) * 3 + 0] = I,
            this.instanceCloneAnimationFrameFromToBlend1Attribute.array[(w - 1) * 3 + 1] = k,
            this.instanceCloneAnimationFrameFromToBlend1Attribute.array[(w - 1) * 3 + 2] = P % 1,
            this.instanceCloneAnimationFrameFromToBlend2Attribute.array[(w - 1) * 3 + 0] = u,
            this.instanceCloneAnimationFrameFromToBlend2Attribute.array[(w - 1) * 3 + 1] = f,
            this.instanceCloneAnimationFrameFromToBlend2Attribute.array[(w - 1) * 3 + 2] = p)
        }
        this.instanceAnimationFrameFromToBlend1Attribute.needsUpdate = !0,
        this.instanceAnimationFrameFromToBlend2Attribute.needsUpdate = !0,
        this.instanceCloneAnimationFrameFromToBlend1Attribute.needsUpdate = !0,
        this.instanceCloneAnimationFrameFromToBlend2Attribute.needsUpdate = !0
    }
    updateCard(e) {
        this.cardTime = this.isCardActive ? this.cardTime + e : 0;
        const t = this.cardTextureSize.x
          , r = this.cardTextureSize.y
          , n = Math.floor(10 * this.cardTime % (t * (r + 1)))
          , o = n / (t * (r + 1))
          , l = math.linearStep(0, .15, o) * math.linearStep(1, .9, o);
        this.whiteTunnelUniforms.u_faceLedLight.value = l,
        this.materials.card.white.uniforms.u_cardUvOffset.value.set(n % t / t, (r - Math.floor(n / t)) / r)
    }
    update(e) {
        const {blackFrameInRatio: t, whiteFrameBreakRatio: r, whiteTunnelRatio: n, whiteFrameRatio: o, blackTunnelRatio: l, whiteTunnelAstronautRatio: c, isBlackTunnelActive: u, isWhiteTunnelActive: f, astronautDropRatio: p, blackTitleRatio: g} = goalTunnels;
        u && (fboHelper.copy(goalBlackTunnel.feedbackRenderTarget.texture, this.renderTarget),
        blur.blur(16, .5, this.renderTarget, this.interRenderTarget),
        blur.blur(4, .5, this.renderTarget, this.interRenderTarget)),
        this.showRatio = f ? math.smoothstep(0, .15, c) : 1,
        this.clonesShowRatio = math.smoothstep(.2, .4, l),
        this.partIdList.forEach(v => {
            this.meshes[v].material = this.materials[v][f ? "white" : "black"],
            this.cloneMeshes[v] && (this.cloneMeshes[v].visible = !f && this.clonesShowRatio > 0)
        }
        ),
        this.meshes.card.visible = p >= .95,
        this.sharedUniforms.u_bgColor.value.copy(properties.bgColor),
        this.sharedUniforms.u_showRatio.value = this.showRatio,
        this.blackTunnelUniforms.u_frameIn.value = t,
        this.blackTunnelUniforms.u_sunFactor.value = u ? 1 - math.smoothstep(.1, .2, l) : 1,
        this.blackTunnelUniforms.u_blackTunnelTexture.value = this.renderTarget.texture,
        this.blackTunnelUniforms.u_blackTunnelRatio.value = u ? math.smoothstep(.1, .3, l) : 0,
        this.blackTunnelUniforms.u_endRatio.value = u ? math.smoothstep(.65, .9, l) : 0,
        this.whiteTunnelUniforms.u_frameOutRatio.value = r,
        this.whiteTunnelUniforms.u_whiteTunnelRatio.value = n,
        this.whiteTunnelUniforms.u_tintColor.value.setStyle("#2533c2").multiplyScalar(math.fit(p, 1, 0, .2, 1) * (r > 0 ? 1 : 0)),
        this.cloneUniforms.u_alpha.value = this.clonesShowRatio,
        this.updateTransforms(e),
        this.updateAnimation(e),
        this.updateCard(e),
        this._cameraNeedsSync = !0,
        this.whiteTunnelUniforms.u_cardPosition.value.copy(this.transformObjectList[0].position),
        this.whiteTunnelUniforms.u_cardPosition.value.y += .9
    }
}
const goalTunnelAstronauts = new GoalTunnelAstronauts
  , blockVert = `#define GLSLIFY 1
attribute float a_instanceId;attribute vec2 uv2;uniform float u_time;uniform float u_ratio;uniform float u_ratioInverse;varying vec3 v_worldPosition;varying vec3 v_worldNormal;varying vec3 v_localPosition;varying vec2 v_uv;varying vec3 v_viewPosition;varying float v_lengthRatio;varying float v_fog;vec3 deform(in vec3 pos){float origZ=pos.z;float blockCount=float(BLOCK_COUNT);float ratio=mix(.1,1.,u_ratioInverse);float lengthRatio=-pos.z/blockCount;float scalar=mix(0.25,ratio,lengthRatio);pos.x*=1.0+scalar*0.5*sin(lengthRatio*6.283184);pos.y*=1.0+scalar*0.5*cos(lengthRatio*6.283184+3.1415926);float angleRatio=smoothstep(0.25,1.,u_ratioInverse);float angle=(angleRatio+angleRatio*lengthRatio*lengthRatio*1.)*-6.283184;float s=sin(angle);float c=cos(angle);mat2 m=mat2(c,-s,s,c);pos.xy=m*pos.xy;pos.y+=ratio*sin(ratio*lengthRatio*3.141592*4.)*0.25;pos.z-=(cos(ratio*1.5+(1.0-ratio)*lengthRatio*3.141592*0.5)*0.5+0.5-1.0)*blockCount;pos.z*=1.0+16.0*(ratio*lengthRatio*lengthRatio)+2.0*ratio*(sin(8.0*lengthRatio)*0.5+0.5);pos.z*=(1.-ratio*ratio*ratio)*0.9+0.1;pos.z+=blockCount/4.;return pos*15.;}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}void main(){float blockCount=float(BLOCK_COUNT);vec3 pos=position;pos.z-=a_instanceId;pos.z/=blockCount;float lengthRatio=-pos.z;pos.z*=blockCount;v_localPosition=pos;v_lengthRatio=lengthRatio;vec3 nor=deform(pos+normal*0.01);pos=deform(pos);nor=normalize(nor-pos);vec4 mvPosition=modelViewMatrix*vec4(pos,1.0);v_viewPosition=mvPosition.xyz;v_fog=-0.005*mvPosition.z/mvPosition.w;gl_Position=projectionMatrix*mvPosition;v_worldPosition=(modelMatrix*vec4(pos,1.0)).xyz;v_worldNormal=inverseTransformDirection(normalMatrix*nor,viewMatrix);v_uv=uv;}`
  , blockFrag = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform float u_ratioInverse;uniform vec3 u_fbm;varying vec3 v_localPosition;varying vec2 v_uv;varying vec3 v_worldPosition;varying vec3 v_worldNormal;varying vec3 v_viewPosition;varying float v_lengthRatio;varying float v_fog;uniform float u_time;float sphOcclusion(in vec3 pos,in vec3 nor,in vec4 sph){vec3 di=sph.xyz-pos;float l=length(di);float nl=dot(nor,di/l);float h=l/sph.w;float h2=h*h;float k2=1.0-h2*nl*nl;return max(0.0,nl)/h2;}float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}vec4 hash(vec4 p4){p4=fract(p4*vec4(.1031,.1030,.0973,.1099));p4+=dot(p4,p4.wzxy+33.33);return fract((p4.xxyz+p4.yzzw)*p4.zywx);}vec3 voronoi(const in vec4 x){vec4 p=floor(x);vec4 f=fract(x);float id=0.0;vec2 res=vec2(100.0);for(int l=-1;l<=1;l++){for(int k=-1;k<=1;k++){for(int j=-1;j<=1;j++){for(int i=-1;i<=1;i++){vec4 b=vec4(float(i),float(j),float(k),float(l));vec4 r=vec4(b)-f+hash(p+b);float d=dot(r,r);float cond=max(sign(res.x-d),0.0);float nCond=1.0-cond;float cond2=nCond*max(sign(res.y-d),0.0);float nCond2=1.0-cond2;id=(dot(p+b,vec4(1.0,57.0,113.0,421.))*cond)+(id*nCond);res=vec2(d,res.x)*cond+res*nCond;res.y=cond2*d+nCond2*res.y;}}}}return vec3(sqrt(res),abs(id));}vec4 hash(float p){vec4 p4=fract(vec4(p)*vec4(.1031,.1030,.0973,.1099));p4+=dot(p4,p4.wzxy+33.33);return fract((p4.xxyz+p4.yzzw)*p4.zywx);}void main(){vec4 sph=vec4(u_fbm.x*2.,u_fbm.y*2.+1.,0.,2.5);vec3 worldNormal=normalize(v_worldNormal);float ao=1.-sphOcclusion(v_worldPosition,worldNormal,sph)*2.*smoothstep(0.8,0.5,u_ratioInverse);float shade=texture2D(u_texture,v_uv).r;float brightness=pow(v_lengthRatio,5.);float t=u_ratioInverse*-2.+u_time*0.2;vec3 vn=voronoi(vec4(v_localPosition*2.+vec3(0.,0.,-t*0.5),t*0.25));vec4 rnd=hash(vn.z);float threshold=0.05+rnd.x*0.1;float r=abs(vn.x-.5)*(1.75+rnd.y*0.5);float pattern=max(0.,1.-smoothstep(threshold-fwidth(r),threshold,r));vec3 color=mix(vec3(0.102,0.184,0.984),vec3(1.),pattern);color*=(.35+shade)*ao;color+=brightness;gl_FragColor=vec4(color,shade+brightness);gl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(1.0),smoothstep(0.8,1.0,u_ratioInverse)*0.5);gl_FragColor.a*=ao*mix(1.,0.15,pattern);gl_FragColor+=linearStep(-10.,-11.,v_localPosition.z);}`;
class GoalWhiteTunnel {
    container = new Object3D;
    baseMesh;
    wallMesh;
    BLOCK_COUNT = 16;
    TEXTURE_SIZE = 1024;
    prevRatio = 0;
    pt0 = new Vector3;
    pt1 = new Vector3;
    pt2 = new Vector3;
    sharedUniforms = {
        u_texture: {
            value: null
        },
        u_ratioInverse: {
            value: 0
        },
        u_fbm: {
            value: null
        }
    };
    preInit() {
        this.fbm = new BrownianMotion,
        this.fbm._positionAmplitude = 2,
        this.fbm._positionFrequency = 1,
        this.sharedUniforms.u_fbm.value = this.fbm._position,
        this.sharedUniforms.u_texture.value = properties.loader.add(settings.TEXTURE_PATH + "tunnels/white_block.webp", {
            type: "texture"
        }).content,
        properties.loader.add(settings.MODEL_PATH + "tunnels/tunnel_block_base.buf", {
            onLoad: t => this._onTunnelBlockLoad(t, !1)
        }),
        properties.loader.add(settings.MODEL_PATH + "tunnels/tunnel_block_wall.buf", {
            onLoad: t => this._onTunnelBlockLoad(t, !0)
        });
        let e = new Mesh(new SphereGeometry(7.5,32,24),new MeshNormalMaterial);
        e.position.z = 0
    }
    _onTunnelBlockLoad(e, t) {
        let r = new InstancedBufferGeometry;
        for (let c in e.attributes)
            r.setAttribute(c, e.attributes[c]);
        r.setIndex(e.index);
        let n = new Float32Array(this.BLOCK_COUNT);
        for (let c = 0; c < this.BLOCK_COUNT; c++)
            n[c] = c;
        r.setAttribute("a_instanceId", new InstancedBufferAttribute(n,1));
        let o = {
            u_ratio: goalTunnels.sharedUniforms.u_whiteTunnelRatio,
            u_texture: this.sharedUniforms.u_texture,
            u_ratioInverse: this.sharedUniforms.u_ratioInverse,
            u_fbm: this.sharedUniforms.u_fbm,
            u_time: goalTunnels.sharedUniforms.u_tunnelTime
        }
          , l = new Mesh(r,new ShaderMaterial({
            uniforms: o,
            vertexShader: blockVert,
            fragmentShader: blockFrag,
            extensions: {
                derivatives: !0
            }
        }));
        l.material.defines.BLOCK_COUNT = this.BLOCK_COUNT,
        l.frustumCulled = !1,
        t ? (this.wallMesh = l,
        l.material.defines.IS_WALL = !0) : this.baseMesh = l,
        this.container.add(l)
    }
    init() {}
    resize(e, t) {}
    update(e) {
        this.sharedUniforms.u_ratioInverse.value = 1 - goalTunnels.whiteTunnelRatio,
        goalTunnels.properties.cameraDollyZoomFovOffset = math.fit(goalTunnels.whiteTunnelRatio, 0, 1, 60, 0);
        let t = goalTunnels.whiteTunnelRatio - this.prevRatio;
        goalTunnelEfx.offsetPostion.z = math.clamp(-t * math.fit(goalTunnels.whiteTunnelRatio, 0, .9, 500, 0, ease.sineOut), -1, 1),
        goalTunnelEfx.offsetRotation.z = math.clamp(-t * math.fit(goalTunnels.whiteTunnelRatio, 0, .8, 45, 0, ease.sineOut), -1, 1),
        this.fbm.update(e),
        goalTunnelEfx.amount = math.fit(goalTunnels.whiteTunnelRatio, .75, 1, 1, 0),
        this.prevRatio = goalTunnels.whiteTunnelRatio
    }
}
const goalWhiteTunnel = new GoalWhiteTunnel
  , vert$f = `#define GLSLIFY 1
attribute float piece;uniform sampler2D u_positionTexture;uniform sampler2D u_orientTexture;uniform vec2 u_textureSize;uniform float u_frameFrom;uniform float u_frameTo;uniform float u_frameRatio;uniform float u_fragmentScale;varying vec3 v_viewPosition;varying vec3 v_localDir;vec3 qrotate(vec4 q,vec3 v){return v+2.*cross(q.xyz,cross(q.xyz,v)+q.w*v);}void main(){vec4 animationUvs=(vec4(piece,u_frameFrom,piece,u_frameTo)+.5)/u_textureSize.xyxy;vec3 piecePosFrom=texture2D(u_positionTexture,animationUvs.xy).xyz;vec4 pieceOrientFrom=texture2D(u_orientTexture,animationUvs.xy);vec3 piecePosTo=texture2D(u_positionTexture,animationUvs.zw).xyz;vec4 pieceOrientTo=texture2D(u_orientTexture,animationUvs.zw);float radius=length(position)*u_fragmentScale;vec3 dir=position/radius;vec3 posFrom=qrotate(pieceOrientFrom,dir);vec3 posTo=qrotate(pieceOrientTo,dir);v_localDir=normalize(mix(posFrom,posTo,u_frameRatio));vec3 pos=v_localDir*radius+mix(piecePosFrom,piecePosTo,u_frameRatio);vec4 mvPosition=modelViewMatrix*vec4(pos,1.0);v_viewPosition=mvPosition.xyz;gl_Position=projectionMatrix*mvPosition;}`
  , frag$j = `#define GLSLIFY 1
uniform sampler2D u_backgroundTexture;uniform vec2 u_resolution;varying vec3 v_viewPosition;varying vec3 v_localDir;vec3 hue2RGBSmooth(in float hue){vec3 rgb=clamp(abs(mod(hue*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);return rgb*rgb*(3.0-2.0*rgb);}void main(){vec3 fdx=dFdx(v_viewPosition);vec3 fdy=dFdy(v_viewPosition);vec3 viewNormal=normalize(cross(fdx,fdy));float alpha=abs(1.-viewNormal.z);vec3 localDir=normalize(v_localDir);vec2 uv=gl_FragCoord.xy/u_resolution.xy;vec3 bgColor=texture2D(u_backgroundTexture,uv).rgb;vec2 refl=reflect(normalize(v_viewPosition),viewNormal).xy;vec2 uvOffset=refl.xy*0.2*vec2(u_resolution.x/u_resolution.y,1.);vec3 color=texture2D(u_backgroundTexture,uv+uvOffset).rgb;color+=clamp(abs(mod((alpha)*8.+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0)*(1.-alpha)*(1.-bgColor);gl_FragColor=vec4(color,alpha);}`;
class Ufx extends PostEffect {
    scene = new Scene;
    camera = new PerspectiveCamera(60,1);
    frameIdx = -1;
    sectionLayer = new Object3D;
    projectDetailsLayer = new Object3D;
    sharedUniforms = {
        u_fromTexture: {
            value: null
        }
    };
    init() {}
    setPostprocessing(e) {
        let t = this.camera
          , r = properties.viewportWidth
          , n = properties.viewportHeight;
        t.position.set(r / 2, -n / 2, n / (2 * Math.tan(t.fov * Math.PI / 360))),
        t.aspect = r / n,
        t.far = t.position.z * 2,
        t.near = t.far / 1e3,
        t.updateProjectionMatrix()
    }
    render(e, t=!1) {
        let r = fboHelper.getColorState()
          , n = properties.renderer;
        fboHelper.copy(e.fromTexture, e.sceneRenderTarget),
        n.setRenderTarget(e.sceneRenderTarget),
        fboHelper.renderer.autoClear = !1,
        fboHelper.renderer.autoClearColor = !1,
        fboHelper.renderer.autoClearStencil = !0,
        fboHelper.renderer.autoClearDepth = !0,
        fboHelper.renderer.clear(!1, !0, !0),
        n.render(this.scene, this.camera),
        n.setRenderTarget(null);
        let o = t ? null : e.toRenderTarget;
        fboHelper.copy(e.sceneTexture, o),
        fboHelper.setColorState(r),
        e.swap()
    }
}
class PreUfx extends Ufx {
    renderOrder = 50
}
const preUfx = new PreUfx;
let _matrixWorld = new Matrix4
  , _matrixWorldInverse = new Matrix4
  , _projectionMatrix = new Matrix4
  , _q$1 = new Quaternion
  , _v1$3 = new Vector3;
class GoalTunnelGlass {
    PIECE_COUNT = 946;
    domFrameHeight = 1;
    domFrameRotation = 0;
    domFrameScale = 1;
    fragmentScale = 1;
    container;
    mesh;
    _geometry;
    ratio = 0;
    frameCount = 0;
    sharedUniforms = {
        u_positionTexture: {
            value: null
        },
        u_orientTexture: {
            value: null
        },
        u_textureSize: {
            value: new Vector2(0,0)
        },
        u_frameFrom: {
            value: 0
        },
        u_frameTo: {
            value: 0
        },
        u_frameRatio: {
            value: 0
        },
        u_fragmentScale: {
            value: 0
        }
    };
    preInit() {
        this.container = new Object3D,
        properties.loader.add(settings.MODEL_PATH + "tunnels/broken_glass.buf", {
            onLoad: e => {
                this._onModelLoad(e)
            }
        }),
        properties.loader.add(settings.MODEL_PATH + "tunnels/broken_glass_animation.buf", {
            onLoad: e => {
                this._onAnimationLoad(e)
            }
        })
    }
    _onModelLoad(e) {
        this.mesh = new Mesh(e,new ShaderMaterial({
            uniforms: {
                u_backgroundTexture: properties.postprocessing.sharedUniforms.u_fromTexture,
                u_resolution: properties.sharedUniforms.u_resolution,
                u_positionTexture: this.sharedUniforms.u_positionTexture,
                u_orientTexture: this.sharedUniforms.u_orientTexture,
                u_textureSize: this.sharedUniforms.u_textureSize,
                u_frameFrom: this.sharedUniforms.u_frameFrom,
                u_frameTo: this.sharedUniforms.u_frameTo,
                u_frameRatio: this.sharedUniforms.u_frameRatio,
                u_fragmentScale: this.sharedUniforms.u_fragmentScale
            },
            vertexShader: vert$f,
            fragmentShader: frag$j,
            transparent: !0,
            extensions: {
                derivatives: !0
            }
        })),
        this.mesh.visible = !1,
        this.mesh.frustumCulled = !1,
        this.mesh.renderOrder = 1e3,
        this.container.add(this.mesh),
        this.mesh.onBeforeRender = this._onBeforeRender.bind(this),
        this.mesh.onAfterRender = this._onAfterRender.bind(this)
    }
    _onBeforeRender(e, t, r) {
        let n = cameraControls._camera;
        _matrixWorld.copy(r.matrixWorld),
        r.matrixWorld.copy(n.matrixWorld),
        _matrixWorldInverse.copy(r.matrixWorldInverse),
        r.matrixWorldInverse.copy(n.matrixWorldInverse),
        _projectionMatrix.copy(r.projectionMatrix),
        r.projectionMatrix.copy(n.projectionMatrix)
    }
    _onAfterRender(e, t, r) {
        this.container.parent == homePage.preUfxContainer && (r.matrixWorld.copy(_matrixWorld),
        r.matrixWorldInverse.copy(_matrixWorldInverse),
        r.projectionMatrix.copy(_projectionMatrix))
    }
    _onAnimationLoad(e) {
        let t = e.attributes.position.array
          , r = new Float32Array(t.length / 3 * 4)
          , n = this.frameCount = t.length / (this.PIECE_COUNT * 3);
        this.sharedUniforms.u_textureSize.value.set(this.PIECE_COUNT, n);
        for (let o = 0, l = 0; o < t.length; o += 3,
        l += 4)
            r[l + 0] = t[o + 0],
            r[l + 1] = t[o + 1],
            r[l + 2] = t[o + 2],
            r[l + 3] = 0;
        this.sharedUniforms.u_positionTexture.value = fboHelper.createDataTexture(r, this.PIECE_COUNT, n, !0, !0),
        this.sharedUniforms.u_orientTexture.value = fboHelper.createDataTexture(e.attributes.orient.array, this.PIECE_COUNT, n, !0, !0)
    }
    init() {
        taskManager.add(this.mesh)
    }
    resize(e, t) {}
    update(e) {
        if (this.mesh && this.container.visible)
            if (this.ratio > 0) {
                let t = cameraControls._camera;
                this.mesh.position.copy(t.position),
                this.mesh.quaternion.copy(t.quaternion),
                this.mesh.translateZ(-goalTunnels.EndCameraDepthToFrame);
                let r = Math.tan(t.fov * math.DEG2RAD / 2) * goalTunnels.EndCameraDepthToFrame * 2
                  , n = this.domFrameHeight / properties.viewportHeight;
                n *= r * this.domFrameScale,
                _q$1.setFromAxisAngle(_v1$3.set(0, 0, 1), -this.domFrameRotation),
                this.mesh.quaternion.multiply(_q$1),
                this.mesh.scale.setScalar(n);
                let o = this.ratio * (this.frameCount - 1)
                  , l = Math.floor(o)
                  , c = Math.min(l + 1, this.frameCount - 1)
                  , u = o - l;
                this.sharedUniforms.u_frameFrom.value = l,
                this.sharedUniforms.u_frameTo.value = c,
                this.sharedUniforms.u_frameRatio.value = u,
                this.sharedUniforms.u_fragmentScale.value = this.fragmentScale,
                this.mesh.visible = !0
            } else
                this.mesh.visible = !1
    }
}
const goalTunnelGlass = new GoalTunnelGlass
  , validateEmail = a => a.match(/^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/);
var toQuerystring_min = {
    exports: {}
};
(function(a, e) {
    (function(t, r) {
        a.exports = r()
    }
    )(commonjsGlobal$1, function() {
        return ( () => {
            var t = {
                d: (p, g) => {
                    for (var v in g)
                        t.o(g, v) && !t.o(p, v) && Object.defineProperty(p, v, {
                            enumerable: !0,
                            get: g[v]
                        })
                }
                ,
                o: (p, g) => Object.prototype.hasOwnProperty.call(p, g),
                r: p => {
                    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(p, Symbol.toStringTag, {
                        value: "Module"
                    }),
                    Object.defineProperty(p, "__esModule", {
                        value: !0
                    })
                }
            }
              , r = {};
            function n(p) {
                return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
                    return typeof g
                }
                : function(g) {
                    return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g
                }
                ,
                n(p)
            }
            t.r(r),
            t.d(r, {
                default: () => f
            });
            var o = encodeURIComponent;
            function l(p, g, v, _, w) {
                var S = _ && w.arrayPrefix || "";
                if (n(g) === "object") {
                    var b = "".concat(p).concat(S).concat(v && "]", "[");
                    return "".concat(u(g, "".concat(v).concat(b), w))
                }
                return v && v.length ? "".concat(v).concat(p, "]").concat(S, "=").concat(o(g)) : "".concat(p).concat(S, "=").concat(o(g))
            }
            function c(p, g, v, _) {
                return g.map(function(w) {
                    return l(p, w, v, !0, _)
                }).join("&")
            }
            function u(p) {
                var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ""
                  , v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                return (Array.isArray(p) ? p.map(function(_, w) {
                    return l("".concat(w), _, g, !0, v)
                }) : Object.keys(p).filter(function(_) {
                    return p[_] !== void 0
                }).map(function(_) {
                    return p[_] && Array.isArray(p[_]) ? c("".concat(_), p[_], g, v) : l(_, p[_], g, !1, v)
                })).join("&").replace(/%20/g, "+")
            }
            const f = u;
            return r
        }
        )()
    })
}
)(toQuerystring_min);
var toQuerystring_minExports = toQuerystring_min.exports;
const toQueryString = getDefaultExportFromCjs(toQuerystring_minExports);
var browser = {
    exports: {}
}
  , debug$1 = {
    exports: {}
}
  , s = 1e3
  , m = s * 60
  , h = m * 60
  , d = h * 24
  , y = d * 365.25
  , ms = function(a, e) {
    e = e || {};
    var t = typeof a;
    if (t === "string" && a.length > 0)
        return parse(a);
    if (t === "number" && isNaN(a) === !1)
        return e.long ? fmtLong(a) : fmtShort(a);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(a))
};
function parse(a) {
    if (a = String(a),
    !(a.length > 100)) {
        var e = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(a);
        if (e) {
            var t = parseFloat(e[1])
              , r = (e[2] || "ms").toLowerCase();
            switch (r) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
                return t * y;
            case "days":
            case "day":
            case "d":
                return t * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
                return t * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
                return t * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
                return t * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
                return t;
            default:
                return
            }
        }
    }
}
function fmtShort(a) {
    return a >= d ? Math.round(a / d) + "d" : a >= h ? Math.round(a / h) + "h" : a >= m ? Math.round(a / m) + "m" : a >= s ? Math.round(a / s) + "s" : a + "ms"
}
function fmtLong(a) {
    return plural(a, d, "day") || plural(a, h, "hour") || plural(a, m, "minute") || plural(a, s, "second") || a + " ms"
}
function plural(a, e, t) {
    if (!(a < e))
        return a < e * 1.5 ? Math.floor(a / e) + " " + t : Math.ceil(a / e) + " " + t + "s"
}
(function(a, e) {
    e = a.exports = n.debug = n.default = n,
    e.coerce = u,
    e.disable = l,
    e.enable = o,
    e.enabled = c,
    e.humanize = ms,
    e.names = [],
    e.skips = [],
    e.formatters = {};
    var t;
    function r(f) {
        var p = 0, g;
        for (g in f)
            p = (p << 5) - p + f.charCodeAt(g),
            p |= 0;
        return e.colors[Math.abs(p) % e.colors.length]
    }
    function n(f) {
        function p() {
            if (p.enabled) {
                var g = p
                  , v = +new Date
                  , _ = v - (t || v);
                g.diff = _,
                g.prev = t,
                g.curr = v,
                t = v;
                for (var w = new Array(arguments.length), S = 0; S < w.length; S++)
                    w[S] = arguments[S];
                w[0] = e.coerce(w[0]),
                typeof w[0] != "string" && w.unshift("%O");
                var b = 0;
                w[0] = w[0].replace(/%([a-zA-Z%])/g, function(R, T) {
                    if (R === "%%")
                        return R;
                    b++;
                    var M = e.formatters[T];
                    if (typeof M == "function") {
                        var P = w[b];
                        R = M.call(g, P),
                        w.splice(b, 1),
                        b--
                    }
                    return R
                }),
                e.formatArgs.call(g, w);
                var C = p.log || e.log || console.log.bind(console);
                C.apply(g, w)
            }
        }
        return p.namespace = f,
        p.enabled = e.enabled(f),
        p.useColors = e.useColors(),
        p.color = r(f),
        typeof e.init == "function" && e.init(p),
        p
    }
    function o(f) {
        e.save(f),
        e.names = [],
        e.skips = [];
        for (var p = (typeof f == "string" ? f : "").split(/[\s,]+/), g = p.length, v = 0; v < g; v++)
            p[v] && (f = p[v].replace(/\*/g, ".*?"),
            f[0] === "-" ? e.skips.push(new RegExp("^" + f.substr(1) + "$")) : e.names.push(new RegExp("^" + f + "$")))
    }
    function l() {
        e.enable("")
    }
    function c(f) {
        var p, g;
        for (p = 0,
        g = e.skips.length; p < g; p++)
            if (e.skips[p].test(f))
                return !1;
        for (p = 0,
        g = e.names.length; p < g; p++)
            if (e.names[p].test(f))
                return !0;
        return !1
    }
    function u(f) {
        return f instanceof Error ? f.stack || f.message : f
    }
}
)(debug$1, debug$1.exports);
var debugExports = debug$1.exports;
(function(a, e) {
    e = a.exports = debugExports,
    e.log = n,
    e.formatArgs = r,
    e.save = o,
    e.load = l,
    e.useColors = t,
    e.storage = typeof chrome < "u" && typeof chrome.storage < "u" ? chrome.storage.local : c(),
    e.colors = ["lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson"];
    function t() {
        return typeof window < "u" && window.process && window.process.type === "renderer" ? !0 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
    }
    e.formatters.j = function(u) {
        try {
            return JSON.stringify(u)
        } catch (f) {
            return "[UnexpectedJSONParseError]: " + f.message
        }
    }
    ;
    function r(u) {
        var f = this.useColors;
        if (u[0] = (f ? "%c" : "") + this.namespace + (f ? " %c" : " ") + u[0] + (f ? "%c " : " ") + "+" + e.humanize(this.diff),
        !!f) {
            var p = "color: " + this.color;
            u.splice(1, 0, p, "color: inherit");
            var g = 0
              , v = 0;
            u[0].replace(/%[a-zA-Z%]/g, function(_) {
                _ !== "%%" && (g++,
                _ === "%c" && (v = g))
            }),
            u.splice(v, 0, p)
        }
    }
    function n() {
        return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments)
    }
    function o(u) {
        try {
            u == null ? e.storage.removeItem("debug") : e.storage.debug = u
        } catch {}
    }
    function l() {
        var u;
        try {
            u = e.storage.debug
        } catch {}
        return !u && typeof process < "u" && "env"in process && (u = {}.DEBUG),
        u
    }
    e.enable(l());
    function c() {
        try {
            return window.localStorage
        } catch {}
    }
}
)(browser, browser.exports);
var browserExports = browser.exports
  , debug = browserExports("jsonp")
  , jsonp_1 = jsonp
  , count = 0;
function noop() {}
function jsonp(a, e, t) {
    typeof e == "function" && (t = e,
    e = {}),
    e || (e = {});
    var r = e.prefix || "__jp", n = e.name || r + count++, o = e.param || "callback", l = e.timeout != null ? e.timeout : 6e4, c = encodeURIComponent, u = document.getElementsByTagName("script")[0] || document.head, f, p;
    l && (p = setTimeout(function() {
        g(),
        t && t(new Error("Timeout"))
    }, l));
    function g() {
        f.parentNode && f.parentNode.removeChild(f),
        window[n] = noop,
        p && clearTimeout(p)
    }
    function v() {
        window[n] && g()
    }
    return window[n] = function(_) {
        debug("jsonp got", _),
        g(),
        t && t(null, _)
    }
    ,
    a += (~a.indexOf("?") ? "&" : "?") + o + "=" + c(n),
    a = a.replace("?&", "?"),
    debug('jsonp req "%s"', a),
    f = document.createElement("script"),
    f.src = a,
    u.parentNode.insertBefore(f, u),
    v
}
const jsonp$1 = getDefaultExportFromCjs(jsonp_1)
  , MAILCHIMP_URL = "https://lusion.us20.list-manage.com/subscribe/post?u=ea813c53ac6d7a0b76f2e36a1&amp;id=44b41b41bf&amp;v_id=4233&amp;f_id=001e18e7f0"
  , getAjaxUrl = a => a.replace("/post?", "/post-json?");
class NewletterForm {
    isSendingTheNewletterRequest = !1;
    domNewsletterForm;
    domNewsletterMessage;
    constructor(e, t, r) {
        this.domNewsletterForm = e,
        this.domNewsletterButton = t,
        this.domNewsletterMessage = r,
        this.domNewsletterForm.addEventListener("submit", this._onFormSubmit.bind(this))
    }
    _onFormSubmit(e) {
        if (e.preventDefault(),
        this.isSendingTheNewletterRequest)
            return;
        this.domNewsletterMessage.classList.remove("error"),
        this.domNewsletterMessage.innerHTML = "";
        const t = e.target
          , n = new FormData(t).get("EMAIL");
        if (!validateEmail(n)) {
            this.domNewsletterMessage.classList.add("error"),
            this.domNewsletterMessage.innerHTML = "The email is not valid!";
            return
        }
        this.isSendingTheNewletterRequest = !0,
        this.domNewsletterButton.disabled = !0;
        const o = getAjaxUrl(MAILCHIMP_URL) + "&" + toQueryString({
            EMAIL: n
        });
        jsonp$1(o, {
            param: "c"
        }, (l, c) => {
            l ? (this.domNewsletterMessage.classList.add("error"),
            this.domNewsletterMessage.innerHTML = "Something went wrong, try again") : c.result !== "success" ? (this.domNewsletterMessage.classList.add("error"),
            this.domNewsletterMessage.innerHTML = "Something went wrong, try again") : (this.domNewsletterMessage.innerHTML = "Almost there! Check your email box!",
            t.reset(),
            setTimeout( () => {
                this.domNewsletterMessage.innerHTML = ""
            }
            , 3e3)),
            this.isSendingTheNewletterRequest = !1,
            this.domNewsletterButton.disabled = !1
        }
        )
    }
}
class FooterSection {
    domContainer;
    offsetY = 0;
    _needsReset = !0;
    preInit() {
        this.domContainer = document.getElementById("footer-section"),
        this.domContactAddress = document.getElementById("footer-contact-address"),
        this.domContactAddress._words = [],
        this.domContactSocials = document.getElementById("footer-contact-socials"),
        this.domContactSocials._words = [],
        this.domContactEnquires = document.getElementById("footer-contact-enquires"),
        this.domContactEnquires._words = [],
        this.domContactBusiness = document.getElementById("footer-contact-business"),
        this.domContactBusiness._words = [],
        this.domNewsletterHeader = document.getElementById("footer-newsletter-header"),
        this.domNewsletterHeader._words = [],
        this.domNewsletterForm = document.getElementById("footer-newsletter-form"),
        this.domNewsletterMessage = document.getElementById("footer-newsletter-feedback-message"),
        this.domNewsletterInput = document.getElementById("footer-newsletter-input"),
        this.domNewsletterInput._time = 0,
        this.domNewsletterInput._animating = !1,
        this.domNewsletterBg = document.getElementById("footer-newsletter-bg"),
        this.domNewsletterButton = document.getElementById("footer-newsletter-input-arrow"),
        this.domFooterBottom = document.getElementById("footer-bottom"),
        this.domFooterBottom._time = 0,
        this.domFooterBottom._animating = !1,
        this.domFooterMiddle = document.getElementById("footer-middle"),
        this.domFooterBottomLabs = document.getElementById("footer-bottom-labs"),
        this.domFooterBottomCopyright = document.getElementById("footer-bottom-copyright"),
        this.domFooterBottomTagline = document.getElementById("footer-bottom-tagline"),
        this.domFooterBottomUp = document.getElementById("footer-bottom-up"),
        this.domFooterBottomUp._time = 0,
        this.domAddressLines = Array.from(document.querySelectorAll(".footer-address-line")),
        this.domSocialsLines = Array.from(document.querySelectorAll(".footer-socials-line")),
        this.domEnquiresLines = [document.getElementById("footer-enquires-header"), document.getElementById("footer-enquires-link")],
        this.domBusinessLines = [document.getElementById("footer-business-header"), document.getElementById("footer-business-link")],
        this.domNewsletterLines = Array.from(document.querySelectorAll(".footer-newsletter-line")),
        this.middleContainers = [this.domContactAddress, this.domContactSocials, this.domContactEnquires, this.domContactBusiness, this.domNewsletterHeader],
        this.bottomContainers = [this.domFooterBottomCopyright, this.domFooterBottomLabs, this.domFooterBottomTagline, this.domFooterBottomUp]
    }
    init() {
        this.formManager = new NewletterForm(this.domNewsletterForm,this.domNewsletterButton,this.domNewsletterMessage),
        this.domFooterBottomUp.addEventListener("click", this._onDomUpBtnClick.bind(this)),
        this._splitText()
    }
    resize(e, t) {
        let r = Array.from(this.domContactAddress.querySelectorAll(".footer-address-line-wrapper"))
          , n = this.domContactAddress.getBoundingClientRect();
        for (let o = 0; o < r.length; o++) {
            let l = r[o]
              , c = l.getBoundingClientRect();
            l.style.setProperty("--delta-x", n.right - c.right + "px")
        }
    }
    getDomRange() {
        return scrollManager.getDomRange(this.domContainer)
    }
    update(e) {
        let t = this.getDomRange();
        if (t.isActive) {
            if (this._needsReset && this._reset(),
            t.screenRatio > -.1 ? document.documentElement.classList.add("is-footer-in") : document.documentElement.classList.remove("is-footer-in"),
            properties.useMobileLayout)
                for (let l = 0; l < this.middleContainers.length; l++) {
                    let c = this.middleContainers[l];
                    for (let u = 0; u < c._words.length; u++) {
                        let f = c._words[u];
                        for (let p = 0; p < f.length; p++) {
                            let g = f[p]
                              , v = 0;
                            g.style.transform = `translate3d(0, ${v}em, 0)`
                        }
                    }
                }
            else
                for (let l = 0; l < this.middleContainers.length; l++) {
                    let c = this.middleContainers[l]
                      , u = scrollManager.getDomRange(c);
                    c._time = math.clamp(c._time + (c._animating ? e : -e), 0, 1 / 0);
                    for (let f = 0; f < c._words.length; f++) {
                        let p = c._words[f];
                        for (let g = 0; g < p.length; g++) {
                            let v = p[g]
                              , _ = math.fit(c._time - f / 10, 0, 1, 1.5, 0, ease.lusion);
                            v.style.transform = `translate3d(0, ${_}em, 0)`
                        }
                    }
                    u.screenRatio > -1 ? c._animating = !0 : c._animating = !1
                }
            let n = scrollManager.getDomRange(this.domNewsletterInput);
            this.domNewsletterInput._time = math.saturate(this.domNewsletterInput._time + (this.domNewsletterInput._animating ? e : -e)),
            n.screenRatio > -1 ? (this.domNewsletterInput._animating = !0,
            this.domNewsletterInput.classList.add("--active")) : (this.domNewsletterInput._animating = !1,
            this.domNewsletterInput.classList.remove("--active")),
            properties.useMobileLayout ? (this.domNewsletterBg.style.transform = "scale3d(1, 1, 1)",
            this.domNewsletterButton.style.transform = "scale(1)") : (this.domNewsletterBg.style.transform = `scale3d(${math.fit(this.domNewsletterInput._time, 0, 1, 0, 1, ease.lusion)}, 1, 1)`,
            this.domNewsletterButton.style.transform = `scale(${math.fit(this.domNewsletterInput._time - .8, 0, .2, 0, 1, ease.lusion)})`);
            let o = scrollManager.getDomRange(this.domFooterBottom);
            if (this.domFooterBottom._time = math.saturate(this.domFooterBottom._time + (this.domFooterBottom._animating ? e * 1 : -e * 1)),
            o.screenRatio > -1 ? this.domFooterBottom._animating = !0 : this.domFooterBottom._animating = !1,
            !properties.useMobileLayout)
                for (let l = 0; l < this.bottomContainers.length; l++) {
                    let c = this.bottomContainers[l];
                    if (l === this.bottomContainers.length - 1) {
                        let u = math.fit(this.domFooterBottom._time - .3, 0, .3, 0, 1, ease.lusion);
                        c.style.transform = `scale(${u})`
                    } else
                        for (let u = 0; u < c._splitted.words.length; u++) {
                            let f = c._splitted.words[u]
                              , p = math.fit(this.domFooterBottom._time - l / 10 - u / 10, 0, .6, 100, 0, ease.lusion);
                            f.style.transform = `translate3d(0, ${p}%, 0)`
                        }
                }
        } else
            this._needsReset = !0
    }
    _splitText() {
        for (let t = 0; t < this.bottomContainers.length; t++) {
            let r = this.bottomContainers[t];
            r._splitted = new SplitType(r,{
                types: "words"
            })
        }
        let e = [{
            lines: this.domAddressLines,
            parent: this.domContactAddress
        }, {
            lines: this.domSocialsLines,
            parent: this.domContactSocials
        }, {
            lines: this.domEnquiresLines,
            parent: this.domContactEnquires
        }, {
            lines: this.domBusinessLines,
            parent: this.domContactBusiness
        }, {
            lines: this.domNewsletterLines,
            parent: this.domNewsletterHeader
        }];
        for (let t = 0; t < this.bottomContainers.length; t++) {
            let r = this.bottomContainers[t];
            r._splitted = new SplitType(r,{
                types: "words"
            })
        }
        for (let t = 0; t < e.length; t++) {
            let r = e[t].lines
              , n = e[t].parent;
            for (let o = 0; o < r.length; o++) {
                let l = r[o];
                this._createWrapper(l, n)
            }
        }
    }
    _createWrapper(e, t) {
        let r = new SplitType(e,{
            types: "words"
        })
          , n = document.createElement("div");
        n.classList.add(e.classList[0] ? e.classList[0] + "-wrapper" : e.id + "-wrapper"),
        n.style.position = "relative",
        n.style.overflow = "hidden",
        n.style.display = "flex",
        n.style.flexDirection = "column",
        n.append(e),
        t.appendChild(n),
        t._words.push(r.words),
        t._time = 0,
        t._animating = !1,
        n._topWords = r.words
    }
    _reset() {
        this._needsReset = !1;
        for (let e = 0; e < this.middleContainers.length; e++) {
            let t = this.middleContainers[e];
            t._time = 0;
            for (let r = 0; r < t._words.length; r++) {
                let n = t._words[r];
                for (let o = 0; o < n.length; o++) {
                    let l = n[o];
                    l.style.transform = "translate3d(0, 0, 0)"
                }
            }
            t._animating = !1
        }
    }
    _onDomUpBtnClick() {
        scrollManager.scrollToPixel(0)
    }
}
const footerSection = new FooterSection;
class GoalSectionRanges {
    items = {};
    itemList = [{
        id: "blackFrameShow",
        isPixelBased: !0
    }, {
        id: "blackFrameIn",
        weight: 1
    }, {
        id: "blackTitle",
        weight: 5
    }, {
        id: "blackTunnel",
        weight: 12
    }, {
        id: "whiteTunnel",
        weight: 2
    }, {
        id: "whiteFrameOut",
        weight: 1
    }, {
        id: "whiteFrameBreak",
        weight: 1.5
    }, {
        id: "astronautDrop",
        isPixelBased: !0
    }, {
        id: "astronautWait",
        isPixelBased: !0
    }];
    offsetY = 0;
    prevRatio = null;
    ratio = null;
    wasActive = null;
    isActive = null;
    _cachedRanges = {};
    totalPixelCount = 0;
    totalTunnelWeight = 0;
    baseY = 0;
    domContainer;
    domImgIn;
    domImgOut;
    tick = 0;
    SHOW_DEBUG = !1;
    _debugTimeline;
    _debugTimelineItems = [];
    _debugTimelineIndicator;
    init(e) {
        this.domContainer = e.querySelector("#home-goal"),
        this.domImgIn = e.querySelector("#home-goal-image-in"),
        this.domImgOut = e.querySelector("#home-goal-image-out");
        for (let t = 0; t < this.itemList.length; t++) {
            let r = this.itemList[t];
            this.items[r.id] = r,
            r.weight && (this.totalTunnelWeight += r.weight)
        }
        if (this.SHOW_DEBUG) {
            this._debugTimeline = document.createElement("div"),
            this._debugTimeline.style = `
				position: fixed;
				bottom: 0;
				left: 0;
				zIndex: 1000;
				height: 4px;
				width: 100%;
				pointerEvents: none;
			`,
            document.body.appendChild(this._debugTimeline);
            for (let t = 0; t < this.itemList.length; t++) {
                let r = this._debugTimelineItems[t] = document.createElement("div");
                r.style = `
					position: absolute;
					left: 0;
					width: 100%;
					height: 100%;
					bottom: 0;
					background: ${t % 2 ? "green" : "blue"};
					transform-origin: 0 0;
				`,
                this._debugTimeline.appendChild(r)
            }
            this._debugTimelineIndicator = document.createElement("div"),
            this._debugTimelineIndicator.style = `
				position: position;
				left: -10px;
				top: -20px;
				width: 0;
				height: 0;
				border-style: solid;
				border-width: 20px 10px 0 10px;
				border-color: red transparent transparent transparent;
			`,
            this._debugTimeline.appendChild(this._debugTimelineIndicator)
        }
    }
    resize(e, t) {
        let r = scrollManager.getDomRange(this.domContainer)
          , n = scrollManager.getDomRange(this.domImgIn)
          , o = scrollManager.getDomRange(this.domImgOut);
        this.baseY = n.top - properties.viewportHeight;
        let c = r.bottom - this.baseY - (t + n.height) * .5 - (t + o.height) * .5;
        this.items.blackFrameShow.pixelCount = (t + n.height) * .5,
        this.items.astronautDrop.pixelCount = (t + o.height) * .5 + t;
        let u = scrollManager.getDomRange(footerSection.domContainer).bottom - r.bottom;
        this.items.astronautWait.pixelCount = u - 0 * this.items.astronautDrop.pixelCount,
        this.totalPixelCount = 0;
        for (let f = 0; f < this.itemList.length; f++) {
            let p = this.itemList[f];
            p.pixelFrom = this.totalPixelCount,
            p.weight && (p.pixelCount = c * p.weight / this.totalTunnelWeight),
            this.totalPixelCount += p.pixelCount,
            p.pixelTo = this.totalPixelCount
        }
        if (this.SHOW_DEBUG)
            for (let f = 0; f < this.itemList.length; f++) {
                let p = this.itemList[f]
                  , g = this._debugTimelineItems[f];
                g.style.transform = `translateX(${p.pixelFrom / this.totalPixelCount * e}px) scaleX(${p.pixelCount / this.totalPixelCount})`
            }
    }
    update(e) {
        this.tick++,
        this.offsetY = scrollManager.scrollPixel - this.baseY,
        this.prevRatio = this.ratio,
        this.ratio = this.offsetY / this.totalPixelCount,
        this.wasActive = this.isActive,
        this.isActive = this.ratio >= 0 && this.ratio < 1,
        this.SHOW_DEBUG && (this._debugTimelineIndicator.style.transform = `translateX(${this.ratio * properties.viewportWidth}px) translate3d(-50%, -20px, 0)`)
    }
    getRange(e, t=e) {
        let r = e + "-" + t
          , n = this._cachedRanges[r];
        return n || (n = this._cachedRanges[r] = {
            from: this.items[e],
            to: this.items[t]
        }),
        n.tick !== this.tick && (n.tick = this.tick,
        n.pixelFrom = n.from.pixelFrom,
        n.pixelTo = n.to.pixelTo,
        n.pixelCount = n.pixelTo - n.pixelFrom,
        n.pixel = scrollManager.scrollPixel - this.baseY - n.pixelFrom,
        n.ratio = n.pixel / n.pixelCount,
        n.isActive = n.ratio >= 0 && n.ratio < 1),
        n
    }
}
const homeGoalSectionRanges = new GoalSectionRanges
  , vert$e = `#define GLSLIFY 1
varying vec3 v_viewPosition;varying vec3 v_worldPosition;varying vec3 v_viewNormal;varying vec2 v_uv;varying vec3 v_localPosition;void main(){vec3 pos=position;pos.z*=0.1;vec4 mvPosition=modelViewMatrix*vec4(pos,1.);gl_Position=projectionMatrix*mvPosition;v_worldPosition=(modelMatrix*vec4(pos,1.)).xyz;v_viewNormal=normalMatrix*normal;v_viewPosition=-mvPosition.xyz;v_uv=uv;v_localPosition=pos;}`
  , frag$i = `#define GLSLIFY 1
varying vec3 v_viewPosition;varying vec3 v_worldPosition;varying vec3 v_viewNormal;varying vec2 v_uv;varying vec3 v_localPosition;uniform sampler2D u_earthTexture;uniform vec3 u_bgColor;uniform vec3 u_atmosphereColor;
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define saturate( a ) clamp( a, 0.0, 1.0 )
float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}
#include <getBlueNoise>
void main(){vec3 bn=getBlueNoise(gl_FragCoord.xy);float faceDirection=gl_FrontFacing ? 1.0 :-1.0;vec3 earthMap=texture2D(u_earthTexture,v_uv).rgb;gl_FragColor.rgb=earthMap;gl_FragColor.a=0.0;}`;
class GoalTunnelsBackground {
    container = new Object3D;
    mesh = null;
    constructor() {}
    preInit() {
        this.earthTexture = properties.loader.add(settings.TEXTURE_PATH + "tunnels/earth_landscape.jpg", {
            type: "texture",
            minFilter: LinearFilter
        }).content,
        properties.loader.add(settings.MODEL_PATH + "tunnels/earth_card.buf", {
            onLoad: e => {
                this.geo = e
            }
        })
    }
    init() {
        this.mesh = new Mesh(this.geo,new ShaderMaterial({
            uniforms: Object.assign({
                u_bgColor: {
                    value: new Color
                },
                u_atmosphereColor: {
                    value: new Color("#4169E1")
                },
                u_earthTexture: {
                    value: this.earthTexture
                }
            }, blueNoise.sharedUniforms),
            vertexShader: vert$e,
            fragmentShader: frag$i
        })),
        this.mesh.renderOrder = -1,
        this.mesh.frustumCulled = !1,
        this.container.add(this.mesh)
    }
    resize(e, t) {}
    update(e) {
        const t = math.saturate(homeGoalSectionRanges.getRange("blackFrameShow").ratio)
          , r = math.saturate(homeGoalSectionRanges.getRange("blackFrameIn").ratio);
        this.mesh.material.uniforms.u_bgColor.value.copy(properties.bgColor),
        this.mesh.position.y = -(10 * (1 - t) + 2.5 + 30 * r),
        this.mesh.scale.setScalar(math.fit(r, 0, .5, 40, 70)),
        this.container.rotation.x = math.fit(r, 0, .5, 0, -1),
        this.mesh.visible = r < 1
    }
}
const goalTunnelsBackground = new GoalTunnelsBackground
  , vert$d = `#define GLSLIFY 1
attribute vec3 a_instancePosition;attribute vec3 a_instanceRotationAxis;attribute vec4 a_instanceRand;attribute float thickness;uniform float u_time;uniform float u_aspect;uniform float u_activeRatio;varying vec3 v_viewNormal;varying float v_thickness;varying vec3 v_cameraPositionLS;varying vec3 v_positionLS;varying vec3 v_normalLS;varying vec4 v_orient;varying float v_fadeOut;
#ifndef HALF_PI
#define HALF_PI 1.5707963267948966
#endif
float elasticOut(float t){return sin(-13.0*(t+1.0)*HALF_PI)*pow(2.0,-10.0*t)+1.0;}float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}vec3 qrotate(vec4 q,vec3 v){return v+2.0*cross(q.xyz,cross(q.xyz,v)+q.w*v);}vec4 quaternion(vec3 axis,float halfAngle){return vec4(axis*sin(halfAngle),cos(halfAngle));}vec3 rotate(vec3 v,vec3 axis,float angle){vec4 q=quaternion(axis,angle*.5);return qrotate(q,v);}void main(){float time=0.5*u_time+4.*a_instanceRand.x;float scale=0.75;vec3 pos=position;vec4 orient=quaternion(a_instanceRotationAxis,(0.5+a_instanceRand.y)*time);pos=qrotate(orient,pos);pos*=scale;vec3 nor=qrotate(orient,normal);vec3 instancePosition=a_instancePosition;instancePosition.y+=0.5*u_time*(1.+a_instanceRand.x);float yLimit=20.0/u_aspect;instancePosition.y=mod(instancePosition.y,yLimit)-0.5*yLimit;v_fadeOut=abs(instancePosition.y)/(yLimit*0.5);pos*=linearStep(a_instanceRand.w*0.5,a_instanceRand.w*0.5+0.5,u_activeRatio);pos+=instancePosition;vec4 orientInv=vec4(-orient.xyz,orient.w);gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.);v_cameraPositionLS=qrotate(orientInv,(cameraPosition-instancePosition)/scale);v_positionLS=position*scale;v_normalLS=normal;v_orient=orient;v_viewNormal=normalMatrix*nor;v_thickness=thickness;}`
  , frag$h = `#define GLSLIFY 1
uniform vec3 u_color;uniform vec3 u_bgColor;uniform vec4 u_planes[25];uniform mat3 normalMatrix;varying vec3 v_viewNormal;varying float v_thickness;varying vec3 v_cameraPositionLS;varying vec3 v_positionLS;varying vec3 v_normalLS;varying vec4 v_orient;varying float v_fadeOut;float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}float plaIntersect(in vec3 ro,in vec3 rd,in vec4 p){return-(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);}vec4 getColorShade(vec3 dir,vec3 vn){float d=dot(dir,vn);float shade=(1.0-max(0.,vn.z))*v_thickness*5.;shade*=(pow(linearStep(2.,-1.,d),4.)*0.15+pow(linearStep(1.,-2.,d),5.)*7.);vec3 rgb=mix(vec3(0.8),clamp(abs(mod((d+vn.z)*12.+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0),1.-shade);return vec4((vec3(u_color)+rgb*1.2)*shade,0.035+(1.-v_thickness)*shade*shade)*(1.-abs(vn.z));}vec3 qrotate(vec4 q,vec3 v){return v+2.0*cross(q.xyz,cross(q.xyz,v)+q.w*v);}void main(){vec3 localDir=normalize(v_positionLS);vec3 viewNormal=normalize(v_viewNormal);float ior=2.418;vec3 norLS=normalize(v_normalLS);vec3 refrLS=refract(normalize(v_positionLS-v_cameraPositionLS),norLS,1./ior);float dist=100.;vec3 planeDir=vec3(0.);for(int i=0;i<25;i++){vec4 plane=u_planes[i];plane.xyz*=-1.;plane.w*=0.7501;float hitDist=plaIntersect(v_positionLS+refrLS*0.001,refrLS,plane);if(hitDist>0.&&hitDist<dist){dist=hitDist;planeDir=u_planes[i].xyz;}}vec3 refrPosLS=v_positionLS+refrLS*dist;refrLS=refract(refrLS,planeDir,ior);vec3 refrLocalDir=qrotate(v_orient,normalize(refrPosLS));vec3 viewPlaneNor=normalMatrix*qrotate(v_orient,planeDir);vec4 frontColorShade=getColorShade(localDir,viewNormal);vec4 backColorShade=getColorShade(refrLocalDir,viewPlaneNor);gl_FragColor=frontColorShade*1.5+vec4(backColorShade.rgb*0.75,backColorShade.a*.5);gl_FragColor.rgb=mix(u_bgColor,gl_FragColor.rgb,linearStep(0.0,0.1,1.0-v_fadeOut));}`
  , _v$1 = new Vector3;
class GoalWhiteTunnelParticles {
    PARTICLE_COUNT = 64;
    container = new Object3D;
    mesh = null;
    material = null;
    geometry = null;
    activeRatio = 0;
    constructor() {}
    preInit() {
        properties.loader.add(settings.MODEL_PATH + "tunnels/diamond.buf", {
            onLoad: e => this.geo = e
        })
    }
    init() {
        let e = this.geo
          , t = new InstancedBufferGeometry;
        for (let u in e.attributes)
            t.attributes[u] = e.attributes[u];
        t.index = e.index;
        let r = math.getSeedRandomFn("diamonds-3");
        const n = new Float32Array(this.PARTICLE_COUNT * 3)
          , o = new Float32Array(this.PARTICLE_COUNT * 3)
          , l = new Float32Array(this.PARTICLE_COUNT * 4);
        let c = [-.694747, .694747, .186157, -.239229, -.50859, .694747, .50859, -.239229, -.186157, .694747, .694747, -.239229, .186157, .694747, .694747, -.239229, .50859, .694747, .50859, -.239229, .694747, .694747, .186157, -.239229, .694747, .694747, -.186157, -.239229, .50859, .694747, -.50859, -.239229, .186157, .694747, -.694746, -.239229, -.186156, .694747, -.694747, -.239229, -.508589, .694747, -.50859, -.239229, -.694747, .694747, -.186157, -.239229, -.694747, -.694747, .186157, -.455518, -.50859, -.694747, .50859, -.455518, -.186157, -.694747, .694747, -.455518, .186157, -.694747, .694747, -.455518, .50859, -.694747, .50859, -.455518, .694746, -.694747, .186157, -.455518, .694746, -.694747, -.186157, -.455518, .50859, -.694747, -.50859, -.455518, .186157, -.694747, -.694746, -.455518, -.186156, -.694747, -.694747, -.455518, -.508589, -.694747, -.50859, -.455518, -.694747, -.694747, -.186157, -.455518, -0, -1, -0, -.34434];
        for (let u = 0, f = 0, p = 0; u < this.PARTICLE_COUNT; u++,
        f += 3,
        p += 4)
            n[f] = 16 * (r() * 2 - 1),
            n[f + 1] = 16 * (r() * 2 - 1),
            n[f + 2] = 19 - (this.PARTICLE_COUNT - u - 1) / (this.PARTICLE_COUNT - 1) * 8,
            _v$1.randomDirection(),
            o[f] = _v$1.x,
            o[f + 1] = _v$1.y,
            o[f + 2] = _v$1.z,
            l[p] = r(),
            l[p + 1] = r(),
            l[p + 2] = r(),
            l[p + 3] = r();
        t.setAttribute("a_instancePosition", new InstancedBufferAttribute(n,3)),
        t.setAttribute("a_instanceRotationAxis", new InstancedBufferAttribute(o,3)),
        t.setAttribute("a_instanceRand", new InstancedBufferAttribute(l,4)),
        this.material = new ShaderMaterial({
            vertexShader: vert$d,
            fragmentShader: frag$h,
            uniforms: {
                u_time: properties.sharedUniforms.u_time,
                u_activeRatio: {
                    value: 0
                },
                u_color: {
                    value: new Color("#689aff")
                },
                u_planes: {
                    value: c
                },
                u_bgColor: {
                    value: new Color
                },
                u_aspect: properties.sharedUniforms.u_aspect
            },
            transparent: !0,
            blending: CustomBlending,
            blendEquation: AddEquation,
            blendSrc: OneFactor,
            blendDst: ZeroFactor,
            blendEquationAlpha: AddEquation,
            blendSrcAlpha: OneFactor,
            blendDstAlpha: OneFactor
        }),
        this.mesh = new Mesh(t,this.material),
        this.mesh.frustumCulled = !1,
        this.container.add(this.mesh)
    }
    resize(e, t) {}
    update(e) {
        const {whiteTunnelWaitRatio: t} = goalTunnels;
        this.activeRatio = math.fit(t, 0, .2, 0, 1),
        this.container.visible = this.activeRatio > 0,
        this.material.uniforms.u_activeRatio.value = this.activeRatio,
        this.material.uniforms.u_bgColor.value.copy(properties.bgColor)
    }
}
const goalWhiteTunnelParticles = new GoalWhiteTunnelParticles
  , vert$c = `#define GLSLIFY 1
attribute float instanceId;attribute vec4 instanceUvInfo;attribute vec4 instanceRands;uniform float u_time;uniform float u_activeRatio;uniform float u_aspect;uniform vec2 u_textureSize;varying float v_fadeOut;varying vec2 v_uv;vec4 hash42(vec2 p){vec4 p4=fract(vec4(p.xyxy)*vec4(.1031,.1030,.0973,.1099));p4+=dot(p4,p4.wzxy+33.33);return fract((p4.xxyz+p4.yzzw)*p4.zywx);}vec2 rotate(vec2 v,float a){float s=sin(a);float c=cos(a);mat2 m=mat2(c,s,-s,c);return m*v;}float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main(){vec3 pos=position;pos.xy*=instanceUvInfo.zw*u_textureSize*0.01;float t=u_time*mix(0.05,0.1,instanceRands.x)+instanceRands.y;float cycle=floor(t);float ratio=fract(t);vec4 cycleRands=hash42(vec2(cycle,instanceId));pos.xy=rotate(pos.xy,instanceRands.z*6.28+sign(cycleRands.z-.5)*u_time*mix(.5,1.,cycleRands.y))*linearStep(instanceRands.w*0.5,instanceRands.w*0.5+0.5,u_activeRatio)*0.35;float yLimit=7.0/u_aspect;vec3 instancePos=vec3(mix(-5.,5.,cycleRands.x),yLimit*mix(-1.0,1.0,ratio),20.+instanceId/float(COUNT));pos+=instancePos;gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.0);v_uv=instanceUvInfo.xy+instanceUvInfo.zw*vec2(uv.x,1.-uv.y);v_uv.y=1.0-v_uv.y;v_fadeOut=2.0*abs(ratio-0.5);}`
  , frag$g = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec3 u_bgColor;varying vec2 v_uv;varying float v_fadeOut;float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main(){gl_FragColor=texture2D(u_texture,v_uv);gl_FragColor.rgb=mix(u_bgColor,gl_FragColor.rgb,linearStep(0.0,0.1,1.0-v_fadeOut));}`
  , goalWhiteTunnelStickerData = [{
    x: 1132,
    y: 3,
    w: 195,
    h: 195
}, {
    x: 744,
    y: 3,
    w: 195,
    h: 256
}, {
    x: 525,
    y: 3,
    w: 213,
    h: 282
}, {
    x: 242,
    y: 3,
    w: 277,
    h: 286
}, {
    x: 1055,
    y: 633,
    w: 209,
    h: 209
}, {
    x: 1076,
    y: 398,
    w: 209,
    h: 209
}, {
    x: 3,
    y: 772,
    w: 298,
    h: 249
}, {
    x: 945,
    y: 3,
    w: 181,
    h: 249
}, {
    x: 1291,
    y: 389,
    w: 160,
    h: 197
}, {
    x: 1055,
    y: 848,
    w: 83,
    h: 122
}, {
    x: 1132,
    y: 204,
    w: 167,
    h: 179
}, {
    x: 1270,
    y: 828,
    w: 192,
    h: 193
}, {
    x: 780,
    y: 265,
    w: 182,
    h: 167
}, {
    x: 564,
    y: 445,
    w: 294,
    h: 184
}, {
    x: 307,
    y: 683,
    w: 205,
    h: 334
}, {
    x: 864,
    y: 438,
    w: 206,
    h: 189
}, {
    x: 968,
    y: 258,
    w: 149,
    h: 134
}, {
    x: 734,
    y: 635,
    w: 165,
    h: 382
}, {
    x: 605,
    y: 291,
    w: 169,
    h: 141
}, {
    x: 302,
    y: 445,
    w: 256,
    h: 232
}, {
    x: 518,
    y: 683,
    w: 210,
    h: 266
}, {
    x: 242,
    y: 295,
    w: 357,
    h: 144
}, {
    x: 3,
    y: 3,
    w: 233,
    h: 469
}, {
    x: 905,
    y: 633,
    w: 144,
    h: 340
}, {
    x: 1270,
    y: 613,
    w: 187,
    h: 209
}, {
    x: 3,
    y: 478,
    w: 293,
    h: 288
}];
new Vector3;
class GoalWhiteTunnelStickers {
    COUNT = 26;
    container = new Object3D;
    mesh = null;
    material = null;
    geometry = null;
    textureSize = new Vector2(1465,1024);
    sharedUniforms = {
        u_texture: {
            value: null
        },
        u_textureSize: {
            value: this.textureSize
        },
        u_activeRatio: {
            value: 0
        }
    };
    preInit() {
        this.sharedUniforms.u_texture.value = properties.loader.add(settings.TEXTURE_PATH + "tunnels/" + (browser$1.isMobile ? "stickers_low.png" : "stickers.png"), {
            type: "texture"
        }).content
    }
    init() {
        let e = new PlaneGeometry(1,1)
          , t = new InstancedBufferGeometry;
        for (let l in e.attributes)
            t.attributes[l] = e.attributes[l];
        t.index = e.index;
        let r = new Float32Array(this.COUNT)
          , n = new Float32Array(this.COUNT * 4)
          , o = new Float32Array(this.COUNT * 4);
        for (let l = 0, c = 0, u = 0; l < this.COUNT; l++,
        c += 3,
        u += 4) {
            r[l] = l / this.COUNT;
            let f = goalWhiteTunnelStickerData[l % goalWhiteTunnelStickerData.length];
            n[u + 0] = f.x / this.textureSize.x,
            n[u + 1] = f.y / this.textureSize.y,
            n[u + 2] = f.w / this.textureSize.x,
            n[u + 3] = f.h / this.textureSize.y,
            o[u] = Math.random(),
            o[u + 1] = Math.random(),
            o[u + 2] = Math.random(),
            o[u + 3] = Math.random()
        }
        t.setAttribute("instanceId", new InstancedBufferAttribute(r,1)),
        t.setAttribute("instanceUvInfo", new InstancedBufferAttribute(n,4)),
        t.setAttribute("instanceRands", new InstancedBufferAttribute(o,4)),
        this.material = new ShaderMaterial({
            vertexShader: vert$c,
            fragmentShader: frag$g,
            uniforms: {
                u_time: properties.sharedUniforms.u_time,
                u_activeRatio: this.sharedUniforms.u_activeRatio,
                u_texture: this.sharedUniforms.u_texture,
                u_textureSize: this.sharedUniforms.u_textureSize,
                u_bgColor: {
                    value: new Color
                },
                u_aspect: properties.sharedUniforms.u_aspect
            },
            transparent: !0,
            blending: CustomBlending,
            blendEquation: AddEquation,
            blendSrc: SrcAlphaFactor,
            blendDst: OneMinusSrcAlphaFactor,
            blendEquationAlpha: AddEquation,
            blendSrcAlpha: ZeroFactor,
            blendDstAlpha: ZeroFactor
        }),
        this.material.defines.COUNT = this.COUNT,
        this.mesh = new Mesh(t,this.material),
        this.mesh.frustumCulled = !1,
        this.container.add(this.mesh)
    }
    resize(e, t) {}
    update(e) {
        const {whiteTunnelWaitRatio: t} = goalTunnels;
        this.activeRatio = math.fit(t, 0, .2, 0, 1),
        this.container.visible = this.activeRatio > 0,
        this.material.uniforms.u_activeRatio.value = this.activeRatio,
        this.material.uniforms.u_bgColor.value.copy(properties.bgColor)
    }
}
const goalWhiteTunnelStickers = new GoalWhiteTunnelStickers;
class GoalTunnels extends Stage3D {
    THRESHOLD = [0, .3, .8, 1];
    blackTitleRatio = 0;
    blackTunnelRatio = 0;
    whiteTunnelRatio = 0;
    frameHeight = 1;
    EndCameraDepthToFrame = 2;
    isBlackTitleActive = !1;
    isBlackTunnelActive = !1;
    isWhiteTunnelActive = !1;
    expectedFov = 45;
    freezeRatio = 0;
    tunnelDeltaTime = 1;
    tunnelTime = 1;
    sharedUniforms = {
        u_whiteTunnelRatio: {
            value: 0
        },
        u_tunnelTime: {
            value: 0
        }
    };
    constructor() {
        super({
            ratio: 0,
            properties: {
                defaultCameraPosition: new Vector3(0,0,25),
                defaultLookAtPosition: new Vector3(0,0,24),
                cameraLookStrength: .2,
                cameraLookEaseDamp: .1,
                bloomAmount: 0,
                cameraFov: 30,
                haloRGBShift: .015,
                clearAlpha: 0
            }
        })
    }
    preInit() {
        goalTunnelEfx.init(),
        properties.postprocessing.queue.push(goalTunnelEfx),
        goalTunnelAstronauts.preInit(),
        goalBlackTunnel.preInit(),
        goalWhiteTunnel.preInit(),
        goalTunnelsBackground.preInit(),
        goalWhiteTunnelParticles.preInit(),
        goalWhiteTunnelStickers.preInit(),
        this.add(goalTunnelsBackground.container),
        this.add(goalBlackTunnel.container),
        this.add(goalWhiteTunnel.container),
        this.add(goalWhiteTunnelParticles.container),
        this.add(goalWhiteTunnelStickers.container),
        goalTunnelGlass.preInit(),
        homePage.preUfxContainer.add(goalTunnelGlass.container)
    }
    init() {
        goalTunnelAstronauts.init(),
        goalBlackTunnel.init(),
        goalWhiteTunnel.init(),
        goalTunnelGlass.init(),
        goalTunnelsBackground.init(),
        goalWhiteTunnelParticles.init(),
        goalWhiteTunnelStickers.init(),
        this.resetAstronautLayer(),
        taskManager.add(this)
    }
    resize(e, t) {
        goalTunnelAstronauts.resize(e, t),
        goalBlackTunnel.resize(e, t),
        goalWhiteTunnel.resize(e, t),
        goalTunnelsBackground.resize(e, t),
        goalWhiteTunnelParticles.resize(e, t),
        goalWhiteTunnelStickers.resize(e, t)
    }
    updateRatios() {
        this.blackFrameInRatio = math.saturate(homeGoalSectionRanges.getRange("blackFrameIn").ratio),
        this.blackTitleRatio = math.saturate(homeGoalSectionRanges.getRange("blackTitle").ratio),
        this.blackTunnelRatio = math.saturate(homeGoalSectionRanges.getRange("blackTunnel").ratio),
        this.whiteFrameRatio = math.saturate(homeGoalSectionRanges.getRange("whiteTunnel").ratio),
        this.whiteFrameOutRatio = math.saturate(homeGoalSectionRanges.getRange("whiteFrameOut").ratio),
        this.whiteFrameBreakRatio = math.saturate(homeGoalSectionRanges.getRange("whiteFrameBreak").ratio),
        this.astronautDropRatio = math.saturate(homeGoalSectionRanges.getRange("whiteFrameBreak", "astronautDrop").ratio),
        this.whiteTunnelRatio = math.saturate(homeGoalSectionRanges.getRange("whiteTunnel", "whiteFrameOut").ratio),
        this.whiteTunnelAstronautRatio = math.saturate(homeGoalSectionRanges.getRange("whiteTunnel", "whiteFrameBreak").ratio),
        this.whiteTunnelAstronautOutRatio = math.saturate(homeGoalSectionRanges.getRange("whiteFrameBreak", "astronautWait").ratio),
        this.whiteTunnelWaitRatio = math.saturate(homeGoalSectionRanges.getRange("astronautWait").ratio);
        let e = this.isBlackTunnelActive
          , t = this.isWhiteTunnelActive;
        this.isBlackTitleActive = this.blackTitleRatio < 1,
        this.isBlackTunnelActive = this.blackTunnelRatio < 1 && !this.isBlackTitleActive,
        this.isWhiteTunnelActive = this.whiteTunnelRatio <= 1 && !this.isBlackTunnelActive && !this.isBlackTitleActive,
        goalBlackTunnel.container.visible = this.isBlackTunnelActive,
        goalWhiteTunnel.container.visible = this.isWhiteTunnelActive && this.astronautDropRatio < 1,
        goalTunnelGlass.container && (goalTunnelGlass.container.visible = goalTunnelGlass.container.visible && this.astronautDropRatio < 1,
        goalTunnelGlass.fragmentScale = math.fit(this.astronautDropRatio, .75, 1, 1, 0)),
        (this.isWhiteTunnelActive && !t || this.isBlackTunnelActive && !e) && (goalTunnelEfx.needsSync = !0),
        this.sharedUniforms.u_whiteTunnelRatio.value = this.whiteTunnelRatio;
        let r = math.mix(this.frameHeight, properties.viewportHeight, this.blackFrameInRatio < 1 ? this.blackFrameInRatio : 1 - this.whiteFrameRatio)
          , n = this.expectedFov / 180 * Math.PI
          , o = this.defaultCameraPosition.distanceTo(this.defaultLookAtPosition)
          , l = Math.tan(n / 2) * o * 2 * properties.viewportHeight / r;
        this.properties.cameraFov = Math.atan(l / 2 / o) * 2 / Math.PI * 180,
        goalTunnelEfx.offsetPostion.set(0, 0, 0),
        goalTunnelEfx.offsetRotation.set(0, 0, 0),
        goalTunnelEfx.offsetScale.set(1, 1, 1),
        goalTunnelEfx.amount = 1
    }
    syncProperties(e) {
        this.properties.haloStrength = this.blackFrameInRatio * (math.mix(0, .15, this.blackTitleRatio) + math.fit(this.blackTunnelRatio, .2, .4, 0, .25)),
        this.properties.haloStrength = math.fit(this.blackTunnelRatio, .65, .75, this.properties.haloStrength, .08),
        this.properties.bloomSaturation = this.blackTunnelRatio < 1 ? math.fit(this.blackTunnelRatio, 0, .7, 1, 3) : 1,
        this.isWhiteTunnelActive ? (this.properties.bloomAmount = this.astronautDropRatio < 1 ? math.fit(this.whiteFrameRatio, 0, .05, 4, 2) : math.fit(this.whiteTunnelWaitRatio, 0, .1, 0, 20),
        this.properties.haloStrength = 0,
        this.properties.clearAlpha = math.fit(this.whiteTunnelWaitRatio, 0, .1, .3, 0),
        this.properties.cameraNear = 1,
        this.properties.cameraFar = 200) : (this.properties.bloomAmount = math.fit(this.blackTitleRatio, 0, .25, 30, 6),
        this.properties.cameraNear = 1,
        this.properties.cameraFar = 200),
        this.properties.cameraLookStrength = .08 * math.smoothstep(.5, 1, this.blackTitleRatio) + .02,
        this.properties.cameraLookStrength *= this.whiteTunnelRatio > 0 ? math.fit(this.whiteTunnelAstronautOutRatio, .75, 1, 0, .5) : 1,
        this.properties.cameraLookStrength = math.fit(this.whiteTunnelWaitRatio, 0, .1, this.properties.cameraLookStrength, .05),
        this.freezeRatio += ((input.isDown ? 1 : 0) - this.freezeRatio) * .1,
        this.tunnelDeltaTime = math.fit(this.freezeRatio, 0, 1, 1, .3) * e,
        this.tunnelDeltaTime = math.fit(this.blackFrameInRatio, 0, 1, e, this.tunnelDeltaTime),
        this.tunnelDeltaTime = math.fit(this.whiteTunnelAstronautOutRatio, .5, .75, this.tunnelDeltaTime, e),
        this.tunnelTime += this.tunnelDeltaTime,
        this.sharedUniforms.u_tunnelTime.value = this.tunnelTime,
        this.properties.autoScrollSpeed = (1 - this.freezeRatio) * input.lastScrollYDirection * 2.5 * math.fit(this.blackFrameInRatio, 0, .5, 0, 1) * math.fit(this.whiteTunnelWaitRatio, 0, .25, 1, 0)
    }
    resetAstronautLayer() {
        this.add(goalTunnelAstronauts.container)
    }
    update(e) {
        this.isBlackTitleActive && properties.bgColor.setStyle("#000"),
        this.isBlackTunnelActive && (properties.bgColor.setStyle("#000"),
        goalBlackTunnel.update(this.tunnelDeltaTime)),
        this.isWhiteTunnelActive && (properties.bgColor.setStyle(this.astronautDropRatio < 1 ? "#fff" : "#000"),
        goalWhiteTunnel.update(this.tunnelDeltaTime),
        this.whiteTunnelRatio == 1 && this.astronautDropRatio < 1 && homePage.preUfxContainer.add(goalTunnelAstronauts.container)),
        goalTunnelAstronauts.update(this.tunnelDeltaTime),
        goalTunnelGlass.update(e),
        goalTunnelsBackground.update(e),
        goalWhiteTunnelParticles.update(e),
        goalWhiteTunnelStickers.update(e)
    }
}
const goalTunnels = new GoalTunnels
  , frameBgVert = `#define GLSLIFY 1
attribute vec2 position;uniform vec2 u_viewportResolution;uniform vec2 u_frameOffset;uniform float u_frameScale;uniform float u_frameRotate;uniform vec2 u_domXY;uniform vec2 u_domWH;uniform vec2 u_dom2Offset;uniform vec2 u_dom2WH;varying vec2 v_uv;varying vec2 v_uv2;mat2 getRotation2D(float a){float s=sin(a);float c=cos(a);return mat2(c,-s,s,c);}void main(){v_uv=position*0.5+0.5;v_uv.y=1.0-v_uv.y;v_uv=(v_uv*u_viewportResolution-u_domXY-u_domWH*0.5);v_uv-=u_frameOffset;v_uv=getRotation2D(u_frameRotate)*v_uv;v_uv/=u_frameScale;v_uv2=v_uv+(-u_dom2Offset);v_uv2=(v_uv2+u_dom2WH*0.5)/u_dom2WH;v_uv=(v_uv+u_domWH*0.5)/u_domWH;gl_Position=vec4(position,0.0,1.0);}`
  , frameBgFrag = `#define GLSLIFY 1
uniform sampler2D u_dom2Texture;uniform vec3 u_bgColor;uniform vec2 u_domWH;uniform vec2 u_dom2WH;uniform float u_globalRadius;uniform float u_radiusScale;uniform vec3 u_glowColor;uniform float u_glowRadius;uniform float u_glowUpperBound;uniform float u_glowPow;uniform float u_glowTint;varying vec2 v_uv;varying vec2 v_uv2;float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}float sdRoundedBox(in vec2 p,in vec2 b,in float r){vec2 q=abs(p)-b+r;return min(max(q.x,q.y),0.0)+length(max(q,0.0))-r;}float getRoundedCornerMask(vec2 uv,vec2 size,float radius,float ratio){vec2 halfSize=size*0.5;float maxDist=length(halfSize);float minSize=min(halfSize.x,halfSize.y);float maxSize=max(halfSize.x,halfSize.y);float t=ratio*maxDist;radius=mix(minSize*linearStep(0.,minSize,t),radius,linearStep(maxSize,maxDist,t));halfSize=min(halfSize,vec2(t));float d=sdRoundedBox((uv-.5)*size,halfSize,radius);return smoothstep(0.,0.-fwidth(d),d);}float sdBox(in vec2 p,in vec2 b){vec2 w=abs(p)-b;vec2 s=vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);float g=max(w.x,w.y);return(g>0.0)?length(max(w,0.0)):g;}void main(){vec3 map=texture2D(u_dom2Texture,v_uv2).rgb;float opacity=1.-getRoundedCornerMask(v_uv,u_domWH,u_globalRadius*u_radiusScale,1.);vec3 color=u_bgColor;float shadow=1.0;vec2 lightPos=vec2(2.,1.5);vec2 tabletSize=vec2(u_domWH.x/u_domWH.y,1.);float tabletRadiusOffset=0.05;vec2 pos=(v_uv*2.-1.)*tabletSize;vec2 toLight=normalize(lightPos-pos);float dist=sdBox(pos,tabletSize-tabletRadiusOffset)-u_glowRadius-tabletRadiusOffset;color=mix(u_glowColor,color,pow(linearStep(0.,u_glowUpperBound,dist),u_glowPow));color=mix(color,mix(map.ggg,map.ggg*u_glowColor,u_glowTint),1.-map.r);gl_FragColor=vec4(color,opacity);}`;
class HomeGoalSectionTunnelTitle {
    domContainer;
    domLines;
    domLineWords = [];
    totalLineHeight = 0;
    RATIO_FROM = .25;
    RATIO_TO = 1;
    init(e) {
        this.domContainer = e.querySelector("#home-goal-tunnel-title"),
        this.domLines = e.querySelectorAll(".home-goal-tunnel-title-line");
        for (let t = 0; t < this.domLines.length; t++) {
            let r = this.domLines[t]
              , o = r.textContent.replace(/\s+/g, " ").split(" ")
              , l = "";
            for (let c = 0; c < o.length; c++)
                l += "<span>" + o[c] + "</span>";
            r.innerHTML = l,
            this.domLineWords[t] = r.querySelectorAll("span")
        }
    }
    resize(e, t) {
        this.domContainer.style.transform = "translateZ(0)";
        let r = this.domContainer.getBoundingClientRect()
          , n = r.width
          , o = r.left;
        this._resetWords();
        for (let l = 0; l < this.domLineWords.length; l++) {
            let c = this.domLineWords[l]
              , u = n;
            for (let p = 0; p < c.length; p++) {
                let g = c[p];
                g._domRect = g.getBoundingClientRect(),
                g._centerX = g._domRect.left + g._domRect.width * .5,
                u -= g._domRect.width
            }
            let f = 0;
            for (let p = 0; p < c.length; p++) {
                let g = c[p];
                g._offsetX = -g._domRect.left + o + f,
                f += g._domRect.width + u / (c.length - 1)
            }
        }
        this.totalLineHeight = this.domLines[this.domLines.length - 1].getBoundingClientRect().bottom - this.domLines[0].getBoundingClientRect().top
    }
    _resetWords() {
        this.domContainer.style.transform = "translateZ(0)";
        for (let e = 0; e < this.domLineWords.length; e++) {
            let t = this.domLineWords[e];
            for (let r = 0; r < t.length; r++) {
                let n = t[r];
                n.style.transform = "translateZ(0)"
            }
        }
    }
    update(e) {
        let t = homeGoalSectionRanges.getRange("blackTitle")
          , r = math.fit(t.ratio, this.RATIO_FROM, this.RATIO_TO, 0, 1);
        if (e = e && r % 1 > 0,
        this.domContainer.style.visibility = e ? "visible" : "hidden",
        e) {
            let n = math.fit(r, .5, 1, 1, 12, ease.cubicIn)
              , o = math.fit(r, .9, 1, 1, 0)
              , l = math.fit(r, .4, .6, 0, 1, ease.cubicInOut);
            n *= math.fit(r, 0, .15, .85, 1, ease.cubicOut),
            o *= math.fit(r, 0, .05, 0, 1);
            let c = homeGoalSectionRanges.offsetY - properties.viewportHeight * .5;
            this.domContainer.style.transform = "translate3d(0," + c + "px,0) scale(" + n + ")  translateY(" + -this.totalLineHeight * .5 + "px) translateY(0.25em)",
            this.domContainer.style.opacity = o;
            for (let u = 0; u < this.domLineWords.length; u++) {
                let f = this.domLineWords[u];
                for (let p = 0; p < f.length; p++) {
                    let g = f[p];
                    g.style.transform = "translateX(" + l * g._offsetX + "px)"
                }
            }
        }
    }
}
const homeGoalSectionTunnelTitle = new HomeGoalSectionTunnelTitle
  , TITLE_STAGGER$1 = 40
  , TITLE_DELAY = .4;
let _m$1 = new Matrix4
  , _q = new Quaternion
  , _e = new Euler
  , _c0 = new Color;
class GoalSection {
    domContainer;
    domContext;
    domContextInner;
    domImgIn;
    domImgInInner;
    domImgOut;
    domImgOutInner;
    frameBgMesh;
    _placeholderTexture1;
    _placeholderTexture2;
    offsetY = 0;
    radiusRatio = 0;
    uiBgColorNeedsOverride = !1;
    isUIBgBlack = !1;
    _needsReset = !0;
    sectionPaddingTop = 0;
    line = null;
    preInit(e) {
        homeGoalSectionRanges.init(e),
        this.domContainer = e.querySelector("#home-goal"),
        this.domContext = e.querySelector("#home-goal-context"),
        this.domContextInner = e.querySelector("#home-goal-context-inner"),
        this.domTitle = e.querySelector("#home-goal-title"),
        this.domTitle._time = 0,
        this.domTitle._animating = !1,
        this.domDescs = e.querySelector("#home-goal-texts"),
        this.domImgIn = e.querySelector("#home-goal-image-in"),
        this.domImgInInner = e.querySelector("#home-goal-image-in-inner"),
        this.domImgOut = e.querySelector("#home-goal-image-out"),
        this.domImgOutInner = e.querySelector("#home-goal-image-out-inner"),
        this.frameBgMesh = new UfxMesh({
            geometry: fboHelper.triGeom,
            material: fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_bgColor: {
                        value: new Color
                    },
                    u_frameOffset: {
                        value: new Vector2
                    },
                    u_frameScale: {
                        value: 1
                    },
                    u_frameRotate: {
                        value: 0
                    },
                    u_radiusScale: {
                        value: 0
                    },
                    u_glowColor: {
                        value: new Color(0,0,0)
                    },
                    u_glowRadius: {
                        value: .11
                    },
                    u_glowUpperBound: {
                        value: .5
                    },
                    u_glowPow: {
                        value: .1
                    },
                    u_glowTint: {
                        value: 0
                    },
                    u_dom2Offset: {
                        value: new Vector2
                    },
                    u_dom2WH: {
                        value: new Vector2
                    },
                    u_dom2Texture: {
                        value: null
                    },
                    u_viewportResolution: properties.sharedUniforms.u_viewportResolution,
                    u_time: properties.sharedUniforms.u_time,
                    u_globalRadius: properties.sharedUniforms.u_globalRadius
                },
                vertexShader: frameBgVert,
                fragmentShader: frameBgFrag,
                depthTest: !1,
                depthWrite: !1,
                derivatives: !0,
                transparent: !0,
                blending: NormalBlending
            })
        }),
        this.frameBgMesh.renderOrder = -1,
        homePage.preUfxContainer.add(this.frameBgMesh),
        this.frameBgMesh.visible = !1,
        homeGoalSectionTunnelTitle.init(e),
        visuals.stage3DList.push(goalTunnels),
        goalTunnels.preInit(),
        this.lineVisual = new Line(1),
        this.lineVisual.preInit()
    }
    init() {
        this._placeholderTexture1 = properties.loader.load(settings.TEXTURE_PATH + "/tunnels/tablet.png", {
            type: "texture",
            flipY: !1,
            minFilter: LinearFilter
        }).content,
        this._placeholderTexture2 = properties.loader.load(settings.TEXTURE_PATH + "/tunnels/desktop.png", {
            type: "texture",
            flipY: !1,
            minFilter: LinearFilter
        }).content,
        goalTunnels.init(),
        this.lineVisual.init(),
        homePage.postUfxContainer.add(this.lineVisual.container)
    }
    show() {}
    hide() {}
    resize(e, t) {
        this._splitText(),
        scrollManager.resize(e, t),
        homeGoalSectionRanges.resize(e, t),
        goalTunnelGlass.resize(e, t),
        homeGoalSectionTunnelTitle.resize(e, t),
        goalTunnels.resize(properties.width, properties.height),
        this.lineVisual.resize(e, t),
        this.sectionPaddingTop = parseFloat(getComputedStyle(this.domContainer).getPropertyValue("padding-top"))
    }
    update(e) {
        homeGoalSectionRanges.update(e);
        let t = scrollManager.getDomRange(this.domContainer)
          , r = t.isActive
          , n = scrollManager.getDomRange(this.domImgIn)
          , o = scrollManager.getDomRange(this.domImgInInner)
          , l = scrollManager.getDomRange(this.domImgOut)
          , c = scrollManager.getDomRange(this.domImgOutInner)
          , u = 0;
        goalTunnels.isActive = homeGoalSectionRanges.isActive && properties.hasInitialized,
        goalTunnels.resetAstronautLayer(),
        goalTunnelGlass.container && (goalTunnelGlass.container.visible = !1),
        this.uiBgColorNeedsOverride = goalTunnels.isActive,
        this.uiBgColorNeedsOverride && (this.isUIBgBlack = homeGoalSectionRanges.getRange("blackTitle", "blackTunnel").isActive || homeGoalSectionRanges.getRange("whiteFrameOut", "astronautWait").isActive);
        let f = 0, p = 1, g, v, _ = homeGoalSectionRanges.getRange("blackFrameIn");
        if (properties.useMobileLayout ? this.domDescs.style.transform = "translateZ(0)" : this.domDescs.style.transform = "translate3d(0," + (n._top - this.sectionPaddingTop - t._top + n.height * .5) + "px,0) translateY(-50%)",
        goalTunnels.isActive) {
            let C = this.frameBgMesh.material.uniforms, R = math.saturate(homeGoalSectionRanges.ratio), T, M, P = 0, I = 1, k = 0, A = 0, O = 0, W = 0, Q = C.u_glowColor.value;
            goalTunnels.ratio = R;
            let H = textureHelper.blackTexture
              , B = 0
              , D = homeGoalSectionRanges.getRange("blackTunnel")
              , q = homeGoalSectionRanges.getRange("blackFrameShow")
              , V = homeGoalSectionRanges.getRange("whiteFrameOut")
              , J = homeGoalSectionRanges.getRange("whiteFrameBreak")
              , U = homeGoalSectionRanges.getRange("whiteFrameBreak", "astronautDrop")
              , ce = homeGoalSectionRanges.getRange("astronautDrop");
            homeGoalSectionTunnelTitle.update(!0);
            let ee = U.ratio
              , ne = ce.ratio
              , ae = 0;
            P = math.saturate(_.ratio);
            let ve = 0;
            if (D.ratio < 1)
                T = n,
                M = o,
                u = Math.max(0, homeGoalSectionRanges.offsetY - _.pixelFrom),
                ae = u,
                f = P * .4,
                ve = 0,
                k = math.fit(P, 0, 1, .11, -.5),
                A = math.fit(P, 0, 1, .25, 2),
                O = math.fit(P, 0, 1, .06, .3),
                Q.setStyle(properties.blackColorHex).lerp(_c0.setStyle(properties.offWhiteColorHex), P),
                this._placeholderTexture1 && this._placeholderTexture1.image.width && (H = this._placeholderTexture1);
            else {
                T = l,
                M = c;
                let Se = -properties.viewportHeight * .5 - l.top + n.top - l.height * .5;
                if (u = homeGoalSectionRanges.offsetY + Se,
                ne < 1 && (u = math.clamp(u, 0, J.pixelTo + Se)),
                ve = 0,
                P = math.fit(homeGoalSectionRanges.offsetY, V.pixelFrom, V.pixelTo, 1, 0),
                B = Math.max(0, homeGoalSectionRanges.offsetY - ce.pixelFrom),
                f = P * -.3,
                ee < 0)
                    W = .8,
                    Q.setStyle(properties.blackColorHex);
                else {
                    k = -.5,
                    A = math.fit(ee, 0, .15, 0, .8),
                    A = math.fit(ee, .15, .3, A, 2),
                    O = math.fit(ee, 0, .1, .3, 1),
                    O = math.fit(ee, .1, 1, O, .2),
                    W = .5;
                    let Ce = math.fit(ee, 0, .1, 1, 0);
                    Ce = math.fit(ee, .1, .8, Ce, .85),
                    Q.setStyle(properties.blueColorHex).lerp(_c0.setStyle(properties.blackColorHex), Ce)
                }
                this._placeholderTexture2 && this._placeholderTexture2.image.width && (H = this._placeholderTexture2),
                goalTunnelGlass.domFrameHeight = l.height,
                goalTunnelGlass.domFrameRotation = f,
                goalTunnelGlass.container && (goalTunnelGlass.container.visible = !0),
                I = 0
            }
            let Y = properties.viewportHeight * .2 * (1 - math.saturate(q.ratio))
              , $ = Math.sqrt(properties.viewportWidth * properties.viewportWidth + properties.viewportHeight * properties.viewportHeight);
            p = math.mix(1, $ / Math.min(T.width, T.height), P),
            goalTunnelGlass.domFrameScale = p,
            ne < 1 ? g = properties.viewportWidth * .5 - T.left - T.width * .5 : g = 0,
            v = -(T.top + Y - scrollManager.scrollPixel + T.height * .5 - properties.viewportHeight * .5 + u),
            goalTunnels.frameHeight = T.height,
            goalTunnelAstronauts.extraCameraViewportOffsetX = -math.fit(U.ratio, 0, 1, 0, -T.left - T.width * .5 + properties.viewportWidth * .5, ease.cubicInOut),
            goalTunnelAstronauts.extraCameraViewportOffsetY = -B,
            properties.cameraViewportOffsetX = g * (1 - P),
            properties.cameraViewportOffsetY = v * (1 - P),
            C.u_dom2Texture.value = H,
            C.u_frameOffset.value.set(g * P, v * P),
            C.u_frameScale.value = p,
            C.u_frameRotate.value = f,
            C.u_radiusScale.value = I,
            C.u_bgColor.value.setStyle(R < .5 ? properties.offWhiteColorHex : properties.blackColorHex),
            C.u_glowRadius.value = k,
            C.u_glowUpperBound.value = A,
            C.u_glowPow.value = O,
            C.u_glowTint.value = W,
            properties.screenPaintOffsetRatio = 1 - P,
            this.frameBgMesh.syncRect(T.left, T.top + Y, T.width, T.height),
            this.frameBgMesh.update(-scrollManager.scrollPixel + u),
            this.frameBgMesh.visible = P < 1,
            this.frameBgMesh.visible = P < 1 && ne < 1,
            goalTunnelGlass.ratio = math.fit(U.ratio, 0, 1, 0, 1, ease.sineOut),
            goalTunnelGlass.container && (goalTunnelGlass.container.visible = goalTunnelGlass.container.visible && goalTunnelGlass.ratio > 0),
            C.u_dom2Offset.value.set(M.left + M.width * .5 - T.left - T.width * .5, M.top + M.height * .5 - T.top - T.height * .5 + ve),
            C.u_dom2WH.value.set(M.width, M.height),
            this.domContextInner.style.transform = `translate3d(0, ${ae}px, 0)`,
            this.domContextInner.style.visibility = this.frameBgMesh.visible ? "visible" : "hidden";
            let L = scrollManager.getDomRange(this.domContext)
              , N = properties.viewportWidth * .5 - L.screenX - properties.cameraViewportOffsetX
              , oe = properties.viewportHeight * .5 - L.screenY - properties.cameraViewportOffsetY - ae;
            this.domContextInner.style.transformOrigin = "0 0",
            this.domContextInner.style.transform = `translate3d(${N}px, ${oe + ae}px, 0) scale(${p}) rotate(${f}rad) translate3d(${-N + g * P}px, ${-oe + v * P}px, 0) `;
            let pe = properties.viewportWidth * .5 - properties.cameraViewportOffsetX
              , K = -properties.viewportHeight * .5 + properties.cameraViewportOffsetY;
            if (pe *= -1,
            K *= -1,
            D.ratio < 1) {
                let Se = this.lineVisual.container.matrix;
                Se.makeTranslation(pe, K, 0),
                _e.set(0, 0, -f),
                _q.setFromEuler(_e),
                _m$1.makeRotationFromQuaternion(_q),
                Se.premultiply(_m$1),
                _m$1.makeScale(p, p, p),
                Se.premultiply(_m$1),
                _m$1.makeTranslation(-pe, -K, 0),
                Se.premultiply(_m$1),
                Se.decompose(this.lineVisual.container.position, this.lineVisual.container.quaternion, this.lineVisual.container.scale),
                this.lineVisual.update(e, t, u)
            }
        } else
            this.lineVisual.update(e, t),
            this.frameBgMesh.visible = !1,
            this.domContextInner.style.visibility = r ? "visible" : "hidden",
            this.domContextInner.style.transform = "translateZ(0)",
            this.lineVisual.container.position.set(0, 0, 0),
            this.lineVisual.container.quaternion.set(0, 0, 0, 1),
            this.lineVisual.container.scale.set(1, 1, 1),
            homeGoalSectionTunnelTitle.update(!1);
        _.ratio >= 1 && (this.lineVisual.container.visible = !1),
        goalTunnels.updateRatios();
        let w = scrollManager.getDomRange(this.domContext, -u)
          , S = w
          , b = properties.useMobileLayout ? 0 : 800;
        if (t.screenRatio < -.8 && t.screenRatio !== -1) {
            if (this.domTitle._time = math.clamp(this.domTitle._time + (this.domTitle._animating ? e : -e), 0, 2),
            w.screenRatio > -1) {
                this.domTitle._animating = !0;
                let C = math.fit(t.showScreenOffset, 0, 1.5, b * -.2, 0);
                this.domTitle.style.transform = `translate3d(0, ${C}px, 0)`,
                properties.useMobileLayout || this.domTitle._splitted.words.forEach( (R, T) => {
                    let M = math.fit(this.domTitle._time - TITLE_DELAY - T / TITLE_STAGGER$1, 0, 1, 200, 0, ease.lusion)
                      , P = math.fit(this.domTitle._time - T / TITLE_STAGGER$1, 0, 1, 100, 0, ease.lusion);
                    R.style.transform = `translate3d(${M}px, ${P}%, 0)`
                }
                )
            }
            S.screenRatio > -1,
            this._needsReset && this._reset()
        } else
            this._needsReset = !0
    }
    _splitText() {
        properties.useMobileLayout ? this.domTitle._splitted && this.domTitle._splitted.revert() : (this.domTitle._splitted = new SplitType(this.domTitle,{
            types: "words, lines",
            charClass: "goal-title-char"
        }),
        this.domTitle._splitted.lines.forEach(e => {
            const t = document.createElement("div");
            t.style.position = "relative",
            t.style.overflow = "hidden",
            t.classList.add("goal-title-line-wrapper"),
            t.append(e),
            this.domTitle.append(t)
        }
        ))
    }
    _reset() {
        this.domTitle._splitted && (this._needsReset = !1,
        this.domTitle._time = 0,
        this.domTitle._animating = !1,
        properties.viewportWidth > settings.MOBILE_WIDTH && this.domTitle._splitted.words.forEach(e => {
            e.style.transform = "translate3d(100%, 100%, 0)"
        }
        ))
    }
}
const homeGoalSection = new GoalSection
  , vertexShader = `#define GLSLIFY 1
attribute float branchRatio;attribute vec3 branchSplinePos;attribute vec3 leafAxis;attribute float leafRatio;attribute float meshId;uniform float u_time;uniform float u_delay;uniform vec3 u_bbMin;uniform vec3 u_bbMax;uniform float u_angleForce;varying vec3 v_position;vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}
#define F4 0.309016994374947451
vec4 simplexNoiseDerivatives(vec4 v_0){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v_0+dot(v_0,vec4(F4)));vec4 x0=v_0-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 values0=vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2));vec2 values1=vec2(dot(p3,x3),dot(p4,x4));vec3 m0=max(0.5-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.5-vec2(dot(x3,x3),dot(x4,x4)),0.0);vec3 temp0=-6.0*m0*m0*values0;vec2 temp1=-6.0*m1*m1*values1;vec3 mmm0=m0*m0*m0;vec2 mmm1=m1*m1*m1;float dx=temp0[0]*x0.x+temp0[1]*x1.x+temp0[2]*x2.x+temp1[0]*x3.x+temp1[1]*x4.x+mmm0[0]*p0.x+mmm0[1]*p1.x+mmm0[2]*p2.x+mmm1[0]*p3.x+mmm1[1]*p4.x;float dy=temp0[0]*x0.y+temp0[1]*x1.y+temp0[2]*x2.y+temp1[0]*x3.y+temp1[1]*x4.y+mmm0[0]*p0.y+mmm0[1]*p1.y+mmm0[2]*p2.y+mmm1[0]*p3.y+mmm1[1]*p4.y;float dz=temp0[0]*x0.z+temp0[1]*x1.z+temp0[2]*x2.z+temp1[0]*x3.z+temp1[1]*x4.z+mmm0[0]*p0.z+mmm0[1]*p1.z+mmm0[2]*p2.z+mmm1[0]*p3.z+mmm1[1]*p4.z;float dw=temp0[0]*x0.w+temp0[1]*x1.w+temp0[2]*x2.w+temp1[0]*x3.w+temp1[1]*x4.w+mmm0[0]*p0.w+mmm0[1]*p1.w+mmm0[2]*p2.w+mmm1[0]*p3.w+mmm1[1]*p4.w;return vec4(dx,dy,dz,dw)*49.0;}vec4 toQuaternion(float angle,vec3 axis){float half_angle=angle/2.0;vec4 q;q.x=axis.x*sin(half_angle);q.y=axis.y*sin(half_angle);q.z=axis.z*sin(half_angle);q.w=cos(half_angle);return q;}vec3 qrotate(vec4 q,vec3 v){return v+2.*cross(q.xyz,cross(q.xyz,v)+q.w*v);}void main(){vec3 pos=position;vec3 worldPosition=(modelMatrix*vec4(pos,1.0)).xyz;float time=u_delay+0.2*u_time;float branchNoiseStrength=0.001;vec3 branchOffset=branchNoiseStrength*branchRatio*branchRatio*simplexNoiseDerivatives(vec4(pos,time)).xyz;branchOffset+=vec3(-1.0,0.0,0.0)*u_angleForce*branchRatio*branchRatio*0.1;if(meshId>0.0){vec3 toBranchSpline=pos-branchSplinePos;float angle=0.005*simplexNoiseDerivatives(vec4(branchRatio*0.5,u_time,meshId,1.0)).x;angle-=0.5*sign(leafAxis.z)*leafRatio*leafRatio*u_angleForce;vec4 q=toQuaternion(angle,leafAxis);toBranchSpline=qrotate(q,toBranchSpline);pos=branchSplinePos+branchOffset+toBranchSpline;}else{pos+=branchOffset;}vec4 mvPosition=modelViewMatrix*vec4(pos,1.0);gl_Position=projectionMatrix*mvPosition;v_position=pos;}`
  , fragmentShader$3 = `#define GLSLIFY 1
uniform vec3 u_bbMin;uniform vec3 u_bbMax;uniform vec3 u_mask;varying vec3 v_position;void main(){gl_FragColor.rgb=u_mask*vec3((v_position.x-u_bbMin.x)/(u_bbMax.x-u_bbMin.x));gl_FragColor.a=1.0;}`
  , vert$b = `#define GLSLIFY 1
attribute float centroidY;uniform mat4 u_shadowViewMatrixCamera;uniform mat4 u_shadowProjectionMatrixCamera;uniform mat4 u_shadowModelMatrixCamera;uniform vec3 u_shadowProjPosition;varying vec3 v_worldPosition;
#include <ufxVert>
varying vec2 v_uv;void main(){vec3 basePos=getBasePosition(position);vec3 screenPos=getScreenPosition(basePos);gl_Position=projectionMatrix*modelViewMatrix*vec4(screenPos,1.0);v_uv=padUv(uv);vec4 worldPosition=modelMatrix*vec4(position,1.0);v_worldPosition=worldPosition.xyz;}`
  , frag$f = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform sampler2D u_shadowTexture;uniform vec3 u_shadowProjPosition;uniform mat4 u_shadowViewMatrixCamera;uniform mat4 u_shadowProjectionMatrixCamera;uniform mat4 u_shadowModelMatrixCamera;uniform vec3 u_bgColor;uniform float u_plantsShadow;uniform vec3 u_previewBgColor;uniform float u_previewBgThreshold;uniform bool u_isVertical;uniform float u_scrollXStrength;uniform float u_activeRatio;varying vec2 v_uv;varying vec3 v_worldPosition;
#include <getBlueNoise>
void main(){vec3 noise=getBlueNoise(gl_FragCoord.xy+vec2(22.,45.));vec2 imageUv=v_uv;float moveAxis=u_isVertical ? 1.-v_uv.y : v_uv.x;float waveOffset=cos(moveAxis*6.2831853)*2.*u_scrollXStrength*u_scrollXStrength;vec2 imageUvOffsetBit=vec2(0.0,0.0);if(u_isVertical){imageUv.x+=waveOffset;imageUvOffsetBit.y=u_scrollXStrength/8.;}else{imageUv.y+=waveOffset;imageUvOffsetBit.x=u_scrollXStrength/8.;}imageUv+=imageUvOffsetBit*noise.x;vec4 image=vec4(0.0,0.0,0.0,0.0);vec4 baseColor=vec4(u_bgColor,0.0);for(int i=0;i<8;i++){vec4 texel=texture2D(u_texture,imageUv);image+=mix(baseColor,texel,texel.a);imageUv+=imageUvOffsetBit;}image/=8.;vec3 worldPosition=v_worldPosition;worldPosition.z+=mix(0.0,-4.,image.a);vec3 projectorDirection=normalize(u_shadowProjPosition-worldPosition);float projectorDistance=length(u_shadowProjPosition-worldPosition);vec4 texCoords=u_shadowViewMatrixCamera*vec4(worldPosition,1.0);vec2 shadowUv=(texCoords.xy/texCoords.w)*0.9;shadowUv.y=1.0-shadowUv.y;vec4 shadowImage=texture2D(u_shadowTexture,shadowUv);float shadow=max(shadowImage.r,max(shadowImage.g,shadowImage.b));shadow=mix(0.,mix(shadow,0.35+shadow*0.65,image.w),u_activeRatio);vec3 color=image.rgb;color=mix(color,u_previewBgColor,smoothstep(u_previewBgThreshold,u_previewBgThreshold+fwidth(moveAxis),moveAxis));color*=mix(1.0,u_plantsShadow,shadow);gl_FragColor=vec4(color,1.);}`
  , _v3 = new Vector3;
let _c1$2 = new Color;
new Color;
class ProjectDetailsScreen {
    screenRT;
    screenCamera;
    screenScene = new Scene;
    screenMesh;
    shadowContainer = new Object3D;
    shadowCamera;
    shadowRt;
    shadowBlurRt1;
    shadowBlurRt2;
    shadowBlurRt3;
    shadowFinalRt;
    plantGeo;
    plantMaterial;
    plantMesh0;
    plantMesh1;
    plantMesh2;
    velocity = new Vector2;
    mouse = new Vector2;
    angleForce = 0;
    angleForceEased = 0;
    shadow = 1;
    previewBgThreshold = 1;
    previewColorRatio = 0;
    previewBgColorDefaultColorHex = "#F3F4F9";
    previewBgColorHex = "#000";
    sharedUniforms = {
        u_shadowTexture: {
            value: null
        },
        u_shadowViewMatrixCamera: {
            value: new Matrix4
        },
        u_shadowProjectionMatrixCamera: {
            value: new Matrix4
        },
        u_shadowModelMatrixCamera: {
            value: new Matrix4
        },
        u_shadowProjPosition: {
            value: new Vector3
        }
    };
    preInit(e) {
        this.screenCamera = new OrthographicCamera(-1,1,1,-1,0,200),
        this.screenCamera.position.set(0, 0, 100),
        this.screenRT = fboHelper.createRenderTarget(1, 1),
        this.screenMesh = new UfxMesh({
            refDom: e,
            uniforms: Object.assign({
                u_texture: {
                    value: this.screenRT.texture
                },
                u_bgColor: projectDetailsSection.sharedUniforms.u_bgColor,
                u_previewBgColor: {
                    value: new Color("#f00")
                },
                u_previewBgThreshold: {
                    value: 1
                },
                u_plantsShadow: {
                    value: 1
                },
                u_scrollXStrength: {
                    value: 0
                },
                u_activeRatio: {
                    value: 0
                },
                u_isVertical: projectDetailsSection.sharedUniforms.u_isVertical
            }, this.sharedUniforms, blueNoise.sharedUniforms),
            vertexShader: vert$b,
            fragmentShader: frag$f,
            depthWrite: !0,
            depthTest: !0,
            transparent: !1
        }),
        projectPage.preUfxContainer.add(this.screenMesh),
        properties.loader.add(settings.MODEL_PATH + "plant.buf", {
            onLoad: t => this.plantGeo = t
        }),
        this.shadowRT = fboHelper.createRenderTarget(1, 1),
        this.shadowBlurRT1 = fboHelper.createRenderTarget(1, 1),
        this.shadowBlurRT2 = fboHelper.createRenderTarget(1, 1),
        this.shadowBlurRT3 = fboHelper.createRenderTarget(1, 1),
        this.shadowFinalRt = fboHelper.createRenderTarget(1, 1),
        this.shadowCamera = new OrthographicCamera(-1,1,1,-1,.001,50),
        this.sharedUniforms.u_shadowTexture.value = this.shadowFinalRt.texture
    }
    init() {
        this.shadowCamera.position.set(0, 0, 10),
        this.shadowCamera.lookAt(.2, 0, 0),
        this.shadowCamera.zoom = 2500,
        this.shadowCamera.updateProjectionMatrix(),
        this.shadowCamera.updateMatrixWorld(),
        this.shadowCamera.updateWorldMatrix(),
        this.plantGeo.computeBoundingBox();
        const e = new ShaderMaterial({
            uniforms: {
                u_time: properties.sharedUniforms.u_time,
                u_bbMin: {
                    value: this.plantGeo.boundingBox.min
                },
                u_bbMax: {
                    value: this.plantGeo.boundingBox.max
                },
                u_delay: {
                    value: 0
                },
                u_angleForce: {
                    value: 0
                },
                u_mask: {
                    value: new Vector3
                }
            },
            vertexShader,
            fragmentShader: fragmentShader$3,
            side: 2
        });
        e.uniforms.u_mask.value.set(1, 0, 0),
        this.plantMesh0 = new Mesh(this.plantGeo,e),
        this.plantMesh0.position.set(-.55, -.8, -5),
        this.plantMesh0.rotation.set(0, -.2, -.2);
        const t = e.clone();
        t.uniforms.u_time = properties.sharedUniforms.u_time,
        t.uniforms.u_mask.value.set(0, 1, 0),
        this.plantMesh1 = new Mesh(this.plantGeo,t),
        this.plantMesh1.position.set(-.75, -.8, 0),
        this.plantMesh1.rotation.set(0, .2, -.5);
        const r = e.clone();
        r.uniforms.u_time = properties.sharedUniforms.u_time,
        r.uniforms.u_mask.value.set(0, 0, 1),
        this.plantMesh2 = new Mesh(this.plantGeo,r),
        this.plantMesh2.position.set(-.45, -.8, 5),
        this.plantMesh2.rotation.set(.3, .3, .1),
        this.shadowContainer.add(this.plantMesh0),
        this.shadowContainer.add(this.plantMesh1),
        this.shadowContainer.add(this.plantMesh2),
        this.plantMesh0.onBeforeRender = this._onPlantMeshRender.bind(this, this.plantMesh0),
        this.plantMesh1.onBeforeRender = this._onPlantMeshRender.bind(this, this.plantMesh1),
        this.plantMesh2.onBeforeRender = this._onPlantMeshRender.bind(this, this.plantMesh2)
    }
    _onPlantMeshRender(e) {
        let t = e.material.uniforms.u_mask.value;
        properties.gl.colorMask(t.x == 1, t.y == 1, t.z == 1, !0)
    }
    resize() {
        let e = properties.width
          , t = properties.height;
        this.screenMesh.syncDom(0),
        this.screenRT.setSize(e, t);
        let r = properties.viewportWidth
          , n = properties.viewportHeight;
        this.screenCamera.left = -r * .5,
        this.screenCamera.right = r * .5,
        this.screenCamera.top = n * .5,
        this.screenCamera.bottom = -n * .5;
        const o = .75;
        let l = Math.ceil(o * e)
          , c = Math.ceil(o * t);
        this.shadowRT.setSize(l, c),
        this.shadowFinalRt.setSize(l, c),
        this.shadowCamera.left = -r * .5,
        this.shadowCamera.right = r * .5,
        this.shadowCamera.top = n * .5,
        this.shadowCamera.bottom = -n * .5,
        this.shadowCamera.updateProjectionMatrix()
    }
    update(e) {
        if (!this.plantMesh0)
            return;
        let t = projectDetailsSection.scrollPane;
        _v3.set(-.1, .1, 10),
        _v3.x += .03 * input.mouseXY.x,
        _v3.y += .015 * input.mouseXY.y,
        this.shadowCamera.position.lerp(_v3, 4 * e),
        this.shadowCamera.lookAt(-.1, 0, 0),
        this.shadowCamera.updateProjectionMatrix(),
        this.shadowCamera.updateMatrixWorld(),
        this.shadowCamera.updateWorldMatrix(),
        this.angleForce += Math.abs(t.scrollViewDelta),
        this.angleForceEased = math.mix(this.angleForceEased, this.angleForce, .02);
        const r = math.clamp(this.angleForce - this.angleForceEased, -1, 1);
        this.sharedUniforms.u_shadowViewMatrixCamera.value.copy(this.shadowCamera.matrixWorldInverse),
        this.sharedUniforms.u_shadowProjectionMatrixCamera.value.copy(this.shadowCamera.projectionMatrix),
        this.sharedUniforms.u_shadowModelMatrixCamera.value.copy(this.shadowCamera.matrixWorld),
        this.sharedUniforms.u_shadowProjPosition.value.copy(this.shadowCamera.position),
        fboHelper.copy(textureHelper.transparentTexture, this.shadowFinalRt);
        const n = fboHelper.getColorState();
        let o = fboHelper.renderer.getRenderTarget()
          , l = fboHelper.renderer;
        l.setRenderTarget(this.shadowRT),
        l.setClearColor(0, 0),
        this.plantMesh0.material.uniforms.u_delay.value = 0,
        this.plantMesh1.material.uniforms.u_delay.value = .2,
        this.plantMesh2.material.uniforms.u_delay.value = .5,
        this.plantMesh0.material.uniforms.u_angleForce.value = r,
        this.plantMesh1.material.uniforms.u_angleForce.value = r,
        this.plantMesh2.material.uniforms.u_angleForce.value = r,
        fboHelper.renderMesh(this.shadowContainer, this.shadowRT, this.shadowCamera),
        properties.gl.colorMask(!0, !0, !0, !0),
        blur.blur(2, 1, this.shadowRT, this.shadowBlurRT1),
        textureHelper.mixChannels(this.shadowRT.texture, this.shadowFinalRt, 0, -1, -1, -1),
        blur.blur(4, .5, this.shadowRT, this.shadowBlurRT2),
        textureHelper.mixChannels(this.shadowRT.texture, this.shadowFinalRt, -1, 1, -1, -1),
        blur.blur(4, .75, this.shadowRT, this.shadowBlurRT3),
        textureHelper.mixChannels(this.shadowRT.texture, this.shadowFinalRt, -1, -1, 2, -1),
        l.setRenderTarget(null),
        this.screenCamera.position.x = properties.viewportWidth * .5,
        this.screenCamera.position.y = -properties.viewportHeight * .5,
        this.screenCamera.updateProjectionMatrix(),
        this.screenMesh.material.uniforms.u_plantsShadow.value = this.shadow,
        this.screenMesh.material.uniforms.u_previewBgThreshold.value = this.previewBgThreshold,
        this.screenMesh.material.uniforms.u_scrollXStrength.value = Math.min(.15, t.isActive ? t.scrollViewDelta : 0),
        this.screenMesh.material.uniforms.u_previewBgColor.value.setStyle(this.previewBgColorDefaultColorHex).lerp(_c1$2.setStyle(this.previewBgColorHex), this.previewColorRatio),
        this.screenMesh.material.uniforms.u_activeRatio.value = projectPage.activeRatio,
        this.screenMesh.update(),
        l.setClearColor(0, 0),
        l.clear(this.screenRT),
        l.setRenderTarget(this.screenRT),
        l.render(this.screenScene, this.screenCamera),
        l.setRenderTarget(o),
        fboHelper.setColorState(n)
    }
}
const projectDetailsScreen = new ProjectDetailsScreen;
class Route {
    constructor(e) {
        this.path = e,
        this.pathNodes = e ? e.split("/") : [],
        this.target = null,
        this.title = "",
        this.dom = null,
        this.scrollNavPath = "",
        this.scrollNavText = "",
        this.hasContentPreloaded = !1,
        this.content = {}
    }
    setTitleDom(e, t, r, n) {
        this.title = e,
        this.dom = t,
        this.scrollNavPath = r,
        this.scrollNavText = n
    }
    setTarget(e) {
        let t = null;
        for (let r = 0; r < e.length; r++) {
            let n = e[r];
            if (n.regExp.test(this.path)) {
                t = n;
                break
            }
        }
        t || (console.error("route not found for path: " + this.path),
        window.location.href = window.location.origin),
        this.target = t.target
    }
}
let loc = window.location
  , ORIGIN = window.location.origin
  , URL_PREFIX_REGEX = new RegExp("^" + ORIGIN.replace(/\//g, "\\/"));
class RouteManager {
    routes = {};
    matchList = [];
    currPath = null;
    _pendingPath = null;
    queryStr;
    onRouteChanged = new MinSignal$2;
    get currRoute() {
        return this.routes[this.currPath]
    }
    init() {
        this.queryStr = loc.href.split("?")[1] || "",
        window.addEventListener("popstate", this._onStatePop.bind(this)),
        this.setUrl()
    }
    addPath(e, t) {
        this.matchList.push({
            regExp: e instanceof RegExp ? e : new RegExp("^" + e + "$"),
            target: t
        })
    }
    _createRoute(e) {
        let t = this.routes[e] = new Route(e);
        return t.setTarget(this.matchList),
        t
    }
    _fetchHtml(e) {
        let t = this.routes[e];
        t ? t.dom && this._onDomReady(t) : properties.loader.load("/" + e, {
            type: "text",
            onLoad: this._initDom.bind(this, this._createRoute(e))
        })
    }
    _initDom(e, t) {
        let r = document;
        if (r.title,
        t) {
            r = r.implementation.createHTMLDocument(),
            r.body.innerHTML = /<body[^>]*>((.|[\n\r])*)<\/body>/im.exec(t)[1];
            let c = /<title[^>]*>((.|[\n\r])*)<\/title>/im.exec(t);
            c && c[1]
        }
        let n = r.getElementById("scroll-nav-section"), o, l;
        n && (o = n.dataset.path,
        l = r.getElementById("scroll-nav-text").innerHTML),
        e.setTitleDom(r.title, r.querySelector(".page"), o, l),
        n.removeAttribute("data-path"),
        this._attachEvents(t ? e.dom : r.documentElement),
        this._onDomReady(e)
    }
    _attachEvents(e) {
        let t = e.querySelectorAll("a");
        for (let r = 0, n = t.length; r < n; r++) {
            let o = t[r];
            if (!o.__hasClickParsed) {
                o.__hasClickParsed = !0;
                let l = o.href.indexOf(window.location.origin) === 0 || o.href.indexOf("/") === 0;
                o.dataset.linkType && (l = o.dataset.linkType === "internal"),
                l ? (o.addEventListener("mouseenter", c => {
                    this.preFetch(this.parseUrl(o.href))
                }
                ),
                o.addEventListener("click", this._onInternalLinkClick.bind(this, o))) : o.addEventListener("click", this._onRegularLinkClick.bind(this, o))
            }
        }
    }
    _onRegularLinkClick(e, t) {
        let r = e.href;
        if (r.indexOf("https://player.vimeo.com/video/") === 0) {
            t.preventDefault();
            let n = r.split("/").pop();
            videoOverlay.initAndPlayVideo(n, !0)
        }
    }
    _onInternalLinkClick(e, t) {
        t.preventDefault();
        let r = !0;
        e._onPreClick && (r = e._onPreClick() !== !1),
        r && this.setUrl(e.href)
    }
    _onDomReady(e) {
        this._pendingPath == e.path && (this._pendingPath = null,
        this.onRouteChanged.dispatch(e))
    }
    parseUrl(e=loc.href) {
        let t = e.replace(URL_PREFIX_REGEX, "")
          , r = t.split("#");
        return r[1],
        r = r[0].split("?"),
        r[1],
        t = this.parsePath(r[0]),
        t
    }
    parsePath(e) {
        return e = e.replace(/^\/|\/$/g, ""),
        e
    }
    setUrl(e=loc.href) {
        let t = this.parseUrl(e);
        this.setPath(t)
    }
    setPath(e) {
        e = this.parsePath(e),
        e !== this.currPath && (history.pushState(null, null, (e || "/") + (this.queryStr ? "?" + this.queryStr : "")),
        this._onStatePop())
    }
    preFetch(e) {
        e = this.parsePath(e),
        this._fetchHtml(e)
    }
    _onStatePop(e) {
        e && e.preventDefault();
        let t = this.parseUrl();
        t !== this.currPath && (this.currPath = t,
        this._pendingPath = t,
        properties.hasInitialized ? this._fetchHtml(t) : this._initDom(this._createRoute(t)))
    }
}
const routeManager = new RouteManager;
let _c1$1 = new Color
  , _c2$1 = new Color;
class Header {
    sectionId = ["home", "about", "project", "who", "end"];
    isActive = !1;
    ratio = 0;
    soundBtnTime = 0;
    soundBtnSize = 0;
    soundBtnHoverRatio = 0;
    soundBtnHoverAngle = 0;
    isSoundBtnHover = !1;
    forceWhite = !1;
    menu = {
        opened: !1,
        ratio: 0
    };
    headerColor = "transparent";
    headerTextColor = "#000";
    preInit() {
        this.domContainer = document.getElementById("header"),
        this.domHeaderContainer = document.getElementById("header-menu"),
        this.domLogoSvg = document.querySelector("#header-logo svg"),
        this.domBackground = document.getElementById("header-background"),
        this.domRight = document.getElementById("header-right"),
        this.domRightSoundBtn = document.getElementById("header-right-sound-btn"),
        this.domRightSoundBtnCanvas = this.domRightSoundBtn.querySelector("canvas"),
        this.domRightSoundBtnCtx = this.domRightSoundBtnCanvas.getContext("2d"),
        this.domRightTalkBtn = document.getElementById("header-right-talk-btn"),
        this.domRightTalkBtnContainer = document.getElementById("header-right-talk-container"),
        this.domRightTalkPlaceholder = document.getElementById("header-right-talk-btn-placeholder"),
        this.domRightMenuBtn = document.getElementById("header-right-menu-btn"),
        this.domMenuLinks = Array.from(document.querySelectorAll("#header-menu-links .header-menu-link")),
        this.domMenuLinkContact = document.querySelector('.header-menu-link[data-scroll-to="contact"]'),
        this.domMenuTalk = document.getElementById("header-menu-talk"),
        this.domMenuNewsletterForm = document.getElementById("header-menu-newsletter-form"),
        this.domMenuNewsletterButton = document.getElementById("header-menu-newsletter-input-arrow"),
        this.domMenuNewsletterMessage = document.getElementById("header-menu-newsletter-feedback-message"),
        this.formManager = new NewletterForm(this.domMenuNewsletterForm,this.domMenuNewsletterButton,this.domMenuNewsletterMessage),
        this.containers = [document.getElementById("header-menu-links"), document.getElementById("header-menu-newsletter"), this.domMenuTalk, document.getElementById("header-menu-labs")],
        routeManager.onRouteChanged.add(this._onRouteChanged, this),
        pagesManager.onScrollTargetChanged.add(this._onPageScrollTargetChange, this),
        document.querySelector("#header-logo")._onPreClick = () => {
            if (routeManager.currRoute.target == homePage)
                return scrollManager.scrollToPixel(0),
                !1
        }
        ,
        pagesManager.onIdled.add( () => {
            this.headerColor = window.getComputedStyle(properties.domRoot, null).getPropertyValue("--header-color"),
            this.headerTextColor = window.getComputedStyle(this.domRightMenuBtn).color,
            this.headerTextColorHover = window.getComputedStyle(properties.domRoot, null).getPropertyValue("--project-details-btn-text-hover")
        }
        )
    }
    init() {
        settings.USE_AUDIO || (this.domRightSoundBtn.style.visibility = "hidden"),
        input.onClicked.add( () => {
            !input.hasThroughElem(this.domRightMenuBtn, "click") && !input.hasThroughElem(this.domHeaderContainer, "click") && this._enableMenu(!1)
        }
        ),
        this.domRightSoundBtn.addEventListener("mouseenter", e => {
            let t = this.domRightSoundBtn.getBoundingClientRect()
              , r = e.clientX - t.left - t.width / 2
              , n = e.clientY - t.top - t.height / 2;
            this.soundBtnHoverAngle = Math.atan2(n, r) - Math.PI / 2,
            this.isSoundBtnHover = !0
        }
        ),
        this.domRightSoundBtn.addEventListener("mouseleave", () => {
            this.isSoundBtnHover = !1
        }
        ),
        this.domRightSoundBtn.addEventListener("click", this._onDomRightSoundBtn.bind(this)),
        this.domRightMenuBtn.addEventListener("click", this._domRightMenuBtnClick.bind(this)),
        this.domMenuLinkContact.addEventListener("click", this._onDomMenuLinkContact.bind(this)),
        this.containers.forEach( (e, t) => {
            e.style.setProperty("--open-delay", t / 50 + "s"),
            e.style.setProperty("--close-delay", Math.abs(t - this.containers.length) / 50 + "s")
        }
        )
    }
    show() {
        this.isActive = !0
    }
    hideTalkBtn() {}
    changeSection(e) {
        scrollManager.scrollTo(e)
    }
    _onDomRightSoundBtn() {
        audios.toggle()
    }
    _onRouteChanged() {
        this._enableMenu(!1)
    }
    _domRightMenuBtnClick() {
        this._enableMenu(!this.menu.opened)
    }
    _onDomMenuLinkContact() {
        routeManager.currRoute.pathNodes[0] === "projects" && routeManager.currRoute.pathNodes[1] ? (properties.isContactFromProjectPage = !0,
        document.querySelector("[data-page='home']").click()) : (scrollManager.scrollTo("footer-section"),
        this._enableMenu(!1))
    }
    _enableMenu(e) {
        this.menu.opened = e,
        this.domContainer.classList.toggle("--menu-opened", e),
        this.domHeaderContainer.classList.toggle("--opened", e),
        this.domBackground.classList.toggle("--opened", e),
        this.domRightMenuBtn.classList.toggle("--opened", e),
        e ? (this.domBackground.style.opacity = properties.viewportWidth >= 1e3 ? .2 : 1,
        this.domHeaderContainer.style.pointerEvents = "auto") : (this.domBackground.style.opacity = 0,
        this.domHeaderContainer.style.pointerEvents = "none")
    }
    _domRightMenuListMouseenter() {
        this.menu.hover = !0
    }
    _domRightMenuListMouseleave() {
        this.menu.hover = !1
    }
    _onWindowClick(e) {
        e.target.closest("#header-menu") || e.target.closest("#header-right-menu-btn") || this._enableMenu(!1)
    }
    _onPageScrollTargetChange(e) {
        const t = this.domMenuLinks.filter(n => n.classList.contains("--active"))[0]
          , r = this.domMenuLinks.filter(n => n.dataset.page === e.id)[0];
        t && t.classList.remove("--active"),
        r && r.classList.add("--active")
    }
    resize(e, t) {
        let r = this.domRightTalkBtn.getBoundingClientRect()
          , n = this.domRightTalkPlaceholder.getBoundingClientRect()
          , o = this.domRightSoundBtn.getBoundingClientRect();
        this.soundBtnSize = o.width,
        this.domRightSoundBtnCanvas.width = Math.round(this.soundBtnSize * (browser$1.devicePixelRatio > 1 ? 2 : 1)),
        this.domRightSoundBtnCanvas.height = Math.round(this.soundBtnSize * (browser$1.devicePixelRatio > 1 ? 2 : 1)),
        this.domRightTalkBtn._width = r.width,
        this.domRightTalkBtn._height = r.height,
        this.domRightTalkBtn._placeholderWidth = n.width,
        this.domRightTalkBtn._toWidth = r.height,
        this.domRightTalkBtn._deltaX = n.left - properties.viewportWidth * .5 + parseFloat(getComputedStyle(this.domRightTalkBtn).fontSize) * 3.2 * .5
    }
    updateSoundWave(e) {
        let t = this.soundBtnHoverRatio = math.saturate(this.soundBtnHoverRatio + (this.isSoundBtnHover ? e : -e) / .3);
        this.soundBtnTime += e * .6 * (1 + t * .5);
        let r = this.soundBtnSize
          , n = this.domRightSoundBtnCtx
          , o = browser$1.devicePixelRatio > 1 ? 2 : 1;
        if (n.save(),
        n.scale(o, o),
        n.clearRect(0, 0, r, r),
        n.translate(r / 2, r / 2),
        t < 1 && (n.beginPath(),
        n.arc(0, 0, r / 2, 0, Math.PI * 2),
        _c1$1.setStyle("#E4E6EF"),
        _c2$1.setStyle("#fff"),
        n.fillStyle = _c1$1.lerp(_c2$1, Math.max(this.menu.ratio, +this.forceWhite)).getStyle(),
        n.fill(),
        n.closePath()),
        t > 0) {
            n.save(),
            t < 1 && (n.globalCompositeOperation = "source-atop");
            let f = ease.cubicInOut(t);
            n.rotate(this.soundBtnHoverAngle),
            n.translate(0, math.fit(t, 0, 1, r * .75, 0, ease.cubicInOut)),
            n.scale(f, f),
            n.beginPath(),
            n.arc(0, 0, r / 2, 0, Math.PI * 2),
            n.fillStyle = this.headerColor,
            n.fill(),
            n.closePath(),
            n.restore()
        }
        _c1$1.setStyle(this.headerTextColor),
        _c2$1.setStyle(this.headerTextColorHover),
        n.strokeStyle = _c1$1.lerp(_c2$1, t).getStyle(),
        n.lineWidth = r * .05,
        n.lineCap = "round",
        n.beginPath();
        let l = 32
          , c = r * .4
          , u = r * .28 * audios.volume;
        for (let f = 0; f < l + 1; f++) {
            let p = -c / 2 + c * f / l
              , g = Math.sin(this.soundBtnTime * 8 + f / l * 7) * u / 2 * math.fit(Math.abs(f / l - .5), .5, .25, .3, 1, ease.sineInOut);
            f == 0 ? n.moveTo(p, g) : n.lineTo(p, g)
        }
        n.stroke(),
        n.closePath(),
        n.restore()
    }
    update(e) {
        this.menu.ratio = math.saturate(this.menu.ratio + (this.menu.opened ? e : -e)),
        this.ratio = math.clamp(this.ratio + (this.isActive ? e : -e), 0, 2);
        const t = math.fit(this.ratio, .9, 1.7, 0, 1)
          , r = math.fit(t, 0, 1, 4, 0, ease.lusion);
        if (this.domRightSoundBtn.style.transform = `translate3d(0, ${r}em, 0)`,
        this.domRightTalkBtn.style.display = "none",
        properties.useMobileLayout || this.updateSoundWave(e),
        properties.useMobileLayout)
            this.domRightTalkBtnContainer.style.opacity = 0,
            this.domRightTalkBtn.style.transform = "none";
        else {
            let l = math.fit(this.ratio, 1, 1.8, 0, 1)
              , c = math.fit(l, 0, 1, 4, 0, ease.lusion);
            this.domRightTalkBtnContainer.style.opacity = 1,
            this.domRightTalkBtn.style.display = "block",
            this.domRightTalkBtn.style.pointerEvents = "auto",
            this.domRightTalkBtn.style.opacity = 1,
            this.domRightTalkBtn.style.transform = `translate3d(0, ${c}em, 0)`
        }
        let n = math.fit(this.ratio, 1.1, 1.9, 0, 1)
          , o = math.fit(n, 0, 1, 4, 0, ease.lusion);
        this.domRightMenuBtn.style.transform = `translate3d(0, ${o}em, 0)`
    }
    _hexToRgb(e) {
        const t = parseInt(e.substring(1, 3), 16) || 0
          , r = parseInt(e.substring(3, 5), 16) || 0
          , n = parseInt(e.substring(5, 7), 16) || 0;
        return [t, r, n]
    }
}
const header = new Header;
class ProjectDetailsData {
    id = "";
    title = "";
    desc = "";
    ctaTitle = "";
    ctaUrl = "";
    colorBg = "#000";
    colorBtnBg = "#000";
    colorBtnBgHover = "#000";
    colorBtnText = "#000";
    colorBtnTextHover = "#000";
    colorHighlight = "#000";
    colorIconBg = "#000";
    colorIconColor = "#000";
    colorText = "#000";
    shadow = 0;
    nextColorBg = "#000";
    nextColorText = "#000";
    nextId = "";
    nextTitle = "";
    nextShadow = 0;
    domServiceSideListItems;
    domRecognitionSideListItems;
    itemDataList = [];
    constructor(e, t) {
        this.id = e,
        this.title = t.querySelector("#project-details-title").innerHTML,
        this.desc = t.querySelector("#project-details-desc").innerHTML,
        this.ctaTitle = t.querySelector("#project-details-launch-cta-text").textContent,
        this.ctaUrl = t.querySelector("#project-details-launch-cta").href;
        let r = {
            ...t.querySelector("#project-details").dataset
        };
        this.colorBg = r.colorBg,
        this.colorBtnBg = r.colorBtnBg,
        this.colorBtnBgHover = r.colorBtnBgHover,
        this.colorBtnText = r.colorBtnText,
        this.colorBtnTextHover = r.colorBtnTextHover,
        this.colorHighlight = r.colorHighlight,
        this.colorIconBg = r.colorIconBg,
        this.colorIconColor = r.colorIconColor,
        this.colorText = r.colorText,
        this.shadow = parseFloat(r.shadow),
        (this.domServiceSideListItems = Array.from(t.querySelectorAll("#project-details-side-list-services > *"))).forEach(l => {
            l.remove()
        }
        ),
        (this.domRecognitionSideListItems = Array.from(t.querySelectorAll("#project-details-side-list-recognitions > *"))).forEach(l => {
            l.remove()
        }
        );
        let n = Array.from(t.querySelectorAll(".project-details-item"));
        for (let l = 0; l < n.length; l++) {
            let c = n[l]
              , u = {
                ...c.dataset
            };
            c.classList.contains("is-text") ? u.content = c.querySelector(".project-details-item-text").textContent : (u.width = parseFloat(u.width),
            u.height = parseFloat(u.height),
            u.parallax = parseFloat(u.parallax || 1),
            u.fullscreen = u.fullscreen !== void 0),
            this.itemDataList.push(u),
            c.remove()
        }
        let o = {
            ...t.querySelector("#project-details-preview").dataset
        };
        this.nextColorBg = o.nextColorBg,
        this.nextColorText = o.nextColorText,
        this.nextId = o.nextId,
        this.nextShadow = parseFloat(o.nextShadow),
        this.nextTitle = t.querySelector("#project-details-preview-title").textContent
    }
}
class UfxTextMesh extends UfxMesh {
    constructor(e={}) {
        super(e),
        this.refDom || console.error("UfxTextMesh: refDom is not defined"),
        this.material.uniforms.u_texture = {
            value: textureHelper.transparentTexture
        },
        this.canvas = document.createElement("canvas")
    }
    syncText() {
        let e = domHelper.getLinesFromText(this.refDom)
          , t = this.refDom.getBoundingClientRect()
          , r = this.canvas
          , n = r.getContext("2d")
          , o = getComputedStyle(this.refDom)
          , l = parseFloat(o.getPropertyValue("padding-left"))
          , c = Math.floor(parseFloat(o.getPropertyValue("font-size")))
          , u = o.getPropertyValue("font-style")
          , f = o.getPropertyValue("font-weight")
          , p = o.getPropertyValue("font-family")
          , g = Math.ceil(t.width)
          , v = Math.ceil(t.height);
        r.width = Math.ceil(g * properties.webglDPR),
        r.height = Math.ceil(v * properties.webglDPR);
        let _ = parseFloat(o.getPropertyValue("line-height"));
        n.save(),
        n.scale(properties.webglDPR, properties.webglDPR),
        n.fillStyle = "#000",
        n.fillRect(0, 0, g, v),
        n.font = u + " " + f + " " + c + "px " + p;
        let w = 0
          , S = [];
        for (let R = 0; R < e.length; R++) {
            let T = Math.ceil(n.measureText(e[R]).width + 1);
            S.push(T),
            w += T
        }
        let b = 0, C;
        C = _ * .15;
        for (let R = 0; R < e.length; R++) {
            let T = l
              , M = R * _ + C
              , P = S[R]
              , I = n.createLinearGradient(T, 0, T + P, 0);
            I.addColorStop(0, "rgb(" + Math.round(b / w * 255) + ", 0, 0)"),
            b += P,
            I.addColorStop(1, "rgb(" + Math.round(b / w * 255) + ", 0, 0)"),
            n.fillStyle = I,
            n.fillRect(T, M, P, _)
        }
        n.globalCompositeOperation = "lighter",
        n.fillStyle = "#0f0",
        C = _ * .8;
        for (let R = 0; R < e.length; R++) {
            let T = l
              , M = R * _ + C;
            n.fillText(e[R], T, M)
        }
        n.restore(),
        this.texture && this.texture.dispose(),
        this.texture = new Texture(this.canvas),
        this.texture.minFilter = LinearFilter,
        this.texture.magFilter = LinearFilter,
        this.material.uniforms.u_texture.value = this.texture,
        this.texture.needsUpdate = !0
    }
}
const vert$a = `#define GLSLIFY 1
#include <ufxVert>
varying vec2 v_uv;void main(){vec3 basePos=getBasePosition(position);vec3 screenPos=getScreenPosition(basePos);gl_Position=projectionMatrix*modelViewMatrix*vec4(screenPos,1.0);v_uv=padUv(uv);}`
  , frag$e = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec2 u_domXY;uniform vec2 u_domWH;uniform float u_opacity;uniform float u_parallax;uniform float u_time;uniform float u_dpr;uniform sampler2D u_screenPaintTexture;uniform vec2 u_resolution;uniform vec2 u_screenRTSize;uniform float u_activeRatio;uniform vec3 u_highlightColor;uniform vec3 u_bgColor;uniform vec2 u_mouseXY;uniform float u_borderRadius;uniform float u_parallaxRatio;uniform float u_isFullscreen;uniform int u_isVertical;varying vec2 v_uv;
#include <getBlueNoise>
float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}
#ifdef IS_TEXT
uniform vec3 u_textColor;uniform float u_textRatio;
#else
uniform float u_readyRatio;float sdRoundedBox(in vec2 p,in vec2 b,in vec4 r){r.xy=(p.x>0.0)?r.xy : r.zw;r.x=(p.y>0.0)?r.x  : r.y;vec2 q=abs(p)-b+r.x;return min(max(q.x,q.y),0.0)+length(max(q,0.0))-r.x;}float getRoundedCornerMask(vec2 uv,vec4 radius){float d=sdRoundedBox((uv-.5)*u_domWH,u_domWH*0.5*mix(0.6,1.,max(u_isFullscreen,u_activeRatio)),radius.yzwx);return smoothstep(0.,0.-fwidth(d),d);}
#endif
void main(){vec3 blueNoises=getBlueNoise(gl_FragCoord.xy+vec2(43.,12.));
#ifdef IS_TEXT
vec4 image=texture2D(u_texture,v_uv);vec3 color=u_textColor;float mask=smoothstep(u_textRatio,u_textRatio-.5/255.,image.r*255./256.);float imageAlpha=image.g;color=mix(u_bgColor,color,(0.2+mask*0.8));
#else
vec2 uv=v_uv;uv-=0.5;uv*=mix(0.6,1.,u_activeRatio);if(u_isVertical==1){uv.y*=u_parallaxRatio;uv.y+=u_parallax*(1.-u_parallaxRatio);}else{uv.x*=u_parallaxRatio;uv.x+=u_parallax*(1.-u_parallaxRatio);}uv+=0.5;vec3 color=texture2D(u_texture,uv).rgb;float imageAlpha=getRoundedCornerMask(v_uv,vec4(u_borderRadius));color=mix(u_highlightColor,color,u_readyRatio);
#endif
imageAlpha*=u_opacity;gl_FragColor=vec4(color,imageAlpha);}`;
let idx = 0;
class ProjectDetailsItem {
    constructor(e="image") {
        this.idx = idx++,
        this.data = {},
        this.type = e,
        this.aspect = 1,
        this.imgVersion = 0,
        this.texture = null,
        this.isActive = !1,
        this.textSpeed = 1,
        this.parallaxRatio = 1,
        this.activeTime = 0,
        this.domVideoButton = null,
        this.onClick = null;
        let t = this.domWrapper = document.createElement("div");
        t.classList.add("project-details-item");
        let r = this.uniforms = Object.assign({
            u_screenPaintTexture: screenPaint.sharedUniforms.u_currPaintTexture,
            u_texture: {
                value: null
            },
            u_activeRatio: {
                value: 0
            },
            u_isFullscreen: {
                value: 0
            },
            u_isVertical: projectDetailsSection.sharedUniforms.u_isVertical,
            u_opacity: projectDetailsSection.sharedUniforms.u_opacity,
            u_bgColor: projectDetailsSection.sharedUniforms.u_bgColor,
            u_screenRTSize: projectDetailsSection.sharedUniforms.u_screenRTSize,
            u_highlightColor: projectDetailsSection.sharedUniforms.u_highlightColor,
            u_textureSize: {
                value: new Vector2(1,1)
            },
            u_time: properties.sharedUniforms.u_time,
            u_dpr: properties.sharedUniforms.u_dpr,
            u_mouseXY: {
                value: input.mouseXY
            },
            u_parallax: {
                value: 0
            },
            u_parallaxRatio: {
                value: 1
            },
            u_borderRadius: {
                value: 0
            }
        }, blueNoise.sharedUniforms);
        switch (t.classList.add("is-" + e),
        e) {
        case "image":
        case "video":
            r.u_readyRatio = {
                value: 0
            },
            this.ufxMesh = new UfxMesh({
                refDom: t,
                uniforms: r,
                depthTest: !1,
                depthWrite: !1,
                vertexShader: vert$a,
                fragmentShader: frag$e,
                transparent: !1
            });
            break;
        case "text":
            this.domText = document.createElement("div"),
            this.domText.classList.add("project-details-item-text"),
            this.domWrapper.appendChild(this.domText),
            r.u_textColor = projectDetailsSection.sharedUniforms.u_textColor,
            r.u_bgColor = projectDetailsSection.sharedUniforms.u_bgColor,
            r.u_textRatio = {
                value: 0
            },
            this.ufxMesh = new UfxTextMesh({
                refDom: this.domText,
                uniforms: r,
                depthTest: !1,
                depthWrite: !1,
                vertexShader: vert$a,
                fragmentShader: frag$e,
                transparent: !1
            }),
            this.ufxMesh.material.defines.IS_TEXT = !0;
            break
        }
        projectDetailsScreen.screenScene.add(this.ufxMesh)
    }
    activate(e) {
        this.data = e,
        this.parallaxRatio = this.uniforms.u_parallaxRatio.value = e.parallax || 1,
        this.isFullscreen = !!e.fullscreen,
        this.uniforms.u_isFullscreen.value = +this.isFullscreen,
        this.uniforms.u_activeRatio.value = 0,
        this.type == "image" ? this._initImage() : this.type == "video" ? this._initVideo() : this.type == "text" ? this._initText() : console.error("unknown type"),
        this.isActive = !0
    }
    deactivate() {
        this.isActive = !1,
        this.playPauseVideo(!1)
    }
    _initVideo() {
        let e = this.data
          , t = browser$1.isMobile ? e.filename.replace("/video", "/mobile_video") : e.filename;
        t.indexOf("/") == 0 && (t = settings.CDN_PATH + t);
        let r = t + ".mp4"
          , n = this.texture;
        if (n && n.__url == r)
            return;
        this.imgVersion++,
        n && n.__loaded && n.dispose(),
        this.aspect = e.width / e.height,
        this.uniforms.u_texture.value = textureHelper.blackTexture,
        this.uniforms.u_textureSize.value.set(e.width, e.height);
        let o;
        const l = document.createElement("video");
        settings.LOCAL_TEXTURE_PATH !== settings.TEXTURE_PATH && (l.crossOrigin = "anonymous"),
        l.muted = !0,
        l.src = r,
        l.loop = !0,
        l.load(),
        o = new VideoTexture(l),
        o.__version = this.version,
        o.__url = this.url,
        o.__loaded = !0,
        this.texture = o,
        this.uniforms.u_texture.value = o
    }
    _initImage() {
        let e = this.data
          , t = browser$1.isMobile ? e.filename.replace("/image", "/mobile_image") : e.filename;
        t.indexOf("/") == 0 && (t = settings.CDN_PATH + t);
        let r = t + ".webp"
          , n = this.texture;
        if (n && n.__url == r)
            return;
        this.imgVersion++,
        n && n.__loaded && n.dispose(),
        this.aspect = e.width / e.height,
        this.uniforms.u_texture.value = textureHelper.blackTexture,
        this.uniforms.u_textureSize.value.set(e.width, e.height);
        let o = new Texture(new Image);
        o.__version = this.version,
        o.__url = this.url,
        properties.loader.load(r, {
            type: "texture",
            content: o,
            minFilter: settings.USE_WEBGL2 ? LinearMipmapLinearFilter : LinearFilter,
            onLoad: l => {
                l.__version != this.imgVersion ? (l.__loaded = !0,
                this.texture = l,
                this.uniforms.u_texture.value = l) : l.dispose()
            }
        })
    }
    _initText() {
        let e = this.data;
        this.domWrapper.style.fontSize = e.fontSize + "em",
        this.domText.innerHTML = e.content,
        this.uniforms.u_textRatio.value = 0,
        this.textSpeed = 50 / Math.max(30, e.content.length)
    }
    _onMouseEnter() {}
    _onMouseLeave() {}
    _onClick() {}
    resize(e, t, r) {
        let n, o;
        r ? (e += this.isFullscreen ? 2 : 0,
        n = e,
        o = e / this.aspect,
        (this.type == "image" || this.type == "video") && (o *= this.parallaxRatio)) : (t += this.isFullscreen ? 2 : 0,
        n = t * this.aspect,
        o = t,
        (this.type == "image" || this.type == "video") && (n *= this.parallaxRatio)),
        this.domWrapper.style.width = n + "px",
        this.type == "text" && r ? this.domWrapper.style.height = "auto" : this.domWrapper.style.height = o + "px",
        this.type == "text" && this.ufxMesh.syncText()
    }
    syncDom() {
        let e = properties.useMobileLayout
          , t = e ? 0 : projectDetailsSection.scrollPane.scrollPixel
          , r = e ? projectDetailsSection.scrollPane.scrollPixel : 0;
        this.ufxMesh.syncDom(-r, -t)
    }
    playPauseVideo(e) {
        if (this.type == "video") {
            let t = this.texture && this.texture.image && this.texture.image.pause ? this.texture.image : null;
            t && (!e && !t.paused && t.pause(),
            e && t.paused && t.play())
        }
    }
    update(e) {
        let t = properties.useMobileLayout
          , r = t ? this.isFullscreen ? 1 : 0 : projectDetailsSection.scrollPane.scrollPixel
          , n = t ? projectDetailsSection.scrollPane.scrollPixel : this.isFullscreen ? 1 : 0
          , o = this.ufxMesh.testViewport(-n, -r);
        if (this.ufxMesh.update(-n, -r),
        o) {
            if (this.uniforms.u_borderRadius.value = this.isFullscreen && !properties.useMobileLayout ? 0 : properties.globalRadius,
            this.type == "image" || this.type == "video")
                if (t) {
                    let l = this.uniforms.u_domXY.value.y;
                    this.uniforms.u_parallax.value = math.fit(l, -this.ufxMesh._domHeight, properties.viewportHeight, -.5, .5)
                } else {
                    let l = this.uniforms.u_domXY.value.x;
                    this.uniforms.u_parallax.value = math.fit(l, -this.ufxMesh._domWidth, properties.viewportWidth, -.5, .5)
                }
            this.activeTime += e,
            this.uniforms.u_activeRatio.value = math.fit(this.activeTime, 0, 1, 0, 1, ease.expoOut),
            this.playPauseVideo(!!pagesManager.isIdle)
        } else
            this.activeTime = 0,
            this.playPauseVideo(!1);
        if (this.type == "image" || this.type == "video") {
            let l = this.uniforms.u_texture.value
              , c = l !== textureHelper.blackTexture && l.__loaded;
            this.uniforms.u_readyRatio.value = Math.min(1, this.uniforms.u_readyRatio.value + (c ? e : 0))
        }
        if (this.type == "text")
            if (this.ufxMesh.testViewport(-n, -r)) {
                let l;
                t ? l = math.unClampedFit(this.uniforms.u_domXY.value.y, properties.viewportHeight, -this.uniforms.u_domWH.value.y, 0, 1) : l = math.unClampedFit(this.uniforms.u_domXY.value.x, properties.viewportWidth, -this.uniforms.u_domWH.value.x, 0, 1);
                let c = l > .2 && l < .8;
                this.uniforms.u_textRatio.value = math.clamp(this.uniforms.u_textRatio.value + e * (c ? this.textSpeed : 0), 0, 1)
            } else
                this.uniforms.u_textRatio.value = 0
    }
}
class ProjectDetailsItems {
    moveContainer;
    itemPool = [];
    imageItemPool = [];
    videoItemPool = [];
    textItemPool = [];
    useItem(e) {
        let t = e.type, r;
        switch (t) {
        case "image":
            r = this.imageItemPool;
            break;
        case "video":
            r = this.videoItemPool;
            break;
        case "text":
            r = this.textItemPool;
            break
        }
        for (let o = 0; o < r.length; o++) {
            let l = r[o];
            if (!l.isActive)
                return l
        }
        let n = new ProjectDetailsItem(t);
        return r.push(n),
        this.itemPool.push(n),
        n
    }
    deactivateAll() {
        for (let e = 0; e < this.itemPool.length; e++) {
            let t = this.itemPool[e];
            t.isActive && (t.deactivate(),
            t.domWrapper.remove())
        }
    }
    pauseAllVideos() {
        for (let e = 0; e < this.itemPool.length; e++)
            this.itemPool[e].playPauseVideo(!1)
    }
    resizeAll(e, t, r) {
        let n = properties.useMobileLayout;
        for (let o = 0; o < this.itemPool.length; o++) {
            let l = this.itemPool[o];
            if (l.isActive) {
                let c = l.isFullscreen && !properties.useMobileLayout;
                l.resize(e, c ? properties.viewportHeight : t, n),
                l.domWrapper.style.top = (c ? -r : 0) + "px"
            }
        }
    }
    syncDoms() {
        for (let e = 0; e < this.itemPool.length; e++) {
            let t = this.itemPool[e];
            t.isActive && t.syncDom()
        }
    }
    update(e, t, r) {
        for (let n = 0; n < this.itemPool.length; n++) {
            let o = this.itemPool[n];
            o.isActive && o.update(e),
            o.isActive && o.ufxMesh.testViewport(-r, -t) ? o.ufxMesh.visible = !0 : o.ufxMesh.visible = !1
        }
    }
}
const projectDetailsItems = new ProjectDetailsItems;
let _c1 = new Color
  , _c2 = new Color;
class ProjectDetailsSection {
    projectDetailsDatas = {};
    projectDetailsData;
    domContainer;
    domHeaderInfo;
    domHeaderBackBtn;
    domTitle;
    domDesc;
    domCta;
    domSideListService;
    domSideListRecognitions;
    domDetailsItemsWrapper;
    domDetailsItemsMoveContainer;
    domPreview;
    domPreviewInner;
    domPreviewHeader;
    domPreviewTitle;
    domPreviewFooterBarInner;
    selectedId = "";
    contentShowRatio = 0;
    nextProjectRatio = 0;
    overScrollRatio = 0;
    overScrollSize = 0;
    previewInnerOffsetFrom = 0;
    previewInnerOffsetTo = 0;
    titleCenterOffsetY = 0;
    previewTitleColorDefaultColorHex = "#c2c3c7";
    previewTitleColorHex = "#000";
    previewShadow = 0;
    scrollPane;
    isVertical = null;
    VERTICAL_BREAK_PIONT = 1e3;
    itemPool = [];
    imageItemPool = [];
    videoItemPool = [];
    textItemPool = [];
    projectDatas = {};
    sharedUniforms = {
        u_opacity: {
            value: 0
        },
        u_isVertical: {
            value: 0
        },
        u_scrollX: {
            value: 0
        },
        u_highlightColor: {
            value: new Color
        },
        u_bgColor: {
            value: new Color
        },
        u_textColor: {
            value: new Color
        }
    };
    domHeaderBackBtnHoverAnimation = {
        animating: !1,
        ratio: 0
    };
    preInit(e) {
        this.domContainer = e.querySelector("#project-details"),
        this.domContainer.style.backgroundColor = "",
        this.domHeaderInfo = e.querySelector("#project-details-header-info"),
        this.domHeaderInfo._ratio = 0,
        this.domHeaderInfo._hide = !1,
        this.domHeaderBackBtn = document.querySelector("#header-center-project-back-btn"),
        this.domHeaderInfoSvg = document.querySelector("#project-details-header-info-svg"),
        this.domMeta = e.querySelector("#project-details-meta"),
        this.domTitle = e.querySelector("#project-details-title"),
        this.domDesc = e.querySelector("#project-details-desc"),
        this.domCta = e.querySelector("#project-details-launch-cta"),
        this.domCtaText = e.querySelector("#project-details-launch-cta-text"),
        this.domCtaMobile = e.querySelector("#project-details-launch-cta-mobile"),
        this.domCtaMobileText = e.querySelector("#project-details-launch-cta-mobile-text"),
        this.domSideListService = e.querySelector("#project-details-side-list-services"),
        this.domSideListRecognitions = e.querySelector("#project-details-side-list-recognitions"),
        this.domDetailsItemsWrapper = e.querySelector("#project-details-items-wrapper"),
        this.domDetailsItemsMoveContainer = e.querySelector("#project-details-items-move-container"),
        this.domPreview = e.querySelector("#project-details-preview"),
        this.domPreviewInner = e.querySelector("#project-details-preview-inner"),
        this.domPreviewTitle = e.querySelector("#project-details-preview-title"),
        this.domPreviewFooter = e.querySelector("#project-details-preview-footer"),
        this.domPreviewFooterBarInner = e.querySelector("#project-details-preview-footer-bar-inner"),
        this.scrollPane = new ScrollPane,
        this.scrollPane.contentDom = this.domDetailsItemsMoveContainer,
        this.scrollPane.init(),
        projectDetailsScreen.preInit(this.domContainer)
    }
    preInitContent(e) {
        let t = e.pathNodes[1];
        this.projectDetailsDatas[t] = new ProjectDetailsData(t,e.dom)
    }
    _onModelLoad(e) {}
    init() {
        projectDetailsScreen.init(),
        projectPage.onHideCompleted.add( () => {
            projectDetailsItems.pauseAllVideos()
        }
        )
    }
    show(e) {
        this._disposeLayout(),
        this._initLayout(e),
        this.overScrollRatio = 0,
        this.scrollPane.isActive = !0,
        this.scrollPane.scrollToPixel(0, !0),
        this.scrollPane.update(0),
        this.scrollPane.isActive = !1,
        this.updatePreviewUI(e, !0),
        this.resize(properties.viewportWidth, properties.viewportHeight),
        this.update(0, !0)
    }
    updatePreviewUI(e, t=!0) {
        let r = this.projectDetailsDatas[e];
        t ? (this.domPreviewTitle.innerHTML = r.nextTitle,
        projectDetailsScreen.previewBgColorHex = r.nextColorBg,
        this.previewTitleColorHex = r.nextColorText,
        this.previewShadow = r.nextShadow) : (this.domPreviewTitle.innerHTML = r.title,
        projectDetailsScreen.previewBgColorHex = r.colorBg,
        this.previewTitleColorHex = r.colorText,
        this.previewShadow = r.shadow)
    }
    _disposeLayout() {
        let e = this.projectDetailsData;
        projectDetailsItems.deactivateAll(),
        e || window.addEventListener("wheel", this._onWindowWheel.bind(this), {
            once: !0
        }),
        e && (e.domServiceSideListItems.forEach(t => {
            t.remove()
        }
        ),
        e.domRecognitionSideListItems.forEach(t => {
            t.remove()
        }
        ))
    }
    _initLayout(e) {
        let t = this.projectDetailsData = this.projectDetailsDatas[e];
        routeManager.preFetch("/projects/" + t.nextId),
        this.domTitle.innerHTML = t.title,
        this.domDesc.innerHTML = t.desc,
        this.domCtaText.textContent = t.ctaTitle,
        routeManager.parseUrl(t.ctaUrl) ? (this.domCta.href = t.ctaUrl,
        this.domCtaMobile.href = t.ctaUrl,
        this.domContainer.classList.add("has-cta")) : this.domContainer.classList.remove("has-cta"),
        this.domSideListService.style.visibility = t.domServiceSideListItems.length > 1 ? "visible" : "hidden",
        this.domSideListRecognitions.style.visibility = t.domRecognitionSideListItems.length > 1 ? "visible" : "hidden",
        t.domServiceSideListItems.forEach(r => {
            this.domSideListService.appendChild(r)
        }
        ),
        t.domRecognitionSideListItems.forEach(r => {
            this.domSideListRecognitions.appendChild(r)
        }
        ),
        this.sharedUniforms.u_highlightColor.value.setStyle(t.colorHighlight),
        this.sharedUniforms.u_textColor.value.setStyle(t.colorText),
        this.sharedUniforms.u_bgColor.value.setStyle(t.colorBg),
        this.domHeaderBackBtn.addEventListener("click", this._onBackBtnClick.bind(this));
        for (let r in t)
            r.replace(/^color(.+)/g, (n, o) => {
                o = o.replace(/([a-z\xE0-\xFF])([A-Z\xC0\xDF])/g, (l, c, u) => c + "-" + u).toLowerCase(),
                properties.domRoot.style.setProperty("--project-details-" + o, t[r])
            }
            );
        properties.domRoot.style.setProperty("--header-color", t.colorHighlight),
        properties.domRoot.style.setProperty("--header-text-color", t.colorBtnText),
        header.domContainer.style.color = t.colorHighlight,
        t.itemDataList.forEach(r => {
            let n = projectDetailsItems.useItem(r);
            n.activate(r),
            this.domDetailsItemsMoveContainer.appendChild(n.domWrapper)
        }
        )
    }
    _onBackBtnClick() {
        this.scrollPane.isActive && pagesManager.isIdle && routeManager.setPath(projectPage.prevNonProjectPath || "/")
    }
    _splitText() {}
    hide(e, t, r) {
        r(),
        this.scrollPane.isActive = !1
    }
    resize(e, t) {
        this._splitText();
        let r = properties.useMobileLayout;
        this.sharedUniforms.u_isVertical.value = r ? 1 : 0,
        r ? this.domMeta.style.transform = "translateZ(0)" : this.domMeta.style.transform = "translate3d(0,-50%,0)";
        let n = this.domMeta.getBoundingClientRect();
        this.domDetailsItemsMoveContainer.style.paddingTop = (r ? n.bottom : 0) + "px",
        r ? (this.overScrollSize = this.domPreviewInner.getBoundingClientRect().height,
        this.domDetailsItemsMoveContainer.style.paddingRight = 0,
        this.domDetailsItemsMoveContainer.style.paddingBottom = this.overScrollSize + this.domDetailsItemsWrapper.getBoundingClientRect().top + "px") : (this.overScrollSize = properties.viewportWidth * .25,
        this.domDetailsItemsMoveContainer.style.paddingRight = this.overScrollSize + "px",
        this.domDetailsItemsMoveContainer.style.paddingBottom = 0);
        let o = this.domDetailsItemsMoveContainer.getBoundingClientRect();
        projectDetailsItems.resizeAll(o.width, o.height, o.top);
        let l = this.domTitle.getBoundingClientRect();
        if (r) {
            let c = this.domPreviewTitle.getBoundingClientRect()
              , u = this.domPreviewInner.getBoundingClientRect();
            this.previewInnerOffsetFrom = 0,
            this.previewInnerOffsetTo = l.top - (c.top - u.top)
        } else
            this.previewInnerOffsetFrom = this.overScrollSize * .2,
            this.previewInnerOffsetTo = n.left;
        this.domHeaderInfo.style.bottom = (properties.viewportHeight - this.domDetailsItemsWrapper.getBoundingClientRect().bottom) / 2 - this.domHeaderInfo.getBoundingClientRect().height / 2 + "px",
        this.titleCenterOffsetY = r ? 0 : properties.viewportHeight * .5 - n.top - l.height * .5,
        this.domPreviewTitle.style.width = l.width + "px",
        this.scrollPane.isVertical = r,
        this.scrollPane.isActive = !0,
        this.scrollPane.resize(e, t),
        this.scrollPane.update(0),
        this.scrollPane.isActive = !1,
        projectDetailsItems.syncDoms(),
        projectDetailsScreen.resize(e, t)
    }
    update(e, t=!1) {
        let r = this.projectDetailsData;
        if (!r)
            return;
        let n = properties.useMobileLayout
          , o = n ? 0 : this.scrollPane.scrollPixel
          , l = n ? this.scrollPane.scrollPixel : 0
          , c = math.fit(projectPage.showRatio * (1 - projectPage.hideRatio), .5, 1, 0, 1)
          , u = math.fit(c, 0, .5, 0, 1, ease.expoOut);
        this.domHeaderBackBtn.style.transform = `translate3d(0,${1 - u}em,0)`,
        this.domHeaderBackBtn.style.opacity = u,
        this.scrollPane.isActive = projectPage.nextProjectRatio == 0 && projectPage.contentShowRatio > .75,
        projectPage.contentShowRatio <= .75 && this.scrollPane.scrollToPixel(0, !0),
        this.scrollPane.update(e);
        let f = (this.scrollPane.contentSize + 1) * this.scrollPane.viewSizePixel - this.scrollPane.scrollPixel - this.overScrollSize;
        n ? f = Math.min(f, l + properties.viewportHeight) : f = Math.min(f, o + properties.viewportWidth),
        f = math.fit(projectPage.nextProjectRatio, 0, 1, f, 0, ease.quintInOut);
        let p = math.fit(projectPage.nextProjectRatio, 0, 1, this.previewInnerOffsetFrom, this.previewInnerOffsetTo);
        n ? (this.domPreview.style.transform = `translate3d(0, ${f}px, 0)`,
        this.domPreviewInner.style.transform = `translate3d(0, ${p}px, 0)`) : (this.domPreview.style.transform = `translate3d(${f}px, 0, 0)`,
        this.domPreviewInner.style.transform = `translate3d(${p}px, 0, 0)`),
        this.domPreviewFooterBarInner.style.transform = `scaleX(${this.overScrollRatio})`;
        let g = c * math.fit(projectPage.nextProjectRatio, 0, .5, 1, 0) * math.fit(projectPage.contentShowRatio, .5, 1, 0, 1)
          , v = 1;
        n ? this.domMeta.style.transform = this.domDetailsItemsMoveContainer.style.transform : (this.domMeta.style.transform = "translate3d(0,-50%,0)",
        v = math.fit(this.scrollPane.scrollPixel, 0, (n ? properties.viewportHeight : properties.viewportWidth) * .25, 1, 0),
        v = Math.min(1 - projectPage.nextProjectRatio, v, c) * math.fit(projectPage.nextProjectRatio, 0, .3, 1, 0));
        let _ = math.fit(projectPage.nextProjectRatio, .75, 1, 0, 1);
        this.domPreviewFooter.style.opacity = ease.expoInOut(g),
        this.domPreviewTitle.style.color = _c1.setStyle(this.previewTitleColorDefaultColorHex).lerp(_c2.setStyle(this.previewTitleColorHex), _).getStyle(),
        projectDetailsScreen.previewColorRatio = _,
        projectDetailsScreen.previewBgThreshold = f / (n ? properties.viewportHeight : properties.viewportWidth),
        projectDetailsScreen.shadow = math.mix(r.shadow, this.previewShadow, projectPage.nextProjectRatio),
        this.domMeta.classList.toggle("is-active", v > .5),
        this.domTitle.style.transform = `translate3d(${this.scrollPane.x / 2}px, ${math.fit(projectPage.contentShowRatio, 0, .65, this.titleCenterOffsetY, 0, ease.expoInOut)}px, 0)`,
        this.domTitle.style.opacity = v;
        let w;
        if (w = math.fit(projectPage.contentShowRatio, .4, .85, 0, 1, ease.expoOut),
        this.domDesc.style.transform = `translate3d(${this.scrollPane.x / 3}px, ${(1 - w) * 30}px, 0)`,
        this.domDesc.style.opacity = Math.min(v, w),
        w = math.fit(projectPage.contentShowRatio, .45, .9, 0, 1, ease.expoOut),
        this.domCta.style.transform = `translate3d(0, ${(1 - w) * 30}px, 0)`,
        this.domCta.style.opacity = Math.min(v, w),
        w = math.fit(projectPage.contentShowRatio, .5, .95, 0, 1, ease.expoOut),
        this.domSideListService.style.transform = `translate3d(${this.scrollPane.x / 5}px, ${(1 - w) * 30}px, 0)`,
        this.domSideListService.style.opacity = Math.min(v, w),
        w = math.fit(projectPage.contentShowRatio, .55, 1, 0, 1, ease.expoOut),
        this.domSideListRecognitions.style.transform = `translate3d(${this.scrollPane.x / 4}px, ${(1 - w) * 30}px, 0)`,
        this.domSideListRecognitions.style.opacity = Math.min(v, w),
        this.domHeaderInfo._ratio = math.saturate(this.domHeaderInfo._ratio + (this.domHeaderInfo._hide ? e : -e)),
        this.domHeaderInfo.style.opacity = w - ease.expoOut(this.domHeaderInfo._ratio),
        this.sharedUniforms.u_opacity.value = g,
        projectDetailsItems.update(e, o, l),
        t || projectDetailsScreen.update(e),
        this.scrollPane.isActive && pagesManager.isIdle) {
            let S = this.scrollPane.targetScrollPixel >= this.scrollPane.contentSize * this.scrollPane.viewSizePixel - 1
              , b = properties.useMobileLayout ? input.deltaDragScrollY + input.deltaWheel : input.deltaDragScrollX + input.deltaWheel;
            this.overScrollRatio = math.saturate(this.overScrollRatio + e * (S && b > 0 ? 3 : b < 0 ? -5 : -.2)),
            this.overScrollRatio == 1 && routeManager.setPath("/projects/" + r.nextId)
        }
    }
    _onWindowWheel() {
        this.domHeaderInfo._hide = !0
    }
}
const projectDetailsSection = new ProjectDetailsSection;
class ProjectPageAudios {
    hasInit = !1;
    constructor() {}
    init() {
        settings.USE_AUDIO && (audios.fadeBgMusic("generic", 1),
        !this.hasInit && (this.domProjectLaunchCta = document.getElementById("project-details-launch-cta"),
        audios.addHoverClickEvents(this.domProjectLaunchCta),
        this.hasInit = !0))
    }
    update() {
        settings.USE_AUDIO
    }
}
const projectPageAudios = new ProjectPageAudios;
class ProjectPage extends Page {
    path = /projects\/([^\/]+)$/;
    id = "project";
    hasExtraPages = !1;
    bypassShowingLoading = !0;
    contentShowRatio = 0;
    nextProjectRatio = 0;
    prevNonProjectPath = null;
    preInit() {
        this._hideShownTween = new Tween(this,this._onContentShowComplete.bind(this));
        let e = this.domContainer;
        projectDetailsSection.preInit(e),
        videoOverlay.preInit()
    }
    preInitContent(e) {
        projectDetailsSection.preInitContent(e)
    }
    init() {
        projectDetailsSection.init(),
        videoOverlay.init(),
        super.init()
    }
    show(e, t, r) {
        this.useGenericTransition = !0,
        this._showPageTween.kill();
        let n = t.pathNodes[1];
        this.hideRatio = 0,
        header.forceWhite = !0,
        header.domRightMenuBtn.style.background = "#fff",
        header.domContainer.classList.add("--is-projects"),
        projectDetailsSection.domHeaderBackBtn.style.pointerEvents = "auto",
        e.target && e.target !== this && (this.prevNonProjectPath = e.path),
        this._onShowCompleteCallback = r,
        e.target === t.target ? (this.useGenericTransition = !1,
        projectDetailsSection.updatePreviewUI(n, !1),
        projectDetailsSection.update(0, !0),
        this._showPageTween.onComplete = this._onNextProjectComplete.bind(this),
        this._showPageTween.fromTo(1, {
            nextProjectRatio: 0
        }, {
            nextProjectRatio: 1
        })) : (e.target && e.target.hasProject(n) && (this.useGenericTransition = !1),
        projectDetailsSection.show(n),
        this._showPageTween.onComplete = r,
        this._showPageTween.fromTo(this.showDuration, {
            showRatio: 0,
            contentShowRatio: 0
        }, {
            showRatio: 1,
            contentShowRatio: 1
        })),
        projectPageAudios.init()
    }
    hide(e, t, r) {
        if (this.useGenericTransition = !0,
        header.domRightMenuBtn.style.removeProperty("background"),
        header.domContainer.classList.remove("--is-projects"),
        projectDetailsSection.domHeaderBackBtn.style.pointerEvents = "none",
        e.target === t.target)
            this.useGenericTransition = !1,
            this.hideRatio = 1,
            r();
        else {
            let n = e.pathNodes[1];
            t.target.hasProject(n) && t.target.isFirstShown && (this.useGenericTransition = !1),
            super.hide(e, t, () => {
                header.domContainer.style.removeProperty("color"),
                header.forceWhite = !1;
                for (let o in projectDetailsSection.projectDetailsData)
                    o.replace(/^color(.+)/g, (l, c) => {
                        c = c.replace(/([a-z\xE0-\xFF])([A-Z\xC0\xDF])/g, (u, f, p) => f + "-" + p).toLowerCase(),
                        properties.domRoot.style.removeProperty("--project-details-" + c),
                        properties.domRoot.style.removeProperty("--header-color"),
                        properties.domRoot.style.removeProperty("--header-text-color")
                    }
                    );
                r()
            }
            )
        }
    }
    resize(e, t) {
        this.hasInitialized && projectDetailsSection.resize(e, t)
    }
    update(e) {
        super.update(e),
        this.hasInitialized && (properties.smaa && (properties.smaa.enabled = !1),
        projectDetailsSection.update(e),
        projectPageAudios.update(e))
    }
    _onContentShowComplete() {
        this._onShowCompleteCallback()
    }
    _onNextProjectComplete() {
        this._hideShownTween.kill();
        let e = pagesManager.currRoute.pathNodes[1];
        this.nextProjectRatio = 0,
        this.contentShowRatio = 0,
        projectDetailsSection.show(e),
        this._hideShownTween.fromTo(1.5, {
            contentShowRatio: 0
        }, {
            contentShowRatio: 1
        })
    }
}
const projectPage = new ProjectPage;
let _brokenGlassStep = 0;
class HomePageAudios {
    hasInit = !1;
    constructor() {}
    init() {
        settings.USE_AUDIO && (audios.fadeBgMusic("generic", 1, 0),
        !this.hasInit && (this.domHomeReelCta = document.getElementById("home-reel-cta"),
        this.domHomeReelVideoWatchBtn = document.getElementById("home-reel-video-watch-btn"),
        this.domHomeFeaturedCta = document.getElementById("home-featured-cta"),
        this.domVideoOverlayPlayBtn = document.getElementById("video-overlay__play-btn"),
        this.domVideoOverlayMuteBtn = document.getElementById("video-overlay__mute-btn"),
        this.domProjectItems = Array.from(document.querySelectorAll("#home .project-item")),
        audios.addHoverClickEvents(this.domHomeReelCta),
        audios.addHoverClickEvents(this.domHomeReelVideoWatchBtn),
        audios.addHoverClickEvents(this.domHomeFeaturedCta),
        audios.addHoverClickEvents(this.domVideoOverlayPlayBtn),
        audios.addHoverClickEvents(this.domVideoOverlayMuteBtn),
        this.domProjectItems.forEach(e => audios.addHoverClickEvents(e)),
        this.hasInit = !0))
    }
    update() {
        if (!settings.USE_AUDIO)
            return;
        const {astronautDropRatio: e, blackFrameInRatio: t, blackTunnelRatio: r, whiteTunnelRatio: n} = goalTunnels;
        t > .5 && r === 0 ? (_brokenGlassStep = 0,
        audios.fadeBgMusic("cinematic_2", .5),
        audios.items.cinematic_2.setFilterFrequencyViaRatio(0),
        _brokenGlassStep = 0) : r > 0 && n === 0 ? (audios.fadeBgMusic("cinematic_3", .5),
        _brokenGlassStep = 0,
        audios.items.cinematic_3.setFilterFrequencyViaRatio(math.fit(goalTunnels.freezeRatio, .25, 1, 0, .5))) : n > 0 && e === 0 ? (audios.fadeBgMusic("cinematic_2", .5),
        audios.items.cinematic_2.setFilterFrequencyViaRatio(1)) : n > 0 && e <= .8 ? (audios.fadeBgMusic("cinematic_2", .5),
        audios.items.cinematic_2.setFilterFrequencyViaRatio(0)) : n > 0 && e > .8 ? audios.fadeBgMusic("generic_end", 1) : (_brokenGlassStep = 0,
        audios.fadeBgMusic("generic", 1)),
        e === 0 ? _brokenGlassStep = 1 : (_brokenGlassStep == 1 && audios.items.glass_broken.play(),
        _brokenGlassStep = 2)
    }
}
const homePageAudios = new HomePageAudios;
class HomePage extends Page {
    path = "";
    id = "home";
    hasEndVisual = !1;
    updateAudio = !1;
    endSectionActiveThreshold = 2.5;
    preInit() {
        let e = this.domContainer;
        homeHeroSection.preInit(e),
        homeReelSection.preInit(e),
        homeFeaturedSection.preInit(e),
        homeGoalSection.preInit(e)
    }
    init() {
        homeHeroSection.init(),
        homeReelSection.init(),
        homeFeaturedSection.init(),
        homeGoalSection.init(),
        super.init()
    }
    hasProject(e) {
        return homeFeaturedSection.projectItemList.hasProject(e)
    }
    show(e, t, r) {
        this.useGenericTransition = !0,
        this.updateAudio = !0,
        homeFeaturedSection.projectItemList.selectedId = null;
        let n = e.pathNodes[1];
        e.target === projectPage && this.hasProject(n) && this.isFirstShown ? (this.useGenericTransition = !1,
        this.showDuration = 1.5,
        scrollManager.scrollToPixel(homeFeaturedSection.projectItemList.getProjectItemTop(n) - properties.viewportHeight * .25, !0),
        homeFeaturedSection.projectItemList.selectedId = n) : this.showDuration = 1,
        homeHeroSection.initEvent(),
        homePageAudios.init(),
        super.show(e, t, r)
    }
    hide(e, t, r) {
        this.updateAudio = !1,
        this.useGenericTransition = !0,
        homeFeaturedSection.projectItemList.selectedId = null,
        t.target === projectPage && this.hasProject(t.pathNodes[1]) ? (this.useGenericTransition = !1,
        this.hideDuration = 1.5,
        homeFeaturedSection.projectItemList.selectedId = t.pathNodes[1]) : this.hideDuration = 1,
        homeHeroSection.hide(),
        super.hide(e, t, r)
    }
    resize(e, t) {
        homeHeroSection.resize(e, t),
        homeReelSection.resize(e, t),
        homeFeaturedSection.resize(e, t),
        homeGoalSection.resize(e, t)
    }
    update(e) {
        if (this.hasInitialized) {
            if (super.update(e),
            homeHeroSection.update(e),
            homeReelSection.update(e),
            homeFeaturedSection.update(e),
            homeGoalSection.update(e),
            pagesManager.scrollTargetPage == this) {
                let t = !0
                  , r = !1
                  , n = !1;
                scrollManager.getDomRange(homeGoalSection.domContainer).screenRatio == 1 ? (properties.bgColor.setStyle(properties.blackColorHex),
                t = !1,
                r = !0) : (properties.bgColor.setStyle(properties.offWhiteColorHex),
                t = !0,
                r = !1),
                homeGoalSection.uiBgColorNeedsOverride && (n = !1,
                homeGoalSection.isUIBgBlack ? (t = !1,
                r = !0) : (t = !0,
                r = !1)),
                footerSection.getDomRange().ratio > -.1 && (t = !0,
                r = !1,
                n = !1),
                document.documentElement.classList.toggle("is-black-bg", r),
                document.documentElement.classList.toggle("is-white-bg", t),
                document.documentElement.classList.toggle("is-blue-bg", n)
            }
            this.updateAudio && homePageAudios.update(e)
        }
    }
}
const homePage = new HomePage
  , getLightUvShader = `#define GLSLIFY 1
uniform vec2 u_lightShadowTextureTexelSize;vec2 getLightUv(vec3 lightToWorld){float flatYScale=1.5;vec2 flatUv=normalize(lightToWorld*vec3(1.,flatYScale,1.)).xz;vec2 dir=abs(normalize(flatUv));flatUv=(flatUv*(dir.y>dir.x ? 1./dir.y : 1./dir.x)*0.5+0.5)*vec2(1.,0.5);float isTop=lightToWorld.y>0.0 ? 1.0 : 0.0;float halfTexelY=u_lightShadowTextureTexelSize.y*0.5;flatUv.y=clamp(0.+isTop*halfTexelY,0.5-(1.-isTop)*halfTexelY,flatUv.y);return flatUv+vec2(0.,isTop*.5);}`;
class AboutHeroLight {
    shadowMapSize = 1024;
    position = new Vector3(0,8,0);
    shadowRenderTarget = null;
    sharedUniforms = {
        u_lightPosition: {
            value: this.position
        },
        u_lightColor: {
            value: new Color("#000")
        },
        u_lightShadowMaxDistance: {
            value: 12
        },
        u_lightShadowTexture: {
            value: null
        },
        u_lightShadowTextureTexelSize: {
            value: new Vector2(1 / this.shadowMapSize,1 / (this.shadowMapSize * 2))
        }
    };
    preInit() {}
    init() {
        shaderHelper.addChunk("getLightUv", getLightUvShader),
        this.shadowRenderTarget = fboHelper.createRenderTarget(this.shadowMapSize, this.shadowMapSize * 2, !0, HalfFloatType);
        let e = this.sharedUniforms.u_lightShadowTexture.value = this.shadowRenderTarget.texture;
        this.shadowRenderTarget.depthBuffer = !0,
        settings.USE_WEBGL2 && (e.format = RedFormat)
    }
    update(e) {
        let t = properties.renderer
          , r = fboHelper.getColorState()
          , n = t.getRenderTarget();
        t.setRenderTarget(this.shadowRenderTarget),
        t.setClearColor(16777215, 1),
        t.clear(),
        t.setRenderTarget(n),
        fboHelper.setColorState(r)
    }
    renderMesh(e) {
        let t = properties.renderer
          , r = fboHelper.getColorState()
          , n = t.getRenderTarget();
        t.autoClearColor = !1,
        fboHelper.renderMesh(e, this.shadowRenderTarget),
        t.setRenderTarget(n),
        fboHelper.setColorState(r)
    }
    postUpdate(e) {
        let t = properties.renderer
          , r = fboHelper.getColorState()
          , n = t.getRenderTarget();
        properties.gl,
        t.autoClear = !1,
        t.setRenderTarget(n),
        fboHelper.setColorState(r)
    }
}
const light = new AboutHeroLight
  , sliceShader = `#define GLSLIFY 1
uniform vec2 u_lightFieldSlicedTextureSize;uniform vec2 u_lightFieldSliceColRowCount;uniform vec3 u_lightFieldGridCount;uniform vec3 u_lightFieldVolumeOffset;uniform vec3 u_lightFieldVolumeSize;vec2 lightFieldGridToUv(vec3 grid){vec2 uv=grid.xy;vec2 colRow=floor(vec2(mod(grid.z,u_lightFieldSliceColRowCount.x),grid.z/u_lightFieldSliceColRowCount.x));uv+=colRow*u_lightFieldGridCount.xy+.5;return uv/u_lightFieldSlicedTextureSize;}vec3 lightFieldGridToUv3(vec3 grid){return grid/u_lightFieldGridCount;}vec3 clampLightFieldGrid(vec3 grid){return clamp(grid,vec3(.5),u_lightFieldGridCount-vec3(.5));}vec3 lightFieldPosToGrid(vec3 pos){return(pos-u_lightFieldVolumeOffset)/u_lightFieldVolumeSize*u_lightFieldGridCount;}vec3 clampedLightFieldPosToGrid(vec3 pos){return clampLightFieldGrid(lightFieldPosToGrid(pos));}vec4 sampleLightField(sampler2D tex,vec3 gridPos){gridPos.z-=.5;vec2 uv1=lightFieldGridToUv(clampLightFieldGrid(vec3(gridPos.xy,floor(gridPos.z)+.5)));vec2 uv2=lightFieldGridToUv(clampLightFieldGrid(vec3(gridPos.xy,ceil(gridPos.z)+.5)));return mix(texture2D(tex,uv1),texture2D(tex,uv2),fract(gridPos.z));}`
  , sliceBlendFrag = `#define GLSLIFY 1
uniform sampler2D u_prevSliceTexture;uniform sampler2D u_drawnSliceTexture;varying vec2 v_uv;
#include <lightFieldSlice>
vec4 sampleSlice4(vec3 gridPos){vec3 sliceOffset=vec3(-.5,.5,0.);return(texture2D(u_drawnSliceTexture,lightFieldGridToUv(clampLightFieldGrid(gridPos+sliceOffset.xxz)))+texture2D(u_drawnSliceTexture,lightFieldGridToUv(clampLightFieldGrid(gridPos+sliceOffset.xyz)))+texture2D(u_drawnSliceTexture,lightFieldGridToUv(clampLightFieldGrid(gridPos+sliceOffset.yxz)))+texture2D(u_drawnSliceTexture,lightFieldGridToUv(clampLightFieldGrid(gridPos+sliceOffset.yyz))))/4.;}void main(){vec3 gridPos=vec3(mod(gl_FragCoord.xy,u_lightFieldGridCount.xy),dot(floor(gl_FragCoord.xy/u_lightFieldGridCount.xy),vec2(1.,u_lightFieldSliceColRowCount.x))+.5);vec4 prev=texture2D(u_prevSliceTexture,v_uv);vec4 curr=(sampleSlice4(gridPos+vec3(0.,0.,-1.))+sampleSlice4(gridPos)*2.+sampleSlice4(gridPos+vec3(0.,0.,1.)))*.25;prev+=(curr-prev)*mix(0.15,0.08,clamp(prev.r,0.,1.));gl_FragColor=prev;}`;
class AboutHeroLightField {
    GRID_COUNT = new Vector3(64,64,64);
    VOLUME_SIZE = new Vector3(8,0,0);
    container = new Object3D;
    prevSliceRenderTarget = null;
    currSliceRenderTarget = null;
    drawnSliceRenderTarget = null;
    sliceTo3DMesh = null;
    sliceBlendMaterial;
    sliceColumnCount = 0;
    sliceRowCount = 0;
    gridSize = 0;
    SHOW_TEST_VOXELS = !1;
    sharedUniforms = {
        u_lightFieldTexture3D: {
            value: null
        },
        u_lightFieldMaxLod: {
            value: 0
        },
        u_lightFieldSlicedTexture: {
            value: null
        },
        u_lightFieldSlicedTextureSize: {
            value: new Vector2
        },
        u_lightFieldSliceColRowCount: {
            value: new Vector2
        },
        u_lightFieldGridSize: {
            value: 0
        },
        u_lightFieldGridCount: {
            value: this.GRID_COUNT
        },
        u_lightFieldVolumeOffset: {
            value: new Vector3
        },
        u_lightFieldVolumeSize: {
            value: new Vector3
        }
    };
    preInit() {}
    init() {
        shaderHelper.addChunk("lightFieldSlice", sliceShader),
        this.gridSize = this.VOLUME_SIZE.x / (this.GRID_COUNT.x - 1),
        this.sharedUniforms.u_lightFieldGridSize.value = this.gridSize,
        this.VOLUME_SIZE.y = this.gridSize * (this.GRID_COUNT.y - 1),
        this.VOLUME_SIZE.z = this.gridSize * (this.GRID_COUNT.z - 1),
        this.sharedUniforms.u_lightFieldVolumeSize.value.setScalar(this.gridSize).add(this.VOLUME_SIZE),
        this.sharedUniforms.u_lightFieldMaxLod.value = Math.log2(Math.min(this.GRID_COUNT.x, this.GRID_COUNT.y, this.GRID_COUNT.z));
        let e = this.GRID_COUNT.x * this.GRID_COUNT.y * this.GRID_COUNT.z
          , t = this.sliceColumnCount = Math.ceil(Math.sqrt(e) / this.GRID_COUNT.x)
          , r = this.sliceRowCount = Math.ceil(this.GRID_COUNT.z / t);
        this.sharedUniforms.u_lightFieldSliceColRowCount.value.set(t, r);
        let n = this.GRID_COUNT.x * t
          , o = this.GRID_COUNT.y * r;
        this.sharedUniforms.u_lightFieldSlicedTextureSize.value.set(n, o),
        this.currSliceRenderTarget = fboHelper.createRenderTarget(n, o),
        this.prevSliceRenderTarget = this.currSliceRenderTarget.clone(),
        this.drawnSliceRenderTarget = this.currSliceRenderTarget.clone(),
        fboHelper.clearColor(0, 0, 0, 0, this.currSliceRenderTarget),
        this.sliceBlendMaterial = fboHelper.createRawShaderMaterial({
            uniforms: {
                u_lightFieldSlicedTextureSize: this.sharedUniforms.u_lightFieldSlicedTextureSize,
                u_lightFieldSliceColRowCount: this.sharedUniforms.u_lightFieldSliceColRowCount,
                u_lightFieldGridCount: this.sharedUniforms.u_lightFieldGridCount,
                u_lightFieldVolumeOffset: this.sharedUniforms.u_lightFieldVolumeOffset,
                u_lightFieldVolumeSize: this.sharedUniforms.u_lightFieldVolumeSize,
                u_prevSliceTexture: {
                    value: null
                },
                u_drawnSliceTexture: {
                    value: this.drawnSliceRenderTarget.texture
                }
            },
            fragmentShader: sliceBlendFrag
        })
    }
    update(e) {
        let t = this.VOLUME_SIZE.clone().multiplyScalar(.5).sub(light.position).multiplyScalar(-1);
        this.sharedUniforms.u_lightFieldVolumeOffset.value.setScalar(-this.gridSize / 2).add(t);
        let r = properties.renderer
          , n = fboHelper.getColorState()
          , o = r.getRenderTarget();
        r.setRenderTarget(this.drawnSliceRenderTarget),
        r.setClearColor(0, 0),
        r.clear(),
        r.setRenderTarget(o),
        fboHelper.setColorState(n)
    }
    renderMesh(e) {
        let t = properties.renderer
          , r = fboHelper.getColorState()
          , n = t.getRenderTarget();
        t.autoClearColor = !1,
        fboHelper.renderMesh(e, this.drawnSliceRenderTarget),
        t.setRenderTarget(n),
        fboHelper.setColorState(r)
    }
    postUpdate(e) {
        let t = properties.renderer
          , r = fboHelper.getColorState()
          , n = t.getRenderTarget();
        properties.gl,
        t.autoClear = !1;
        let o = this.prevSliceRenderTarget;
        this.prevSliceRenderTarget = this.currSliceRenderTarget,
        this.currSliceRenderTarget = o,
        this.sharedUniforms.u_lightFieldSlicedTexture.value = this.currSliceRenderTarget.texture,
        this.sliceBlendMaterial.uniforms.u_prevSliceTexture.value = this.prevSliceRenderTarget.texture,
        fboHelper.render(this.sliceBlendMaterial, this.currSliceRenderTarget),
        t.setRenderTarget(n),
        fboHelper.setColorState(r)
    }
}
const lightField = new AboutHeroLightField
  , fragSim = `#define GLSLIFY 1
uniform sampler2D u_simPrevPosLifeTexture;uniform sampler2D u_simDefaultPosLifeTexture;uniform float u_introDeltaTime;uniform float u_noiseTime;uniform float u_noiseScale;uniform float u_noiseStableFactor;uniform vec3 u_lightPosition;varying vec2 v_uv;
#define PI2 6.283185307179586
vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}
#define F4 0.309016994374947451
vec4 simplexNoiseDerivatives(vec4 v){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v+dot(v,vec4(F4)));vec4 x0=v-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 values0=vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2));vec2 values1=vec2(dot(p3,x3),dot(p4,x4));vec3 m0=max(0.5-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.5-vec2(dot(x3,x3),dot(x4,x4)),0.0);vec3 temp0=-6.0*m0*m0*values0;vec2 temp1=-6.0*m1*m1*values1;vec3 mmm0=m0*m0*m0;vec2 mmm1=m1*m1*m1;float dx=temp0[0]*x0.x+temp0[1]*x1.x+temp0[2]*x2.x+temp1[0]*x3.x+temp1[1]*x4.x+mmm0[0]*p0.x+mmm0[1]*p1.x+mmm0[2]*p2.x+mmm1[0]*p3.x+mmm1[1]*p4.x;float dy=temp0[0]*x0.y+temp0[1]*x1.y+temp0[2]*x2.y+temp1[0]*x3.y+temp1[1]*x4.y+mmm0[0]*p0.y+mmm0[1]*p1.y+mmm0[2]*p2.y+mmm1[0]*p3.y+mmm1[1]*p4.y;float dz=temp0[0]*x0.z+temp0[1]*x1.z+temp0[2]*x2.z+temp1[0]*x3.z+temp1[1]*x4.z+mmm0[0]*p0.z+mmm0[1]*p1.z+mmm0[2]*p2.z+mmm1[0]*p3.z+mmm1[1]*p4.z;float dw=temp0[0]*x0.w+temp0[1]*x1.w+temp0[2]*x2.w+temp1[0]*x3.w+temp1[1]*x4.w+mmm0[0]*p0.w+mmm0[1]*p1.w+mmm0[2]*p2.w+mmm1[0]*p3.w+mmm1[1]*p4.w;return vec4(dx,dy,dz,dw)*49.0;}vec3 curl(in vec3 p,in float noiseTime,in float persistence){vec4 xNoisePotentialDerivatives=vec4(0.0);vec4 yNoisePotentialDerivatives=vec4(0.0);vec4 zNoisePotentialDerivatives=vec4(0.0);for(int i=0;i<2;++i){float twoPowI=pow(2.0,float(i));float scale=0.5*twoPowI*pow(persistence,float(i));xNoisePotentialDerivatives+=simplexNoiseDerivatives(vec4(p*twoPowI,noiseTime))*scale;yNoisePotentialDerivatives+=simplexNoiseDerivatives(vec4((p+vec3(123.4,129845.6,-1239.1))*twoPowI,noiseTime))*scale;zNoisePotentialDerivatives+=simplexNoiseDerivatives(vec4((p+vec3(-9519.0,9051.0,-123.0))*twoPowI,noiseTime))*scale;}return vec3(xNoisePotentialDerivatives[3]-zNoisePotentialDerivatives[1],zNoisePotentialDerivatives[2]-yNoisePotentialDerivatives[3],yNoisePotentialDerivatives[1]-xNoisePotentialDerivatives[2]);}void main(){vec4 posLife=texture2D(u_simPrevPosLifeTexture,v_uv);vec3 posLifeOrigin=posLife.xyz-u_lightPosition;posLife.w-=(0.5+u_noiseStableFactor)*u_introDeltaTime;if(posLife.w<0.0){vec3 defPosOrigin=texture2D(u_simDefaultPosLifeTexture,v_uv).xyz;vec3 defPos=defPosOrigin*(1.25+sin(u_noiseTime*2.5+v_uv.x*21.)*0.25)+u_lightPosition;posLife.w+=1.;posLife.xyz=defPos;}vec3 toLight=posLife.xyz-u_lightPosition;vec3 axis=vec3(sin(u_noiseTime),cos(u_noiseTime*2.+v_uv.y*6.283185),0.0);vec3 spinDir=cross(axis,toLight);float dist=length(toLight);if(dist>0.01){float spinStrength=u_introDeltaTime*(0.1+smoothstep(0.5,2.0,dist-v_uv.x*0.5)*(v_uv.y<0.5 ? 1. :-1.)*mix(2.,4.,v_uv.x))*mix(0.75,1.5,u_noiseStableFactor);posLife.xyz+=spinDir*spinStrength;}posLife.xyz+=(1.25+0.5*u_noiseScale)*curl((posLife.xyz-u_lightPosition)*(0.4+0.3*u_noiseStableFactor),u_noiseTime,0.2)*u_introDeltaTime*mix(0.4,1.5,posLife.w*posLife.w)*mix(0.75,1.25,v_uv.x);gl_FragColor=posLife;}`;
new Vector3;
class AboutHeroParticlesSimulation {
    SIM_TEXTURE_WIDTH = 128;
    SIM_TEXTURE_HEIGHT = browser$1.isMobile ? 128 : 192;
    currPositionRenderTarget = null;
    prevPositionRenderTarget = null;
    ORIGIN = new Vector3(0,8,0);
    isPlaying = !0;
    isFirstSim = !0;
    noiseSpeed = .4;
    _noise = new Simple1DNoise;
    noiseScaleTime = Math.random();
    noiseStableFactorTime = Math.random();
    noiseStableFactor = Math.random();
    sharedUniforms = {
        u_simCurrPosLifeTexture: {
            value: null
        },
        u_simPrevPosLifeTexture: {
            value: null
        },
        u_simDefaultPosLifeTexture: {
            value: null
        },
        u_simTextureSize: {
            value: new Vector2(this.SIM_TEXTURE_WIDTH,this.SIM_TEXTURE_HEIGHT)
        },
        u_noiseStableFactor: {
            value: 0
        }
    };
    preInit() {
        this.currPositionRenderTarget = fboHelper.createRenderTarget(this.SIM_TEXTURE_WIDTH, this.SIM_TEXTURE_HEIGHT, !0, FloatType),
        this.prevPositionRenderTarget = this.currPositionRenderTarget.clone(),
        this.positionMaterial = fboHelper.createRawShaderMaterial({
            uniforms: {
                u_lightPosition: light.sharedUniforms.u_lightPosition,
                u_simPrevPosLifeTexture: this.sharedUniforms.u_simPrevPosLifeTexture,
                u_simDefaultPosLifeTexture: this.sharedUniforms.u_simDefaultPosLifeTexture,
                u_introDeltaTime: aboutHero.sharedUniforms.u_introDeltaTime,
                u_noiseTime: {
                    value: 0
                },
                u_noiseScale: {
                    value: 0
                },
                u_noiseStableFactor: this.sharedUniforms.u_noiseStableFactor
            },
            fragmentShader: fragSim
        });
        let e = this.SIM_TEXTURE_WIDTH * this.SIM_TEXTURE_HEIGHT
          , t = new Float32Array(e * 4);
        for (let n = 0, o = 0; n < e; n++,
        o += 4) {
            let l = Math.random()
              , c = Math.random()
              , u = l * 2 * Math.PI
              , f = Math.acos(2 * c - 1)
              , p = .25 + Math.cbrt(Math.random()) * .5
              , g = Math.sin(u)
              , v = Math.cos(u)
              , _ = Math.sin(f)
              , w = Math.cos(f);
            t[o + 0] = p * _ * v,
            t[o + 1] = p * _ * g,
            t[o + 2] = p * w,
            t[o + 3] = n / e - 1
        }
        let r = this.sharedUniforms.u_simDefaultPosLifeTexture.value = fboHelper.createDataTexture(t, this.SIM_TEXTURE_WIDTH, this.SIM_TEXTURE_HEIGHT, !0, !0);
        fboHelper.copy(r, this.currPositionRenderTarget)
    }
    init() {}
    update(e) {
        if (this.isPlaying) {
            let t = this.currPositionRenderTarget;
            this.currPositionRenderTarget = this.prevPositionRenderTarget,
            this.prevPositionRenderTarget = t,
            this.sharedUniforms.u_simCurrPosLifeTexture.value = this.currPositionRenderTarget.texture,
            this.sharedUniforms.u_simPrevPosLifeTexture.value = this.prevPositionRenderTarget.texture,
            this.positionMaterial.uniforms.u_noiseTime.value += e * this.noiseSpeed,
            this.noiseScaleTime += e;
            const r = this._noise.getFbm(this.noiseScaleTime, 3);
            this.positionMaterial.uniforms.u_noiseScale.value = 10 * Math.abs(r),
            this.noiseStableFactorTime += .5 * e,
            this.noiseStableFactor += .05 * Math.abs(this._noise.getFbm(this.noiseStableFactorTime, 3)),
            this.sharedUniforms.u_noiseStableFactor.value = math.fit(aboutHero.introRatio, 0, .4, 0, 1) * math.smoothstep(.9, .95, .5 + .5 * Math.sin(this.noiseStableFactor)),
            fboHelper.render(this.positionMaterial, this.currPositionRenderTarget)
        }
    }
}
const sim = new AboutHeroParticlesSimulation
  , vert$9 = `#define GLSLIFY 1
attribute vec2 simUv;uniform sampler2D u_simCurrPosLifeTexture;uniform vec2 u_simTextureSize;uniform float u_sceneHideRatio;uniform float u_isEmissive;uniform float u_noiseStableFactor;uniform sampler2D u_lightFieldSlicedTexture;
#include <lightFieldSlice>
varying vec3 v_worldPosition;varying vec3 v_viewNormal;varying vec3 v_worldNormal;varying float v_depth;varying float v_diff;varying float v_ao;varying float v_emission;float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}vec4 hash43(vec3 p){vec4 p4=fract(vec4(p.xyzx)*vec4(.1031,.1030,.0973,.1099));p4+=dot(p4,p4.wzxy+33.33);return fract((p4.xxyz+p4.yzzw)*p4.zywx);}void main(){vec4 currPositionInfo=texture2D(u_simCurrPosLifeTexture,simUv);vec4 rands=hash43(vec3(simUv,0.));float particleSize=mix(0.06,0.175,u_isEmissive)*(0.5+rands.x*0.5);float particleSizeScale=linearStep(0.0,0.1,currPositionInfo.w)*linearStep(1.0,0.9,currPositionInfo.w);particleSize*=particleSizeScale*(1.0-u_sceneHideRatio);vec3 pos=position*particleSize+currPositionInfo.xyz;gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.0);v_worldPosition=(modelMatrix*vec4(pos,1.0)).xyz;v_viewNormal=normalMatrix*normal;v_worldNormal=normalize((vec4(v_viewNormal,0.)*viewMatrix).xyz);vec3 rayGridDir=v_worldNormal;vec3 rayGridPos=lightFieldPosToGrid(v_worldPosition);vec4 indirectDiffuse=sampleLightField(u_lightFieldSlicedTexture,rayGridPos+rayGridDir);float lifeFalloff=mix(0.5,1.,particleSizeScale);v_emission=(indirectDiffuse.a*0.55*lifeFalloff+0.45)*u_isEmissive;v_diff=(1.-indirectDiffuse.a)*lifeFalloff;v_diff*=linearStep(5.,1.5,length(v_worldPosition-vec3(0.,8.,0.)));v_ao=1.0-indirectDiffuse.a;
#include <aboutHeroVisualFinal_vert>
}`
  , frag$d = `#define GLSLIFY 1
uniform sampler2D u_lightFieldSlicedTexture;uniform float u_noiseStableFactor;uniform float u_emissiveRatio;uniform float u_contrast;varying vec3 v_worldPosition;varying vec3 v_worldNormal;varying vec3 v_viewNormal;varying float v_depth;varying float v_diff;varying float v_emission;varying float v_ao;
#include <lightFieldSlice>
#include <getScatter>
#include <getBlueNoise>
float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main(){vec3 noise=getBlueNoise(gl_FragCoord.xy);vec3 viewNormal=normalize(v_viewNormal);vec3 worldNormal=normalize(v_worldNormal);vec3 rayGridPos=lightFieldPosToGrid(v_worldPosition);vec3 rayGridDir=worldNormal;vec3 rayGridSpecDir=reflect(normalize(v_worldPosition-cameraPosition),worldNormal);vec4 indirectSpecular=sampleLightField(u_lightFieldSlicedTexture,rayGridPos+normalize(rayGridSpecDir+(noise-.5)*0.25)*(1.+noise.z));float specular=indirectSpecular.r;vec3 rayGridRefractDir=refract(normalize(v_worldPosition-cameraPosition),worldNormal,1./1.4);vec4 refractionInfo=sampleLightField(u_lightFieldSlicedTexture,rayGridPos+normalize(rayGridRefractDir+(noise-.5)*0.25)*(1.5+noise.z));float refraction=refractionInfo.r*(1.-refractionInfo.a*0.75);float shade=v_diff*0.45+specular+refraction;shade+=getScatter(cameraPosition,v_worldPosition)*1.35;float viewShade=linearStep(-1.,1.,dot(viewNormal,vec3(.5773)));shade=mix(shade,viewShade,v_emission*v_ao)*(.4+v_ao*.6);gl_FragColor=vec4(mix(shade,smoothstep(0.,1.,shade),0.5),v_depth,1.,mix(v_diff*v_diff+v_emission,1.,u_emissiveRatio));}`
  , lightFieldVert = `#define GLSLIFY 1
attribute vec2 position;uniform sampler2D u_simCurrPosLifeTexture;uniform float u_noiseStableFactor;
#include <lightFieldSlice>
varying vec4 v_color;float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}vec4 hash43(vec3 p){vec4 p4=fract(vec4(p.xyzx)*vec4(.1031,.1030,.0973,.1099));p4+=dot(p4,p4.wzxy+33.33);return fract((p4.xxyz+p4.yzzw)*p4.zywx);}void main(){vec4 rands=hash43(vec3(position.xy,0.));vec4 currPositionInfo=texture2D(u_simCurrPosLifeTexture,position.xy);float scale=linearStep(1.0,0.9,currPositionInfo.w);vec3 pos=currPositionInfo.xyz;vec3 lightFieldGrid=clampedLightFieldPosToGrid(pos);vec2 lightFieldUv=lightFieldGridToUv(lightFieldGrid);gl_Position=vec4(lightFieldUv*2.0-1.0,0.0,1.0);gl_PointSize=1.0;vec3 color=position.x<0.005 ? vec3(1.): vec3(0.1);v_color=vec4(color,1.)*scale;}`
  , lightFieldFrag = `#define GLSLIFY 1
varying vec4 v_color;void main(){gl_FragColor=v_color;}`
  , motionVert = `#define GLSLIFY 1
attribute vec2 simUv;uniform sampler2D u_simPrevPosLifeTexture;uniform sampler2D u_simCurrPosLifeTexture;uniform vec2 u_simTextureSize;uniform float u_strength;uniform float u_aspect;varying vec2 v_delta;varying float v_headTail;float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}vec4 hash43(vec3 p){vec4 p4=fract(vec4(p.xyzx)*vec4(.1031,.1030,.0973,.1099));p4+=dot(p4,p4.wzxy+33.33);return fract((p4.xxyz+p4.yzzw)*p4.zywx);}vec2 rotate(vec2 v,float a){float s=sin(a);float c=cos(a);mat2 m=mat2(c,s,-s,c);return m*v;}void main(){vec4 currPositionInfo=texture2D(u_simCurrPosLifeTexture,simUv);vec4 prevPositionInfo=texture2D(u_simPrevPosLifeTexture,simUv);vec4 rands=hash43(vec3(simUv.xy,0.));float particleSize=(simUv.x<0.005 ? 0.175 : 0.06)*(0.5+rands.x*0.5);mat4 mvp=projectionMatrix*modelViewMatrix;vec4 currScreenPos=mvp*vec4(currPositionInfo.xyz,1.0);vec4 prevScreenPos=mvp*vec4(prevPositionInfo.xyz,1.0);currScreenPos/=currScreenPos.w;prevScreenPos/=prevScreenPos.w;vec2 screenPosDelta=currScreenPos.xy-prevScreenPos.xy;float screenPosDist=length(screenPosDelta);float angle=screenPosDist>0.001 ? atan(screenPosDelta.y,screenPosDelta.x*u_aspect): 0.;vec4 screenPos=position.x>-0.0001 ? currScreenPos : prevScreenPos;vec4 offsetScreenPos=modelViewMatrix*vec4((position.x>0. ? currPositionInfo.xyz : prevPositionInfo.xyz),1.0);offsetScreenPos.xy+=particleSize;offsetScreenPos=projectionMatrix*offsetScreenPos;offsetScreenPos/=offsetScreenPos.w;offsetScreenPos=offsetScreenPos-screenPos;v_delta=screenPosDelta;v_headTail=position.x;vec4 pos=vec4(position,0.);pos.xy=rotate(pos.xy,angle)*length(offsetScreenPos.xy*vec2(u_aspect,1.));pos.xy*=vec2(1./u_aspect,1.);pos+=screenPos;pos.xy+=v_delta*.5;v_delta=v_delta*2.+.5;gl_Position=pos;if(currPositionInfo.w>prevPositionInfo.w){gl_Position=vec4(2.,0.,0.,1.);}}`
  , motionFrag = `#define GLSLIFY 1
varying vec2 v_delta;varying float v_headTail;void main(){float ratio=sqrt(abs(v_headTail)*2.);float strength=sign(v_headTail)*ratio*-.5;gl_FragColor=vec4(v_delta,strength+.5,v_headTail+0.5);}`
  , getScatter = `#define GLSLIFY 1
uniform vec2 u_lightScatterDivider;uniform float u_lightScatterPowInv;uniform vec3 u_lightScatterPos0;uniform vec3 u_lightScatterPos1;uniform float u_lightScatterRatio;float getScatterCoff(vec3 start,vec3 dir,vec3 lightPos,float d){vec3 q=start-lightPos;float b=dot(dir,q);float c=dot(q,q);float t=c-b*b;float s=1.0/(2.5+pow(0.001+t,0.8));return s*(atan((d+b)*s)-atan(b*s));}vec2 getScatterLine(vec3 start,vec3 dir,vec3 lightPos0,vec3 lightPos1,float d){vec3 segCenter=(lightPos0+lightPos1)*0.5;vec3 segDir=normalize(lightPos1-lightPos0);vec3 diff=start-segCenter;float segExtent=distance(lightPos0,lightPos1)*0.5;float a01=-dot(dir,segDir);float b0=dot(diff,dir);float b1=-dot(diff,segDir);float det=abs(1.0-a01*a01);float s=clamp((a01*b0-b1)/max(0.0001,det),-segExtent,segExtent);vec3 lightPos=segDir*s+segCenter;return vec2(getScatterCoff(start,dir,segExtent>0.0 ? lightPos : lightPos0,d),s/segExtent*0.5+0.5);}float getScatter(vec3 cameraPosition,vec3 worldPos,vec2 lightScatterDivider,float lightScatterPowInv){vec3 worldToCamera=worldPos-cameraPosition;float d=length(worldToCamera);vec3 dir=worldToCamera/d;vec2 val=getScatterLine(cameraPosition,dir,u_lightScatterPos0,u_lightScatterPos1,d);return pow(max(0.0,val.x/mix(lightScatterDivider.x,lightScatterDivider.y,val.y)),lightScatterPowInv)*u_lightScatterRatio;}float getScatter(vec3 cameraPosition,vec3 worldPos){return getScatter(cameraPosition,worldPos,u_lightScatterDivider,u_lightScatterPowInv);}`;
class AboutHeroScatter {
    sharedUniforms = {
        u_lightScatterDivider: {
            value: new Vector2(1.1,5.5)
        },
        u_lightScatterPowInv: {
            value: 0
        },
        u_lightScatterRatio: {
            value: 0
        },
        u_lightScatterPos0: {
            value: new Vector3(0,18,0)
        },
        u_lightScatterPos1: {
            value: new Vector3(0,0,0)
        }
    };
    constructor() {
        this._brownianMotion0 = new BrownianMotion,
        this._brownianMotion1 = new BrownianMotion
    }
    init() {
        shaderHelper.addChunk("getScatter", getScatter)
    }
    update(e) {
        let t = math.fit(aboutHero.introRatio, 0, .2, 2, .7);
        t = math.fit(aboutHero.introRatio, .7, .85, t, .4),
        this.sharedUniforms.u_lightScatterPowInv.value = t,
        this.sharedUniforms.u_lightScatterRatio.value = math.fit(aboutHero.introRatio, .7, .85, 1, 0, ease.cubicIn)
    }
}
const aboutHeroScatter = new AboutHeroScatter
  , fragmentShader$2 = `#define GLSLIFY 1
varying vec2 v_uv;uniform sampler2D u_texture;void main(){gl_FragColor=texture2D(u_texture,v_uv).rrra;}`
  , motionBlurFragmentShader = `#define GLSLIFY 1
varying vec2 v_uv;uniform sampler2D u_texture;uniform sampler2D u_motionTexture;uniform float u_blurRatio;
#include <getBlueNoise>
void main(){vec3 noise=getBlueNoise(gl_FragCoord.xy+vec2(41.,25.));vec4 motion=texture2D(u_motionTexture,v_uv);motion.xy-=0.5;motion.xy*=(motion.z-.5)/16.*u_blurRatio*0.25;vec4 c=vec4(0.);vec2 offset=motion.xy*noise.xy;for(int i=0;i<16;i++){offset+=motion.xy;c+=texture2D(u_texture,v_uv+offset);}c/=16.;gl_FragColor=vec4(c.rrr,c.a);vec4 color=texture2D(u_texture,v_uv).rrra;gl_FragColor=max(color,gl_FragColor);}`
  , blurFragmentShader = `#define GLSLIFY 1
varying vec2 v_uv;uniform sampler2D u_texture;uniform float u_aspect;uniform float u_blurRatio;
#include <getBlueNoise>
void main(){vec3 noise=getBlueNoise(gl_FragCoord.xy);vec4 texture=texture2D(u_texture,v_uv);vec2 ra=vec2(0.);float fi=0.;float theta=noise.x*6.283185307179586;vec2 strength=vec2(1.,1.*u_aspect)*.006*texture.b*u_blurRatio;for(int i=0;i<8;i++){theta+=10.166407384630519;ra+=texture2D(u_texture,v_uv+vec2(cos(theta),sin(theta))*sqrt((fi+.5)/8.)*strength).ra;fi+=1.;}ra/=8.;gl_FragColor=ra.xxxy;}`;
class AboutPageHeroEfxPrepass extends PostEffect {
    isActive = !0;
    cacheRT = null;
    motionBlurRatio = 1;
    motionRT;
    motionTmpRT;
    useMotionBlur = !1;
    blurRatio = 0;
    scene = new Scene;
    needsRenderScene = !0;
    renderOrder = 5;
    init(e) {
        Object.assign(this, e),
        super.init(),
        this.cacheRT = fboHelper.createRenderTarget(1, 1),
        this.motionRT = fboHelper.createRenderTarget(1, 1),
        this.motionRT.depthBuffer = !0,
        this.motionTmpRT = fboHelper.createRenderTarget(1, 1),
        this._material = fboHelper.createRawShaderMaterial({
            uniforms: Object.assign({
                u_texture: {
                    value: null
                },
                u_motionTexture: {
                    value: this.motionRT.texture
                },
                u_aspect: {
                    value: 1
                },
                u_blurRatio: {
                    value: 0
                }
            }, blueNoise.sharedUniforms),
            fragmentShader: fragmentShader$2
        }),
        this._motionBlurMaterial = fboHelper.createRawShaderMaterial({
            uniforms: this._material.uniforms,
            fragmentShader: motionBlurFragmentShader
        }),
        this._blurMaterial = fboHelper.createRawShaderMaterial({
            uniforms: this._material.uniforms,
            fragmentShader: blurFragmentShader
        })
    }
    needsRender() {
        return this.isActive
    }
    setPostprocessing(e) {
        const t = e.width
          , r = e.height;
        this.cacheRT.setSize(t, r),
        this._material.uniforms.u_aspect.value = t / r
    }
    renderMotion(e, t, r, n) {
        let o = properties.renderer
          , l = fboHelper.getColorState()
          , c = o.getRenderTarget();
        this.motionRT.setSize(r, n),
        o.setRenderTarget(this.motionRT),
        o.setClearColor(8355711, 0),
        o.clear(),
        fboHelper.renderMesh(e, this.motionRT, t),
        blur.blur(2, 1, this.motionRT, this.motionTmpRT, this.motionRT),
        o.setRenderTarget(c),
        fboHelper.setColorState(l),
        this.useMotionBlur = !0
    }
    render(e, t=!1) {
        if (fboHelper.copy(e.fromTexture, this.cacheRT),
        this.useMotionBlur ? (this.useMotionBlur = !1,
        this.material = this._motionBlurMaterial,
        this.material.uniforms.u_blurRatio.value = this.motionBlurRatio) : (this.material = this.blurRatio > 0 ? this._blurMaterial : this._material,
        this.material.uniforms.u_blurRatio.value = this.blurRatio),
        this.needsRenderScene) {
            this.material.uniforms.u_texture.value = e.fromTexture,
            fboHelper.render(this.material, e.toRenderTarget);
            let r = fboHelper.getColorState();
            fboHelper.renderer.autoClear = !1,
            fboHelper.renderer.setRenderTarget(e.toRenderTarget),
            fboHelper.renderer.render(this.scene, e.camera),
            fboHelper.setColorState(r),
            e.swap()
        } else
            super.render(e, t)
    }
}
const aboutPageHeroEfxPrepass = new AboutPageHeroEfxPrepass;
class AboutHeroParticles {
    container = new Object3D;
    emissiveMesh = null;
    nonEmissiveMesh = null;
    lightFieldMesh = null;
    lodIds = ["l", "m", "s", "xs"];
    lodRefGeometries = [];
    preInit() {
        for (let p = settings.IS_SMALL_SCREEN ? 1 : 0; p < 4; p++)
            properties.loader.add(settings.MODEL_PATH + "about/sphere_" + this.lodIds[p] + ".buf", {
                onLoad: this._onGeometryLoad.bind(this, p)
            });
        let e = sim.SIM_TEXTURE_WIDTH * sim.SIM_TEXTURE_HEIGHT
          , t = new Float32Array(e * 2)
          , r = new InstancedBufferGeometry
          , n = new InstancedBufferGeometry
          , o = new Float32Array((sim.SIM_TEXTURE_WIDTH - 1) * sim.SIM_TEXTURE_HEIGHT * 2)
          , l = new Float32Array(sim.SIM_TEXTURE_HEIGHT * 2);
        for (let p = 0, g = 0, v = 0, _ = 0; p < e; p++,
        g += 2) {
            let w = t[g + 0] = (p % sim.SIM_TEXTURE_WIDTH + .5) / sim.SIM_TEXTURE_WIDTH
              , S = t[g + 1] = (~~(p / sim.SIM_TEXTURE_WIDTH) + .5) / sim.SIM_TEXTURE_HEIGHT;
            p % sim.SIM_TEXTURE_WIDTH == 0 ? (l[v + 0] = w,
            l[v + 1] = S,
            v += 2) : (o[_ + 0] = w,
            o[_ + 1] = S,
            _ += 2)
        }
        r.setAttribute("simUv", new InstancedBufferAttribute(o,2)),
        this.nonEmissiveMesh = new Mesh(r,new ShaderMaterial({
            uniforms: Object.assign({
                u_simCurrPosLifeTexture: sim.sharedUniforms.u_simCurrPosLifeTexture,
                u_simTextureSize: sim.sharedUniforms.u_simTextureSize,
                u_noiseStableFactor: sim.sharedUniforms.u_noiseStableFactor,
                u_isEmissive: {
                    value: 0
                },
                u_emissiveRatio: {
                    value: 0
                }
            }, lightField.sharedUniforms, aboutHeroScatter.sharedUniforms, aboutHero.sharedUniforms, blueNoise.sharedUniforms),
            vertexShader: vert$9,
            fragmentShader: frag$d
        })),
        this.nonEmissiveMesh.renderOrder = 5,
        this.nonEmissiveMesh.frustumCulled = !1,
        this.container.add(this.nonEmissiveMesh),
        n.setAttribute("simUv", new InstancedBufferAttribute(l,2)),
        this.emissiveMesh = new Mesh(n,new ShaderMaterial({
            uniforms: Object.assign({}, this.nonEmissiveMesh.material.uniforms, {
                u_isEmissive: {
                    value: 1
                },
                u_emissiveRatio: {
                    value: 0
                }
            }),
            vertexShader: vert$9,
            fragmentShader: frag$d
        })),
        this.emissiveMesh.renderOrder = 5,
        this.emissiveMesh.frustumCulled = !1,
        this.container.add(this.emissiveMesh);
        let c = new PlaneGeometry(1,1)
          , u = new InstancedBufferGeometry;
        for (let p in c.attributes)
            u.attributes[p] = c.attributes[p];
        u.setIndex(c.getIndex()),
        u.setAttribute("simUv", new InstancedBufferAttribute(t,2)),
        this.motionMesh = new Mesh(u,new ShaderMaterial({
            uniforms: {
                u_simPrevPosLifeTexture: sim.sharedUniforms.u_simPrevPosLifeTexture,
                u_simCurrPosLifeTexture: sim.sharedUniforms.u_simCurrPosLifeTexture,
                u_aspect: properties.sharedUniforms.u_aspect
            },
            vertexShader: motionVert,
            fragmentShader: motionFrag
        })),
        this.motionMesh.frustumCulled = !1;
        let f = new BufferGeometry;
        f.setAttribute("position", new BufferAttribute(t,2)),
        this.lightFieldMesh = new Points(f,fboHelper.createRawShaderMaterial({
            uniforms: Object.assign({
                u_simCurrPosLifeTexture: sim.sharedUniforms.u_simCurrPosLifeTexture,
                u_noiseStableFactor: sim.sharedUniforms.u_noiseStableFactor
            }, lightField.sharedUniforms),
            vertexShader: lightFieldVert,
            fragmentShader: lightFieldFrag,
            blending: CustomBlending,
            blendEquation: MaxEquation,
            blendSrc: OneFactor,
            blendDst: OneFactor,
            blendEquationAlpha: MaxEquation,
            blendSrcAlpha: OneFactor,
            blendDstAlpha: OneFactor
        })),
        this.lightFieldMesh.frustumCulled = !1
    }
    _onGeometryLoad(e, t) {
        this.lodRefGeometries[e] = t
    }
    init() {}
    update(e) {
        this.nonEmissiveMesh.material.uniforms.u_emissiveRatio.value = math.fit(aboutHero.introRatio, 0, .2, 0, .75),
        this.emissiveMesh.material.uniforms.u_emissiveRatio.value = math.fit(aboutHero.introRatio, 0, .2, 0, .75);
        let t, r = aboutHero.introRatio < .3, n = !r && aboutHero.introRatio < .7, o = 0, l = 0;
        settings.IS_SMALL_SCREEN ? (o = r ? 2 : 3,
        l = r ? 1 : n ? 2 : 3) : (o = r ? 1 : n ? 2 : 3,
        l = r ? 0 : n ? 1 : 3),
        t = this.lodRefGeometries[o];
        for (let u in t.attributes)
            this.nonEmissiveMesh.geometry.attributes[u] = t.attributes[u];
        this.nonEmissiveMesh.geometry.setIndex(t.getIndex()),
        t = this.lodRefGeometries[l];
        for (let u in t.attributes)
            this.emissiveMesh.geometry.attributes[u] = t.attributes[u];
        this.emissiveMesh.geometry.setIndex(t.getIndex()),
        lightField.renderMesh(this.lightFieldMesh);
        let c = math.fit(aboutHero.introRatio, 0, .1, 1, 1.5);
        c = math.fit(aboutHero.introRatio, .1, .15, c, 0),
        aboutPageHeroEfxPrepass.motionBlurRatio = c,
        aboutPageHeroEfxPrepass.motionBlurRatio > 0 && aboutPageHeroEfxPrepass.renderMotion(this.motionMesh, properties.camera, properties.width >> 2, properties.height >> 2)
    }
}
const aboutHeroParticles = new AboutHeroParticles
  , vert$8 = `#define GLSLIFY 1
attribute float piece;attribute float instanceId;attribute vec4 instanceRands;uniform sampler2D u_posRandTexture;uniform sampler2D u_orientTexture;uniform vec2 u_animationTextureSize;uniform float u_time;uniform float u_globalTime;uniform float u_scale;uniform float u_noiseStableFactor;uniform float u_hudRatio;
#ifdef IS_SHADOW
uniform vec3 u_lightPosition;uniform float u_lightShadowMaxDistance;varying float v_distToLight;
#include <getLightUv>
#else
varying vec3 v_worldPosition;varying vec3 v_viewNormal;varying vec2 v_uv;varying float v_depth;
#endif
float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}vec3 qrotate(vec4 q,vec3 v){return v+2.0*cross(q.xyz,cross(q.xyz,v)+q.w*v);}vec4 quaternion(vec3 axis,float halfAngle){return vec4(axis*sin(halfAngle),cos(halfAngle));}vec4 hash42(vec2 p){vec4 p4=fract(vec4(p.xyxy)*vec4(.1031,.1030,.0973,.1099));p4+=dot(p4,p4.wzxy+33.33);return fract((p4.xxyz+p4.yzzw)*p4.zywx);}vec2 rotate(vec2 v,float a){float s=sin(a);float c=cos(a);mat2 m=mat2(c,s,-s,c);return m*v;}void main(){float duration=0.25+2.+4.;float time=duration*instanceRands.x+u_time;float cycle=floor(time/duration);time=time-duration*cycle;vec4 cycleRands=hash42(vec2(cycle,instanceId));float flyUpRatio=pow(linearStep(2.25,6.25,time),1.5);float appearRatio=linearStep(0.,0.25,time-instanceRands.y)*(1.0-u_hudRatio);vec4 selfSpin=quaternion(normalize(instanceRands.xyz-0.5),flyUpRatio*mix(5.0,30.,cycleRands.z));float pieceScale=appearRatio;vec3 origin=vec3(0.0,1.9+instanceRands.w*0.4,0.0);float angle=cycleRands.x*6.2832;float radius=4.+cycleRands.w*4.;float rollRatio=1.0-linearStep(0.,3.25,time+instanceRands.x);radius-=(rollRatio*rollRatio)*5.;vec2 dir=vec2(cos(angle),sin(angle));vec3 instanceOffset=vec3(dir.x*radius,flyUpRatio*mix(30.0,40.,cycleRands.z)+u_noiseStableFactor*(0.5+0.5*sin(u_globalTime+instanceId*0.1))*0.1,dir.y*radius);instanceOffset.xz=rotate(instanceOffset.xz,flyUpRatio*flyUpRatio*mix(-1.,1.,instanceRands.z))*smoothstep(1.5,0.35,flyUpRatio);float frame=linearStep(0.25,2.25,time)*119.;float frameFloor=floor(frame);float frameCeil=min(frameFloor+1.,119.);float frameFract=frame-frameFloor;vec4 simUvs=(vec3(piece,frameFloor,frameCeil).xyxz+.5)/u_animationTextureSize.xyxy;vec4 posRand1=texture2D(u_posRandTexture,simUvs.xy);vec4 orient1=texture2D(u_orientTexture,simUvs.xy);vec4 posRand2=texture2D(u_posRandTexture,simUvs.zw);vec4 orient2=texture2D(u_orientTexture,simUvs.zw);
#ifdef IS_SHADOW
pieceScale*=1.5;
#endif
vec3 pos1=qrotate(orient1,position)*pieceScale+posRand1.xyz;vec3 pos2=qrotate(orient2,position)*pieceScale+posRand2.xyz;vec3 pos=u_scale*0.75*mix(0.5,1.5,instanceRands.z*instanceRands.z)*linearStep(1.,0.9,flyUpRatio)*(qrotate(selfSpin,mix(pos1,pos2,frameFract)-origin)+origin)*mix(0.3,0.7,cycleRands.w)+instanceOffset;
#ifdef IS_SHADOW
pos=(modelMatrix*vec4(pos,1.0)).xyz;vec3 center=instanceOffset+origin-u_lightPosition;pos-=u_lightPosition;v_distToLight=length(pos)/u_lightShadowMaxDistance;if(center.y>0.0){pos.y=max(0.001,pos.y);}else{pos.y=min(-0.001,pos.y);}gl_Position=vec4(getLightUv(pos)*2.0-1.0,1.-v_distToLight,1.0);
#else
vec3 nor1=qrotate(selfSpin,qrotate(orient1,normal));vec3 nor2=qrotate(selfSpin,qrotate(orient2,normal));vec3 nor=normalize(mix(nor1,nor2,frameFract));gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.0);v_worldPosition=(modelMatrix*vec4(pos,1.0)).xyz;v_viewNormal=normalMatrix*nor;v_uv=uv;vec4 viewPosition=modelViewMatrix*vec4(pos,1.0);
#include <aboutHeroVisualFinal_vert>
#endif
}`
  , frag$c = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec4 u_textureChannelMixer;uniform vec3 u_lightColor;uniform vec3 u_lightPosition;uniform float u_noiseStableFactor;varying vec3 v_worldPosition;varying vec3 v_viewNormal;varying vec2 v_uv;varying float v_depth;vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}
#include <getScatter>
void main(){float pattern=dot(u_textureChannelMixer,texture2D(u_texture,v_uv));vec3 viewNormal=normalize(v_viewNormal);vec3 worldNormal=inverseTransformDirection(viewNormal,viewMatrix);vec3 worldToLight=u_lightPosition-v_worldPosition;float worldToLightDist=length(worldToLight);float attenutation=1.0/(0.05+(0.02-0.005*u_noiseStableFactor)*worldToLightDist*worldToLightDist);worldToLight/=worldToLightDist;vec3 cameraToWorld=normalize(v_worldPosition-cameraPosition);float diff=0.25+0.75*dot(worldNormal,worldToLight);float spec=0.8*dot(reflect(cameraToWorld,worldNormal),worldToLight);vec3 color=vec3(pattern);color*=attenutation*(0.05+diff+spec*diff);gl_FragColor=vec4(color*0.85+0.15,spec*(0.3+u_noiseStableFactor));gl_FragColor.rgb+=getScatter(cameraPosition,v_worldPosition);
#include <aboutHeroVisualFinal_frag>
}`
  , lightShadowMapFrag = `#define GLSLIFY 1
varying float v_distToLight;void main(){gl_FragColor=vec4(v_distToLight);}`;
class AboutHeroRocks {
    ROCK_PIECE_COUNT = 16;
    FRAME_COUNT = 120;
    FPS = 60;
    COUNT = browser$1.isMobile ? 48 : 64;
    container = new Object3D;
    meshList = [];
    shadowMeshList = [];
    meshAnimationUniformList = [];
    meshInstanceUniformsList = [];
    meshInstanceAttributesList = [];
    time = 0;
    sharedUniforms = {
        u_texture: {
            value: null
        },
        u_animationTextureSize: {
            value: new Vector2(this.ROCK_PIECE_COUNT,this.FRAME_COUNT)
        },
        u_time: {
            value: 0
        },
        u_globalTime: {
            value: 0
        },
        u_scale: {
            value: 0
        },
        u_lightPosition: light.sharedUniforms.u_lightPosition,
        u_noiseStableFactor: sim.sharedUniforms.u_noiseStableFactor
    };
    preInit() {
        properties.loader.add(settings.TEXTURE_PATH + "about/rocks.webp", {
            type: "texture",
            onLoad: e => {
                let t = fboHelper.createRawShaderMaterial({
                    uniforms: Object.assign({
                        u_texture: {
                            value: e
                        }
                    }, aboutHeroScatter.sharedUniforms),
                    fragmentShader: `
						uniform sampler2D u_texture;
						varying vec2 v_uv;
						void main () {
							vec2 uv = v_uv * 0.5;
							gl_FragColor = vec4(
								texture2D(u_texture, uv).g,
								texture2D(u_texture, uv + vec2(.5, 0.)).g,
								texture2D(u_texture, uv + vec2(0., .5)).g,
								texture2D(u_texture, uv + vec2(.5, .5)).g
							);
						}`
                })
                  , r = fboHelper.createRenderTarget(512, 512);
                r.texture.minFitler = LinearMipmapLinearFilter,
                r.texture.generateMipmaps = !0,
                fboHelper.render(t, r),
                this.sharedUniforms.u_texture.value = r.texture,
                t.dispose(),
                e.dispose()
            }
        }).content;
        for (let e = 0; e < 4; e++) {
            this.meshAnimationUniformList[e] = {
                u_posRandTexture: {
                    value: null
                },
                u_orientTexture: {
                    value: null
                }
            },
            this.meshInstanceUniformsList[e] = Object.assign({
                u_textureChannelMixer: {
                    value: new Vector4(+(e == 0),+(e == 1),+(e == 2),+(e == 3))
                }
            }, this.meshAnimationUniformList[e], this.sharedUniforms, aboutHero.sharedUniforms, light.sharedUniforms, aboutHeroScatter.sharedUniforms);
            let t = new Float32Array(this.COUNT)
              , r = new Float32Array(this.COUNT * 4);
            for (let n = 0; n < this.COUNT; n++)
                t[n] = e + n * 4,
                r[n * 4 + 0] = Math.random(),
                r[n * 4 + 1] = Math.random(),
                r[n * 4 + 2] = Math.random(),
                r[n * 4 + 3] = Math.random();
            this.meshInstanceAttributesList[e] = {
                instanceId: new InstancedBufferAttribute(t,1),
                instanceRands: new InstancedBufferAttribute(r,4)
            },
            properties.loader.add(settings.MODEL_PATH + "about/rock_" + e + ".buf", {
                onLoad: this._onRockLoad.bind(this, e, !1)
            }),
            properties.loader.add(settings.MODEL_PATH + "about/rock_" + e + "_low.buf", {
                onLoad: this._onRockLoad.bind(this, e, !0)
            }),
            properties.loader.add(settings.MODEL_PATH + "about/rock_animation_" + e + ".buf", {
                onLoad: this._onRockAnimationLoad.bind(this, e)
            })
        }
    }
    loadRock(e) {}
    _onRockLoad(e, t, r) {
        let n = new InstancedBufferGeometry;
        for (let c in r.attributes)
            n.setAttribute(c, r.attributes[c]);
        n.index = r.index;
        let o = this.meshInstanceAttributesList[e];
        n.setAttribute("instanceId", o.instanceId),
        n.setAttribute("instanceRands", o.instanceRands);
        let l = new Mesh(n,new ShaderMaterial({
            uniforms: this.meshInstanceUniformsList[e],
            vertexShader: vert$8,
            fragmentShader: frag$c
        }));
        l.frustumCulled = !1,
        t ? (this.shadowMeshList[e] = l,
        l.material.defines.IS_SHADOW = !0,
        l.material.fragmentShader = lightShadowMapFrag,
        l.material.side = DoubleSide) : this.meshList[e] = l
    }
    _onRockAnimationLoad(e, t) {
        let r = t.attributes.position.array
          , n = t.attributes.orient.array
          , o = new Float32Array(r.length / 3 * 4)
          , l = [];
        for (let c = 0, u = 0, f = 0; u < r.length; c++,
        u += 3,
        f += 4)
            o[f] = r[u],
            o[f + 1] = r[u + 1],
            o[f + 2] = r[u + 2],
            c < this.ROCK_PIECE_COUNT && (l[c] = Math.random()),
            o[f + 3] = l[c % this.ROCK_PIECE_COUNT];
        this.meshAnimationUniformList[e].u_posRandTexture.value = fboHelper.createDataTexture(o, this.ROCK_PIECE_COUNT, this.FRAME_COUNT, !0, !0),
        this.meshAnimationUniformList[e].u_orientTexture.value = fboHelper.createDataTexture(n, this.ROCK_PIECE_COUNT, this.FRAME_COUNT, !0, !0)
    }
    init() {
        for (let e = 0; e < 4; e++)
            this.container.add(this.meshList[e])
    }
    update(e) {
        if (properties.hasInitialized) {
            sim.sharedUniforms.u_noiseStableFactor.value,
            this.time += e,
            this.sharedUniforms.u_time.value = this.time,
            this.sharedUniforms.u_globalTime.value = properties.time,
            this.sharedUniforms.u_scale.value = math.fit(aboutHero.introRatio, 0, .2, 0, 1);
            for (let t = 0; t < 4; t++)
                light.renderMesh(this.shadowMeshList[t])
        }
    }
}
const aboutHeroRocks = new AboutHeroRocks
  , frag$b = `#define GLSLIFY 1
uniform sampler2D u_prevTexture;uniform sampler2D u_lightShadowTexture;uniform vec3 u_lightPosition;uniform vec2 u_blueNoiseOffset;uniform float u_lightShadowMaxDistance;uniform float u_radius;uniform float u_texelSize;varying vec2 v_uv;
#include <getLightUv>
#include <getBlueNoise>
float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main(){vec3 blueNoise=getBlueNoise(gl_FragCoord.xy+u_blueNoiseOffset);vec2 uvDir=normalize(v_uv-0.5);vec2 uv=v_uv-uvDir*u_texelSize;vec3 worldPosition=vec3(uv*2.0-1.0,0.0).xzy*u_radius;worldPosition.z*=-1.0;vec3 lightToWorld=worldPosition-u_lightPosition;float distToLight=length(lightToWorld);float expandRatio=linearStep(u_lightPosition.y,14.,distToLight);vec3 lightSampleStep=((vec3(lightToWorld.x,0.0,lightToWorld.z)*(1.0-expandRatio*0.75)+(blueNoise-0.5)*expandRatio*4.)*25.0*expandRatio*expandRatio)/float(LIGHT_SHADOW_SAMPLE_COUNT)*-mix(0.06,0.1,expandRatio);vec3 lightToWorldPos=lightToWorld+lightSampleStep*blueNoise.y;float accum=0.0;for(int i=0;i<LIGHT_SHADOW_SAMPLE_COUNT;i++){float selfDist=min(1.0,length(lightToWorldPos)/u_lightShadowMaxDistance);vec2 lightShadowUv=getLightUv(lightToWorldPos);float dist=texture2D(u_lightShadowTexture,lightShadowUv).r;float delta=selfDist-dist;accum+=delta>0. ? min(delta*delta*20.,1.): 1.0;lightToWorldPos+=lightSampleStep;}float shadowMask=accum/float(LIGHT_SHADOW_SAMPLE_COUNT);shadowMask=mix(shadowMask,1.0,expandRatio);shadowMask=pow(shadowMask,6.);float prevShadowMask=texture2D(u_prevTexture,v_uv).r;gl_FragColor=vec4(mix(prevShadowMask,shadowMask,shadowMask>prevShadowMask ? 0.5 : 0.2));}`
  , groundVert = `#define GLSLIFY 1
varying vec3 v_viewPosition;varying vec3 v_worldPosition;varying vec3 v_viewNormal;varying vec2 v_uv;varying vec3 v_localPosition;varying float v_depth;void main(){vec3 pos=position;vec4 mvPosition=modelViewMatrix*vec4(position,1.);gl_Position=projectionMatrix*mvPosition;v_worldPosition=(modelMatrix*vec4(position,1.)).xyz;v_viewNormal=normalMatrix*normal;v_viewPosition=-mvPosition.xyz;v_uv=uv;v_localPosition=position;
#include <aboutHeroVisualFinal_vert>
}`
  , groundFrag = `#define GLSLIFY 1
varying vec3 v_viewPosition;varying vec3 v_worldPosition;varying vec3 v_viewNormal;varying vec2 v_uv;varying vec3 v_localPosition;varying float v_depth;uniform sampler2D u_texture;uniform sampler2D u_groundShadowTexture;uniform vec3 u_color;uniform vec3 u_bgColor;uniform vec3 u_lightPosition;uniform float u_fogA;uniform float u_fogB;uniform float u_sceneRatio;uniform float u_hudRatio;uniform float u_noiseStableFactor;
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define saturate( a ) clamp( a, 0.0, 1.0 )
float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}vec3 applyFog(in vec3 rgb,in float distance,in vec3 rayOri,in vec3 rayDir){float a=u_fogA;float b=u_fogB;float fogAmount=(a/b)*exp(-rayOri.y*b)*(1.0-exp(-distance*rayDir.y*b))/rayDir.y;return mix(rgb,u_bgColor,fogAmount);}vec2 dHdxy_fwd(){vec2 dSTdx=dFdx(v_uv);vec2 dSTdy=dFdy(v_uv);float scale=0.1;float Hll=scale*texture2D(u_texture,v_uv).b;float dBx=scale*texture2D(u_texture,v_uv+dSTdx).b-Hll;float dBy=scale*texture2D(u_texture,v_uv+dSTdy).b-Hll;return vec2(dBx,dBy);}vec3 perturbNormalArb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=dFdx(surf_pos.xyz);vec3 vSigmaY=dFdy(surf_pos.xyz);vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}
#include <getScatter>
#include <getBlueNoise>
void main(){vec3 blueNoise=getBlueNoise(gl_FragCoord.xy+vec2(48.,31.));vec3 mixedTexture=texture2D(u_texture,v_uv).rgb;float shadow=mixedTexture.r;float light=clamp(mixedTexture.g,0.1,1.0);float faceDirection=gl_FrontFacing ? 1.0 :-1.0;vec3 normal=normalize(v_viewNormal)*faceDirection;normal=perturbNormalArb(-v_viewPosition,normal,dHdxy_fwd(),faceDirection);vec3 N=inverseTransformDirection(normal,viewMatrix);vec3 L=normalize(u_lightPosition-v_worldPosition);vec3 V=normalize(cameraPosition-v_worldPosition);vec3 reflection=normalize(reflect(-V,N));float NdL=clamp(dot(N,L),0.001,1.0);float NdV=clamp(abs(dot(N,V)),0.001,1.0);vec3 lightToWorld=v_worldPosition-u_lightPosition;float distToLight=length(lightToWorld);float attenutation=1.0/(0.05+(0.025-0.005*u_noiseStableFactor)*distToLight*distToLight);float dist=1.0-pow(2.0*length(v_uv-0.5),2.0);float rockShadows=texture2D(u_groundShadowTexture,(vec2(v_localPosition.x,-v_localPosition.z)+(blueNoise.xy-.5)*0.1)*0.0425+0.5).r;float spec=dot(reflect(V,N),L)*linearStep(0.9,0.0,N.y)*4.;gl_FragColor.rgb=vec3(light+attenutation*spec);gl_FragColor.rgb*=shadow*(0.5+rockShadows*0.5)*(1.+spec);gl_FragColor.rgb=applyFog(gl_FragColor.rgb,length(cameraPosition-v_worldPosition),cameraPosition,-V);gl_FragColor.rgb+=getScatter(cameraPosition,v_worldPosition);
#include <aboutHeroVisualFinal_frag>
gl_FragColor.r=mix(gl_FragColor.r,shadow*(1.-abs(N.y)),u_hudRatio);gl_FragColor.r*=u_sceneRatio;gl_FragColor.g-=blueNoise.z*0.004;gl_FragColor.b=linearStep(15.,66.,v_worldPosition.z);gl_FragColor.a=spec*shadow;}`;
class AboutHeroGround {
    container = new Object3D;
    geometry = null;
    mesh = null;
    texture = null;
    RADIUS = 12;
    SIZE = 768;
    sharedUniforms = {
        u_groundShadowTexture: {
            value: null
        }
    };
    prevRenderTarget = null;
    currRenderTarget = null;
    blurCacheRenderTarget = null;
    preInit() {
        properties.loader.add(settings.MODEL_PATH + "about/terrain.buf", {
            onLoad: e => this.geometry = e
        }),
        this.texture = properties.loader.load(settings.TEXTURE_PATH + "about/terrain_shadow_light_height.webp", {
            type: "texture",
            flipY: !0,
            minFilter: LinearFilter
        }).content
    }
    init() {
        this.prevRenderTarget = fboHelper.createRenderTarget(this.SIZE, this.SIZE),
        this.currRenderTarget = this.prevRenderTarget.clone(),
        this.blurCacheRenderTarget = this.prevRenderTarget.clone(),
        this.mesh = new Mesh(new CircleGeometry(1.1,128),fboHelper.createRawShaderMaterial({
            uniforms: Object.assign({
                u_prevTexture: {
                    value: null
                },
                u_radius: {
                    value: this.RADIUS
                },
                u_texelSize: {
                    value: 1 / this.SIZE
                },
                u_blueNoiseOffset: {
                    value: new Vector2
                }
            }, light.sharedUniforms, blueNoise.sharedUniforms),
            fragmentShader: frag$b
        })),
        this.mesh.material.defines.LIGHT_SHADOW_SAMPLE_COUNT = 8,
        this.groundMesh = new Mesh(this.geometry,new ShaderMaterial({
            uniforms: Object.assign({
                u_texture: {
                    value: this.texture
                },
                u_groundShadowTexture: {
                    value: this.currRenderTarget.texture
                },
                u_color: {
                    value: new Color
                },
                u_bgColor: {
                    value: new Color
                },
                u_noiseStableFactor: sim.sharedUniforms.u_noiseStableFactor,
                u_fogA: {
                    value: .03
                },
                u_fogB: {
                    value: .285
                }
            }, light.sharedUniforms, aboutHeroScatter.sharedUniforms, blueNoise.sharedUniforms, aboutHero.sharedUniforms),
            vertexShader: groundVert,
            fragmentShader: groundFrag
        })),
        this.groundMesh.material.extensions.derivatives = !0,
        this.container.add(this.groundMesh),
        fboHelper.clearColor(1, 1, 1, 1, this.currRenderTarget)
    }
    update(e) {
        let t = this.prevRenderTarget;
        this.prevRenderTarget = this.currRenderTarget,
        this.currRenderTarget = t;
        let r = properties.renderer
          , n = fboHelper.getColorState()
          , o = r.getRenderTarget();
        r.setRenderTarget(this.currRenderTarget),
        r.setClearColor(16777215, 1),
        this.mesh.material.uniforms.u_blueNoiseOffset.value.set(~~(Math.random() * 128), ~~(Math.random() * 128)),
        this.mesh.material.uniforms.u_prevTexture.value = this.prevRenderTarget.texture,
        fboHelper.renderMesh(this.mesh, this.currRenderTarget),
        r.setRenderTarget(o),
        fboHelper.setColorState(n),
        sim.sharedUniforms.u_noiseStableFactor.value,
        this.groundMesh.material.uniforms.u_groundShadowTexture.value = this.currRenderTarget.texture,
        this.groundMesh.material.uniforms.u_bgColor.value.copy(properties.bgColor),
        this.groundMesh.material.uniforms.u_color.value.set("#fff")
    }
}
const aboutHeroGround = new AboutHeroGround
  , vert$7 = `#define GLSLIFY 1
attribute float t;attribute float totalLength;attribute float lineId;varying float v_t;varying float v_totalLength;varying float v_thicknessRatio;varying vec3 v_viewNormal;varying vec3 v_worldNormal;varying vec3 v_worldPosition;vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}void main(){v_t=t;v_totalLength=totalLength;float yIndex=floor(position.y+.5);v_thicknessRatio=step(mod(yIndex,4.),0.5);vec3 pos=position+normal*mix(0.04,0.1,v_thicknessRatio);vec3 nor=normalize(normalMatrix*normal);v_viewNormal=nor;v_worldNormal=inverseTransformDirection(nor,viewMatrix);v_worldPosition=(modelMatrix*vec4(pos,1.0)).xyz;gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.0);gl_Position.z-=0.1/gl_Position.w;}`
  , frag$a = `#define GLSLIFY 1
uniform float u_time;uniform float u_hudRatio;varying float v_t;varying float v_totalLength;varying float v_thicknessRatio;varying vec3 v_viewNormal;varying vec3 v_worldNormal;varying vec3 v_worldPosition;vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}vec2 fade(vec2 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}float pnoise(vec2 P,vec2 rep){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod(Pi,rep.xyxy);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main(){float t=mod(v_t-u_time*2.,v_totalLength);float noiseScale=0.25;float n=pnoise(vec2(t*noiseScale,0.),vec2(v_totalLength*noiseScale,100.));float shade=mix(0.3+smoothstep(0.,0.-fwidth(n),n)*0.6,1.,v_thicknessRatio);shade*=linearStep(50.,-20.,v_worldPosition.z);gl_FragColor=vec4(shade,0.,0.,1.)*step(v_totalLength-v_t,v_totalLength*u_hudRatio);gl_FragColor.b=linearStep(15.,66.,v_worldPosition.z);gl_FragColor.r*=.85;}`;
let SEGMENT_COUNT = 3
  , THREHSOLDS = [60, 245, 806, 966, 991, 1026, 1191, 1853, 2061, 3111, 4279, 4309, 4338, 5265, 5316, 5447, 5475, 6407, 6445, 7116, 7235, 7349, 7934, 8555, 8583, 8614, 9154, 9640, 9688, 10163, 10420, 10645, 10895, 11074, 11286, 11453, 11596, 11628, 11740, 11799, 11832]
  , v0 = new Vector3;
new Vector3;
new Vector3;
class AboutHeroLines {
    container = new Object3D;
    time = 0;
    sharedUniforms = {};
    preInit() {
        properties.loader.add(settings.MODEL_PATH + "about/terrain_lines.buf", {
            onLoad: this._onLineLoad.bind(this)
        })
    }
    _onLineLoad(e) {
        let t = e.attributes.position.array
          , r = THREHSOLDS.length
          , n = t.length / 3
          , o = new Float32Array(n * SEGMENT_COUNT * 3)
          , l = new Float32Array(n * SEGMENT_COUNT * 3)
          , c = new Float32Array(n * SEGMENT_COUNT)
          , u = new Float32Array(n * SEGMENT_COUNT)
          , f = new Uint8Array(n * SEGMENT_COUNT)
          , p = new Uint16Array((n - r) * 6 * SEGMENT_COUNT)
          , g = new Vector3
          , v = new Vector3
          , _ = new Vector3
          , w = new Vector3
          , S = new Vector3
          , b = new Vector3
          , C = new Quaternion
          , R = new Vector3
          , T = 0
          , M = 0
          , P = 0;
        for (let A = 0; A < THREHSOLDS.length; A++) {
            let O = A == 0 ? 0 : THREHSOLDS[A - 1]
              , W = THREHSOLDS[A];
            _.fromArray(t, O * 3),
            v.copy(_),
            S.set(0, 1, 0);
            let Q = 0;
            for (let D = O; D < W; D++) {
                let q = D * 3;
                g.copy(v),
                v.copy(_),
                D < W - 1 && _.fromArray(t, q + 3),
                w.subVectors(_, g).normalize(),
                b.crossVectors(S, w).normalize(),
                C.setFromAxisAngle(w, Math.PI * 2 / SEGMENT_COUNT),
                R.copy(S),
                Q += v0.copy(v).sub(g).length();
                for (let V = 0; V < SEGMENT_COUNT; V++) {
                    if (R.applyQuaternion(C),
                    o[M + 0] = v.x,
                    o[M + 1] = v.y,
                    o[M + 2] = v.z,
                    l[M + 0] = R.x,
                    l[M + 1] = R.y,
                    l[M + 2] = R.z,
                    c[T] = Q,
                    f[T] = A,
                    D < W - 1) {
                        let J = V == SEGMENT_COUNT - 1 ? 1 - SEGMENT_COUNT : 1;
                        p[P++] = T,
                        p[P++] = T + J,
                        p[P++] = T + SEGMENT_COUNT,
                        p[P++] = T + J,
                        p[P++] = T + SEGMENT_COUNT + J,
                        p[P++] = T + SEGMENT_COUNT
                    }
                    T++,
                    M += 3
                }
            }
            let H = SEGMENT_COUNT * (W - O);
            T -= H;
            let B = T + H;
            for (; T < B; T++)
                u[T] = Q
        }
        let I = new BufferGeometry;
        I.setAttribute("position", new BufferAttribute(o,3)),
        I.setAttribute("normal", new BufferAttribute(l,3)),
        I.setAttribute("t", new BufferAttribute(c,1)),
        I.setAttribute("totalLength", new BufferAttribute(u,1)),
        I.setAttribute("lineId", new BufferAttribute(f,1)),
        I.setIndex(new BufferAttribute(p,1));
        let k = new ShaderMaterial({
            uniforms: Object.assign({
                u_time: properties.sharedUniforms.u_time
            }, aboutHero.sharedUniforms),
            vertexShader: vert$7,
            fragmentShader: frag$a,
            blending: CustomBlending,
            blendEquation: MaxEquation,
            blendSrc: OneFactor,
            blendDst: OneFactor,
            blendEquationAlpha: AddEquation,
            blendSrcAlpha: OneFactor,
            blendDstAlpha: OneFactor
        });
        k.extensions.derivatives = !0,
        this.mesh = new Mesh(I,k),
        this.mesh.renderOrder = 15,
        this.container.add(this.mesh)
    }
    init() {}
    update(e) {}
}
const aboutHeroLines = new AboutHeroLines
  , vert$6 = `#define GLSLIFY 1
attribute vec2 boneIndices;attribute vec2 boneWeights;uniform vec3 u_bonePoses[BONE_COUNT];uniform vec4 u_boneOrients[BONE_COUNT];varying vec3 v_worldPosition;varying vec3 v_worldNormal;varying vec2 v_uv;varying float v_depth;vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}vec3 qrotate(vec4 q,vec3 v){return v+2.0*cross(q.xyz,cross(q.xyz,v)+q.w*v);}void main(){vec3 pos=vec3(0.0);vec3 nor=vec3(0.0);vec3 bonePos;vec4 boneOrient;bonePos=u_bonePoses[int(boneIndices.x)];boneOrient=u_boneOrients[int(boneIndices.x)];pos+=(qrotate(boneOrient,position)+bonePos)*boneWeights.x;nor+=qrotate(boneOrient,normal)*boneWeights.x;bonePos=u_bonePoses[int(boneIndices.y)];boneOrient=u_boneOrients[int(boneIndices.y)];pos+=(qrotate(boneOrient,position)+bonePos)*boneWeights.y;nor+=qrotate(boneOrient,normal)*boneWeights.y;vec4 mvPosition=modelViewMatrix*vec4(pos,1.0);gl_Position=projectionMatrix*mvPosition;v_worldPosition=(modelMatrix*vec4(pos,1.0)).xyz;v_worldNormal=inverseTransformDirection(nor,viewMatrix);v_uv=uv;
#include <aboutHeroVisualFinal_vert>
}`
  , frag$9 = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec3 u_lightPosition;uniform vec3 u_lightMixer;uniform float u_sceneRatio;uniform float u_hudRatio;varying vec3 v_worldPosition;varying vec3 v_worldNormal;varying vec2 v_uv;varying float v_depth;float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}
#include <getScatter>
void main(){vec3 worldNormal=normalize(v_worldNormal);vec3 worldToLight=u_lightPosition-v_worldPosition;float worldToLightDist=length(worldToLight);worldToLight/=worldToLightDist;vec3 cameraToWorld=normalize(v_worldPosition-cameraPosition);vec4 map=texture2D(u_texture,v_uv);float light=dot(u_lightMixer,map.rgb);light=pow(light,1.25);float baseShade=map.a;vec3 color=vec3(baseShade*light);gl_FragColor=vec4(color,0.);gl_FragColor.rgb+=getScatter(cameraPosition,v_worldPosition);
#include <aboutHeroVisualFinal_frag>
gl_FragColor.r*=u_sceneRatio*(1.-u_hudRatio);}`
  , shadowVert = `#define GLSLIFY 1
varying vec2 v_uv;void main(){v_uv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`
  , shadowFrag = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec3 u_lightMixer;varying vec2 v_uv;
#include <getBlueNoise>
void main(){vec3 blueNoises=getBlueNoise(gl_FragCoord.xy+vec2(3.,36.));vec3 map3=texture2D(u_texture,v_uv).xyz;float light1=dot(u_lightMixer,map3);float light2=dot(u_lightMixer.gbr,map3);float light=mix(light1,light2,blueNoises.x);light=light*light*.3+.7;gl_FragColor=vec4(light,1.,1.,0.);}`;
let _v1$2 = new Vector3
  , _v2$1 = new Vector3
  , _q1$1 = new Quaternion
  , _q2 = new Quaternion;
class aboutHeroPerson {
    BONE_COUNT = 54;
    FPS = 60;
    container = new Object3D;
    geometry = null;
    mesh = null;
    texture = null;
    shadowMesh = null;
    shadowTexture = null;
    time = 0;
    frameCount = 0;
    bonePosAnimationData;
    boneOrientAnimationData;
    bonePoses = new Float32Array(this.BONE_COUNT * 3);
    boneOrients = new Float32Array(this.BONE_COUNT * 4);
    sharedUniforms = {
        u_texture: {
            value: null
        },
        u_lightMixer: {
            value: new Vector3(1,0,0)
        }
    };
    preInit() {
        properties.loader.load(settings.TEXTURE_PATH + "about/person_light.webp", {
            type: "texture",
            onLoad: e => {
                this.lightTexture = e,
                this._onTextureLoad(e)
            }
        }).content,
        properties.loader.load(settings.TEXTURE_PATH + "about/person.webp", {
            type: "texture",
            onLoad: e => {
                this.texture = e,
                this._onTextureLoad(e)
            }
        }).content,
        this.shadowTexture = properties.loader.load(settings.TEXTURE_PATH + "about/ground_person_shadow.webp", {
            type: "texture"
        }).content,
        properties.loader.add(settings.MODEL_PATH + "about/person.buf", {
            onLoad: e => {
                this._onModelLoad(e)
            }
        }),
        properties.loader.add(settings.MODEL_PATH + "about/person_idle.buf", {
            onLoad: e => {
                this._onAnimationLoad(e)
            }
        })
    }
    _onTextureLoad() {
        if (this.lightTexture && this.texture) {
            let e = fboHelper.createRenderTarget(this.lightTexture.image.width, this.lightTexture.image.height);
            e.texture.minFilter = LinearMipMapNearestFilter,
            e.texture.generateMipmaps = !1,
            this.sharedUniforms.u_texture.value = e.texture,
            fboHelper.copy(textureHelper.transparentTexture, e),
            textureHelper.mixChannels(this.lightTexture, e, 0, 1, 2, -1),
            e.texture.generateMipmaps = !0,
            textureHelper.mixChannels(this.texture, e, -1, -1, -1, 0),
            this.texture.dispose(),
            this.lightTexture.dispose(),
            this.texture = null,
            this.lightTexture = null
        }
    }
    _onModelLoad(e) {
        this.mesh = new Mesh(e,new ShaderMaterial({
            uniforms: Object.assign({
                u_texture: this.sharedUniforms.u_texture,
                u_lightMixer: this.sharedUniforms.u_lightMixer,
                u_bonePoses: {
                    value: this.bonePoses
                },
                u_boneOrients: {
                    value: this.boneOrients
                }
            }, light.sharedUniforms, aboutHeroScatter.sharedUniforms, aboutHero.sharedUniforms),
            vertexShader: vert$6,
            fragmentShader: frag$9
        })),
        this.mesh.material.defines.BONE_COUNT = this.BONE_COUNT,
        this.container.add(this.mesh)
    }
    _onAnimationLoad(e) {
        this.bonePosAnimationData = e.attributes.position.array,
        this.boneOrientAnimationData = e.attributes.orient.array,
        this.frameCount = this.bonePosAnimationData.length / (this.BONE_COUNT * 3)
    }
    init() {
        this.shadowMesh = new Mesh(new PlaneGeometry(1.5,1.5),new ShaderMaterial({
            uniforms: Object.assign({
                u_texture: {
                    value: this.shadowTexture
                },
                u_lightMixer: this.sharedUniforms.u_lightMixer
            }, blueNoise.sharedUniforms),
            vertexShader: shadowVert,
            fragmentShader: shadowFrag,
            blending: MultiplyBlending
        })),
        this.shadowMesh.renderOrder = 10,
        this.shadowMesh.position.y = .01,
        this.shadowMesh.rotation.x = -Math.PI / 2,
        this.container.add(this.shadowMesh)
    }
    update(e) {
        if (this.mesh && this.frameCount) {
            this.time += e * .5;
            let t = this.time * this.FPS % this.frameCount
              , r = Math.floor(t)
              , n = Math.ceil(t) % this.frameCount
              , o = t - r
              , l = r * this.BONE_COUNT
              , c = n * this.BONE_COUNT
              , u = this.frameCount / 3;
            this.sharedUniforms.u_lightMixer.value.set(math.fit(t, u * 2, this.frameCount, 0, 1) + math.fit(t, 0, u, 1, 0), math.fit(t, 0, u, 0, 1) * math.fit(t, u, u * 2, 1, 0), math.fit(t, u, u * 2, 0, 1) * math.fit(t, u * 2, this.frameCount, 1, 0));
            for (let f = 0; f < this.BONE_COUNT; f++)
                _v1$2.fromArray(this.bonePosAnimationData, (l + f) * 3).lerp(_v2$1.fromArray(this.bonePosAnimationData, (c + f) * 3), o).toArray(this.bonePoses, f * 3),
                _q1$1.fromArray(this.boneOrientAnimationData, (l + f) * 4).slerp(_q2.fromArray(this.boneOrientAnimationData, (c + f) * 4), o).toArray(this.boneOrients, f * 4)
        }
    }
}
const aboutHeroPerson$1 = new aboutHeroPerson
  , aboutHeroVisualFinalVert = `#define GLSLIFY 1
float viewZ=(modelViewMatrix*vec4(pos,1.0)).z;float near=1.;float far=100.0;v_depth=1.0-(viewZ+near)/(near-far);`
  , aboutHeroVisualFinalFrag = `#define GLSLIFY 1
gl_FragColor.r=gl_FragColor.r;gl_FragColor.g=v_depth;gl_FragColor.b=1.0;`
  , vert$5 = `#define GLSLIFY 1
varying vec3 v_worldPosition;varying vec2 v_uv;varying float v_depth;varying float v_instanceId;varying float v_opacity;attribute float a_instanceId;attribute vec3 a_instancePos;attribute vec3 a_instanceRands;uniform float u_introTime;uniform float u_sceneRatio;uniform float u_hudRatio;vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}
#define F4 0.309016994374947451
vec4 simplexNoiseDerivatives(vec4 v_0){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v_0+dot(v_0,vec4(F4)));vec4 x0=v_0-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 values0=vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2));vec2 values1=vec2(dot(p3,x3),dot(p4,x4));vec3 m0=max(0.5-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.5-vec2(dot(x3,x3),dot(x4,x4)),0.0);vec3 temp0=-6.0*m0*m0*values0;vec2 temp1=-6.0*m1*m1*values1;vec3 mmm0=m0*m0*m0;vec2 mmm1=m1*m1*m1;float dx=temp0[0]*x0.x+temp0[1]*x1.x+temp0[2]*x2.x+temp1[0]*x3.x+temp1[1]*x4.x+mmm0[0]*p0.x+mmm0[1]*p1.x+mmm0[2]*p2.x+mmm1[0]*p3.x+mmm1[1]*p4.x;float dy=temp0[0]*x0.y+temp0[1]*x1.y+temp0[2]*x2.y+temp1[0]*x3.y+temp1[1]*x4.y+mmm0[0]*p0.y+mmm0[1]*p1.y+mmm0[2]*p2.y+mmm1[0]*p3.y+mmm1[1]*p4.y;float dz=temp0[0]*x0.z+temp0[1]*x1.z+temp0[2]*x2.z+temp1[0]*x3.z+temp1[1]*x4.z+mmm0[0]*p0.z+mmm0[1]*p1.z+mmm0[2]*p2.z+mmm1[0]*p3.z+mmm1[1]*p4.z;float dw=temp0[0]*x0.w+temp0[1]*x1.w+temp0[2]*x2.w+temp1[0]*x3.w+temp1[1]*x4.w+mmm0[0]*p0.w+mmm0[1]*p1.w+mmm0[2]*p2.w+mmm1[0]*p3.w+mmm1[1]*p4.w;return vec4(dx,dy,dz,dw)*49.0;}vec2 rotate(vec2 v,float a){float s=sin(a);float c=cos(a);mat2 m=mat2(c,s,-s,c);return m*v;}float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main(){vec3 localPos=position;localPos.xy=rotate(localPos.xy,a_instanceRands.y*6.28+sign(-a_instancePos.x)*u_introTime*mix(0.03,0.15,a_instanceRands.z));vec3 pos=(9.0+2.0*a_instanceRands.x)*localPos;vec3 noise=simplexNoiseDerivatives(vec4((a_instancePos+pos)*0.5,u_introTime*0.075)).yzw;float cycle=fract((0.08+0.08*a_instanceRands.x)*u_introTime+a_instanceRands.z);vec3 instancePos=a_instancePos+vec3(cycle*(a_instancePos.x*0.75+sign(a_instancePos.x)*0.25),0.0,0.0)+noise*vec3(0.35,0.2,0.1);instancePos.y-=linearStep(4.,1.,abs(instancePos.x))*1.+0.5;pos+=instancePos;vec4 mvPosition=modelViewMatrix*vec4(pos,1.);gl_Position=projectionMatrix*mvPosition;v_worldPosition=(modelMatrix*vec4(pos,1.)).xyz;v_uv=uv;v_instanceId=a_instanceId;float d=(modelViewMatrix*vec4(instancePos,1.0)).z;v_opacity=smoothstep(1.,3.,-d)*u_sceneRatio*(1.-u_hudRatio)*linearStep(0.,0.25,cycle)*linearStep(1.,0.75,cycle)*mix(1.,0.75,a_instanceRands.x);if(v_opacity<0.004){gl_Position.z=2.*gl_Position.w;}
#include <aboutHeroVisualFinal_vert>
}`
  , frag$8 = `#define GLSLIFY 1
varying vec3 v_worldPosition;varying vec2 v_uv;varying float v_depth;varying float v_instanceId;varying float v_opacity;uniform sampler2D u_currSceneTexture;uniform sampler2D u_fogTexture;uniform vec2 u_resolution;uniform vec3 u_lightPosition;uniform float u_noiseStableFactor;uniform float u_time;
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define saturate( a ) clamp( a, 0.0, 1.0 )
#include <getBlueNoise>
#include <getScatter>
float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main(){float faceDirection=gl_FrontFacing ? 1.0 :-1.0;vec2 screenPaintUv=gl_FragCoord.xy/u_resolution;vec2 fogMap=texture2D(u_fogTexture,v_uv).rg;vec4 currScene=texture2D(u_currSceneTexture,screenPaintUv);float depth=v_depth-fogMap.y*0.02;float depthMask=fogMap.x*1.35-fogMap.y*0.15;gl_FragColor.r=depthMask*v_opacity;gl_FragColor.gb=currScene.gb;gl_FragColor.a=exp(-length(v_worldPosition+vec3(0.,0.,-max(0.,fogMap.y-0.25)*10.+5.)-vec3(0.,0.,0.))*(0.22-fogMap.x*0.2))*fogMap.y*linearStep(0.0,0.035,depth-currScene.g)*v_opacity*0.45;}`;
class AboutHeroFog {
    container = new Object3D;
    geometry = null;
    material = null;
    mesh = null;
    texture = null;
    cacheRT = null;
    INSTANCES_COUNT = 32;
    preInit() {
        this.texture = properties.loader.add(settings.TEXTURE_PATH + "about/fog.png", {
            type: "texture"
        }).content
    }
    init() {
        let e = math.getSeedRandomFn("fog96");
        this.cacheRT = fboHelper.createRenderTarget(1, 1);
        const t = new PlaneGeometry(1,1,3,3);
        this.geometry = new InstancedBufferGeometry;
        for (let l in t.attributes)
            this.geometry.setAttribute(l, t.attributes[l]);
        this.geometry.setIndex(t.index);
        const r = new Float32Array(this.INSTANCES_COUNT)
          , n = new Float32Array(this.INSTANCES_COUNT * 3)
          , o = new Float32Array(this.INSTANCES_COUNT * 3);
        for (let l = 0, c = 0; l < this.INSTANCES_COUNT; l++)
            r[l] = l,
            n[c] = 12 * (e() * 2 - 1),
            n[c + 1] = -.25 + .5 * e(),
            n[c + 2] = 12 * (1 - l / (this.INSTANCES_COUNT - 1) * 2),
            o[c] = e() * 2 - 1,
            o[c + 1] = e() * 2 - 1,
            o[c + 2] = e() * 2 - 1,
            c += 3;
        this.geometry.setAttribute("a_instanceId", new InstancedBufferAttribute(r,1)),
        this.geometry.setAttribute("a_instancePos", new InstancedBufferAttribute(n,3)),
        this.geometry.setAttribute("a_instanceRands", new InstancedBufferAttribute(o,3)),
        this.material = new ShaderMaterial({
            uniforms: Object.assign({
                u_fogTexture: {
                    value: this.texture
                },
                u_currSceneTexture: {
                    value: this.cacheRT.texture
                },
                u_lightPosition: light.sharedUniforms.u_lightPosition,
                u_resolution: properties.sharedUniforms.u_resolution
            }, blueNoise.sharedUniforms, aboutHeroScatter.sharedUniforms, aboutHero.sharedUniforms),
            vertexShader: vert$5,
            fragmentShader: frag$8,
            side: DoubleSide,
            depthWrite: !1,
            blending: CustomBlending,
            blendEquation: AddEquation,
            blendSrc: SrcAlphaFactor,
            blendDst: OneMinusSrcAlphaFactor,
            blendEquationAlpha: AddEquation,
            blendSrcAlpha: ZeroFactor,
            blendDstAlpha: OneFactor
        }),
        this.mesh = new Mesh(this.geometry,this.material),
        this.mesh.renderOrder = 20,
        this.mesh.frustumCulled = !1,
        this.mesh.onBeforeRender = this.onBeforeRender.bind(this),
        this.container.add(this.mesh)
    }
    onBeforeRender() {
        let e = fboHelper.renderer
          , t = e.getRenderTarget();
        fboHelper.clearMultisampleRenderTargetState(),
        fboHelper.copy(t.texture, this.cacheRT),
        e.setRenderTarget(t)
    }
    resize(e, t) {
        this.cacheRT.setSize(e, t)
    }
    update(e) {}
}
const aboutHeroFog = new AboutHeroFog
  , vert$4 = `#define GLSLIFY 1
varying vec3 v_viewPosition;varying vec3 v_worldPosition;varying vec3 v_viewNormal;varying vec2 v_uv;varying vec3 v_localPosition;varying float v_depth;uniform vec3 u_lightPosition;void main(){vec3 pos=position;vec4 mvPosition=modelViewMatrix*vec4(pos,1.);gl_Position=projectionMatrix*mvPosition;v_worldPosition=(modelMatrix*vec4(pos,1.)).xyz;v_viewNormal=normalMatrix*normal;v_viewPosition=-mvPosition.xyz;v_uv=uv;v_localPosition=position;gl_Position.z=1.*(gl_Position.w);}`
  , frag$7 = `#define GLSLIFY 1
varying vec3 v_viewPosition;varying vec3 v_worldPosition;varying vec3 v_viewNormal;varying vec2 v_uv;varying vec3 v_localPosition;varying float v_depth;uniform vec3 u_bgColor;uniform vec3 u_lightPosition;uniform vec2 u_resolution;uniform sampler2D u_currSceneTexture;uniform float u_sceneRatio;uniform float u_hudRatio;
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define saturate( a ) clamp( a, 0.0, 1.0 )
float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}
#include <getScatter>
#include <getBlueNoise>
void main(){vec3 noise=getBlueNoise(gl_FragCoord.xy+vec2(57.,27.));gl_FragColor.r=getScatter(cameraPosition,v_worldPosition);gl_FragColor.r*=u_sceneRatio*(1.-u_hudRatio);gl_FragColor.g=1.;gl_FragColor.b=linearStep(15.,66.,v_worldPosition.z);gl_FragColor.a=0.;gl_FragColor.r+=noise.r*0.004;}`;
class AboutHeroHalo {
    container = new Object3D;
    mesh = null;
    preInit() {
        properties.loader.add(settings.MODEL_PATH + "about/bg_box.buf", {
            onLoad: this._onGeometryLoad.bind(this)
        })
    }
    _onGeometryLoad(e) {
        this.mesh = new Mesh(e,new ShaderMaterial({
            uniforms: Object.assign({
                u_resolution: properties.sharedUniforms.u_resolution
            }, light.sharedUniforms, blueNoise.sharedUniforms, aboutHeroScatter.sharedUniforms, aboutHero.sharedUniforms),
            vertexShader: vert$4,
            fragmentShader: frag$7
        })),
        this.mesh.renderOrder = 10,
        this.container.add(this.mesh)
    }
    init() {}
    resize(e, t) {}
    update(e) {}
}
const aboutHeroHalo = new AboutHeroHalo
  , vert$3 = `#define GLSLIFY 1
uniform sampler2D u_positionTexture;uniform sampler2D u_norShadeTexture;uniform float u_activeRatio;uniform float u_showRatio;uniform vec3 u_mouse;uniform vec2 u_resolution;uniform float u_time;uniform float u_isForward;uniform float u_glitchOffset;uniform float u_glitchStrength;uniform float u_glitchThreshold;attribute vec2 a_simUv;attribute vec4 a_rands1;attribute vec4 a_rands2;varying float v_shade;varying float v_showRatio;varying float v_blurriness;varying vec2 v_toCenter;varying vec2 v_uv;varying vec3 v_color;vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}
#define F4 0.309016994374947451
vec4 simplexNoiseDerivatives(vec4 v){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v+dot(v,vec4(F4)));vec4 x0=v-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 values0=vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2));vec2 values1=vec2(dot(p3,x3),dot(p4,x4));vec3 m0=max(0.5-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.5-vec2(dot(x3,x3),dot(x4,x4)),0.0);vec3 temp0=-6.0*m0*m0*values0;vec2 temp1=-6.0*m1*m1*values1;vec3 mmm0=m0*m0*m0;vec2 mmm1=m1*m1*m1;float dx=temp0[0]*x0.x+temp0[1]*x1.x+temp0[2]*x2.x+temp1[0]*x3.x+temp1[1]*x4.x+mmm0[0]*p0.x+mmm0[1]*p1.x+mmm0[2]*p2.x+mmm1[0]*p3.x+mmm1[1]*p4.x;float dy=temp0[0]*x0.y+temp0[1]*x1.y+temp0[2]*x2.y+temp1[0]*x3.y+temp1[1]*x4.y+mmm0[0]*p0.y+mmm0[1]*p1.y+mmm0[2]*p2.y+mmm1[0]*p3.y+mmm1[1]*p4.y;float dz=temp0[0]*x0.z+temp0[1]*x1.z+temp0[2]*x2.z+temp1[0]*x3.z+temp1[1]*x4.z+mmm0[0]*p0.z+mmm0[1]*p1.z+mmm0[2]*p2.z+mmm1[0]*p3.z+mmm1[1]*p4.z;float dw=temp0[0]*x0.w+temp0[1]*x1.w+temp0[2]*x2.w+temp1[0]*x3.w+temp1[1]*x4.w+mmm0[0]*p0.w+mmm0[1]*p1.w+mmm0[2]*p2.w+mmm1[0]*p3.w+mmm1[1]*p4.w;return vec4(dx,dy,dz,dw)*49.0;}vec4 hash42(vec2 p){vec4 p4=fract(vec4(p.xyxy)*vec4(.1031,.1030,.0973,.1099));p4+=dot(p4,p4.wzxy+33.33);return fract((p4.xxyz+p4.yzzw)*p4.zywx);}float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}void main(){vec3 basePos=texture2D(u_positionTexture,a_simUv).xyz;vec3 pos=basePos;float yRatio=basePos.y*0.5+0.5;float showRatio=smoothstep(a_rands1.x*0.2+yRatio*0.4,0.4+a_rands1.y*0.2+yRatio*0.4,u_showRatio);pos*=1.3;pos+=(simplexNoiseDerivatives(vec4(basePos*8.,u_time)).yzw*0.2+vec3(1.*yRatio,0.0,-1.))*(1.-showRatio);v_showRatio=showRatio;vec4 norShade=texture2D(u_norShadeTexture,a_simUv);float depth=clamp(1.-pos.z,0.0,1.0);vec3 nor=norShade.xyz*2.-1.;vec3 worldPosition=(modelMatrix*vec4(pos,1.0)).xyz;vec3 viewNormal=normalMatrix*normalize(nor);vec3 worldNormal=inverseTransformDirection(viewNormal,viewMatrix);vec3 lightDir=normalize(u_mouse-worldPosition);float distToLight=distance(u_mouse,worldPosition);float light=norShade.w*1.25;float diff=linearStep(0.35,1.0,dot(worldNormal,lightDir))/sqrt(distToLight*0.1);light*=diff+0.6;light+=(0.05+diff*0.15)*smoothstep(0.0,0.005,norShade.w);float frontFaceMultiplier=linearStep(-0.2,0.0,viewNormal.z);light*=frontFaceMultiplier;v_blurriness=min(1.0,(abs(depth-(1.-u_activeRatio*showRatio)*0.5))*2.5)*(2.-showRatio);float basePointSize=0.009*(1.+pow(v_blurriness,1.5)*8.)*frontFaceMultiplier;float pointSize=max(basePointSize,12./u_resolution.y);float subpixelMultiplier=pow(basePointSize/pointSize,1.5);pos.xy+=position.xy*pointSize*step(0.003,light)*linearStep(0.0,0.75,u_activeRatio);vec4 verticalRands=hash42(vec2(floor(basePos.y*3.+cos(basePos.y*3.+u_glitchOffset)*2.+u_glitchOffset),0.))*u_glitchStrength;float glitchWeight=verticalRands.x*step(u_glitchThreshold,verticalRands.y);pos.x+=(verticalRands.z*verticalRands.z)*glitchWeight*0.35*cos(basePos.y+u_glitchOffset);gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.0);v_color=mix(vec3(1.0),(viewNormal.xzy*0.5+0.5)*vec3(1.0,0.5,2.0),glitchWeight);light*=(1.+glitchWeight*1.5);light+=0.1*glitchWeight;float scanline=smoothstep(0.04,0.,abs(fract(u_time*-0.3-basePos.y*.5+.5)));light+=scanline*(0.25*norShade.w*(1.0-light)+smoothstep(0.03,0.,abs(viewNormal.z)));v_shade=min(1.0,light*(1.-v_blurriness*0.5))*subpixelMultiplier*showRatio;v_toCenter=(uv-.5)*2.;v_uv=uv;}`
  , frag$6 = `#define GLSLIFY 1
varying float v_shade;varying float v_showRatio;varying vec2 v_toCenter;varying float v_blurriness;varying vec2 v_uv;varying vec3 v_color;float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}vec3 linearStep(vec3 edge0,vec3 edge1,vec3 x){return clamp((x-edge0)/(edge1-edge0),vec3(0.),vec3(1.));}void main(){float shade=v_shade;float d=length(v_toCenter);float range=v_blurriness*5.;float brightness=linearStep(1.,1.-range-fwidth(d),d);shade*=brightness*(1.25-v_blurriness*v_shade);gl_FragColor=vec4(shade)*v_showRatio*v_showRatio;gl_FragColor.a*=pow(1.-v_blurriness,3.)*0.8*linearStep(0.8,1.0,v_showRatio*v_showRatio);}`
  , PARTICLE_COUNT = 8192
  , SIM_TEXTURE_WIDTH = 128
  , SIM_TEXTURE_HEIGHT = 64
  , MAX_FACE_NUM = 2;
let _v1$1 = new Vector3;
new Vector3;
let _m = new Matrix4;
class AboutHeroFaces {
    container = new Object3D;
    faceContainer = new Object3D;
    isActive = !1;
    hasStartedLoads = {};
    teamPosDataTextures = {};
    teamNShadeDataTextures = {};
    sharedUniforms = {
        u_mouse: {
            value: new Vector3
        },
        u_glitchOffset: {
            value: 0
        },
        u_glitchStrength: {
            value: 0
        },
        u_showRatio: {
            value: 0
        }
    };
    currId = "";
    nextId = "";
    transitionRatio = 0;
    showRatio = 0;
    activeRatio = 1;
    hideRatio = 0;
    meshArray = [];
    preInit() {}
    load(e) {
        this.hasStartedLoads[e] || (this.hasStartedLoads[e] = !0,
        properties.loader[properties.hasInitialized ? "load" : "add"](settings.TEAM_PATH + e + ".buf", {
            onLoad: t => {
                this._onModelLoaded(e, t)
            }
        }))
    }
    _onModelLoaded(e, t) {
        let r = t.attributes.position.array
          , n = new Float32Array(PARTICLE_COUNT * 4);
        for (let o = 0, l = 0, c = 0; o < PARTICLE_COUNT; o++,
        l += 3,
        c += 4)
            n[c] = r[l],
            n[c + 1] = r[l + 1],
            n[c + 2] = r[l + 2],
            n[c + 3] = 1 / PARTICLE_COUNT;
        this.teamPosDataTextures[e] = fboHelper.createDataTexture(n, SIM_TEXTURE_WIDTH, SIM_TEXTURE_HEIGHT, !0, !0),
        this.teamNShadeDataTextures[e] = fboHelper.createDataTexture(t.attributes.nShade.array, SIM_TEXTURE_WIDTH, SIM_TEXTURE_HEIGHT, !1, !0)
    }
    init() {
        this.container.add(this.faceContainer),
        this.container.scale.set(27.5, 27.5, 16),
        this.container.rotation.y = Math.PI + .2,
        this.container.rotation.x = .1,
        this.container.position.y = 34,
        this.container.position.z = 25,
        this.container.updateMatrixWorld(!0);
        let e = new PlaneGeometry(1,1)
          , t = new InstancedBufferGeometry;
        for (let l in e.attributes)
            t.attributes[l] = e.attributes[l];
        t.index = e.index;
        let r = new Float32Array(PARTICLE_COUNT * 2)
          , n = new Float32Array(PARTICLE_COUNT * 4)
          , o = new Float32Array(PARTICLE_COUNT * 4);
        for (let l = 0, c = 0, u = 0; l < PARTICLE_COUNT; l++,
        c += 2,
        u += 4)
            r[c] = (l % SIM_TEXTURE_WIDTH + .5) / SIM_TEXTURE_WIDTH,
            r[c + 1] = (~~(l / SIM_TEXTURE_WIDTH) + .5) / SIM_TEXTURE_HEIGHT,
            n[u] = Math.random(),
            n[u + 1] = Math.random(),
            n[u + 2] = Math.random(),
            n[u + 3] = Math.random(),
            o[u] = Math.random(),
            o[u + 1] = Math.random(),
            o[u + 2] = Math.random(),
            o[u + 3] = Math.random();
        t.setAttribute("a_simUv", new InstancedBufferAttribute(r,2)),
        t.setAttribute("a_rands1", new InstancedBufferAttribute(n,4)),
        t.setAttribute("a_rands2", new InstancedBufferAttribute(o,4));
        for (let l = 0; l < MAX_FACE_NUM; l++) {
            const c = new ShaderMaterial({
                uniforms: {
                    u_time: properties.sharedUniforms.u_time,
                    u_resolution: properties.sharedUniforms.u_resolution,
                    u_mouse: this.sharedUniforms.u_mouse,
                    u_glitchOffset: this.sharedUniforms.u_glitchOffset,
                    u_glitchStrength: this.sharedUniforms.u_glitchStrength,
                    u_glitchThreshold: {
                        value: 0
                    },
                    u_activeRatio: {
                        value: 0
                    },
                    u_showRatio: this.sharedUniforms.u_showRatio,
                    u_positionTexture: {
                        value: null
                    },
                    u_norShadeTexture: {
                        value: null
                    }
                },
                vertexShader: vert$3,
                fragmentShader: frag$6,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0,
                blending: CustomBlending,
                blendEquation: AddEquation,
                blendSrc: OneFactor,
                blendDst: OneFactor,
                blendEquationAlpha: AddEquation,
                blendSrcAlpha: OneFactor,
                blendDstAlpha: OneFactor
            });
            c.extensions.derivatives = !0;
            const u = new Mesh(t,c);
            u.frustumCulled = !1,
            u.visible = !1,
            this.meshArray.push(u),
            this.faceContainer.add(u)
        }
    }
    resize(e, t) {}
    update(e) {
        if (this.meshArray.length > 0) {
            let t = this.transitionRatio;
            this.sharedUniforms.u_showRatio.value = this.showRatio;
            let r = input.easedMouseDynamics.default.value;
            _v1$1.set(r.x, r.y, .5).unproject(cameraControls._camera).sub(cameraControls._camera.position).normalize(),
            _v1$1.multiplyScalar(75 / _v1$1.z).add(cameraControls._camera.position),
            _m.copy(this.faceContainer.matrixWorld).invert(),
            _v1$1.applyMatrix4(_m);
            let n = math.clamp(_v1$1.y * .03, -.05, .05)
              , o = math.clamp(_v1$1.x * .03, -.05, .05);
            _v1$1.applyMatrix4(this.faceContainer.matrixWorld),
            this.sharedUniforms.u_mouse.value.copy(_v1$1);
            let l = this.meshArray[0];
            l.material.uniforms.u_positionTexture.value = this.teamPosDataTextures[this.currId],
            l.material.uniforms.u_norShadeTexture.value = this.teamNShadeDataTextures[this.currId],
            l.material.uniforms.u_activeRatio.value = 1 - t,
            l.material.uniforms.u_glitchThreshold.value = math.fit(l.material.uniforms.u_activeRatio.value, .4, 1, 0, .9),
            l.material.uniforms.u_activeRatio.value *= this.activeRatio,
            l.position.x = t * -1.5,
            l.position.z = -t * 2 - (1 - this.activeRatio) * 2,
            l.rotation.y = t * -.3 + o,
            l.rotation.x = t * .4 + n,
            l.visible = !0;
            let c = this.meshArray[1];
            c.material.uniforms.u_positionTexture.value = this.teamPosDataTextures[this.nextId],
            c.material.uniforms.u_norShadeTexture.value = this.teamNShadeDataTextures[this.nextId],
            c.material.uniforms.u_activeRatio.value = t,
            c.material.uniforms.u_glitchThreshold.value = math.fit(c.material.uniforms.u_activeRatio.value, .4, 1, 0, .9),
            c.material.uniforms.u_activeRatio.value *= this.activeRatio,
            c.position.x = (t - 1) * -1.5,
            c.position.z = (t - 1) * 2 - (1 - this.activeRatio) * 2,
            c.rotation.y = (t - 1) * -.3 + o,
            c.rotation.x = (t - 1) * -.4 + n,
            c.visible = !0,
            this.sharedUniforms.u_glitchOffset.value = Math.random() * 1e3,
            this.sharedUniforms.u_glitchStrength.value = Math.random(),
            this.container.visible = this.isActive
        }
    }
}
const aboutHeroFaces = new AboutHeroFaces
  , fragmentShader$1 = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec3 u_colorBurn;uniform float u_colorBurnAlpha;uniform vec3 u_colorDodge;uniform float u_colorDodgeAlpha;varying vec2 v_uv;vec3 colorDodge(in vec3 src,in vec3 dst){return mix(step(0.,src)*(min(vec3(1.),dst/(1.-src))),vec3(1.),step(1.,dst));}vec3 colorBurn(in vec3 src,in vec3 dst){return mix(step(0.,src)*(1.-min(vec3(1.),(1.-dst)/src)),vec3(1.),step(1.,dst));}void main(){vec4 texture=texture2D(u_texture,v_uv);vec3 colorBurn=mix(texture.rgb,colorBurn(u_colorBurn,texture.rgb),u_colorBurnAlpha);vec3 colorDodge=mix(texture.rgb,colorDodge(u_colorDodge,texture.rgb),u_colorDodgeAlpha);texture.rgb=mix(colorBurn,colorDodge,texture.rgb);gl_FragColor=texture;}`;
let _sceneColorBurn = new Color("#00f0ff")
  , _sceneColorDodge = new Color("#005aff")
  , _sceneColorBurnAlpha = .15
  , _sceneColorDodgeAlpha = .12
  , _hudColorBurn = new Color("#79a8ff")
  , _hudColorDodge = new Color("#a5ff44")
  , _hudColorBurnAlpha = 1
  , _hudColorDodgeAlpha = .7;
class AboutPageHeroEfx extends PostEffect {
    colorBurn = new Color("#000");
    colorDodge = new Color("#000");
    hudRatio = 1;
    isActive = !0;
    renderOrder = 20;
    randSimplex1Ds = [];
    init(e) {
        Object.assign(this, e),
        super.init(),
        this.material = fboHelper.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_colorBurn: {
                    value: this.colorBurn
                },
                u_colorBurnAlpha: {
                    value: 1
                },
                u_colorDodge: {
                    value: this.colorDodge
                },
                u_colorDodgeAlpha: {
                    value: 1
                }
            },
            fragmentShader: fragmentShader$1
        })
    }
    needsRender() {
        return this.isActive
    }
    render(e, t=!1) {
        let r = this.material.uniforms;
        this.colorBurn.copy(_sceneColorBurn).lerp(_hudColorBurn, this.hudRatio),
        this.colorDodge.copy(_sceneColorDodge).lerp(_hudColorDodge, this.hudRatio),
        r.u_colorBurnAlpha.value = math.mix(_sceneColorBurnAlpha, _hudColorBurnAlpha, this.hudRatio * this.hudRatio),
        r.u_colorDodgeAlpha.value = math.mix(_sceneColorDodgeAlpha, _hudColorDodgeAlpha, this.hudRatio * this.hudRatio),
        super.render(e, t)
    }
}
const aboutPageHeroEfx = new AboutPageHeroEfx
  , vert$2 = `#define GLSLIFY 1
attribute vec3 instancePos;attribute vec4 instanceRands;attribute float instanceDensity;uniform float u_time;uniform float u_showRatio;varying vec2 v_uv;varying vec2 v_charUv;varying vec3 v_worldPosition;varying vec4 v_instanceRands;varying float v_opacity;void main(){float charCount=mix(50.,100.,instanceRands.y);vec3 pos=position;v_uv=uv;pos.xy*=vec2(1.,6./5.*charCount);v_charUv=vec2(1.-position.x,position.y*charCount)+vec2(.5,0.);v_charUv.y-=u_time*mix(2.,10.,instanceRands.x);pos=pos*0.75+instancePos;gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.);v_worldPosition=(modelMatrix*vec4(pos,1.)).xyz;v_instanceRands=instanceRands;v_opacity=mix(.5,1.,instanceDensity)*u_showRatio;}`
  , frag$5 = `#define GLSLIFY 1
uniform sampler2D u_letterTexture;uniform float u_time;varying vec2 v_charUv;varying vec2 v_uv;varying vec3 v_worldPosition;varying vec4 v_instanceRands;varying float v_opacity;float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}vec4 hash43(vec3 p){vec4 p4=fract(vec4(p.xyzx)*vec4(.1031,.1030,.0973,.1099));p4+=dot(p4,p4.wzxy+33.33);return fract((p4.xxyz+p4.yzzw)*p4.zywx);}void main(){float fade=1.-linearStep(15.,66.,v_worldPosition.z);float MAX_CHAR=42.;float charIdx=floor(mod(v_charUv.y,MAX_CHAR));float charTime=u_time*mix(1.,2.,v_instanceRands.y+hash43(vec3(charIdx,-100.,v_instanceRands.z)).x);vec4 charRands=hash43(vec3(charIdx,v_instanceRands.w,floor(charTime*-2.)));charIdx=mod(charIdx+floor(charRands.x*MAX_CHAR),MAX_CHAR);vec2 charUv=vec2((v_charUv.x+charIdx)/MAX_CHAR,mod(v_charUv.y,1.));float shade=texture2D(u_letterTexture,charUv).r;gl_FragColor=vec4(shade)*charRands.w*charRands.y*v_opacity;gl_FragColor*=smoothstep(0.5,0.35,abs(v_uv.y-.5))*(0.5+fade*0.5)*(0.3+v_instanceRands.z*1.25)*smoothstep(100.,150.,mod(v_charUv.y-200.*v_instanceRands.y,200.));gl_FragColor.a*=3.;}`;
class AboutHeroLetters {
    container = new Object3D;
    rt;
    blurRt;
    sharedUniforms = {};
    mesh;
    meshList = [];
    preInit() {
        properties.loader.add(settings.MODEL_PATH + "about/letter_placements.buf", {
            onLoad: this._onGeometryLoad.bind(this)
        })
    }
    _onGeometryLoad(e) {
        let t = new PlaneGeometry(1,1).translate(0, .5, 0).rotateY(Math.PI)
          , r = e.attributes.position.count
          , n = Math.floor(r / 4)
          , o = new ShaderMaterial({
            uniforms: Object.assign({
                u_time: properties.sharedUniforms.u_time,
                u_showRatio: aboutHeroFaces.sharedUniforms.u_showRatio
            }, aboutHero.sharedUniforms),
            depthTest: !1,
            depthWrite: !1,
            vertexShader: vert$2,
            fragmentShader: frag$5,
            transparent: !0,
            blending: CustomBlending,
            blendEquation: AddEquation,
            blendSrc: OneFactor,
            blendDst: OneFactor,
            blendEquationAlpha: AddEquation,
            blendSrcAlpha: OneFactor,
            blendDstAlpha: OneFactor
        });
        for (let l = 0; l < 4; l++) {
            let c = new InstancedBufferGeometry;
            for (let p in t.attributes)
                c.setAttribute(p, t.attributes[p]);
            c.setIndex(t.index);
            let u = new Float32Array(r * 4);
            for (let p = 0; p < n; p++)
                u[p * 4 + 0] = Math.random(),
                u[p * 4 + 1] = Math.random(),
                u[p * 4 + 2] = Math.random(),
                u[p * 4 + 3] = Math.random();
            c.setAttribute("instanceRands", new InstancedBufferAttribute(u,4));
            let f = n * l;
            c.setAttribute("instancePos", new InstancedBufferAttribute(e.attributes.position.array.slice(f * 3, (f + n) * 3),3)),
            c.setAttribute("instanceDensity", new InstancedBufferAttribute(e.attributes.density.array.slice(f, f + n),1)),
            this.meshList[l] = new Mesh(c,o)
        }
        this.rt = fboHelper.createRenderTarget(1, 1),
        this.blurRt = fboHelper.createRenderTarget(1, 1),
        this.mesh = new Mesh(new PlaneGeometry(2,2),fboHelper.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: this.rt.texture
                }
            },
            depthTest: !1,
            depthWrite: !1,
            transparent: !0,
            blending: CustomBlending,
            blendEquation: AddEquation,
            blendSrc: OneFactor,
            blendDst: OneFactor,
            blendEquationAlpha: AddEquation,
            blendSrcAlpha: OneFactor,
            blendDstAlpha: OneFactor
        })),
        this.mesh.frustumCulled = !1,
        this.mesh.renderOrder = 10,
        this.container.add(this.mesh),
        this.mesh.onBeforeRender = this._onBeforeRender.bind(this)
    }
    init() {}
    _onBeforeRender() {
        (properties.width != this.rt.width || properties.height != this.rt.height) && this.rt.setSize(properties.width, properties.height);
        let e = properties.renderer
          , t = e.getRenderTarget()
          , r = fboHelper.getColorState();
        e.setClearColor(0, 0),
        e.setRenderTarget(this.rt),
        e.clear(),
        e.autoClear = !1,
        fboHelper.renderMesh(this.meshList[0], this.rt, properties.camera),
        blur.blur(16, .5, this.rt, this.blurRt, this.rt),
        fboHelper.renderMesh(this.meshList[1], this.rt, properties.camera),
        blur.blur(8, .5, this.rt, this.blurRt, this.rt),
        fboHelper.renderMesh(this.meshList[2], this.rt, properties.camera),
        blur.blur(4, .5, this.rt, this.blurRt, this.rt),
        fboHelper.renderMesh(this.meshList[3], this.rt, properties.camera),
        e.setRenderTarget(t),
        fboHelper.setColorState(r)
    }
    update(e) {}
}
const aboutHeroLetters = new AboutHeroLetters
  , _v = new Vector3
  , _q0 = new Quaternion
  , _q1 = new Quaternion;
class AboutHero extends Stage3D {
    container = new Object3D;
    sceneContainer = new Object3D;
    hudContainer = new Object3D;
    cameraSplineGeo = null;
    cameraSplinePositions = null;
    cameraSplineOrientation = null;
    sceneRatio = 0;
    sceneHideRatio = 0;
    initialSplineRatio = 0;
    hudRatio = 0;
    introRatio = 0;
    outSectionRatio = 0;
    freezeRatio = 1;
    introTime = 0;
    scrollYRatio = 0;
    panningSplineRaito = 0;
    sharedUniforms = {
        u_sceneRatio: {
            value: 0
        },
        u_sceneHideRatio: {
            value: 0
        },
        u_hudRatio: {
            value: 0
        },
        u_introRatio: {
            value: 0
        },
        u_introTime: {
            value: 0
        },
        u_introDeltaTime: {
            value: 0
        },
        u_letterTexture: {
            value: null
        }
    };
    constructor() {
        super({
            properties: {
                defaultCameraPosition: new Vector3(0,5,5),
                defaultLookAtPosition: new Vector3(0,5,0),
                cameraDollyZoomFovOffset: 0,
                cameraFov: 60,
                bloomAmount: 4,
                bloomRadius: .25,
                bloomThreshold: .8,
                bloomSmoothWidth: .3,
                haloStrength: 0,
                clearAlpha: 0,
                cameraLookStrength: .1,
                screenPaintOffsetRatio: 0,
                screenPaintDistortionRGBShift: .1
            }
        })
    }
    preInit() {
        aboutPageHeroEfxPrepass.init(),
        properties.postprocessing.queue.push(aboutPageHeroEfxPrepass),
        aboutPageHeroEfx.init(),
        properties.postprocessing.queue.push(aboutPageHeroEfx),
        this.sharedUniforms.u_letterTexture.value = properties.loader.add(settings.TEXTURE_PATH + "font.png", {
            minFilter: LinearFilter,
            type: "texture"
        }).content,
        shaderHelper.addChunk("aboutHeroVisualFinal_vert", aboutHeroVisualFinalVert),
        shaderHelper.addChunk("aboutHeroVisualFinal_frag", aboutHeroVisualFinalFrag),
        properties.loader.add(settings.MODEL_PATH + "about/camera_spline.buf", {
            onLoad: e => this.cameraSplineGeo = e
        }),
        light.preInit(),
        sim.preInit(),
        lightField.preInit(),
        aboutHeroParticles.preInit(),
        aboutHeroRocks.preInit(),
        aboutHeroGround.preInit(),
        aboutHeroLines.preInit(),
        aboutHeroPerson$1.preInit(),
        aboutHeroFog.preInit(),
        aboutHeroHalo.preInit(),
        aboutHeroFaces.preInit(),
        aboutHeroLetters.preInit()
    }
    init() {
        light.init(),
        sim.init(),
        lightField.init(),
        aboutHeroParticles.init(),
        aboutHeroRocks.init(),
        aboutHeroGround.init(),
        aboutHeroLines.init(),
        aboutHeroPerson$1.init(),
        aboutHeroFog.init(),
        aboutHeroScatter.init(),
        aboutHeroHalo.init(),
        aboutHeroFaces.init(),
        aboutHeroLetters.init(),
        this.add(aboutHeroParticles.container),
        this.sceneContainer.add(aboutHeroRocks.container),
        this.sceneContainer.add(aboutHeroPerson$1.container),
        this.sceneContainer.add(aboutHeroFog.container),
        this.add(this.sceneContainer),
        this.add(aboutHeroGround.container),
        this.add(aboutHeroHalo.container),
        this.hudContainer.add(aboutHeroLines.container),
        this.add(this.hudContainer),
        aboutPageHeroEfxPrepass.scene.add(aboutHeroFaces.container),
        aboutPageHeroEfxPrepass.scene.add(aboutHeroLetters.container),
        this.cameraSplinePositions = this.cameraSplineGeo.attributes.position,
        this.cameraSplineOrientation = this.cameraSplineGeo.attributes.orient,
        taskManager.add(this),
        taskManager.add(aboutPageHeroEfxPrepass.scene)
    }
    resize(e, t) {
        aboutHeroFog.resize(e, t),
        aboutHeroHalo.resize(e, t),
        aboutHeroFaces.resize(e, t)
    }
    syncProperties(e) {
        this.sharedUniforms.u_introRatio.value = this.introRatio;
        const t = math.saturate(this.initialSplineRatio) * 149 + math.saturate(this.panningSplineRaito) * 50
          , r = Math.floor(t)
          , n = Math.min(this.cameraSplinePositions.count - 1, Math.ceil(t))
          , o = t - r;
        this.sceneRatio = this.sharedUniforms.u_sceneRatio.value = math.fit(this.introRatio, .01, .1, 0, 1, ease.cubicOut),
        this.sceneHideRatio = this.sharedUniforms.u_sceneHideRatio.value = math.fit(this.introRatio, .85, 1, 0, 1),
        this.sharedUniforms.u_hudRatio.value = this.hudRatio,
        this.properties.bloomAmount = 3,
        this.properties.bloomAmount = math.fit(this.introRatio, .1, .85, this.properties.bloomAmount, 1.5, ease.sineOut),
        this.properties.bloomAmount = math.fit(this.introRatio, .85, 1, this.properties.bloomAmount, 10),
        this.properties.bloomAmount = math.fit(this.hudRatio, 0, .5, this.properties.bloomAmount, 12.5),
        this.properties.haloStrength = .08,
        this.properties.haloStrength = math.fit(this.introRatio, .1, .4, this.properties.haloStrength, .15),
        this.properties.haloStrength = math.fit(this.hudRatio, 0, .5, this.properties.haloStrength, 0),
        this.properties.screenPaintDistortionRGBShift = math.mix(0, properties.defaults.screenPaintDistortionRGBShift, this.outSectionRatio),
        this.properties.cameraLookStrength = math.fit(this.initialSplineRatio, 0, 1, .1, .035),
        _v.fromArray(this.cameraSplinePositions.array, n * 3),
        this.properties.defaultCameraPosition.fromArray(this.cameraSplinePositions.array, r * 3),
        this.properties.defaultCameraPosition.lerp(_v, o),
        _q0.fromArray(this.cameraSplineOrientation.array, r * 4),
        _q1.fromArray(this.cameraSplineOrientation.array, n * 4),
        _q0.slerp(_q1, o),
        _v.set(0, 0, 1).applyQuaternion(_q0).add(this.properties.defaultCameraPosition),
        this.properties.defaultLookAtPosition.copy(_v),
        this.properties.cameraDollyZoomFovOffset = math.fit(this.initialSplineRatio, .4, .8, 0, -10, ease.sineInOut),
        this.properties.defaultCameraPosition.y += math.fit(this.scrollYRatio, 0, 1, 0, -10, ease.sineOut),
        this.properties.defaultLookAtPosition.y += math.fit(this.scrollYRatio, 0, 1, 0, -10.1, ease.sineOut),
        this.freezeRatio += ((input.isDown ? 1 - this.hudRatio : 0) - this.freezeRatio) * .1
    }
    update(e) {
        let t = e * math.mix(1, .1, this.freezeRatio);
        this.introTime += t,
        this.sharedUniforms.u_introTime.value = this.introTime,
        this.sharedUniforms.u_introDeltaTime.value = t,
        aboutHeroScatter.update(),
        this.hudRatio < 1 ? (sim.update(e),
        lightField.update(t),
        aboutHeroParticles.update(t),
        aboutHeroParticles.container.visible = !0) : aboutHeroParticles.container.visible = !1,
        this.sceneRatio > 0 && this.hudRatio < 1 ? (light.update(t),
        aboutHeroRocks.update(t),
        aboutHeroPerson$1.update(t),
        aboutHeroFog.update(t),
        aboutHeroHalo.update(t),
        this.sceneContainer.visible = !0) : this.sceneContainer.visible = !1,
        this.sceneRatio > 0 && aboutHeroGround.update(t),
        this.hudRatio > 0 ? (aboutHeroLines.update(e),
        this.hudContainer.visible = !0) : this.hudContainer.visible = !1,
        aboutHeroFaces.update(e),
        aboutHeroLetters.update(e),
        aboutPageHeroEfxPrepass.blurRatio = this.hudRatio,
        aboutPageHeroEfxPrepass.needsRenderScene = aboutHeroFaces.isActive,
        aboutPageHeroEfx.hudRatio = aboutHeroFaces.showRatio,
        this.hudRatio < 1 && lightField.postUpdate(e),
        this.sceneRatio > 0 && this.hudRatio < 1 && light.postUpdate(e)
    }
}
const aboutHero = new AboutHero
  , vert$1 = `#define GLSLIFY 1
attribute float char;uniform float u_time;uniform float u_showRatio;uniform float u_hideRatio;uniform float u_aspect;uniform vec2 u_toDomXY;uniform vec2 u_toDomWH;uniform vec2 u_toDomPivot;varying float v_dist;
#include <ufxVert>
float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}float cubicInOut(float t){return t<0.5? 4.0*t*t*t: 0.5*pow(2.0*t-2.0,3.0)+1.0;}float cubicBezier(float p0,float p1,float p2,float p3,float t){float c=(p1-p0)*3.;float b=(p2-p1)*3.-c;float a=p3-p0-c-b;float t2=t*t;float t3=t2*t;return a*t3+b*t2+c*t+p0;}float easeOutBack(float t){return cubicBezier(0.,1.3,1.1,1.,t);}void main(){vec3 pos=vec3(position.xy,0.);vec3 aspectCorrectedPos=pos*vec3(1.,u_aspect,1.);v_dist=position.z;vec3 basePos=getBasePosition(aspectCorrectedPos);basePos.y=1.-basePos.y;vec3 screenPos=getScreenPosition(basePos);float vertexShowRatio=easeOutBack(linearStep(0.,1.,u_showRatio*2.2-aspectCorrectedPos.x-(aspectCorrectedPos.y)*0.2));screenPos.y-=(1.0-vertexShowRatio)*(u_domWH.y+min(u_domWH.y*1.1,100.));pos.x-=char/5.*0.08;vec3 aspectCorrectedToPos=pos*vec3(1.,u_aspect,1.);vec3 toBasePos=vec3((aspectCorrectedToPos.xy)*u_toDomWH-u_toDomPivot,aspectCorrectedToPos.z);toBasePos.y=1.-toBasePos.y;vec3 toScreenPos=toBasePos+vec3(u_toDomPivot.xy,0.);toScreenPos=(toScreenPos+vec3(u_toDomXY.xy,0.))*vec3(1.,-1.,1.);float vertexHideRatio=cubicInOut(linearStep(0.,1.,u_hideRatio*2.2-aspectCorrectedPos.x-pow(aspectCorrectedPos.y,1.+u_hideRatio)*0.2));screenPos=mix(screenPos,toScreenPos,vertexHideRatio);gl_Position=projectionMatrix*modelViewMatrix*vec4(screenPos,1.0);}`
  , frag$4 = `#define GLSLIFY 1
varying float v_dist;void main(){float alpha=smoothstep(0.,0.+fwidth(v_dist),v_dist);gl_FragColor=vec4(1.,1.,1.,alpha);}`;
let _needsSync = !1;
class AboutWhoLogo {
    container = new Object3D;
    fromDom;
    toDom;
    mesh;
    toMesh;
    containerWidth = 0;
    hideRatio = 0;
    preInit(e) {
        this.fromDom = e.querySelector("#about-who-title-main-logo"),
        this.toDom = e.querySelector("#about-who-title-left-2"),
        aboutPage.postUfxContainer.add(this.container),
        this.toMesh = new UfxMesh({
            refDom: this.toDom
        }),
        properties.loader.add(settings.MODEL_PATH + "about/logo_text.buf", {
            onLoad: this._onGeometryLoad.bind(this)
        })
    }
    _onGeometryLoad(e) {
        let t = this.toMesh.material.uniforms;
        this.mesh = new UfxMesh({
            refDom: this.fromDom,
            geometry: e,
            uniforms: {
                u_showRatio: {
                    value: 1
                },
                u_hideRatio: {
                    value: 0
                },
                u_aspect: {
                    value: 1 / .200957
                },
                u_toDomXY: t.u_domXY,
                u_toDomWH: t.u_domWH,
                u_toDomPivot: t.u_domPivot,
                u_time: properties.sharedUniforms.u_time
            },
            vertexShader: vert$1,
            fragmentShader: frag$4
        }),
        this.container.add(this.mesh)
    }
    init() {}
    resize(e, t) {
        _needsSync = !0
    }
    update(e, t, r, n, o) {
        this.mesh && (_needsSync && (_needsSync = !1,
        this.mesh.syncDom(r, t - n),
        this.toMesh.syncDom(r, t - o)),
        this.mesh.material.uniforms.u_showRatio.value = math.fit(aboutPage.time, .5, 1.5, 0, 1),
        properties.useMobileLayout ? (this.mesh.material.uniforms.u_showRatio.value *= 1 - this.hideRatio,
        this.mesh.material.uniforms.u_hideRatio.value = 0) : this.mesh.material.uniforms.u_hideRatio.value = this.hideRatio,
        this.mesh.update(r, t),
        this.toMesh.update(r, t))
    }
}
const aboutWhoLogo = new AboutWhoLogo;
class WhoSubsectionWeAre {
    domContainer;
    domScroll;
    domLeftTexts;
    logoHideRatio = 0;
    preInit(e) {
        this.domContainer = e.querySelector("#about-who-subsection-we-are"),
        this.domScroll = e.querySelector("#about-who-title-main-scroll"),
        this.domLeftTexts = e.querySelectorAll("#about-who-title-left-1, #about-who-title-left-2 svg, #about-who-title-left-3, #about-who-title-left-4 span"),
        this.domRightTexts = e.querySelectorAll(".about-who-title-right-text"),
        aboutWhoLogo.preInit(e)
    }
    init() {
        aboutWhoLogo.init()
    }
    show() {}
    hide() {}
    resize(e, t) {
        this.offsetUnitSize = Math.max(60, properties.viewportWidth * .08),
        aboutWhoLogo.resize(e, t)
    }
    update(e, t, r, n, o) {
        if (this.domContainer.style.visibility = t ? "visible" : "hidden",
        this.domContainer.style.opacity = t ? 1 : 0,
        aboutWhoLogo.container.visible = t,
        t) {
            let l = properties.useMobileLayout ? properties.viewportWidth * -r : 0;
            this.domContainer.style.transform = "translate3d(" + l + "px, 0, 0)";
            let c = aboutHero.introRatio < .05;
            this.logoHideRatio = math.saturate(this.logoHideRatio + e * (c ? -1 : 1));
            let u = this.offsetUnitSize;
            aboutWhoLogo._pageScrollOffsetXRatio = 0;
            for (let p = 0; p < this.domLeftTexts.length; p++) {
                let g = this.domLeftTexts[p]
                  , _ = (!properties.useMobileLayout && p == 5 ? 4 : p) / (this.domLeftTexts.length - 1)
                  , w = math.fit(this.logoHideRatio, _ * .2, _ * .2 + .8, 0, 1)
                  , S = math.fit(r, 0, _ * .5 + .3, 0, -10, ease.cubicOut);
                g._pageScrollOffsetXRatio = S,
                properties.useMobileLayout || p != 1 ? (w = math.fit(w, .35, 1, 0, 1, ease.cubicOut),
                g.style.opacity = w,
                g.style.transform = "translate3d(" + ((1 - w) * 1 + S) * u + "px, 0, 0)",
                p == 1 && (aboutWhoLogo.hideRatio = this.logoHideRatio)) : (aboutWhoLogo.hideRatio = w,
                aboutWhoLogo._pageScrollOffsetXRatio = S)
            }
            for (let p = 0; p < this.domRightTexts.length; p++) {
                let g = this.domRightTexts[p]
                  , v = p / (this.domRightTexts.length - 1)
                  , _ = math.fit(this.logoHideRatio, .5 + v * .1, v * .1 + .9, 0, 1, ease.cubicOut)
                  , w = math.fit(r, .35, v * .5 + 1.35, 0, -5, ease.cubicOut);
                g.style.opacity = _,
                g.style.transform = "translate3d(" + ((1 - _) * 1 + w) * u + "px, 0, 0)"
            }
            let f = math.fit(this.logoHideRatio, 0, .35, 1, 0, ease.cubicInOut);
            this.domScroll.style.opacity = f,
            properties.useMobileLayout ? this.domScroll.style.transform = "translate3d(50%, " + (1 - f) * 120 + "%, 0)" : this.domScroll.style.transform = "translate3d(0, " + (1 - f) * 120 + "%, 0)",
            aboutWhoLogo.update(e, -r * properties.viewportWidth + aboutWhoLogo._pageScrollOffsetXRatio * u, -scrollManager.scrollPixel + o, aboutWhoLogo._pageScrollOffsetXRatio * u, this.domLeftTexts[1]._pageScrollOffsetXRatio * u)
        }
    }
}
const whoSubsectionWeAre = new WhoSubsectionWeAre;
class WhoSubsectionDetails {
    domContainer;
    activeFaceId = -1;
    domTopWords;
    domBottomWords;
    preInit(e) {
        this.domContainer = e.querySelector("#about-who-subsection-details");
        let t = this.domContainer.querySelector("#about-who-desc-top")
          , r = this.domContainer.querySelector("#about-who-desc-bottom");
        this.domTopWords = this._parseDomText(t),
        this.domBottomWords = this._parseDomText(r)
    }
    _parseDomText(e) {
        let t = e.querySelectorAll("span");
        for (let r = 0; r < t.length; r++) {
            let n = t[r]
              , o = t[r].innerHTML.split(" ");
            n.innerHTML = "<span>" + o.join("</span><span>") + "</span>"
        }
        return e.querySelectorAll("span span")
    }
    init() {}
    show() {}
    hide() {}
    resize(e, t) {
        let r;
        r = this.domTopWords;
        let n = 1 / 0
          , o = -1;
        for (let l = 0; l < r.length; l++) {
            let c = r[l];
            c.style.transform = "translateZ(0)",
            c.style.opacity = 1;
            let u = c.getBoundingClientRect().left;
            u <= n && o++,
            n = u + 1,
            c._line = o
        }
        this.domTopWords._lineCount = o + 1,
        r = this.domBottomWords,
        n = 1 / 0,
        o = -1;
        for (let l = 0; l < r.length; l++) {
            let c = r[l];
            c.style.transform = "translateZ(0)",
            c.style.opacity = 1;
            let u = c.getBoundingClientRect().right;
            u <= n && o++,
            n = u + 1,
            c._line = o
        }
        this.domBottomWords._lineCount = o + 1
    }
    update(e, t, r) {
        if (this.domContainer.style.visibility = t ? "visible" : "hidden",
        t) {
            let n = 0;
            if (properties.useMobileLayout)
                n = math.fit(r, -.75, -.25, 0, 1) * math.fit(r, .25, .5, 1, 0);
            else {
                n = 1;
                let o, l;
                o = this.domTopWords,
                l = o._lineCount;
                for (let c = 0; c < o.length; c++) {
                    let u = o[c]
                      , f = u._line / l
                      , p = c / o.length
                      , g = math.fit(r, -1 + f * .5, -.1, 0, 1)
                      , v = math.fit(r, -1 + p * .5, -.1, 0, 1)
                      , _ = math.fit(r, .1, .5 + f * .5, 0, 1)
                      , w = math.fit(r, .1, .5 + p * .5, 0, 1);
                    u.style.transform = "translate3d(" + (math.fit(g, 0, 1, 10, 0) + math.fit(_, 0, 1, 0, -10)) + "em, 0, 0) translate3d(" + (math.fit(r, -1, 0, -50, 0) + math.fit(r, .1, 1, 0, 20)) + "vw, 0, 0)",
                    u.style.opacity = v * (1 - w)
                }
                o = this.domBottomWords,
                l = o._lineCount;
                for (let c = 0; c < o.length; c++) {
                    let u = o[c]
                      , f = u._line / l
                      , p = c / o.length
                      , g = math.fit(r, -.6 + f * .5, -.1, 0, 1)
                      , v = math.fit(r, -.6 + p * .5, -.1, 0, 1)
                      , _ = math.fit(r, .2, .5 + f * .5, 0, 1)
                      , w = math.fit(r, .2, .5 + p * .5, 0, 1);
                    u.style.transform = "translate3d(" + (math.fit(g, 0, 1, 10, 0) + math.fit(_, 0, 1, 0, -10)) + "em, 0, 0) translate3d(" + (math.fit(r, -1, 0, -20, 0) + math.fit(r, 0, 1, 0, 50)) + "vw, 0, 0)",
                    u.style.opacity = v * (1 - w)
                }
            }
            this.domContainer.style.opacity = n
        }
    }
}
const whoSubsectionDetails = new WhoSubsectionDetails;
class TextAnimationHelper {
    setMatrixText(e, t, r=0, n=40, o=2, l=1 / 15) {
        e._rawTime = 0,
        e._time = 0,
        e._direction = 1,
        e._prevRefreshTime = -1 / 0,
        e._refreshRate = l,
        e._delay = r,
        t = t.replace("<br>", `
`),
        e._text = t,
        e._letterPerSecond = n,
        e._maxRandLetterCount = o,
        e.textContent = ""
    }
    resetMatrixTextTime(e) {
        e._rawTime = 0,
        e._time = 0,
        e._prevRefreshTime = -1 / 0
    }
    updateMatrixText(e, t=properties.deltaTime) {
        if (e._rawTime += t,
        e._time += t * e._direction,
        e._time = math.clamp(e._time, 0, e._delay + (e._text.length + e._maxRandLetterCount) / e._letterPerSecond),
        e._rawTime >= e._prevRefreshTime + e._refreshRate) {
            e._prevRefreshTime = e._rawTime;
            let r = e._text
              , n = Math.max(0, Math.floor(e._letterPerSecond * (e._time - e._delay)))
              , o = Math.min(r.length, n - e._maxRandLetterCount)
              , l = Math.min(r.length, n)
              , c = "";
            if (n > 0) {
                c = r.substr(0, o);
                for (let u = 0; u < l - o; u++)
                    c += String.fromCharCode(33 + ~~(Math.random() * 93));
                c = c.replace(`
`, "<br>")
            }
            e._str != c && (e._str = c,
            e.innerHTML = c)
        }
    }
}
const textAnimationHelper = new TextAnimationHelper
  , letterVert = `#define GLSLIFY 1
#include <ufxVert>
uniform float u_letterIdx;varying vec2 v_pixel;void main(){vec3 basePos=getBasePosition(position);vec3 screenPos=getScreenPosition(basePos);gl_Position=projectionMatrix*modelViewMatrix*vec4(screenPos,1.0);v_pixel=vec2(u_letterIdx*5.+1.,1.)+vec2(uv.x,1.-uv.y)*vec2(3.,4.);}`
  , letterFrag = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform float u_opacity;uniform float u_time;varying vec2 v_pixel;vec4 hash43(vec3 p){vec4 p4=fract(vec4(p.xyzx)*vec4(.1031,.1030,.0973,.1099));p4+=dot(p4,p4.wzxy+33.33);return fract((p4.xxyz+p4.yzzw)*p4.zywx);}void main(){vec4 rands=hash43(vec3(floor(v_pixel),floor(u_opacity*3.)+floor(u_time+sin(u_time*3.)*1.5)));float opacity=mix(pow(rands.x,5.),0.95+rands.y*0.05,smoothstep(.75,1.,u_opacity))*u_opacity;vec2 uv=(floor(v_pixel)+.5)/vec2(210.,6.);float mask=texture2D(u_texture,uv).r;vec2 dd=abs(fract(v_pixel)-.5);float dotMask=step(max(dd.x,dd.y),.05);gl_FragColor=vec4(1.,1.,1.,max(dotMask*.3*(opacity*0.5+u_opacity*0.5),mask*opacity));}`;
class WhoSubsectionTeam {
    domContainer;
    domProgress;
    domLeftTexts;
    domLeftNamePlaceholder;
    domLeftNameText;
    domLeftJobPlaceholder;
    domLeftJobText;
    domRight;
    domIndicator;
    domIndicatorInner;
    teamDataMap = {};
    teamDataList = [];
    faceId = "edan";
    targetActiveFaceIndex = 0;
    faceIndex = 0;
    _faceIndexTween;
    facesCount = 0;
    faceIndexTimer = 0;
    containerOffsetX = 0;
    itemActiveRatio = 0;
    isForward = !0;
    wasActive = null;
    isChangable = !1;
    canSwipe = !0;
    hasSwiped = !1;
    hasSwipedOnce = !1;
    _isAnimating = !1;
    timeBaseChangeSpeed = .2;
    lastSwipeTime = -1;
    domCursorDirection = -1;
    domCursorActive = !1;
    domCursorActiveRatio = 0;
    domCursorRotateRatio = 0;
    domCursorExtraRotationMotion = new SecondOrderDynamics(0,1,.8,1.2);
    faceRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        offsetX: 0,
        offsetY: 0
    };
    letterRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        offsetX: 0,
        offsetY: 0
    };
    domRightWidth = 0;
    preInit(e) {
        this.domContainer = e.querySelector("#about-who-subsection-team"),
        this.domProgress = e.querySelector("#about-who-team-progress"),
        this.domLeft = e.querySelector("#about-who-team-left"),
        this.domLeftInfo = e.querySelector("#about-who-team-info"),
        this.domLeftNameIcon = e.querySelector("#about-who-team-name-icon"),
        this.domLeftNamePlaceholder = e.querySelector("#about-who-team-name-placeholder"),
        this.domLeftNameText = e.querySelector("#about-who-team-name-text"),
        this.domLeftJobPlaceholder = e.querySelector("#about-who-team-job-placeholder"),
        this.domLeftJobText = e.querySelector("#about-who-team-job-text"),
        this.domNumber = e.querySelector("#about-who-team-number"),
        this.domTopCompass = e.querySelector("#about-who-team-top-compass"),
        this.domBottomCompass = e.querySelector("#about-who-team-bottom-compass"),
        this.domDots = e.querySelector("#about-who-team-dots"),
        this.domLetterContainer = e.querySelector("#about-who-team-letter-container"),
        this.domIndicator = this.domProgress.querySelector("#about-who-team-indicator"),
        this.domIndicatorInner = this.domProgress.querySelector("#about-who-team-indicator-inner"),
        this.domIndicator._prevActiveRatio = -1,
        this.domRight = e.querySelector("#about-who-team-right"),
        this.domTitle = e.querySelector("#about-who-team-title"),
        this.domDesc = e.querySelector("#about-who-team-desc"),
        this.domDescText = e.querySelector("#about-who-team-desc-text"),
        this.domDescSquare = e.querySelector("#about-who-team-square"),
        this.domCursor = e.querySelector("#about-who-face-cursor"),
        this.domCursorArrow = e.querySelector("#about-who-face-cursor-arrow"),
        this.domFaces = e.querySelector("#about-who-team-faces"),
        this.domMobileSwipe = e.querySelector("#about-who-team-left-mobile-tips"),
        this.domTeamNumber = e.querySelector("#about-who-team-number-center-item"),
        properties.loader.add(settings.TEAM_PATH + "team.json", {
            onLoad: t => {
                this.teamDataList = t,
                this._createUIElements();
                for (let r = 0; r < t.length; r++)
                    t[r].index = r,
                    this.teamDataMap[t[r].id] = t[r]
            }
        }),
        aboutHeroFaces.load(this.faceId),
        this.letterMesh = new UfxMesh({
            uniforms: {
                u_texture: {
                    value: properties.loader.add(settings.TEXTURE_PATH + "font.png", {
                        minFilter: LinearFilter,
                        type: "texture"
                    }).content
                },
                u_letterIdx: {
                    value: 0
                },
                u_opacity: {
                    value: 1
                },
                u_time: properties.sharedUniforms.u_time
            },
            vertexShader: letterVert,
            fragmentShader: letterFrag
        }),
        this.letterMesh.visible = !1,
        aboutPage.postUfxContainer.add(this.letterMesh),
        this._faceIndexTween = new Tween(this, () => {
            this.onTweenComplete()
        }
        )
    }
    init() {
        input.onXScrolled.add( () => {
            properties.useMobileLayout && this.canSwipe && this.wasActive && properties.time - this.lastSwipeTime > .5 && (this.hasSwiped = !0,
            this.canSwipe = !1,
            this.domCursorDirection = input.lastScrollXDirection,
            this.lastSwipeTime = properties.time)
        }
        , this),
        input.onUped.add( () => {
            this.canSwipe = !0
        }
        , this)
    }
    onPageShow() {
        aboutHeroFaces.showRatio = 0;
        for (let e = 0; e < this.teamDataList.length; e++) {
            let t = this.teamDataList[e].id;
            aboutHeroFaces.load(t)
        }
        this.facesCount = this.teamDataList.length,
        this.updateTeamNumberUI()
    }
    prev() {
        this.targetActiveFaceIndex--,
        this.isForward = !1,
        this._clearTween(),
        this._isAnimating = !0,
        this._faceIndexTween.to(1.25 + Math.abs(this.targetActiveFaceIndex - this.faceIndex) * .25, {
            faceIndex: this.targetActiveFaceIndex
        }, ease.cubicInOut),
        this.updateTeamNumberUI()
    }
    next() {
        this.targetActiveFaceIndex++,
        this.isForward = !0,
        this._clearTween(),
        this._isAnimating = !0,
        this._faceIndexTween.to(1.25 + Math.abs(this.targetActiveFaceIndex - this.faceIndex) * .25, {
            faceIndex: this.targetActiveFaceIndex
        }, ease.cubicInOut),
        this.updateTeamNumberUI()
    }
    _clearTween() {
        this._isAnimating = !1,
        this._faceIndexTween.kill()
    }
    updateTeamNumberUI() {
        const t = `${(math.mod(this.targetActiveFaceIndex, this.facesCount) + 1001).toString().substring(1)}`;
        this.domTeamNumber.innerHTML = t
    }
    onTweenComplete() {
        this._clearTween(),
        this.faceIndexTimer = 0,
        this._changeFaceUIByIndex(math.mod(this.targetActiveFaceIndex, this.teamDataList.length))
    }
    reset() {
        this._clearTween(),
        this.faceIndexTimer = 0,
        this.targetActiveFaceIndex = 0,
        this.faceIndex = 0,
        this.canSwipe = !0,
        this.isForward = !0,
        this._changeFaceUIByIndex(0)
    }
    resize(e, t) {
        this._splitText(),
        this.syncContainerOffset(),
        this.domRightWidth = this.domRight.offsetWidth;
        let r = this.domContainer.getBoundingClientRect()
          , n = this.domFaces.getBoundingClientRect();
        this._updateRect(this.faceRect, n, r);
        let o = this.domLetterContainer.getBoundingClientRect();
        this._updateRect(this.letterRect, o, r),
        this._splitText()
    }
    _updateRect(e, t, r) {
        e.x = t.left - aboutWhoSection.subsectionContainerOffsetX - this.containerOffsetX,
        e.y = t.top - aboutWhoSection.subsectionContainerOffsetY + scrollManager.scrollPixel,
        e.width = t.width,
        e.height = t.height,
        e.offsetX = t.left - r.left,
        e.offsetY = t.top - r.top
    }
    _changeFaceUIByIndex(e) {
        e = math.mod(e, this.teamDataList.length);
        let t = this.faceId = this.teamDataList[e].id
          , r = this.teamDataMap[t].name
          , n = this.teamDataMap[t].role;
        this.domLeftNamePlaceholder.innerHTML = r,
        textAnimationHelper.setMatrixText(this.domLeftNameText, r, 0, 1, 3, 1 / 30),
        this.domLeftJobPlaceholder.innerHTML = n,
        textAnimationHelper.setMatrixText(this.domLeftJobText, n, 0, 1, 3, 1 / 30)
    }
    _createUIElements() {
        let e = document.createElement("div");
        e.id = "about-who-team-top-compass-inner",
        this.topCompassInnerDiv = e;
        for (let r = 0; r < this.teamDataList.length - 4; r++)
            for (let n = 0; n < 4; n++) {
                let o = document.createElement("div");
                o.classList.add("about-who-team-top-compass-long"),
                e.append(o);
                for (let l = 0; l < 4; l++) {
                    let c = document.createElement("div");
                    c.classList.add("about-who-team-top-compass-small"),
                    e.append(c)
                }
            }
        this.domTopCompass.append(e);
        let t = document.createElement("div");
        t.id = "about-who-team-bottom-compass-inner",
        this.bottomCompassInnerDiv = t;
        for (let r = 0; r < this.teamDataList.length - 4; r++)
            for (let n = 0; n < 4; n++) {
                let o = document.createElement("div");
                o.classList.add("about-who-team-bottom-compass-long"),
                t.append(o);
                for (let l = 0; l < 4; l++) {
                    let c = document.createElement("div");
                    c.classList.add("about-who-team-bottom-compass-small"),
                    t.append(c)
                }
            }
        this.domBottomCompass.append(t);
        for (let r = 0; r < 11; r++) {
            let n = document.createElement("div");
            n.classList.add("about-who-team-dots-col");
            for (let o = 0; o < 3; o++) {
                let l = document.createElement("div");
                l.classList.add("about-who-team-dot"),
                n.append(l)
            }
            this.domDots.append(n)
        }
        this.topCompassInnerDiv._width = this.topCompassInnerDiv.getBoundingClientRect().width - this.domTopCompass.getBoundingClientRect().width,
        this.bottomCompassInnerDiv._width = this.bottomCompassInnerDiv.getBoundingClientRect().width - this.domBottomCompass.getBoundingClientRect().width
    }
    syncContainerOffset() {
        this.containerOffsetX = properties.useMobileLayout ? 0 : (aboutWhoSection.scrollRatio * aboutWhoSection.PAGE_DISTANCE - aboutWhoSection.PAGE_DISTANCE * 2) * properties.viewportWidth,
        this.domContainer.style.transform = "translate3d(" + this.containerOffsetX + "px,0,0)"
    }
    _splitText() {}
    preUpdate() {
        this.domCursor.style.display = "none",
        this.letterMesh.visible = !1
    }
    onSwipe() {
        this.hasSwipedOnce = !0
    }
    update(e, t, r, n, o, l) {
        let c = l > .5;
        aboutHeroFaces.showRatio = math.saturate(aboutHeroFaces.showRatio + (c ? e : -e) / 1.5),
        aboutHeroFaces.isActive = aboutHeroFaces.showRatio > 0,
        this.itemActiveRatio = math.saturate(this.itemActiveRatio + (aboutHeroFaces.isActive ? this._isAnimating ? -2 : 2 : 0) * e),
        t && this.syncContainerOffset(),
        c && !this.hasSwipedOnce ? this.domMobileSwipe.classList.add("--is-active") : this.domMobileSwipe.classList.remove("--is-active");
        let u = this.faceRect.x + aboutWhoSection.subsectionContainerOffsetX + this.containerOffsetX
          , f = this.faceRect.y + aboutWhoSection.subsectionContainerOffsetY - scrollManager.scrollPixel
          , p = this.faceRect.width
          , g = this.faceRect.height
          , v = input.easedMouseDynamics.default.value.x
          , _ = input.easedMouseDynamics.default.value.y
          , w = (v * .5 + .5) * properties.viewportWidth
          , S = (.5 - _ * .5) * properties.viewportHeight
          , b = !1;
        if (properties.useMobileLayout)
            this.domCursor.style.display = "none";
        else if (this.wasActive || (this.domCursorActiveRatio = 0),
        b = c && w > u && w < u + p && S > f && S < f + g,
        this.domCursorActiveRatio = math.saturate(this.domCursorActiveRatio + (b ? e : -e) * 1.5),
        b = this.domCursorActiveRatio > 0,
        this.domCursorDirection = w - u - p * .5 > 0 ? 1 : -1,
        b) {
            this.domCursor.style.display = "flex";
            let M = w - u
              , P = S + this.faceRect.offsetY - f
              , I = Math.min(2.5, input.easedMouseDynamics.default.valueVel.length() / 5 + 1) * ease.backOut(this.domCursorActiveRatio) * math.fit(n, 0, properties.viewportHeight, 1, 0);
            this.domCursor.style.transform = `translate3d(${M}px, ${P}px,0) translate3d(-50%, -50%, 0) scale(${I})`,
            this.domCursorRotateRatio = math.saturate(this.domCursorRotateRatio + (this.domCursorDirection > 0 ? e * 3 : e * -3)),
            this.domCursorExtraRotationMotion.update(e, math.clamp(input.easedMouseDynamics.default.valueVel.y * -this.domCursorDirection, -1, 1));
            let k = ease.backInOut(this.domCursorRotateRatio);
            this.domCursorArrow.style.transform = `rotate(${k * 180 + this.domCursorExtraRotationMotion.value * 75}deg)`
        } else
            this.domCursor.style.display = "none";
        let C = 0
          , R = 0
          , T = 0;
        if (t ? (properties.useMobileLayout ? (C = math.fit(r, -.5, 0, 0, 1),
        R = math.fit(r, -.5, 0, 0, 1) * math.fit(r, .5, 1, 1, 0),
        T = l) : (C = math.fit(r, -.5, -.2, 0, 1),
        R = math.fit(r, -.4, -.1, 0, 1),
        T = math.fit(r, -.3, 0, 0, 1)),
        this.domTitle.style.opacity = C,
        this.domDesc.style.opacity = R,
        this.domLeft.style.opacity = T,
        this.domLeft.style.visibility = "visible",
        this.domTitle.style.visibility = "visible",
        this.domDesc.style.visibility = "visible",
        this.letterMesh.syncRect(this.letterRect.x + aboutWhoSection.subsectionContainerOffsetX + this.containerOffsetX, this.letterRect.y + aboutWhoSection.subsectionContainerOffsetY - scrollManager.scrollPixel, this.letterRect.width, this.letterRect.height),
        this.letterMesh.update(),
        this.letterMesh.visible = !0) : (this.domLeft.style.visibility = "hidden",
        this.domTitle.style.visibility = "hidden",
        this.domDesc.style.visibility = "hidden"),
        this.teamDataList.length)
            if (t) {
                this.wasActive || this.reset(),
                properties.useMobileLayout || (aboutHero.properties.cameraViewportOffsetX = (properties.viewportWidth / 2 - (properties.viewportWidth - this.domRightWidth) / 2) * math.fit(r, -aboutWhoSection.PAGE_DISTANCE, 0, 0, 1, ease.cubicInOut));
                let M = this.hasSwiped && c;
                (M || b && input.justClicked) && (audios.countPlay("click"),
                this.domCursorDirection == 1 ? this.next() : this.prev()),
                M && this.onSwipe();
                let P = this.faceIndexTimer;
                this.faceIndexTimer = Math.min(1, this.faceIndexTimer + e * this.timeBaseChangeSpeed * (this._isAnimating ? 0 : 1)),
                P < 1 && this.faceIndexTimer >= 1 && (this.isForward ? this.next() : this.prev());
                let I = Math.floor(math.mod(this.faceIndex, this.teamDataList.length))
                  , k = math.mod(I + 1, this.teamDataList.length)
                  , A = this.faceIndex - Math.floor(this.faceIndex);
                aboutHeroFaces.currId = this.teamDataList[I].id,
                aboutHeroFaces.nextId = this.teamDataList[k].id,
                aboutHeroFaces.transitionRatio = A;
                let O = this.domIndicatorInner;
                O.style.transform = "scaleX(" + this.faceIndexTimer + ")",
                this.domIndicator.style.transform = "scaleX(" + ease.expoInOut(this.itemActiveRatio) + ")";
                let W = this.itemActiveRatio > .95 ? 1 : (Math.cos(this.itemActiveRatio * 17.213) * .5 + .5) * Math.pow(this.itemActiveRatio, .25);
                this.domLeftNameIcon.style.opacity = W,
                this.domLeftNameText._direction = this.domLeftJobText._direction = this._isAnimating ? -1 : 1,
                this.domLeftNameText._letterPerSecond = this.domLeftJobText._letterPerSecond = this._isAnimating ? 60 : 30,
                textAnimationHelper.updateMatrixText(this.domLeftNameText),
                textAnimationHelper.updateMatrixText(this.domLeftJobText),
                this.letterMesh.material.uniforms.u_letterIdx.value = aboutHeroFaces.currId.substring(0, 1).toUpperCase().charCodeAt(0) - 65,
                this.letterMesh.material.uniforms.u_opacity.value = T * W
            } else
                this._clearTween();
        this.wasActive = t,
        this.hasSwiped = !1
    }
}
const whoSubsectionTeam = new WhoSubsectionTeam;
class AboutWhoSection {
    domContainer;
    activeFaceId = -1;
    scrollRatio = 0;
    subsectionContainerOffsetY = 0;
    subsectionContainerOffsetX = 0;
    RANGE_START_WAIT = 3.5;
    RANGE_PAGE_12 = 1.75;
    RANGE_PAGE_23 = 1.75;
    RANGE_PAGE_34 = 1.75;
    RANGE_END_WAIT = 2.5;
    PAGE_DISTANCE = 1.25;
    THRESHOLDS = [];
    MOBILE_THRESHOLDS = [];
    preInit(e) {
        this.domContainer = e.querySelector("#about-who"),
        this.domSubsectionContainer = e.querySelector("#about-who-subsection-container"),
        this.domCrosses = e.querySelector("#about-crosses ");
        let t = 0
          , r = 0;
        this.THRESHOLDS.push(t += this.RANGE_START_WAIT),
        this.THRESHOLDS.push(t += this.RANGE_PAGE_12),
        this.THRESHOLDS.push(t += this.RANGE_PAGE_23),
        r = t,
        this.MOBILE_THRESHOLDS.push.apply(this.MOBILE_THRESHOLDS, this.THRESHOLDS),
        this.THRESHOLDS.push(t += this.RANGE_END_WAIT),
        this.MOBILE_THRESHOLDS.push(r += this.RANGE_PAGE_34),
        this.MOBILE_THRESHOLDS.push(r += this.RANGE_END_WAIT),
        whoSubsectionWeAre.preInit(e),
        whoSubsectionDetails.preInit(e),
        whoSubsectionTeam.preInit(e),
        aboutHero.preInit(),
        visuals.stage3DList.push(aboutHero)
    }
    init() {
        whoSubsectionWeAre.init(),
        whoSubsectionDetails.init(),
        whoSubsectionTeam.init(),
        aboutHero.init()
    }
    resize(e, t) {
        this.syncSubsectionContainerTransform(),
        whoSubsectionWeAre.resize(e, t),
        whoSubsectionDetails.resize(e, t),
        whoSubsectionTeam.resize(e, t),
        aboutHero.resize(properties.width, properties.height)
    }
    show() {
        aboutWhoLogo.hideRatio = 0,
        whoSubsectionTeam.onPageShow()
    }
    getMoveRatio() {
        return -scrollManager.getDomRange(this.domContainer).screenY / (properties.useMobileLayout ? properties.viewportHeight : properties.viewportWidth)
    }
    getScrollRatio() {
        let e = properties.useMobileLayout ? this.MOBILE_THRESHOLDS : this.THRESHOLDS
          , t = this.getMoveRatio()
          , r = 0;
        return t < e[0] ? r = 0 : t < e[1] ? r = math.fit(t, e[0], e[1], 0, 1, ease.cubicInOut) : properties.useMobileLayout ? t < e[2] ? r = math.fit(t, e[1], e[2], 1, 2, ease.cubicInOut) : r = math.fit(t, e[2], e[3], 2, 3, ease.cubicInOut) : r = math.fit(t, e[1], e[2], 1, 2, ease.cubicInOut),
        this.scrollRatio = r
    }
    syncSubsectionContainerTransform() {
        let e = properties.useMobileLayout ? this.MOBILE_THRESHOLDS : this.THRESHOLDS
          , t = properties.useMobileLayout ? properties.viewportHeight : properties.viewportWidth;
        this.scrollableSize = e[e.length - 1] * t;
        let n = scrollManager.getDomRange(this.domContainer).isActive
          , o = scrollManager.getDomRange(this.domContainer)
          , l = this.getScrollRatio() * this.PAGE_DISTANCE;
        this.subsectionContainerOffsetY = math.fit(o.screenY, 0, -this.scrollableSize, 0, this.scrollableSize),
        properties.useMobileLayout ? this.subsectionContainerOffsetX = 0 : this.subsectionContainerOffsetX = l * -properties.viewportWidth,
        this.domSubsectionContainer.style.transform = "translate3d(" + this.subsectionContainerOffsetX + "px," + this.subsectionContainerOffsetY + "px, 0)",
        this.domCrosses.style.transform = "translate3d(" + -this.subsectionContainerOffsetX + "px,0, 0)",
        n || (aboutHero.isActive = !1)
    }
    update(e) {
        let t = properties.useMobileLayout ? this.MOBILE_THRESHOLDS : this.THRESHOLDS
          , r = properties.useMobileLayout ? properties.viewportHeight : properties.viewportWidth;
        this.scrollableSize = t[t.length - 1] * r;
        let o = scrollManager.getDomRange(this.domContainer).isActive
          , l = scrollManager.getDomRange(this.domContainer);
        if (this.syncSubsectionContainerTransform(),
        whoSubsectionTeam.preUpdate(),
        o) {
            let c = this.getScrollRatio() * this.PAGE_DISTANCE
              , u = -l.screenY / (properties.useMobileLayout ? properties.viewportHeight : properties.viewportWidth);
            aboutHero.initialSplineRatio = math.fit(u, 0, t[1], 0, 1),
            aboutHero.hudRatio = math.fit(u, t[1], t[1] + this.RANGE_PAGE_23 * .5, 0, 1),
            aboutHero.outSectionRatio = math.fit(u / t[3], .9, 1, 0, 1),
            aboutHero.properties.cameraViewportOffsetX = 0,
            aboutHero.properties.cameraViewportOffsetY = 0,
            aboutHero.scrollYRatio = 0,
            aboutHero.faceShowRatio = 0,
            c < this.PAGE_DISTANCE ? (aboutHero.introRatio = u / (this.RANGE_START_WAIT + this.RANGE_PAGE_12),
            whoSubsectionWeAre.update(e, !0, c, u, this.subsectionContainerOffsetY)) : (aboutHero.introRatio = 1,
            whoSubsectionWeAre.update(e, !1, c, u, this.subsectionContainerOffsetY)),
            c > 0 && c < this.PAGE_DISTANCE * 2 ? whoSubsectionDetails.update(e, !0, c - this.PAGE_DISTANCE, this.subsectionContainerOffsetY) : whoSubsectionDetails.update(e, !1, c - this.PAGE_DISTANCE, this.subsectionContainerOffsetY);
            let f = this.getMoveRatio();
            properties.useMobileLayout ? aboutHero.panningSplineRaito = math.fit(f, t[2], t[4], 0, 1) : aboutHero.panningSplineRaito = math.fit(f, t[1], t[3], 0, 1);
            let p = math.fit(c - this.PAGE_DISTANCE * 2 - (properties.useMobileLayout ? this.PAGE_DISTANCE : 0), -1, 0, 0, 1)
              , g = Math.max(0, scrollManager.scrollPixel - l.top - t[t.length - 1] * r);
            c >= this.PAGE_DISTANCE ? (aboutHero.properties.cameraViewportOffsetY = g,
            aboutHero.scrollYRatio = g / r,
            whoSubsectionTeam.update(e, !0, c - this.PAGE_DISTANCE * 2, g, this.subsectionContainerOffsetY, p)) : whoSubsectionTeam.update(e, !1, c - this.PAGE_DISTANCE * 2, g, this.subsectionContainerOffsetY, p),
            aboutHero.isActive = !0
        } else
            aboutHero.isActive = !1,
            whoSubsectionTeam.wasActive = !1
    }
}
const aboutWhoSection = new AboutWhoSection
  , TITLE_STAGGER = 20
  , DESCRIPTION_STAGGER = 50;
class AboutClientSection {
    _needsReset = !0;
    isSectionWasActive = !1;
    preInit(e) {
        this.domContainer = e.querySelector("#about-clients"),
        this.domTitle = e.querySelector("#about-clients-title"),
        this.domTitle._time = 0,
        this.domTitle._animating = !1,
        this.domTitle._words = [],
        this.domDesc = e.querySelector("#about-clients-desc"),
        this.domDesc._time = 0,
        this.domDesc._animating = !1,
        this.domCarousel = e.querySelector("#about-clients-carousel"),
        this.domCarouselLines = Array.from(this.domCarousel.querySelectorAll(".about-clients-carousel-line")),
        this.domCarouselLinesWrapper = []
    }
    init() {
        this._createCarousel()
    }
    resize(e, t) {
        this._splitText();
        for (let r = 0; r < this.domCarouselLines.length; r++) {
            let n = this.domCarouselLines[r]
              , o = this.domCarouselLinesWrapper[r];
            o._width = n.getBoundingClientRect().width
        }
    }
    update(e) {
        let r = scrollManager.getDomRange(this.domContainer).isActive
          , n = scrollManager.scrollViewDelta
          , o = scrollManager.getDomRange(this.domTitle)
          , l = scrollManager.getDomRange(this.domDesc);
        if (r) {
            this._needsReset && this._reset(),
            this.domTitle._time = math.clamp(this.domTitle._time + (this.domTitle._animating ? e : -e), 0, 1 + this.domTitle._words.length / TITLE_STAGGER),
            this.domDesc._time = math.clamp(this.domDesc._time + (this.domDesc._animating ? e : -e), 0, 1 + this.domDesc._splitted.words.length / DESCRIPTION_STAGGER),
            o.screenRatio > -1 && (this.domTitle._animating = !0,
            properties.useMobileLayout ? this.domTitle._words.forEach(c => {
                c.forEach(u => {
                    u.style.transform = "translate3d(0, 0, 0)"
                }
                )
            }
            ) : this.domTitle._words.forEach( (c, u) => {
                c.forEach( (f, p) => {
                    let g = math.saturate(this.domTitle._time - u / 20)
                      , v = ease.expoOut(g);
                    f.style.transform = `translate3d(0, ${100 * (1 - v) - (4 - p) * 100 * v}%, 0)`
                }
                )
            }
            )),
            l.screenRatio > -1 && (this.domDesc._animating = !0,
            this.domDesc._splitted.words.forEach( (c, u) => {
                let f = properties.viewportWidth >= settings.MOBILE_WIDTH ? ease.lusion(this.domDesc._time - u / DESCRIPTION_STAGGER) : 1
                  , p = properties.viewportWidth >= settings.MOBILE_WIDTH ? math.fit(this.domDesc._time - u / DESCRIPTION_STAGGER, 0, 1, 100, 0, ease.lusion) : 0;
                c.style.transform = `translate3d(0, ${p}%, 0)`,
                c.style.opacity = f
            }
            ));
            for (let c = 0; c < this.domCarouselLinesWrapper.length; c++) {
                let u = this.domCarouselLinesWrapper[c]
                  , f = c % 2;
                u._time += e * input.lastScrollYDirection * (100 + f * 35) + n * (100 + f * 35);
                let p = -math.loop(u._time, 0, u._width);
                u.style.transform = `translateX(${p}px)`
            }
        } else
            this._needsReset = !0;
        this.isSectionWasActive = r
    }
    _createCarousel() {
        this.domCarouselLines.forEach(e => {
            const t = document.createElement("div");
            t.classList.add("about-clients-carousel-line-wrapper");
            const r = e.cloneNode(!0)
              , n = e.cloneNode(!0);
            t.append(r, n, e),
            this.domCarousel.append(t),
            t._time = 0,
            this.domCarouselLinesWrapper.push(t)
        }
        )
    }
    _splitText() {
        this.domTitleWordList = [],
        this.domTitle._splitted = new SplitType(this.domTitle,{
            types: "words",
            wordClass: "about-clients-title-word"
        }),
        this.domTitle._splitted.words.forEach( (e, t) => {
            const r = []
              , n = e.parentNode
              , o = document.createElement("div");
            o.style.position = "relative",
            o.style.overflow = "hidden",
            o.classList.add("about-clients-title-word-wrapper"),
            o.style.display = "flex",
            o.style.flexDirection = "column",
            e.remove(),
            this.domTitleWordList.push(o);
            for (let l = 0; l < 3; l++) {
                const c = e.cloneNode(!0);
                c.style.transform = "translate3d(0, 100%, 0)",
                o.append(c),
                r.push(c),
                this.domTitle._words[t] = r
            }
            n.append(o),
            e.remove()
        }
        ),
        this.domDesc._splitted = new SplitType(this.domDesc,{
            types: "words",
            wordClass: "about-clients-desc-text-word"
        })
    }
    _reset() {
        this.domTitle._splitted && (this._needsReset = !1,
        this.domTitle._time = 0,
        this.domTitle._animating = !1,
        this.domTitle._splitted.words.forEach(e => {
            e.style.transform = "translate3d(0, 100%, 0)"
        }
        ),
        this.domDesc._time = 0,
        this.domDesc._animating = !1,
        this.domDesc._splitted.words.forEach(e => {
            e.style.transform = "translate3d(0, 100%, 0)",
            e.style.opacity = 0
        }
        ))
    }
}
const aboutClientSection = new AboutClientSection;
class SVGParser {
    parse(e) {
        const t = this;
        function r(Y, $) {
            if (Y.nodeType !== 1)
                return;
            const L = M(Y);
            let N = !1
              , oe = null;
            switch (Y.nodeName) {
            case "svg":
                $ = w(Y, $);
                break;
            case "style":
                o(Y);
                break;
            case "g":
                $ = w(Y, $);
                break;
            case "path":
                $ = w(Y, $),
                Y.hasAttribute("d") && (oe = n(Y));
                break;
            case "rect":
                $ = w(Y, $),
                oe = u(Y);
                break;
            case "polygon":
                $ = w(Y, $),
                oe = f(Y);
                break;
            case "polyline":
                $ = w(Y, $),
                oe = p(Y);
                break;
            case "circle":
                $ = w(Y, $),
                oe = g(Y);
                break;
            case "ellipse":
                $ = w(Y, $),
                oe = v(Y);
                break;
            case "line":
                $ = w(Y, $),
                oe = _(Y);
                break;
            case "defs":
                N = !0;
                break;
            case "use":
                $ = w(Y, $);
                const Se = (Y.getAttributeNS("http://www.w3.org/1999/xlink", "href") || "").substring(1)
                  , Ce = Y.viewportElement.getElementById(Se);
                Ce ? r(Ce, $) : console.warn("SVGLoader: 'use node' references non-existent node id: " + Se);
                break
            }
            oe && ($.fill !== void 0 && $.fill !== "none" && oe.color.setStyle($.fill),
            I(oe, ne),
            H.push(oe),
            oe.userData = {
                node: Y,
                style: $
            });
            const pe = Y.childNodes;
            for (let K = 0; K < pe.length; K++) {
                const Se = pe[K];
                N && Se.nodeName !== "style" && Se.nodeName !== "defs" || r(Se, $)
            }
            L && (D.pop(),
            D.length > 0 ? ne.copy(D[D.length - 1]) : ne.identity())
        }
        function n(Y) {
            const $ = new ShapePath
              , L = new Vector2
              , N = new Vector2
              , oe = new Vector2;
            let pe = !0
              , K = !1;
            const Se = Y.getAttribute("d");
            if (Se === "" || Se === "none")
                return null;
            const Ce = Se.match(/[a-df-z][^a-df-z]*/gi);
            for (let Te = 0, we = Ce.length; Te < we; Te++) {
                const Ae = Ce[Te]
                  , Ne = Ae.charAt(0)
                  , Ue = Ae.slice(1).trim();
                pe === !0 && (K = !0,
                pe = !1);
                let le;
                switch (Ne) {
                case "M":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z += 2)
                        L.x = le[Z + 0],
                        L.y = le[Z + 1],
                        N.x = L.x,
                        N.y = L.y,
                        Z === 0 ? $.moveTo(L.x, L.y) : $.lineTo(L.x, L.y),
                        Z === 0 && oe.copy(L);
                    break;
                case "H":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z++)
                        L.x = le[Z],
                        N.x = L.x,
                        N.y = L.y,
                        $.lineTo(L.x, L.y),
                        Z === 0 && K === !0 && oe.copy(L);
                    break;
                case "V":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z++)
                        L.y = le[Z],
                        N.x = L.x,
                        N.y = L.y,
                        $.lineTo(L.x, L.y),
                        Z === 0 && K === !0 && oe.copy(L);
                    break;
                case "L":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z += 2)
                        L.x = le[Z + 0],
                        L.y = le[Z + 1],
                        N.x = L.x,
                        N.y = L.y,
                        $.lineTo(L.x, L.y),
                        Z === 0 && K === !0 && oe.copy(L);
                    break;
                case "C":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z += 6)
                        $.bezierCurveTo(le[Z + 0], le[Z + 1], le[Z + 2], le[Z + 3], le[Z + 4], le[Z + 5]),
                        N.x = le[Z + 2],
                        N.y = le[Z + 3],
                        L.x = le[Z + 4],
                        L.y = le[Z + 5],
                        Z === 0 && K === !0 && oe.copy(L);
                    break;
                case "S":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z += 4)
                        $.bezierCurveTo(S(L.x, N.x), S(L.y, N.y), le[Z + 0], le[Z + 1], le[Z + 2], le[Z + 3]),
                        N.x = le[Z + 0],
                        N.y = le[Z + 1],
                        L.x = le[Z + 2],
                        L.y = le[Z + 3],
                        Z === 0 && K === !0 && oe.copy(L);
                    break;
                case "Q":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z += 4)
                        $.quadraticCurveTo(le[Z + 0], le[Z + 1], le[Z + 2], le[Z + 3]),
                        N.x = le[Z + 0],
                        N.y = le[Z + 1],
                        L.x = le[Z + 2],
                        L.y = le[Z + 3],
                        Z === 0 && K === !0 && oe.copy(L);
                    break;
                case "T":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z += 2) {
                        const Ke = S(L.x, N.x)
                          , j = S(L.y, N.y);
                        $.quadraticCurveTo(Ke, j, le[Z + 0], le[Z + 1]),
                        N.x = Ke,
                        N.y = j,
                        L.x = le[Z + 0],
                        L.y = le[Z + 1],
                        Z === 0 && K === !0 && oe.copy(L)
                    }
                    break;
                case "A":
                    le = b(Ue, [3, 4], 7);
                    for (let Z = 0, He = le.length; Z < He; Z += 7) {
                        if (le[Z + 5] == L.x && le[Z + 6] == L.y)
                            continue;
                        const Ke = L.clone();
                        L.x = le[Z + 5],
                        L.y = le[Z + 6],
                        N.x = L.x,
                        N.y = L.y,
                        l($, le[Z], le[Z + 1], le[Z + 2], le[Z + 3], le[Z + 4], Ke, L),
                        Z === 0 && K === !0 && oe.copy(L)
                    }
                    break;
                case "m":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z += 2)
                        L.x += le[Z + 0],
                        L.y += le[Z + 1],
                        N.x = L.x,
                        N.y = L.y,
                        Z === 0 ? $.moveTo(L.x, L.y) : $.lineTo(L.x, L.y),
                        Z === 0 && oe.copy(L);
                    break;
                case "h":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z++)
                        L.x += le[Z],
                        N.x = L.x,
                        N.y = L.y,
                        $.lineTo(L.x, L.y),
                        Z === 0 && K === !0 && oe.copy(L);
                    break;
                case "v":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z++)
                        L.y += le[Z],
                        N.x = L.x,
                        N.y = L.y,
                        $.lineTo(L.x, L.y),
                        Z === 0 && K === !0 && oe.copy(L);
                    break;
                case "l":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z += 2)
                        L.x += le[Z + 0],
                        L.y += le[Z + 1],
                        N.x = L.x,
                        N.y = L.y,
                        $.lineTo(L.x, L.y),
                        Z === 0 && K === !0 && oe.copy(L);
                    break;
                case "c":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z += 6)
                        $.bezierCurveTo(L.x + le[Z + 0], L.y + le[Z + 1], L.x + le[Z + 2], L.y + le[Z + 3], L.x + le[Z + 4], L.y + le[Z + 5]),
                        N.x = L.x + le[Z + 2],
                        N.y = L.y + le[Z + 3],
                        L.x += le[Z + 4],
                        L.y += le[Z + 5],
                        Z === 0 && K === !0 && oe.copy(L);
                    break;
                case "s":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z += 4)
                        $.bezierCurveTo(S(L.x, N.x), S(L.y, N.y), L.x + le[Z + 0], L.y + le[Z + 1], L.x + le[Z + 2], L.y + le[Z + 3]),
                        N.x = L.x + le[Z + 0],
                        N.y = L.y + le[Z + 1],
                        L.x += le[Z + 2],
                        L.y += le[Z + 3],
                        Z === 0 && K === !0 && oe.copy(L);
                    break;
                case "q":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z += 4)
                        $.quadraticCurveTo(L.x + le[Z + 0], L.y + le[Z + 1], L.x + le[Z + 2], L.y + le[Z + 3]),
                        N.x = L.x + le[Z + 0],
                        N.y = L.y + le[Z + 1],
                        L.x += le[Z + 2],
                        L.y += le[Z + 3],
                        Z === 0 && K === !0 && oe.copy(L);
                    break;
                case "t":
                    le = b(Ue);
                    for (let Z = 0, He = le.length; Z < He; Z += 2) {
                        const Ke = S(L.x, N.x)
                          , j = S(L.y, N.y);
                        $.quadraticCurveTo(Ke, j, L.x + le[Z + 0], L.y + le[Z + 1]),
                        N.x = Ke,
                        N.y = j,
                        L.x = L.x + le[Z + 0],
                        L.y = L.y + le[Z + 1],
                        Z === 0 && K === !0 && oe.copy(L)
                    }
                    break;
                case "a":
                    le = b(Ue, [3, 4], 7);
                    for (let Z = 0, He = le.length; Z < He; Z += 7) {
                        if (le[Z + 5] == 0 && le[Z + 6] == 0)
                            continue;
                        const Ke = L.clone();
                        L.x += le[Z + 5],
                        L.y += le[Z + 6],
                        N.x = L.x,
                        N.y = L.y,
                        l($, le[Z], le[Z + 1], le[Z + 2], le[Z + 3], le[Z + 4], Ke, L),
                        Z === 0 && K === !0 && oe.copy(L)
                    }
                    break;
                case "Z":
                case "z":
                    $.currentPath.autoClose = !0,
                    $.currentPath.curves.length > 0 && (L.copy(oe),
                    $.currentPath.currentPoint.copy(L),
                    pe = !0);
                    break;
                default:
                    console.warn(Ae)
                }
                K = !1
            }
            return $
        }
        function o(Y) {
            if (!(!Y.sheet || !Y.sheet.cssRules || !Y.sheet.cssRules.length))
                for (let $ = 0; $ < Y.sheet.cssRules.length; $++) {
                    const L = Y.sheet.cssRules[$];
                    if (L.type !== 1)
                        continue;
                    const N = L.selectorText.split(/,/gm).filter(Boolean).map(oe => oe.trim());
                    for (let oe = 0; oe < N.length; oe++) {
                        const pe = Object.fromEntries(Object.entries(L.style).filter( ([,K]) => K !== ""));
                        B[N[oe]] = Object.assign(B[N[oe]] || {}, pe)
                    }
                }
        }
        function l(Y, $, L, N, oe, pe, K, Se) {
            if ($ == 0 || L == 0) {
                Y.lineTo(Se.x, Se.y);
                return
            }
            N = N * Math.PI / 180,
            $ = Math.abs($),
            L = Math.abs(L);
            const Ce = (K.x - Se.x) / 2
              , Te = (K.y - Se.y) / 2
              , we = Math.cos(N) * Ce + Math.sin(N) * Te
              , Ae = -Math.sin(N) * Ce + Math.cos(N) * Te;
            let Ne = $ * $
              , Ue = L * L;
            const le = we * we
              , Z = Ae * Ae
              , He = le / Ne + Z / Ue;
            if (He > 1) {
                const xe = Math.sqrt(He);
                $ = xe * $,
                L = xe * L,
                Ne = $ * $,
                Ue = L * L
            }
            const Ke = Ne * Z + Ue * le
              , j = (Ne * Ue - Ke) / Ke;
            let z = Math.sqrt(Math.max(0, j));
            oe === pe && (z = -z);
            const ge = z * $ * Ae / L
              , Ee = -z * L * we / $
              , Oe = Math.cos(N) * ge - Math.sin(N) * Ee + (K.x + Se.x) / 2
              , ze = Math.sin(N) * ge + Math.cos(N) * Ee + (K.y + Se.y) / 2
              , te = c(1, 0, (we - ge) / $, (Ae - Ee) / L)
              , be = c((we - ge) / $, (Ae - Ee) / L, (-we - ge) / $, (-Ae - Ee) / L) % (Math.PI * 2);
            Y.currentPath.absellipse(Oe, ze, $, L, te, te + be, pe === 0, N)
        }
        function c(Y, $, L, N) {
            const oe = Y * L + $ * N
              , pe = Math.sqrt(Y * Y + $ * $) * Math.sqrt(L * L + N * N);
            let K = Math.acos(Math.max(-1, Math.min(1, oe / pe)));
            return Y * N - $ * L < 0 && (K = -K),
            K
        }
        function u(Y) {
            const $ = T(Y.getAttribute("x") || 0)
              , L = T(Y.getAttribute("y") || 0)
              , N = T(Y.getAttribute("rx") || Y.getAttribute("ry") || 0)
              , oe = T(Y.getAttribute("ry") || Y.getAttribute("rx") || 0)
              , pe = T(Y.getAttribute("width"))
              , K = T(Y.getAttribute("height"))
              , Se = 1 - .551915024494
              , Ce = new ShapePath;
            return Ce.moveTo($ + N, L),
            Ce.lineTo($ + pe - N, L),
            (N !== 0 || oe !== 0) && Ce.bezierCurveTo($ + pe - N * Se, L, $ + pe, L + oe * Se, $ + pe, L + oe),
            Ce.lineTo($ + pe, L + K - oe),
            (N !== 0 || oe !== 0) && Ce.bezierCurveTo($ + pe, L + K - oe * Se, $ + pe - N * Se, L + K, $ + pe - N, L + K),
            Ce.lineTo($ + N, L + K),
            (N !== 0 || oe !== 0) && Ce.bezierCurveTo($ + N * Se, L + K, $, L + K - oe * Se, $, L + K - oe),
            Ce.lineTo($, L + oe),
            (N !== 0 || oe !== 0) && Ce.bezierCurveTo($, L + oe * Se, $ + N * Se, L, $ + N, L),
            Ce
        }
        function f(Y) {
            function $(pe, K, Se) {
                const Ce = T(K)
                  , Te = T(Se);
                oe === 0 ? N.moveTo(Ce, Te) : N.lineTo(Ce, Te),
                oe++
            }
            const L = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g
              , N = new ShapePath;
            let oe = 0;
            return Y.getAttribute("points").replace(L, $),
            N.currentPath.autoClose = !0,
            N
        }
        function p(Y) {
            function $(pe, K, Se) {
                const Ce = T(K)
                  , Te = T(Se);
                oe === 0 ? N.moveTo(Ce, Te) : N.lineTo(Ce, Te),
                oe++
            }
            const L = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g
              , N = new ShapePath;
            let oe = 0;
            return Y.getAttribute("points").replace(L, $),
            N.currentPath.autoClose = !1,
            N
        }
        function g(Y) {
            const $ = T(Y.getAttribute("cx") || 0)
              , L = T(Y.getAttribute("cy") || 0)
              , N = T(Y.getAttribute("r") || 0)
              , oe = new Path;
            oe.absarc($, L, N, 0, Math.PI * 2);
            const pe = new ShapePath;
            return pe.subPaths.push(oe),
            pe
        }
        function v(Y) {
            const $ = T(Y.getAttribute("cx") || 0)
              , L = T(Y.getAttribute("cy") || 0)
              , N = T(Y.getAttribute("rx") || 0)
              , oe = T(Y.getAttribute("ry") || 0)
              , pe = new Path;
            pe.absellipse($, L, N, oe, 0, Math.PI * 2);
            const K = new ShapePath;
            return K.subPaths.push(pe),
            K
        }
        function _(Y) {
            const $ = T(Y.getAttribute("x1") || 0)
              , L = T(Y.getAttribute("y1") || 0)
              , N = T(Y.getAttribute("x2") || 0)
              , oe = T(Y.getAttribute("y2") || 0)
              , pe = new ShapePath;
            return pe.moveTo($, L),
            pe.lineTo(N, oe),
            pe.currentPath.autoClose = !1,
            pe
        }
        function w(Y, $) {
            $ = Object.assign({}, $);
            let L = {};
            if (Y.hasAttribute("class")) {
                const K = Y.getAttribute("class").split(/\s/).filter(Boolean).map(Se => Se.trim());
                for (let Se = 0; Se < K.length; Se++)
                    L = Object.assign(L, B["." + K[Se]])
            }
            Y.hasAttribute("id") && (L = Object.assign(L, B["#" + Y.getAttribute("id")]));
            function N(K, Se, Ce) {
                Ce === void 0 && (Ce = function(we) {
                    return we.startsWith("url") && console.warn("SVGLoader: url access in attributes is not implemented."),
                    we
                }
                ),
                Y.hasAttribute(K) && ($[Se] = Ce(Y.getAttribute(K))),
                L[K] && ($[Se] = Ce(L[K])),
                Y.style && Y.style[K] !== "" && ($[Se] = Ce(Y.style[K]))
            }
            function oe(K) {
                return Math.max(0, Math.min(1, T(K)))
            }
            function pe(K) {
                return Math.max(0, T(K))
            }
            return N("fill", "fill"),
            N("fill-opacity", "fillOpacity", oe),
            N("fill-rule", "fillRule"),
            N("opacity", "opacity", oe),
            N("stroke", "stroke"),
            N("stroke-opacity", "strokeOpacity", oe),
            N("stroke-width", "strokeWidth", pe),
            N("stroke-linejoin", "strokeLineJoin"),
            N("stroke-linecap", "strokeLineCap"),
            N("stroke-miterlimit", "strokeMiterLimit", pe),
            N("visibility", "visibility"),
            $
        }
        function S(Y, $) {
            return Y - ($ - Y)
        }
        function b(Y, $, L) {
            if (typeof Y != "string")
                throw new TypeError("Invalid input: " + typeof Y);
            const N = {
                SEPARATOR: /[ \t\r\n\,.\-+]/,
                WHITESPACE: /[ \t\r\n]/,
                DIGIT: /[\d]/,
                SIGN: /[-+]/,
                POINT: /\./,
                COMMA: /,/,
                EXP: /e/i,
                FLAGS: /[01]/
            }
              , oe = 0
              , pe = 1
              , K = 2
              , Se = 3;
            let Ce = oe
              , Te = !0
              , we = ""
              , Ae = "";
            const Ne = [];
            function Ue(Ke, j, z) {
                const ge = new SyntaxError('Unexpected character "' + Ke + '" at index ' + j + ".");
                throw ge.partial = z,
                ge
            }
            function le() {
                we !== "" && (Ae === "" ? Ne.push(Number(we)) : Ne.push(Number(we) * Math.pow(10, Number(Ae)))),
                we = "",
                Ae = ""
            }
            let Z;
            const He = Y.length;
            for (let Ke = 0; Ke < He; Ke++) {
                if (Z = Y[Ke],
                Array.isArray($) && $.includes(Ne.length % L) && N.FLAGS.test(Z)) {
                    Ce = pe,
                    we = Z,
                    le();
                    continue
                }
                if (Ce === oe) {
                    if (N.WHITESPACE.test(Z))
                        continue;
                    if (N.DIGIT.test(Z) || N.SIGN.test(Z)) {
                        Ce = pe,
                        we = Z;
                        continue
                    }
                    if (N.POINT.test(Z)) {
                        Ce = K,
                        we = Z;
                        continue
                    }
                    N.COMMA.test(Z) && (Te && Ue(Z, Ke, Ne),
                    Te = !0)
                }
                if (Ce === pe) {
                    if (N.DIGIT.test(Z)) {
                        we += Z;
                        continue
                    }
                    if (N.POINT.test(Z)) {
                        we += Z,
                        Ce = K;
                        continue
                    }
                    if (N.EXP.test(Z)) {
                        Ce = Se;
                        continue
                    }
                    N.SIGN.test(Z) && we.length === 1 && N.SIGN.test(we[0]) && Ue(Z, Ke, Ne)
                }
                if (Ce === K) {
                    if (N.DIGIT.test(Z)) {
                        we += Z;
                        continue
                    }
                    if (N.EXP.test(Z)) {
                        Ce = Se;
                        continue
                    }
                    N.POINT.test(Z) && we[we.length - 1] === "." && Ue(Z, Ke, Ne)
                }
                if (Ce === Se) {
                    if (N.DIGIT.test(Z)) {
                        Ae += Z;
                        continue
                    }
                    if (N.SIGN.test(Z)) {
                        if (Ae === "") {
                            Ae += Z;
                            continue
                        }
                        Ae.length === 1 && N.SIGN.test(Ae) && Ue(Z, Ke, Ne)
                    }
                }
                N.WHITESPACE.test(Z) ? (le(),
                Ce = oe,
                Te = !1) : N.COMMA.test(Z) ? (le(),
                Ce = oe,
                Te = !0) : N.SIGN.test(Z) ? (le(),
                Ce = pe,
                we = Z) : N.POINT.test(Z) ? (le(),
                Ce = K,
                we = Z) : Ue(Z, Ke, Ne)
            }
            return le(),
            Ne
        }
        const C = ["mm", "cm", "in", "pt", "pc", "px"]
          , R = {
            mm: {
                mm: 1,
                cm: .1,
                in: 1 / 25.4,
                pt: 72 / 25.4,
                pc: 6 / 25.4,
                px: -1
            },
            cm: {
                mm: 10,
                cm: 1,
                in: 1 / 2.54,
                pt: 72 / 2.54,
                pc: 6 / 2.54,
                px: -1
            },
            in: {
                mm: 25.4,
                cm: 2.54,
                in: 1,
                pt: 72,
                pc: 6,
                px: -1
            },
            pt: {
                mm: 25.4 / 72,
                cm: 2.54 / 72,
                in: 1 / 72,
                pt: 1,
                pc: 6 / 72,
                px: -1
            },
            pc: {
                mm: 25.4 / 6,
                cm: 2.54 / 6,
                in: 1 / 6,
                pt: 72 / 6,
                pc: 1,
                px: -1
            },
            px: {
                px: 1
            }
        };
        function T(Y) {
            let $ = "px";
            if (typeof Y == "string" || Y instanceof String)
                for (let N = 0, oe = C.length; N < oe; N++) {
                    const pe = C[N];
                    if (Y.endsWith(pe)) {
                        $ = pe,
                        Y = Y.substring(0, Y.length - pe.length);
                        break
                    }
                }
            let L;
            return $ === "px" && t.defaultUnit !== "px" ? L = R.in[t.defaultUnit] / t.defaultDPI : (L = R[$][t.defaultUnit],
            L < 0 && (L = R[$].in * t.defaultDPI)),
            L * parseFloat(Y)
        }
        function M(Y) {
            if (!(Y.hasAttribute("transform") || Y.nodeName === "use" && (Y.hasAttribute("x") || Y.hasAttribute("y"))))
                return null;
            const $ = P(Y);
            return D.length > 0 && $.premultiply(D[D.length - 1]),
            ne.copy($),
            D.push($),
            $
        }
        function P(Y) {
            const $ = new Matrix3
              , L = q;
            if (Y.nodeName === "use" && (Y.hasAttribute("x") || Y.hasAttribute("y"))) {
                const N = T(Y.getAttribute("x"))
                  , oe = T(Y.getAttribute("y"));
                $.translate(N, oe)
            }
            if (Y.hasAttribute("transform")) {
                const N = Y.getAttribute("transform").split(")");
                for (let oe = N.length - 1; oe >= 0; oe--) {
                    const pe = N[oe].trim();
                    if (pe === "")
                        continue;
                    const K = pe.indexOf("(")
                      , Se = pe.length;
                    if (K > 0 && K < Se) {
                        const Ce = pe.slice(0, K)
                          , Te = b(pe.slice(K + 1));
                        switch (L.identity(),
                        Ce) {
                        case "translate":
                            if (Te.length >= 1) {
                                const we = Te[0];
                                let Ae = 0;
                                Te.length >= 2 && (Ae = Te[1]),
                                L.translate(we, Ae)
                            }
                            break;
                        case "rotate":
                            if (Te.length >= 1) {
                                let we = 0
                                  , Ae = 0
                                  , Ne = 0;
                                we = Te[0] * Math.PI / 180,
                                Te.length >= 3 && (Ae = Te[1],
                                Ne = Te[2]),
                                V.makeTranslation(-Ae, -Ne),
                                J.makeRotation(we),
                                U.multiplyMatrices(J, V),
                                V.makeTranslation(Ae, Ne),
                                L.multiplyMatrices(V, U)
                            }
                            break;
                        case "scale":
                            if (Te.length >= 1) {
                                const we = Te[0];
                                let Ae = we;
                                Te.length >= 2 && (Ae = Te[1]),
                                L.scale(we, Ae)
                            }
                            break;
                        case "skewX":
                            Te.length === 1 && L.set(1, Math.tan(Te[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
                            break;
                        case "skewY":
                            Te.length === 1 && L.set(1, 0, 0, Math.tan(Te[0] * Math.PI / 180), 1, 0, 0, 0, 1);
                            break;
                        case "matrix":
                            Te.length === 6 && L.set(Te[0], Te[2], Te[4], Te[1], Te[3], Te[5], 0, 0, 1);
                            break
                        }
                    }
                    $.premultiply(L)
                }
            }
            return $
        }
        function I(Y, $) {
            function L(K) {
                ee.set(K.x, K.y, 1).applyMatrix3($),
                K.set(ee.x, ee.y)
            }
            function N(K) {
                const Se = K.xRadius
                  , Ce = K.yRadius
                  , Te = Math.cos(K.aRotation)
                  , we = Math.sin(K.aRotation)
                  , Ae = new Vector3(Se * Te,Se * we,0)
                  , Ne = new Vector3(-Ce * we,Ce * Te,0)
                  , Ue = Ae.applyMatrix3($)
                  , le = Ne.applyMatrix3($)
                  , Z = q.set(Ue.x, le.x, 0, Ue.y, le.y, 0, 0, 0, 1)
                  , He = V.copy(Z).invert()
                  , z = J.copy(He).transpose().multiply(He).elements
                  , ge = Q(z[0], z[1], z[4])
                  , Ee = Math.sqrt(ge.rt1)
                  , Oe = Math.sqrt(ge.rt2);
                if (K.xRadius = 1 / Ee,
                K.yRadius = 1 / Oe,
                K.aRotation = Math.atan2(ge.sn, ge.cs),
                !((K.aEndAngle - K.aStartAngle) % (2 * Math.PI) < Number.EPSILON)) {
                    const te = V.set(Ee, 0, 0, 0, Oe, 0, 0, 0, 1)
                      , be = J.set(ge.cs, ge.sn, 0, -ge.sn, ge.cs, 0, 0, 0, 1)
                      , xe = te.multiply(be).multiply(Z)
                      , ke = qe => {
                        const {x: Ve, y: Ge} = new Vector3(Math.cos(qe),Math.sin(qe),0).applyMatrix3(xe);
                        return Math.atan2(Ge, Ve)
                    }
                    ;
                    K.aStartAngle = ke(K.aStartAngle),
                    K.aEndAngle = ke(K.aEndAngle),
                    k($) && (K.aClockwise = !K.aClockwise)
                }
            }
            function oe(K) {
                const Se = O($)
                  , Ce = W($);
                K.xRadius *= Se,
                K.yRadius *= Ce;
                const Te = Se > Number.EPSILON ? Math.atan2($.elements[1], $.elements[0]) : Math.atan2(-$.elements[3], $.elements[4]);
                K.aRotation += Te,
                k($) && (K.aStartAngle *= -1,
                K.aEndAngle *= -1,
                K.aClockwise = !K.aClockwise)
            }
            const pe = Y.subPaths;
            for (let K = 0, Se = pe.length; K < Se; K++) {
                const Te = pe[K].curves;
                for (let we = 0; we < Te.length; we++) {
                    const Ae = Te[we];
                    Ae.isLineCurve ? (L(Ae.v1),
                    L(Ae.v2)) : Ae.isCubicBezierCurve ? (L(Ae.v0),
                    L(Ae.v1),
                    L(Ae.v2),
                    L(Ae.v3)) : Ae.isQuadraticBezierCurve ? (L(Ae.v0),
                    L(Ae.v1),
                    L(Ae.v2)) : Ae.isEllipseCurve && (ce.set(Ae.aX, Ae.aY),
                    L(ce),
                    Ae.aX = ce.x,
                    Ae.aY = ce.y,
                    A($) ? N(Ae) : oe(Ae))
                }
            }
        }
        function k(Y) {
            const $ = Y.elements;
            return $[0] * $[4] - $[1] * $[3] < 0
        }
        function A(Y) {
            const $ = Y.elements
              , L = $[0] * $[3] + $[1] * $[4];
            if (L === 0)
                return !1;
            const N = O(Y)
              , oe = W(Y);
            return Math.abs(L / (N * oe)) > Number.EPSILON
        }
        function O(Y) {
            const $ = Y.elements;
            return Math.sqrt($[0] * $[0] + $[1] * $[1])
        }
        function W(Y) {
            const $ = Y.elements;
            return Math.sqrt($[3] * $[3] + $[4] * $[4])
        }
        function Q(Y, $, L) {
            let N, oe, pe, K, Se;
            const Ce = Y + L
              , Te = Y - L
              , we = Math.sqrt(Te * Te + 4 * $ * $);
            return Ce > 0 ? (N = .5 * (Ce + we),
            Se = 1 / N,
            oe = Y * Se * L - $ * Se * $) : Ce < 0 ? oe = .5 * (Ce - we) : (N = .5 * we,
            oe = -.5 * we),
            Te > 0 ? pe = Te + we : pe = Te - we,
            Math.abs(pe) > 2 * Math.abs($) ? (Se = -2 * $ / pe,
            K = 1 / Math.sqrt(1 + Se * Se),
            pe = Se * K) : Math.abs($) === 0 ? (pe = 1,
            K = 0) : (Se = -.5 * pe / $,
            pe = 1 / Math.sqrt(1 + Se * Se),
            K = Se * pe),
            Te > 0 && (Se = pe,
            pe = -K,
            K = Se),
            {
                rt1: N,
                rt2: oe,
                cs: pe,
                sn: K
            }
        }
        const H = []
          , B = {}
          , D = []
          , q = new Matrix3
          , V = new Matrix3
          , J = new Matrix3
          , U = new Matrix3
          , ce = new Vector2
          , ee = new Vector3
          , ne = new Matrix3
          , ae = new DOMParser().parseFromString(e, "image/svg+xml");
        return r(ae.documentElement, {
            fill: "#000",
            fillOpacity: 1,
            strokeOpacity: 1,
            strokeWidth: 1,
            strokeLineJoin: "miter",
            strokeLineCap: "butt",
            strokeMiterLimit: 4
        }),
        {
            paths: H,
            xml: ae.documentElement
        }
    }
    createShapes(e) {
        const r = {
            ORIGIN: 0,
            DESTINATION: 1,
            BETWEEN: 2,
            LEFT: 3,
            RIGHT: 4,
            BEHIND: 5,
            BEYOND: 6
        }
          , n = {
            loc: r.ORIGIN,
            t: 0
        };
        function o(S, b, C, R) {
            const T = S.x
              , M = b.x
              , P = C.x
              , I = R.x
              , k = S.y
              , A = b.y
              , O = C.y
              , W = R.y
              , Q = (I - P) * (k - O) - (W - O) * (T - P)
              , H = (M - T) * (k - O) - (A - k) * (T - P)
              , B = (W - O) * (M - T) - (I - P) * (A - k)
              , D = Q / B
              , q = H / B;
            if (B === 0 && Q !== 0 || D <= 0 || D >= 1 || q < 0 || q > 1)
                return null;
            if (Q === 0 && B === 0) {
                for (let V = 0; V < 2; V++)
                    if (l(V === 0 ? C : R, S, b),
                    n.loc == r.ORIGIN) {
                        const J = V === 0 ? C : R;
                        return {
                            x: J.x,
                            y: J.y,
                            t: n.t
                        }
                    } else if (n.loc == r.BETWEEN) {
                        const J = +(T + n.t * (M - T)).toPrecision(10)
                          , U = +(k + n.t * (A - k)).toPrecision(10);
                        return {
                            x: J,
                            y: U,
                            t: n.t
                        }
                    }
                return null
            } else {
                for (let U = 0; U < 2; U++)
                    if (l(U === 0 ? C : R, S, b),
                    n.loc == r.ORIGIN) {
                        const ce = U === 0 ? C : R;
                        return {
                            x: ce.x,
                            y: ce.y,
                            t: n.t
                        }
                    }
                const V = +(T + D * (M - T)).toPrecision(10)
                  , J = +(k + D * (A - k)).toPrecision(10);
                return {
                    x: V,
                    y: J,
                    t: D
                }
            }
        }
        function l(S, b, C) {
            const R = C.x - b.x
              , T = C.y - b.y
              , M = S.x - b.x
              , P = S.y - b.y
              , I = R * P - M * T;
            if (S.x === b.x && S.y === b.y) {
                n.loc = r.ORIGIN,
                n.t = 0;
                return
            }
            if (S.x === C.x && S.y === C.y) {
                n.loc = r.DESTINATION,
                n.t = 1;
                return
            }
            if (I < -Number.EPSILON) {
                n.loc = r.LEFT;
                return
            }
            if (I > Number.EPSILON) {
                n.loc = r.RIGHT;
                return
            }
            if (R * M < 0 || T * P < 0) {
                n.loc = r.BEHIND;
                return
            }
            if (Math.sqrt(R * R + T * T) < Math.sqrt(M * M + P * P)) {
                n.loc = r.BEYOND;
                return
            }
            let k;
            R !== 0 ? k = M / R : k = P / T,
            n.loc = r.BETWEEN,
            n.t = k
        }
        function c(S, b) {
            const C = []
              , R = [];
            for (let T = 1; T < S.length; T++) {
                const M = S[T - 1]
                  , P = S[T];
                for (let I = 1; I < b.length; I++) {
                    const k = b[I - 1]
                      , A = b[I]
                      , O = o(M, P, k, A);
                    O !== null && C.find(W => W.t <= O.t + Number.EPSILON && W.t >= O.t - Number.EPSILON) === void 0 && (C.push(O),
                    R.push(new Vector2(O.x,O.y)))
                }
            }
            return R
        }
        function u(S, b, C) {
            const R = new Vector2;
            b.getCenter(R);
            const T = [];
            return C.forEach(M => {
                M.boundingBox.containsPoint(R) && c(S, M.points).forEach(I => {
                    T.push({
                        identifier: M.identifier,
                        isCW: M.isCW,
                        point: I
                    })
                }
                )
            }
            ),
            T.sort( (M, P) => M.point.x - P.point.x),
            T
        }
        function f(S, b, C, R, T) {
            (T == null || T === "") && (T = "nonzero");
            const M = new Vector2;
            S.boundingBox.getCenter(M);
            const P = [new Vector2(C,M.y), new Vector2(R,M.y)]
              , I = u(P, S.boundingBox, b);
            I.sort( (H, B) => H.point.x - B.point.x);
            const k = []
              , A = [];
            I.forEach(H => {
                H.identifier === S.identifier ? k.push(H) : A.push(H)
            }
            );
            const O = k[0].point.x
              , W = [];
            let Q = 0;
            for (; Q < A.length && A[Q].point.x < O; )
                W.length > 0 && W[W.length - 1] === A[Q].identifier ? W.pop() : W.push(A[Q].identifier),
                Q++;
            if (W.push(S.identifier),
            T === "evenodd") {
                const H = W.length % 2 === 0
                  , B = W[W.length - 2];
                return {
                    identifier: S.identifier,
                    isHole: H,
                    for: B
                }
            } else if (T === "nonzero") {
                let H = !0
                  , B = null
                  , D = null;
                for (let q = 0; q < W.length; q++) {
                    const V = W[q];
                    H ? (D = b[V].isCW,
                    H = !1,
                    B = V) : D !== b[V].isCW && (D = b[V].isCW,
                    H = !0)
                }
                return {
                    identifier: S.identifier,
                    isHole: H,
                    for: B
                }
            } else
                console.warn('fill-rule: "' + T + '" is currently not implemented.')
        }
        let p = 999999999
          , g = -999999999
          , v = e.subPaths.map(S => {
            const b = S.getPoints();
            let C = -999999999
              , R = 999999999
              , T = -999999999
              , M = 999999999;
            for (let P = 0; P < b.length; P++) {
                const I = b[P];
                I.y > C && (C = I.y),
                I.y < R && (R = I.y),
                I.x > T && (T = I.x),
                I.x < M && (M = I.x)
            }
            return g <= T && (g = T + 1),
            p >= M && (p = M - 1),
            {
                curves: S.curves,
                points: b,
                isCW: ShapeUtils.isClockWise(b),
                identifier: -1,
                boundingBox: new Box2(new Vector2(M,R),new Vector2(T,C))
            }
        }
        );
        v = v.filter(S => S.points.length > 1);
        for (let S = 0; S < v.length; S++)
            v[S].identifier = S;
        const _ = v.map(S => f(S, v, p, g, e.userData ? e.userData.style.fillRule : void 0))
          , w = [];
        return v.forEach(S => {
            if (!_[S.identifier].isHole) {
                const C = new Shape;
                C.curves = S.curves,
                _.filter(T => T.isHole && T.for === S.identifier).forEach(T => {
                    const M = v[T.identifier]
                      , P = new Path;
                    P.curves = M.curves,
                    C.holes.push(P)
                }
                ),
                w.push(C)
            }
        }
        ),
        w
    }
    getStrokeStyle(e, t, r, n, o) {
        return e = e !== void 0 ? e : 1,
        t = t !== void 0 ? t : "#000",
        r = r !== void 0 ? r : "miter",
        n = n !== void 0 ? n : "butt",
        o = o !== void 0 ? o : 4,
        {
            strokeColor: t,
            strokeWidth: e,
            strokeLineJoin: r,
            strokeLineCap: n,
            strokeMiterLimit: o
        }
    }
    pointsToStroke(e, t, r, n) {
        const o = []
          , l = []
          , c = [];
        if (SVGLoader.pointsToStrokeWithBuffers(e, t, r, n, o, l, c) === 0)
            return null;
        const u = new BufferGeometry;
        return u.setAttribute("position", new Float32BufferAttribute(o,3)),
        u.setAttribute("normal", new Float32BufferAttribute(l,3)),
        u.setAttribute("uv", new Float32BufferAttribute(c,2)),
        u
    }
    pointsToStrokeWithBuffers(e, t, r, n, o, l, c, u) {
        const f = new Vector2
          , p = new Vector2
          , g = new Vector2
          , v = new Vector2
          , _ = new Vector2
          , w = new Vector2
          , S = new Vector2
          , b = new Vector2
          , C = new Vector2
          , R = new Vector2
          , T = new Vector2
          , M = new Vector2
          , P = new Vector2
          , I = new Vector2
          , k = new Vector2
          , A = new Vector2
          , O = new Vector2;
        r = r !== void 0 ? r : 12,
        n = n !== void 0 ? n : .001,
        u = u !== void 0 ? u : 0,
        e = Te(e);
        const W = e.length;
        if (W < 2)
            return 0;
        const Q = e[0].equals(e[W - 1]);
        let H, B = e[0], D;
        const q = t.strokeWidth / 2
          , V = 1 / (W - 1);
        let J = 0, U, ce, ee, ne, ae = !1, ve = 0, Y = u * 3, $ = u * 2;
        L(e[0], e[1], f).multiplyScalar(q),
        b.copy(e[0]).sub(f),
        C.copy(e[0]).add(f),
        R.copy(b),
        T.copy(C);
        for (let we = 1; we < W; we++) {
            H = e[we],
            we === W - 1 ? Q ? D = e[1] : D = void 0 : D = e[we + 1];
            const Ae = f;
            if (L(B, H, Ae),
            g.copy(Ae).multiplyScalar(q),
            M.copy(H).sub(g),
            P.copy(H).add(g),
            U = J + V,
            ce = !1,
            D !== void 0) {
                L(H, D, p),
                g.copy(p).multiplyScalar(q),
                I.copy(H).sub(g),
                k.copy(H).add(g),
                ee = !0,
                g.subVectors(D, B),
                Ae.dot(g) < 0 && (ee = !1),
                we === 1 && (ae = ee),
                g.subVectors(D, H),
                g.normalize();
                const Ne = Math.abs(Ae.dot(g));
                if (Ne > Number.EPSILON) {
                    const Ue = q / Ne;
                    g.multiplyScalar(-Ue),
                    v.subVectors(H, B),
                    _.copy(v).setLength(Ue).add(g),
                    A.copy(_).negate();
                    const le = _.length()
                      , Z = v.length();
                    v.divideScalar(Z),
                    w.subVectors(D, H);
                    const He = w.length();
                    switch (w.divideScalar(He),
                    v.dot(A) < Z && w.dot(A) < He && (ce = !0),
                    O.copy(_).add(H),
                    A.add(H),
                    ne = !1,
                    ce ? ee ? (k.copy(A),
                    P.copy(A)) : (I.copy(A),
                    M.copy(A)) : pe(),
                    t.strokeLineJoin) {
                    case "bevel":
                        K(ee, ce, U);
                        break;
                    case "round":
                        Se(ee, ce),
                        ee ? oe(H, M, I, U, 0) : oe(H, k, P, U, 1);
                        break;
                    case "miter":
                    case "miter-clip":
                    default:
                        const Ke = q * t.strokeMiterLimit / le;
                        if (Ke < 1)
                            if (t.strokeLineJoin !== "miter-clip") {
                                K(ee, ce, U);
                                break
                            } else
                                Se(ee, ce),
                                ee ? (w.subVectors(O, M).multiplyScalar(Ke).add(M),
                                S.subVectors(O, I).multiplyScalar(Ke).add(I),
                                N(M, U, 0),
                                N(w, U, 0),
                                N(H, U, .5),
                                N(H, U, .5),
                                N(w, U, 0),
                                N(S, U, 0),
                                N(H, U, .5),
                                N(S, U, 0),
                                N(I, U, 0)) : (w.subVectors(O, P).multiplyScalar(Ke).add(P),
                                S.subVectors(O, k).multiplyScalar(Ke).add(k),
                                N(P, U, 1),
                                N(w, U, 1),
                                N(H, U, .5),
                                N(H, U, .5),
                                N(w, U, 1),
                                N(S, U, 1),
                                N(H, U, .5),
                                N(S, U, 1),
                                N(k, U, 1));
                        else
                            ce ? (ee ? (N(C, J, 1),
                            N(b, J, 0),
                            N(O, U, 0),
                            N(C, J, 1),
                            N(O, U, 0),
                            N(A, U, 1)) : (N(C, J, 1),
                            N(b, J, 0),
                            N(O, U, 1),
                            N(b, J, 0),
                            N(A, U, 0),
                            N(O, U, 1)),
                            ee ? I.copy(O) : k.copy(O)) : ee ? (N(M, U, 0),
                            N(O, U, 0),
                            N(H, U, .5),
                            N(H, U, .5),
                            N(O, U, 0),
                            N(I, U, 0)) : (N(P, U, 1),
                            N(O, U, 1),
                            N(H, U, .5),
                            N(H, U, .5),
                            N(O, U, 1),
                            N(k, U, 1)),
                            ne = !0;
                        break
                    }
                } else
                    pe()
            } else
                pe();
            !Q && we === W - 1 && Ce(e[0], R, T, ee, !0, J),
            J = U,
            B = H,
            b.copy(I),
            C.copy(k)
        }
        if (!Q)
            Ce(H, M, P, ee, !1, U);
        else if (ce && o) {
            let we = O
              , Ae = A;
            ae !== ee && (we = A,
            Ae = O),
            ee ? (ne || ae) && (Ae.toArray(o, 0 * 3),
            Ae.toArray(o, 3 * 3),
            ne && we.toArray(o, 1 * 3)) : (ne || !ae) && (Ae.toArray(o, 1 * 3),
            Ae.toArray(o, 3 * 3),
            ne && we.toArray(o, 0 * 3))
        }
        return ve;
        function L(we, Ae, Ne) {
            return Ne.subVectors(Ae, we),
            Ne.set(-Ne.y, Ne.x).normalize()
        }
        function N(we, Ae, Ne) {
            o && (o[Y] = we.x,
            o[Y + 1] = we.y,
            o[Y + 2] = 0,
            l && (l[Y] = 0,
            l[Y + 1] = 0,
            l[Y + 2] = 1),
            Y += 3,
            c && (c[$] = Ae,
            c[$ + 1] = Ne,
            $ += 2)),
            ve += 3
        }
        function oe(we, Ae, Ne, Ue, le) {
            f.copy(Ae).sub(we).normalize(),
            p.copy(Ne).sub(we).normalize();
            let Z = Math.PI;
            const He = f.dot(p);
            Math.abs(He) < 1 && (Z = Math.abs(Math.acos(He))),
            Z /= r,
            g.copy(Ae);
            for (let Ke = 0, j = r - 1; Ke < j; Ke++)
                v.copy(g).rotateAround(we, Z),
                N(g, Ue, le),
                N(v, Ue, le),
                N(we, Ue, .5),
                g.copy(v);
            N(v, Ue, le),
            N(Ne, Ue, le),
            N(we, Ue, .5)
        }
        function pe() {
            N(C, J, 1),
            N(b, J, 0),
            N(M, U, 0),
            N(C, J, 1),
            N(M, U, 1),
            N(P, U, 0)
        }
        function K(we, Ae, Ne) {
            Ae ? we ? (N(C, J, 1),
            N(b, J, 0),
            N(M, U, 0),
            N(C, J, 1),
            N(M, U, 0),
            N(A, U, 1),
            N(M, Ne, 0),
            N(I, Ne, 0),
            N(A, Ne, .5)) : (N(C, J, 1),
            N(b, J, 0),
            N(P, U, 1),
            N(b, J, 0),
            N(A, U, 0),
            N(P, U, 1),
            N(P, Ne, 1),
            N(k, Ne, 0),
            N(A, Ne, .5)) : we ? (N(M, Ne, 0),
            N(I, Ne, 0),
            N(H, Ne, .5)) : (N(P, Ne, 1),
            N(k, Ne, 0),
            N(H, Ne, .5))
        }
        function Se(we, Ae) {
            Ae && (we ? (N(C, J, 1),
            N(b, J, 0),
            N(M, U, 0),
            N(C, J, 1),
            N(M, U, 0),
            N(A, U, 1),
            N(M, J, 0),
            N(H, U, .5),
            N(A, U, 1),
            N(H, U, .5),
            N(I, J, 0),
            N(A, U, 1)) : (N(C, J, 1),
            N(b, J, 0),
            N(P, U, 1),
            N(b, J, 0),
            N(A, U, 0),
            N(P, U, 1),
            N(P, J, 1),
            N(A, U, 0),
            N(H, U, .5),
            N(H, U, .5),
            N(A, U, 0),
            N(k, J, 1)))
        }
        function Ce(we, Ae, Ne, Ue, le, Z) {
            switch (t.strokeLineCap) {
            case "round":
                le ? oe(we, Ne, Ae, Z, .5) : oe(we, Ae, Ne, Z, .5);
                break;
            case "square":
                if (le)
                    f.subVectors(Ae, we),
                    p.set(f.y, -f.x),
                    g.addVectors(f, p).add(we),
                    v.subVectors(p, f).add(we),
                    Ue ? (g.toArray(o, 1 * 3),
                    v.toArray(o, 0 * 3),
                    v.toArray(o, 3 * 3)) : (g.toArray(o, 1 * 3),
                    g.toArray(o, 3 * 3),
                    v.toArray(o, 0 * 3));
                else {
                    f.subVectors(Ne, we),
                    p.set(f.y, -f.x),
                    g.addVectors(f, p).add(we),
                    v.subVectors(p, f).add(we);
                    const He = o.length;
                    Ue ? (g.toArray(o, He - 1 * 3),
                    v.toArray(o, He - 2 * 3),
                    v.toArray(o, He - 4 * 3)) : (g.toArray(o, He - 2 * 3),
                    v.toArray(o, He - 1 * 3),
                    v.toArray(o, He - 4 * 3))
                }
                break
            }
        }
        function Te(we) {
            let Ae = !1;
            for (let Ue = 1, le = we.length - 1; Ue < le; Ue++)
                if (we[Ue].distanceTo(we[Ue + 1]) < n) {
                    Ae = !0;
                    break
                }
            if (!Ae)
                return we;
            const Ne = [];
            Ne.push(we[0]);
            for (let Ue = 1, le = we.length - 1; Ue < le; Ue++)
                we[Ue].distanceTo(we[Ue + 1]) >= n && Ne.push(we[Ue]);
            return Ne.push(we[we.length - 1]),
            Ne
        }
    }
}
const svgParser = new SVGParser
  , titleVert = `#define GLSLIFY 1
#ifdef IS_EDGE
attribute vec2 instancedPositionA;attribute vec2 instancedPositionB;varying vec2 v_toNode;uniform float u_radius;
#endif
uniform float u_scrollRatio;
#include <ufxVert>
varying vec2 v_uv;varying float v_ddd;float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main(){
#ifdef IS_EDGE
bool isTop=position.y>0.;vec3 pos=vec3(isTop ? instancedPositionA : instancedPositionB,0.0);
#else
vec3 pos=position;
#endif
float lineRatio=floor(pos.y*6.)/6.;pos*=1.5;pos.x-=linearStep(lineRatio*0.4,0.56+lineRatio*0.4,u_scrollRatio)*0.5;vec3 basePos=getBasePosition(pos);vec3 screenPos=getScreenPosition(basePos);
#ifdef IS_EDGE
vec2 vAB=(instancedPositionA-instancedPositionB)*u_domWH;float angle=atan(vAB.y,vAB.x)+3.1415926*0.5;float s=sin(angle);float c=cos(angle);mat2 m=mat2(c,-s,s,c);v_toNode=m*(position.xy*vec2(1.,step(0.5,abs(position.y))));screenPos.xy+=v_toNode*u_radius;
#endif
gl_Position=projectionMatrix*modelViewMatrix*vec4(screenPos,1.0);v_uv=padUv(uv*0.002);}`
  , titleFrag = `#define GLSLIFY 1
uniform sampler2D u_screenPaintTexture;uniform sampler2D u_gradientTexture;uniform vec2 u_screenPaintTextureSize;uniform vec2 u_resolution;uniform float u_time;uniform float u_invertRatio;uniform sampler2D u_texture;varying vec2 v_uv;
#ifdef IS_EDGE
varying vec2 v_toNode;
#endif
#include <getBlueNoise>
#include <textureBicubic>
void main(){vec3 noise=getBlueNoise(gl_FragCoord.xy+vec2(38.,27.));vec2 screenPaintUv=gl_FragCoord.xy/u_resolution;vec4 screenPaintData=textureBicubic(u_screenPaintTexture,screenPaintUv,u_screenPaintTextureSize);float timeOffset=u_time;
#ifdef IS_EDGE
timeOffset+=3.1415926;
#endif
float d=cos((screenPaintUv.x+screenPaintUv.y)*4.+timeOffset)*0.5+0.5;float screenPaintStrength=1.;float constantStrength=0.;float alpha=1.0;
#ifdef IS_EDGE
vec2 toNode=v_toNode;float toNodeDist=length(toNode);alpha=smoothstep(1.0+fwidth(toNodeDist),1.0,toNodeDist);screenPaintStrength=4.;vec3 baseColor=vec3(0.004+d*d*0.15);constantStrength=max(0.,d*2.-1.)*0.15;
#else
vec3 baseColor=vec3(0.004+d*d*0.015);
#endif
float hue=(screenPaintData.x+screenPaintData.y)*1.5+d*2.;vec3 color=mix(baseColor,texture2D(u_gradientTexture,vec2(hue,0.0)).rgb,max(screenPaintData.z,screenPaintData.w)*screenPaintStrength+constantStrength)+noise.x*0.004;gl_FragColor=vec4(mix(color,1.-color,u_invertRatio),alpha);}`;
class PostUfx extends Ufx {
    renderOrder = 100
}
const postUfx = new PostUfx;
class AboutAwardSection {
    domContainer;
    domTitle;
    domCapabilitySectionContainer;
    offsetY = 0;
    showItemPerSecond = 10;
    _needsReset = !0;
    isSectionWasActive = !1;
    preInit(e) {
        this.domContainer = e.querySelector("#about-award"),
        this.domTitle = e.querySelector("#about-award-title"),
        this.domHeaders = Array.from(e.querySelectorAll(".about-award-header")),
        this.domItems = Array.from(e.querySelectorAll(".about-award-item"));
        for (let l = 0; l < this.domHeaders.length; l++) {
            let c = this.domHeaders[l]
              , u = c.querySelector(".about-award-header-title")
              , f = c.querySelector(".about-award-header-svg")
              , p = c.querySelector(".about-award-header-text");
            u._splitted = new SplitType(u,{
                types: "chars"
            }),
            p._splitted = new SplitType(p,{
                types: "chars"
            }),
            c._title = u,
            c._svg = f,
            c._number = p,
            c._animating = !1,
            c._time = 0
        }
        for (let l = 0; l < this.domItems.length; l++) {
            let c = this.domItems[l]
              , u = c.querySelector(".about-award-line")
              , f = Array.from(c.querySelectorAll(".about-award-item-wrapper"));
            c._animating = !1,
            c._time = 0;
            for (let p = 0; p < f.length; p++) {
                let g = f[p]
                  , v = Array.from(g.querySelectorAll(".about-award-item-wrapper-text"));
                for (let _ = 0; _ < v.length; _++) {
                    let w = v[_];
                    w._splitted = new SplitType(w,{
                        types: "words"
                    })
                }
                g._texts = v
            }
            c._line = u,
            c._wrappers = f
        }
        this.domCapabilitySectionContainer = e.querySelector("#about-capability");
        let t = svgParser.createShapes(svgParser.parse(this.domTitle.outerHTML).paths[0])
          , r = new ShapeGeometry(t);
        r.scale(1 / 1438, 1 / 1252, 1);
        let n = this._generateEdgeIndices(r)
          , o = properties.loader.add(settings.TEXTURE_PATH + "award_gradient.png", {
            type: "texture",
            minFilter: LinearFilter
        }).content;
        o.wrapS = o.wrapT = RepeatWrapping,
        this.titleEdgeMesh = new UfxMesh({
            refDom: this.domTitle,
            geometry: n,
            uniforms: Object.assign({
                u_screenPaintTexture: screenPaint.sharedUniforms.u_currPaintTexture,
                u_screenPaintTextureSize: screenPaint.sharedUniforms.u_paintTextureSize,
                u_time: properties.sharedUniforms.u_time,
                u_gradientTexture: {
                    value: o
                },
                u_radius: {
                    value: 2
                },
                u_invertRatio: {
                    value: 0
                },
                u_scrollRatio: {
                    value: 0
                }
            }, blueNoise.sharedUniforms),
            vertexShader: titleVert,
            fragmentShader: titleFrag
        }),
        this.titleEdgeMesh.material.defines.IS_EDGE = !0,
        aboutPage.postUfxContainer.add(this.titleEdgeMesh),
        this.titleMesh = new UfxMesh({
            refDom: this.domTitle,
            geometry: r,
            uniforms: this.titleEdgeMesh.material.uniforms,
            vertexShader: titleVert,
            fragmentShader: titleFrag
        }),
        this.titleMesh.renderOrder = 1,
        aboutPage.postUfxContainer.add(this.titleMesh)
    }
    _generateEdgeIndices(e) {
        let t = {}
          , r = []
          , n = []
          , o = e.attributes.position.array
          , l = e.index.array;
        for (let p = 0; p < l.length; p += 3) {
            let g = l[p]
              , v = l[p + 1]
              , _ = l[p + 2]
              , w = g < v ? `${g}_${v}` : `${v}_${g}`
              , S = v < _ ? `${v}_${_}` : `${_}_${v}`
              , b = _ < g ? `${_}_${g}` : `${g}_${_}`;
            t[w] ? t[w].count++ : t[w] = {
                count: 1,
                p0: g,
                p1: v
            },
            t[S] ? t[S].count++ : t[S] = {
                count: 1,
                p0: v,
                p1: _
            },
            t[b] ? t[b].count++ : t[b] = {
                count: 1,
                p0: _,
                p1: g
            }
        }
        let c = 0;
        for (let p in t) {
            let g = t[p];
            g.count === 1 && (r[c] = o[g.p0 * 3],
            n[c] = o[g.p1 * 3],
            c++,
            r[c] = o[g.p0 * 3 + 1],
            n[c] = o[g.p1 * 3 + 1],
            c++)
        }
        let u = new PlaneGeometry(2,2,1,3)
          , f = new InstancedBufferGeometry;
        return f.index = u.index,
        f.attributes.position = u.attributes.position,
        f.attributes.instancedPositionA = new InstancedBufferAttribute(new Float32Array(r),2),
        f.attributes.instancedPositionB = new InstancedBufferAttribute(new Float32Array(n),2),
        f
    }
    init() {}
    show() {}
    hide() {}
    resize(e, t) {
        this._splitText(),
        this.titleMesh.syncDom(-scrollManager.scrollPixel),
        this.titleEdgeMesh.syncDom(-scrollManager.scrollPixel),
        this.titleEdgeMesh.material.uniforms.u_radius.value = Math.max(1, properties.viewportWidth / 1200)
    }
    update(e) {
        let t = scrollManager.getDomRange(this.domContainer)
          , r = t.isActive;
        if (this.titleMesh.visible = r,
        this.titleEdgeMesh.visible = r,
        this.titleMesh.visible) {
            this.titleMesh.material.uniforms.u_scrollRatio.value = math.fit(t.ratio, -.75, .75, 0, 1),
            this.titleMesh.update(-scrollManager.scrollPixel),
            this.titleEdgeMesh.update(-scrollManager.scrollPixel);
            let n = scrollManager.getDomRange(this.domCapabilitySectionContainer);
            this.titleMesh.material.uniforms.u_invertRatio.value = math.fit(n.screenRatio, -1, -.75, 0, 1)
        }
        if (r) {
            for (let n = 0; n < this.domHeaders.length; n++) {
                let o = this.domHeaders[n]
                  , l = scrollManager.getDomRange(o);
                l.screenRatio > -1 ? o._animating = !0 : o._animating = !1,
                o._time = math.clamp(o._time + (o._animating ? e : -e), 0, 1.5),
                o._svg.style.transform = `scale(${math.fit(o._time, .2, .6, 0, 1, ease.backOut)}) rotate(${math.fit(l.screenRatio - n / 10, -1, 1, n % 2 === 0 ? -360 : 360, 0)}deg)`;
                for (let c = 0; c < o._title._splitted.chars.length; c++) {
                    let u = o._title._splitted.chars[c]
                      , f = math.fit(o._time - c / 25, 0, .7, 30, 0, ease.expoOut)
                      , p = math.fit(o._time - c / 25, 0, .7, 100, 0, ease.expoOut);
                    properties.viewportWidth < settings.MOBILE_WIDTH && (p = 0,
                    f = 0),
                    u.style.transform = `translate3d(0, ${p}%, 0) rotate(${f}deg)`
                }
                for (let c = 0; c < o._number._splitted.chars.length; c++) {
                    let u = o._number._splitted.chars[c]
                      , f = math.fit(o._time - c / 20, .2, .9, 100, 0, ease.expoOut);
                    properties.viewportWidth < settings.MOBILE_WIDTH && (f = 0),
                    u.style.transform = `translate3d(0, ${f}%, 0)`
                }
            }
            for (let n = 0; n < this.domItems.length; n++) {
                let o = this.domItems[n];
                scrollManager.getDomRange(o).screenRatio > -1 ? o._animating = !0 : o._animating = !1,
                o._time = math.clamp(o._time + (o._animating ? e : -e), 0, 1.5),
                o._line.style.transform = `scale3d(${math.fit(o._time, .2, 1, 0, 1, ease.expoOut)} ,1 ,1)`;
                for (let c = 0; c < o._wrappers.length; c++) {
                    let u = o._wrappers[c];
                    for (let f = 0; f < u._texts.length; f++) {
                        let p = u._texts[f];
                        for (let g = 0; g < p._splitted.words.length; g++) {
                            let v = p._splitted.words[g]
                              , _ = math.fit(o._time - c / 10 - f / 20 - g / 50, 0, .8, 100, 0, ease.expoOut);
                            properties.viewportWidth < settings.MOBILE_WIDTH && (_ = 0),
                            v.style.transform = `translate3d(0, ${_}%, 0)`
                        }
                    }
                }
            }
            this._needsReset && this._reset()
        } else
            this._needsReset = !0;
        this.isSectionWasActive = r
    }
    _splitText() {}
    _reset() {
        this._needsReset = !1;
        for (let e = 0; e < this.domHeaders.length; e++) {
            let t = this.domHeaders[e];
            t._animating = !1,
            t._time = 0
        }
        for (let e = 0; e < this.domItems.length; e++) {
            let t = this.domItems[e]
              , r = Array.from(t.querySelectorAll(".about-award-item-wrapper"));
            t._animating = !1,
            t._time = 0;
            for (let n = 0; n < r.length; n++) {
                let o = r[n]
                  , l = Array.from(o.querySelectorAll(".about-award-item-wrapper-text"));
                for (let c = 0; c < l.length; c++) {
                    let u = l[c];
                    u._splitted = new SplitType(u,{
                        types: "words"
                    })
                }
                o._texts = l
            }
        }
    }
}
const aboutAwardSection = new AboutAwardSection
  , NUMBER_OF_CARDS = 4;
class AboutCapabilitySection {
    domContainer;
    domList;
    domLine1;
    domLine2;
    domCards;
    showItemPerSecond = 10;
    time = 0;
    _needsReset = !0;
    preInit(e) {
        this.domContainer = e.querySelector("#about-capability"),
        this.domTitle = e.querySelector("#about-capability-title"),
        this.domSubheader = e.querySelector("#about-capability-subheader"),
        this.domSubheaderText = e.querySelector("#about-capability-subheader-text"),
        this.domSubhheaderCards = Array.from(e.querySelectorAll(".about-capability-subheader-card")),
        this.domLine1 = e.querySelector("#about-capability-title-line-1"),
        this.domLine2 = e.querySelector("#about-capability-title-line-2"),
        this.domCardsWrapper = e.querySelector("#about-capability-cards-wrapper"),
        this.domCards = e.querySelector("#about-capability-cards"),
        this.domCardsArray = Array.from(this.domContainer.querySelectorAll(".about-capability-card")),
        this.titleTime = 0,
        browser$1.isMobile || (this.lineVisual = new Line(2),
        this.lineVisual.preInit(),
        this.lineVisual2 = new Line(3),
        this.lineVisual2.preInit())
    }
    init() {
        browser$1.isMobile || (this.lineVisual.init(),
        aboutPage.postUfxContainer.add(this.lineVisual.container),
        this.lineVisual2.init(),
        aboutPage.postUfxContainer.add(this.lineVisual2.container))
    }
    resize(e, t) {
        this._splitText(),
        this.domCards.style.transform = "translateZ(0)";
        for (let u = 0, f = this.domCardsArray.length; u < f; u++)
            this.domCardsArray[u].style = "translateZ(0)";
        let r = this.domCardsArray[0].getBoundingClientRect();
        this.domCards.style.height = properties.viewportWidth < 812 ? "auto" : r.height + "px";
        for (let u = 0, f = this.domCardsArray.length; u < f; u++)
            ;
        browser$1.isMobile || (this.lineVisual.resize(e, t),
        this.lineVisual2.resize(e, t));
        let n = this.domCardsWrapper.getBoundingClientRect()
          , o = this.domCards.getBoundingClientRect()
          , l = this.domLine1.getBoundingClientRect()
          , c = this.domLine2.getBoundingClientRect();
        for (let u = 0, f = this.domCardsArray.length; u < f; u++) {
            let p = this.domCardsArray[u];
            p._width = r.width,
            p._height = r.height,
            p._offsetY = u % 2 === 0 ? 30 : -30
        }
        this.domCardsWrapper._height = this.domCardsWrapper.offsetHeight - this.domCardsArray[0]._height,
        this.domCardsWrapper._width = n.width,
        this.domCardsWrapper._cardOffset = this.domCardsWrapper._width - this.domCardsArray[0]._width * NUMBER_OF_CARDS,
        this.domCards._screenRatio = o.height / properties.viewportHeight,
        this.domLine2._translateX = c.left - l.left,
        this.domTitle._height = this.domTitle.getBoundingClientRect().height,
        scrollManager.resize(properties.viewportWidth, properties.viewportHeight)
    }
    update(e) {
        let t = scrollManager.getDomRange(this.domContainer);
        this.isSectionActive = t.isActive,
        browser$1.isMobile || (this.lineVisual.update(e, t),
        this.lineVisual2.update(e, t));
        let r = scrollManager.getDomRange(this.domTitle);
        if (this.domTitle.style.visibility = this.isSectionActive ? "visible" : "hidden",
        this.domCards.style.transform = "translateZ(0)",
        properties.screenPaintOffsetRatio *= math.fit(t.screenRatio, -.5, 0, 1, 0) + math.fit(t.screenRatio, .8, 1, 0, 1),
        this.isSectionActive) {
            this._needsReset && this._reset();
            let n = math.fit(t.screenRatio, -.6, .2, 0, 1)
              , o = math.fit(t.screenRatio, -.5, .7, 0, 1)
              , l = math.fit(t.screenRatio, -.5, .7, -Math.PI / 2, Math.PI - Math.PI / 2);
            if (this.time += e,
            properties.viewportWidth > 812) {
                let u = scrollManager.getDomRange(this.domCardsWrapper)
                  , f = scrollManager.getEaseInOutOffset(scrollManager.scrollPixel - u.top + (properties.viewportHeight - u.height) * .5, properties.viewportHeight * 3, 5, 1);
                this.domCards.style.transform = `translate3d(0, ${f}px, 0)`;
                for (let p = 0, g = this.domCardsArray.length; p < g; p++) {
                    let v = this.domCardsArray[p]
                      , _ = this.domCardsWrapper._width / 2 - v._width / 2
                      , w = p / NUMBER_OF_CARDS * (this.domCardsWrapper._width + this.domCardsWrapper._cardOffset / (NUMBER_OF_CARDS - 1))
                      , S = math.fit(n, .2, 1, _, w, ease.expoOut)
                      , b = math.fit(o, 0, .7 - Math.abs(g - 1 - p) / 20, 180, 0, ease.backInOut)
                      , C = math.fit(Math.abs(math.fit(n, 0, .75, 0, 1) * 2 - 1), 1, 0, 0, (p - 1.5) * 9, ease.expoInOut)
                      , R = Math.cos(this.time * 3 + p) * Math.cos(l);
                    v.style.transform = `translate3d(${S}px, ${R * 10}px, 0) rotateZ(${C}deg) rotate3d(0, 1,  0, ${b}deg)`
                }
            } else {
                let u = scrollManager.getDomRange(this.domCards)
                  , f = math.fit(u.showScreenOffset, 0, this.domCards._screenRatio, 0, 1);
                this.domCards.style.perspectiveOrigin = `center ${f * 100}%`;
                for (let p = 0, g = this.domCardsArray.length; p < g; p++) {
                    let v = this.domCardsArray[p]
                      , _ = scrollManager.getDomRange(v)
                      , w = math.fit(_.screenRatio, -.85 - p % 2 / 10, 0, 180, 0, ease.cubicInOut);
                    v.style.transform = `rotateY(${w}deg)`
                }
            }
            let c = r.screenRatio > -1;
            this.titleTime += e * (c ? 1 : 0),
            this.domTitle._splitted.words.forEach( (u, f) => {
                if (properties.useMobileLayout)
                    u.style.transform = "translate3d(0px, 0, 0)";
                else if (f < 2) {
                    let p = math.fit(this.titleTime - f / 10, 0, 1, 100, 0, ease.lusion);
                    u.style.transform = `translate3d(0, ${p}%, 0)`
                } else {
                    let p = math.fit(this.titleTime - f / 10, 1, 2, -this.domLine2._translateX, 0, ease.lusion)
                      , g = math.fit(this.titleTime - f / 10, .1, 1.1, -100, 0, ease.lusion);
                    u.style.transform = `translate3d(${p}px, ${g}%, 0)`
                }
            }
            ),
            this.domSubheaderText._splitted.lines.forEach( (u, f) => {
                let p = c ? math.saturate(this.titleTime - f / 10 - .25) : 0
                  , g = properties.viewportWidth >= settings.MOBILE_WIDTH ? Math.round(ease.expoOut(p) * 1e3) / 1e3 : 1;
                u.style.transform = `translate3d(0, ${math.fit(g, 0, 1, 110, 0)}%, 0)`
            }
            );
            for (let u = 0, f = this.domSubhheaderCards.length; u < f; u++) {
                let p = this.domSubhheaderCards[u]
                  , g = c ? math.saturate(this.titleTime - u / 10 - .25) : 0
                  , v = properties.viewportWidth >= settings.MOBILE_WIDTH ? Math.round(ease.expoOut(g) * 1e3) / 1e3 : 1;
                p.style.transform = `translate3d(0, ${math.fit(v, 0, 1, 110, 0)}%, 0)`
            }
        } else
            this._needsReset = !0
    }
    _splitText() {
        this.domTitle._splitted = new SplitType(this.domTitle,{
            types: "words, lines",
            charClass: "about-capability-title-char"
        }),
        this.domTitle._splitted.lines.forEach(e => {
            const t = document.createElement("div");
            t.style.position = "relative",
            t.style.overflow = "hidden",
            t.append(e),
            this.domTitle.append(t)
        }
        ),
        this.domSubheaderText._splitted = new SplitType(this.domSubheaderText,{
            types: "lines"
        }),
        this.domSubheaderText._splitted.lines.forEach(e => {
            const t = document.createElement("div");
            t.style.position = "relative",
            t.style.overflow = "hidden",
            t.append(e),
            this.domSubheaderText.append(t)
        }
        )
    }
    _reset() {
        if (this.domTitle._splitted) {
            this._needsReset = !1,
            this.titleTime = 0,
            this.domTitle._splitted.words.forEach(e => {
                e.style.transform = "translate3d(0, 100%, 0)"
            }
            ),
            this.domSubheaderText._splitted.chars.forEach(e => {
                e.style.transform = "translate3d(0, 100%, 0)"
            }
            );
            for (let e = 0, t = this.domSubhheaderCards.length; e < t; e++) {
                let r = this.domSubhheaderCards[e];
                r.style.transform = "translate3d(0, 110%, 0)"
            }
        }
    }
}
const aboutCapabilitySection = new AboutCapabilitySection;
class AboutPageAudios {
    hasInit = !1;
    bgFilterActive = !1;
    bgTrackName = "cinematic_0";
    constructor() {}
    init() {
        settings.USE_AUDIO && (this.hasInit || (this.hasInit = !0))
    }
    update(e) {
        if (!settings.USE_AUDIO)
            return;
        e ? audios.fadeBgMusic(this.bgTrackName, 1) : audios.fadeBgMusic("generic", 1),
        audios.items[this.bgTrackName].setFilterFrequencyViaRatio(math.fit(aboutHero.freezeRatio, .25, 1, 0, .75))
    }
}
const aboutPageAudios = new AboutPageAudios;
let _c = new Color;
class AboutPage extends Page {
    path = "about";
    id = "about";
    endVisualColor = properties.offWhiteColorHex;
    preInit() {
        let e = this.domContainer;
        aboutWhoSection.preInit(e),
        aboutClientSection.preInit(e),
        aboutAwardSection.preInit(e),
        aboutCapabilitySection.preInit(e)
    }
    init() {
        aboutWhoSection.init(),
        aboutClientSection.init(),
        aboutAwardSection.init(),
        aboutCapabilitySection.init(),
        super.init()
    }
    resize(e, t) {
        aboutWhoSection.resize(e, t),
        aboutClientSection.resize(e, t),
        aboutAwardSection.resize(e, t),
        aboutCapabilitySection.resize(e, t)
    }
    show(e, t, r) {
        aboutWhoSection.show(),
        aboutPageAudios.init(),
        super.show(e, t, r)
    }
    update(e) {
        super.update(e);
        let t = !1
          , r = !0
          , n = !1;
        if (pagesManager.scrollTargetPage == this) {
            properties.bgColor.setStyle(properties.blackColorHex);
            let o = scrollManager.getDomRange(aboutCapabilitySection.domContainer);
            properties.bgColor.lerp(_c.setStyle(properties.blueColorHex), math.fit(o.screenRatio, -1, -.5, 0, 1)),
            o.screenRatio > -.75 ? (n = !0,
            r = !1) : (n = !1,
            r = !0),
            footerSection.getDomRange().ratio > -.1 && (t = !0,
            r = !1,
            n = !1),
            document.documentElement.classList.toggle("is-black-bg", r),
            document.documentElement.classList.toggle("is-white-bg", t),
            document.documentElement.classList.toggle("is-blue-bg", n)
        }
        aboutWhoSection.update(e),
        aboutClientSection.update(e),
        aboutAwardSection.update(e),
        aboutCapabilitySection.update(e),
        aboutPageAudios.update(r)
    }
}
const aboutPage = new AboutPage;
class ProjectsMainSection {
    domContainer;
    domTitle;
    projectItemList;
    time = 0;
    _needsReset = !0;
    preInit(e) {
        this.domContainer = e.querySelector("#projects-main"),
        this.projectItemList = new ProjectItemList(projectsPage,e.querySelector(".project-list")),
        this.domItems = e.querySelectorAll(".project-item"),
        this.domTitle = e.querySelector("#projects-main-title"),
        this.domTitle._time = 0,
        this.domTitle._animating = !1,
        this.domTitleProjectNumber = e.querySelector("#projects-main-title-project-number"),
        this.domTitleProjectArrow = e.querySelector("#projects-main-title-project-arrow")
    }
    init() {}
    hasProject(e) {
        return this.projectItemList.hasProject(e)
    }
    resize(e, t) {
        this._splitText(),
        this.projectItemList.resize(e, t)
    }
    update(e) {
        if (scrollManager.getDomRange(this.domContainer).isActive) {
            this._needsReset && this._reset();
            let r = scrollManager.getDomRange(this.domTitle);
            if (this.domTitle._time = math.clamp(this.domTitle._time + (this.domTitle._animating ? e : -e), 0, 2),
            r.screenRatio > -1 && (this.domTitle._animating = !0),
            properties.useMobileLayout)
                this.domTitleProjectArrow.style.transform = "scale(1)";
            else {
                this.domTitle._splitted.chars.forEach( (o, l) => {
                    let c = math.fit(this.domTitle._time * 1.5 - l / 20 - .2, 0, 1, 100, 0, ease.lusion)
                      , u = math.fit(this.domTitle._time * 1.5 - l / 20 - .2, 0, 1, 30, 0, ease.lusion);
                    o.style.transform = `translate3d(0, ${c}%, 0) rotate(${u}deg)`
                }
                ),
                this.domTitleProjectNumber._splitted.chars.forEach( (o, l) => {
                    let c = math.fit(this.domTitle._time - l / 20 - .5, 0, 1, 100, 0, ease.lusion);
                    o.style.transform = `translate3d(0, ${c}%, 0)`
                }
                );
                let n = ease.elasticOut(math.saturate(this.domTitle._time - .6));
                this.domTitleProjectArrow.style.transform = `scale(${n})`
            }
        } else
            this._needsReset = !0;
        this.projectItemList.zoomRatio = math.fit(projectsPage.activeRatio, 0, .75, 1, 0),
        this.projectItemList.update(e)
    }
    _reset() {
        this.domTitle._splitted && (this._needsReset = !1,
        this.domTitle._time = 0,
        this.domTitle._animating = !1,
        properties.useMobileLayout ? (this.domTitle._splitted.chars && this.domTitle._splitted.chars.forEach(e => {
            e.style.transform = "translate3d(0, 0, 0)"
        }
        ),
        this.domTitleProjectNumber._splitted.chars && this.domTitleProjectNumber._splitted.chars.forEach(e => {
            e.style.transform = "translate3d(0, 0, 0)"
        }
        ),
        this.domTitleProjectArrow.style.transform = "scale(1)") : (this.domTitle._splitted.chars.forEach(e => {
            e.style.transform = "translate3d(0, 100%, 0)"
        }
        ),
        this.domTitleProjectNumber._splitted.chars.forEach(e => {
            e.style.transform = "translate3d(0, 100%, 0)"
        }
        ),
        this.domTitleProjectArrow.style.transform = "scale(0)"))
    }
    _splitText() {
        properties.useMobileLayout ? (this.domTitle._splitted && this.domTitle._splitted.revert(),
        this.domTitleProjectNumber._splitted && this.domTitleProjectNumber._splitted.revert()) : (this.domTitle._splitted = new SplitType(this.domTitle,{
            types: "chars"
        }),
        this.domTitleProjectNumber._splitted = new SplitType(this.domTitleProjectNumber,{
            types: "chars"
        }))
    }
}
const projectsMainSection = new ProjectsMainSection;
class ProjectsPageAudios {
    hasInit = !1;
    constructor() {}
    init() {
        settings.USE_AUDIO && (audios.fadeBgMusic("generic", 1),
        !this.hasInit && (this.domProjectItems = Array.from(document.querySelectorAll("#projects .project-item")),
        this.domProjectItems.forEach(e => {
            audios.addHoverClickEvents(e)
        }
        ),
        this.hasInit = !0))
    }
    update() {
        settings.USE_AUDIO
    }
}
const projectsPageAudios = new ProjectsPageAudios;
class ProjectsPage extends Page {
    path = "projects";
    id = "projects";
    endVisualUseTextured = !0;
    preInit() {
        let e = this.domContainer;
        projectsMainSection.preInit(e)
    }
    init() {
        projectsMainSection.init()
    }
    hasProject(e) {
        return projectsMainSection.projectItemList.hasProject(e)
    }
    show(e, t, r) {
        this.useGenericTransition = !0,
        projectsMainSection.projectItemList.selectedId = null;
        let n = e.pathNodes[1];
        e.target === projectPage && this.hasProject(n) && this.isFirstShown ? (this.useGenericTransition = !1,
        this.showDuration = 1.5,
        scrollManager.scrollToPixel(projectsMainSection.projectItemList.getProjectItemTop(n) - properties.viewportHeight * .25, !0),
        projectsMainSection.projectItemList.selectedId = n) : this.showDuration = 1,
        projectsPageAudios.init(),
        super.show(e, t, r)
    }
    hide(e, t, r) {
        this.useGenericTransition = !0,
        projectsMainSection.projectItemList.selectedId = null,
        t.target === projectPage && this.hasProject(t.pathNodes[1]) ? (this.useGenericTransition = !1,
        this.hideDuration = 1.5,
        projectsMainSection.projectItemList.selectedId = t.pathNodes[1]) : this.hideDuration = 1,
        super.hide(e, t, r)
    }
    resize(e, t) {
        projectsMainSection.resize(e, t)
    }
    update(e) {
        if (super.update(e),
        !!this.hasInitialized) {
            if (projectsMainSection.update(e),
            pagesManager.scrollTargetPage == this) {
                properties.bgColor.setStyle(properties.offWhiteColorHex);
                let t = !0
                  , r = !1
                  , n = !1;
                document.documentElement.classList.toggle("is-black-bg", r),
                document.documentElement.classList.toggle("is-white-bg", t),
                document.documentElement.classList.toggle("is-blue-bg", n)
            }
            projectsPageAudios.update(e)
        }
    }
}
const projectsPage = new ProjectsPage;
var dayjs_min = {
    exports: {}
};
(function(a, e) {
    (function(t, r) {
        a.exports = r()
    }
    )(commonjsGlobal$1, function() {
        var t = 1e3
          , r = 6e4
          , n = 36e5
          , o = "millisecond"
          , l = "second"
          , c = "minute"
          , u = "hour"
          , f = "day"
          , p = "week"
          , g = "month"
          , v = "quarter"
          , _ = "year"
          , w = "date"
          , S = "Invalid Date"
          , b = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/
          , C = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g
          , R = {
            name: "en",
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            ordinal: function(D) {
                var q = ["th", "st", "nd", "rd"]
                  , V = D % 100;
                return "[" + D + (q[(V - 20) % 10] || q[V] || q[0]) + "]"
            }
        }
          , T = function(D, q, V) {
            var J = String(D);
            return !J || J.length >= q ? D : "" + Array(q + 1 - J.length).join(V) + D
        }
          , M = {
            s: T,
            z: function(D) {
                var q = -D.utcOffset()
                  , V = Math.abs(q)
                  , J = Math.floor(V / 60)
                  , U = V % 60;
                return (q <= 0 ? "+" : "-") + T(J, 2, "0") + ":" + T(U, 2, "0")
            },
            m: function D(q, V) {
                if (q.date() < V.date())
                    return -D(V, q);
                var J = 12 * (V.year() - q.year()) + (V.month() - q.month())
                  , U = q.clone().add(J, g)
                  , ce = V - U < 0
                  , ee = q.clone().add(J + (ce ? -1 : 1), g);
                return +(-(J + (V - U) / (ce ? U - ee : ee - U)) || 0)
            },
            a: function(D) {
                return D < 0 ? Math.ceil(D) || 0 : Math.floor(D)
            },
            p: function(D) {
                return {
                    M: g,
                    y: _,
                    w: p,
                    d: f,
                    D: w,
                    h: u,
                    m: c,
                    s: l,
                    ms: o,
                    Q: v
                }[D] || String(D || "").toLowerCase().replace(/s$/, "")
            },
            u: function(D) {
                return D === void 0
            }
        }
          , P = "en"
          , I = {};
        I[P] = R;
        var k = "$isDayjsObject"
          , A = function(D) {
            return D instanceof H || !(!D || !D[k])
        }
          , O = function D(q, V, J) {
            var U;
            if (!q)
                return P;
            if (typeof q == "string") {
                var ce = q.toLowerCase();
                I[ce] && (U = ce),
                V && (I[ce] = V,
                U = ce);
                var ee = q.split("-");
                if (!U && ee.length > 1)
                    return D(ee[0])
            } else {
                var ne = q.name;
                I[ne] = q,
                U = ne
            }
            return !J && U && (P = U),
            U || !J && P
        }
          , W = function(D, q) {
            if (A(D))
                return D.clone();
            var V = typeof q == "object" ? q : {};
            return V.date = D,
            V.args = arguments,
            new H(V)
        }
          , Q = M;
        Q.l = O,
        Q.i = A,
        Q.w = function(D, q) {
            return W(D, {
                locale: q.$L,
                utc: q.$u,
                x: q.$x,
                $offset: q.$offset
            })
        }
        ;
        var H = function() {
            function D(V) {
                this.$L = O(V.locale, null, !0),
                this.parse(V),
                this.$x = this.$x || V.x || {},
                this[k] = !0
            }
            var q = D.prototype;
            return q.parse = function(V) {
                this.$d = function(J) {
                    var U = J.date
                      , ce = J.utc;
                    if (U === null)
                        return new Date(NaN);
                    if (Q.u(U))
                        return new Date;
                    if (U instanceof Date)
                        return new Date(U);
                    if (typeof U == "string" && !/Z$/i.test(U)) {
                        var ee = U.match(b);
                        if (ee) {
                            var ne = ee[2] - 1 || 0
                              , ae = (ee[7] || "0").substring(0, 3);
                            return ce ? new Date(Date.UTC(ee[1], ne, ee[3] || 1, ee[4] || 0, ee[5] || 0, ee[6] || 0, ae)) : new Date(ee[1],ne,ee[3] || 1,ee[4] || 0,ee[5] || 0,ee[6] || 0,ae)
                        }
                    }
                    return new Date(U)
                }(V),
                this.init()
            }
            ,
            q.init = function() {
                var V = this.$d;
                this.$y = V.getFullYear(),
                this.$M = V.getMonth(),
                this.$D = V.getDate(),
                this.$W = V.getDay(),
                this.$H = V.getHours(),
                this.$m = V.getMinutes(),
                this.$s = V.getSeconds(),
                this.$ms = V.getMilliseconds()
            }
            ,
            q.$utils = function() {
                return Q
            }
            ,
            q.isValid = function() {
                return this.$d.toString() !== S
            }
            ,
            q.isSame = function(V, J) {
                var U = W(V);
                return this.startOf(J) <= U && U <= this.endOf(J)
            }
            ,
            q.isAfter = function(V, J) {
                return W(V) < this.startOf(J)
            }
            ,
            q.isBefore = function(V, J) {
                return this.endOf(J) < W(V)
            }
            ,
            q.$g = function(V, J, U) {
                return Q.u(V) ? this[J] : this.set(U, V)
            }
            ,
            q.unix = function() {
                return Math.floor(this.valueOf() / 1e3)
            }
            ,
            q.valueOf = function() {
                return this.$d.getTime()
            }
            ,
            q.startOf = function(V, J) {
                var U = this
                  , ce = !!Q.u(J) || J
                  , ee = Q.p(V)
                  , ne = function(pe, K) {
                    var Se = Q.w(U.$u ? Date.UTC(U.$y, K, pe) : new Date(U.$y,K,pe), U);
                    return ce ? Se : Se.endOf(f)
                }
                  , ae = function(pe, K) {
                    return Q.w(U.toDate()[pe].apply(U.toDate("s"), (ce ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(K)), U)
                }
                  , ve = this.$W
                  , Y = this.$M
                  , $ = this.$D
                  , L = "set" + (this.$u ? "UTC" : "");
                switch (ee) {
                case _:
                    return ce ? ne(1, 0) : ne(31, 11);
                case g:
                    return ce ? ne(1, Y) : ne(0, Y + 1);
                case p:
                    var N = this.$locale().weekStart || 0
                      , oe = (ve < N ? ve + 7 : ve) - N;
                    return ne(ce ? $ - oe : $ + (6 - oe), Y);
                case f:
                case w:
                    return ae(L + "Hours", 0);
                case u:
                    return ae(L + "Minutes", 1);
                case c:
                    return ae(L + "Seconds", 2);
                case l:
                    return ae(L + "Milliseconds", 3);
                default:
                    return this.clone()
                }
            }
            ,
            q.endOf = function(V) {
                return this.startOf(V, !1)
            }
            ,
            q.$set = function(V, J) {
                var U, ce = Q.p(V), ee = "set" + (this.$u ? "UTC" : ""), ne = (U = {},
                U[f] = ee + "Date",
                U[w] = ee + "Date",
                U[g] = ee + "Month",
                U[_] = ee + "FullYear",
                U[u] = ee + "Hours",
                U[c] = ee + "Minutes",
                U[l] = ee + "Seconds",
                U[o] = ee + "Milliseconds",
                U)[ce], ae = ce === f ? this.$D + (J - this.$W) : J;
                if (ce === g || ce === _) {
                    var ve = this.clone().set(w, 1);
                    ve.$d[ne](ae),
                    ve.init(),
                    this.$d = ve.set(w, Math.min(this.$D, ve.daysInMonth())).$d
                } else
                    ne && this.$d[ne](ae);
                return this.init(),
                this
            }
            ,
            q.set = function(V, J) {
                return this.clone().$set(V, J)
            }
            ,
            q.get = function(V) {
                return this[Q.p(V)]()
            }
            ,
            q.add = function(V, J) {
                var U, ce = this;
                V = Number(V);
                var ee = Q.p(J)
                  , ne = function(Y) {
                    var $ = W(ce);
                    return Q.w($.date($.date() + Math.round(Y * V)), ce)
                };
                if (ee === g)
                    return this.set(g, this.$M + V);
                if (ee === _)
                    return this.set(_, this.$y + V);
                if (ee === f)
                    return ne(1);
                if (ee === p)
                    return ne(7);
                var ae = (U = {},
                U[c] = r,
                U[u] = n,
                U[l] = t,
                U)[ee] || 1
                  , ve = this.$d.getTime() + V * ae;
                return Q.w(ve, this)
            }
            ,
            q.subtract = function(V, J) {
                return this.add(-1 * V, J)
            }
            ,
            q.format = function(V) {
                var J = this
                  , U = this.$locale();
                if (!this.isValid())
                    return U.invalidDate || S;
                var ce = V || "YYYY-MM-DDTHH:mm:ssZ"
                  , ee = Q.z(this)
                  , ne = this.$H
                  , ae = this.$m
                  , ve = this.$M
                  , Y = U.weekdays
                  , $ = U.months
                  , L = U.meridiem
                  , N = function(K, Se, Ce, Te) {
                    return K && (K[Se] || K(J, ce)) || Ce[Se].slice(0, Te)
                }
                  , oe = function(K) {
                    return Q.s(ne % 12 || 12, K, "0")
                }
                  , pe = L || function(K, Se, Ce) {
                    var Te = K < 12 ? "AM" : "PM";
                    return Ce ? Te.toLowerCase() : Te
                }
                ;
                return ce.replace(C, function(K, Se) {
                    return Se || function(Ce) {
                        switch (Ce) {
                        case "YY":
                            return String(J.$y).slice(-2);
                        case "YYYY":
                            return Q.s(J.$y, 4, "0");
                        case "M":
                            return ve + 1;
                        case "MM":
                            return Q.s(ve + 1, 2, "0");
                        case "MMM":
                            return N(U.monthsShort, ve, $, 3);
                        case "MMMM":
                            return N($, ve);
                        case "D":
                            return J.$D;
                        case "DD":
                            return Q.s(J.$D, 2, "0");
                        case "d":
                            return String(J.$W);
                        case "dd":
                            return N(U.weekdaysMin, J.$W, Y, 2);
                        case "ddd":
                            return N(U.weekdaysShort, J.$W, Y, 3);
                        case "dddd":
                            return Y[J.$W];
                        case "H":
                            return String(ne);
                        case "HH":
                            return Q.s(ne, 2, "0");
                        case "h":
                            return oe(1);
                        case "hh":
                            return oe(2);
                        case "a":
                            return pe(ne, ae, !0);
                        case "A":
                            return pe(ne, ae, !1);
                        case "m":
                            return String(ae);
                        case "mm":
                            return Q.s(ae, 2, "0");
                        case "s":
                            return String(J.$s);
                        case "ss":
                            return Q.s(J.$s, 2, "0");
                        case "SSS":
                            return Q.s(J.$ms, 3, "0");
                        case "Z":
                            return ee
                        }
                        return null
                    }(K) || ee.replace(":", "")
                })
            }
            ,
            q.utcOffset = function() {
                return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
            }
            ,
            q.diff = function(V, J, U) {
                var ce, ee = this, ne = Q.p(J), ae = W(V), ve = (ae.utcOffset() - this.utcOffset()) * r, Y = this - ae, $ = function() {
                    return Q.m(ee, ae)
                };
                switch (ne) {
                case _:
                    ce = $() / 12;
                    break;
                case g:
                    ce = $();
                    break;
                case v:
                    ce = $() / 3;
                    break;
                case p:
                    ce = (Y - ve) / 6048e5;
                    break;
                case f:
                    ce = (Y - ve) / 864e5;
                    break;
                case u:
                    ce = Y / n;
                    break;
                case c:
                    ce = Y / r;
                    break;
                case l:
                    ce = Y / t;
                    break;
                default:
                    ce = Y
                }
                return U ? ce : Q.a(ce)
            }
            ,
            q.daysInMonth = function() {
                return this.endOf(g).$D
            }
            ,
            q.$locale = function() {
                return I[this.$L]
            }
            ,
            q.locale = function(V, J) {
                if (!V)
                    return this.$L;
                var U = this.clone()
                  , ce = O(V, J, !0);
                return ce && (U.$L = ce),
                U
            }
            ,
            q.clone = function() {
                return Q.w(this.$d, this)
            }
            ,
            q.toDate = function() {
                return new Date(this.valueOf())
            }
            ,
            q.toJSON = function() {
                return this.isValid() ? this.toISOString() : null
            }
            ,
            q.toISOString = function() {
                return this.$d.toISOString()
            }
            ,
            q.toString = function() {
                return this.$d.toUTCString()
            }
            ,
            D
        }()
          , B = H.prototype;
        return W.prototype = B,
        [["$ms", o], ["$s", l], ["$m", c], ["$H", u], ["$W", f], ["$M", g], ["$y", _], ["$D", w]].forEach(function(D) {
            B[D[1]] = function(q) {
                return this.$g(q, D[0], D[1])
            }
        }),
        W.extend = function(D, q) {
            return D.$i || (D(q, H, W),
            D.$i = !0),
            W
        }
        ,
        W.locale = O,
        W.isDayjs = A,
        W.unix = function(D) {
            return W(1e3 * D)
        }
        ,
        W.en = I[P],
        W.Ls = I,
        W.p = {},
        W
    })
}
)(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = getDefaultExportFromCjs(dayjs_minExports);
class PlaygroundPage extends Page {
    path = "playground";
    id = "playground";
    mesh = null;
    container = new Object3D;
    events = [{
        date: dayjs("2019-01-25")
    }, {
        date: dayjs("2019-09-25")
    }, {
        date: dayjs("2022-04-25")
    }];
    domEvents = [];
    preInit() {
        let e = this.domContainer;
        this.domMain = e.querySelector("#playground-main"),
        this.domInner = e.querySelector("#playground-main-inner"),
        this.domTimeline = e.querySelector("#playground-main-timeline"),
        this.domTimelineLine = e.querySelector("#playground-main-timeline-line"),
        this.domTimelineLineProgress = e.querySelector("#playground-main-timeline-line-progress");
        for (let t = 0; t < this.events.length; t++) {
            let r = document.createElement("div");
            r.classList.add("playground-main-timeline-event");
            let n = document.createElement("div");
            n.classList.add("playground-main-timeline-dot"),
            n.addEventListener("mouseenter", this._onDomDotMouseenter.bind(this)),
            n.addEventListener("mouseleave", this._onDomDotMouseleave.bind(this));
            let o = document.createElement("div");
            o.classList.add("playground-main-timeline-text"),
            o.innerHTML = this.events[t].date.format("YY MMMM'DD"),
            r.append(o),
            r.append(n),
            this.domTimeline.append(r),
            this.domEvents[t] = r
        }
        properties.loader.add(settings.MODEL_PATH + "playground/tunnel.buf", {
            onLoad: t => {
                this._onTunnelLoad(t)
            }
        })
    }
    init() {
        this.domTimeline.addEventListener("click", this._onDomTimelineClick.bind(this))
    }
    resize(e, t) {
        let r = Number(getComputedStyle(this.domMain).getPropertyValue("padding-left").split("px")[0])
          , n = this.events[this.events.length - 1].date.diff(this.events[0].date, "day")
          , o = properties.viewportWidth - 2 * r;
        this.offsetRatio = r / properties.viewportWidth,
        this.domMain._height = this.domMain.getBoundingClientRect().height - properties.viewportHeight;
        for (let l = 0; l < this.domEvents.length; l++) {
            let c = this.domEvents[l]
              , p = this.events[l].date.diff(this.events[0].date, "day") / n;
            c._ratio = math.fit(p, 0, 1, this.offsetRatio, 1 - this.offsetRatio),
            c.style.left = p * o + r + "px"
        }
    }
    update(e) {
        super.update(e);
        let t = scrollManager.getDomRange(this.domContainer)
          , r = math.fit(t.screenRatio, -.5, .5, 0, 1);
        if (r < 1) {
            this.domInner.style.transform = `translate3d(0, ${-scrollManager.y}px, 0)`,
            this.domTimelineLineProgress.style.transform = `scale3d(${r}, 1, 1)`;
            for (let n = 0; n < this.domEvents.length; n++) {
                let o = this.domEvents[n];
                r >= o._ratio ? o.classList.add("--active") : o.classList.remove("--active")
            }
        }
    }
    _onTunnelLoad(e) {
        this.mesh = new Mesh(e,new MeshNormalMaterial),
        this.container.add(this.mesh)
    }
    _onDomTimelineClick(e) {
        let t = e.clientX / properties.viewportWidth;
        scrollManager.scrollToPixel(t * this.domMain._height)
    }
    _onDomDotMouseenter(e) {
        e.target.closest(".playground-main-timeline-event").classList.add("--hover")
    }
    _onDomDotMouseleave(e) {
        e.target.closest(".playground-main-timeline-event").classList.remove("--hover")
    }
}
const playgroundPage = new PlaygroundPage;
var FLUID_CELL = 0
  , AIR_CELL = 1
  , SOLID_CELL = 2
  , EMIT_RATE = 2e3;
let _v0 = new Vector2
  , _v1 = new Vector2
  , _v2 = new Vector2;
function clamp(a, e, t) {
    return a < e ? e : a > t ? t : a
}
class FlipSim {
    constructor() {
        this.isFlushing = !1,
        this.hasInitialized = !1,
        this.emitterPosA = new Vector2(1,1),
        this.emitterPosB = new Vector2(1,1),
        this.colliderRectList = []
    }
    addColliderRect = (e, t=0, r=0, n=0, o=0) => {
        let l = this.fInvSpacing
          , c = this.fNumY
          , u = clamp(Math.round(e.x * l) - t, 0, this.fNumX - 1)
          , f = clamp(Math.round(e.y * l) - o, 0, this.fNumY - 1)
          , p = clamp(Math.round((e.x + e.w) * l) + r, 0, this.fNumX - 1)
          , g = clamp(Math.round((e.y + e.h) * l) + n, 0, this.fNumY - 1);
        p = Math.max(u, p),
        g = Math.max(f, g),
        this.colliderRectList.push(e);
        for (let _ = u; _ <= p; _++)
            for (let w = f; w <= g; w++) {
                var v = _ * c + w;
                this.s[v] = 0
            }
        e.x = u / l,
        e.y = f / l,
        e.w = Math.max(1, p - u) / l,
        e.h = Math.max(1, g - f) / l,
        e.l = e.x,
        e.r = e.x + e.w,
        e.b = e.y,
        e.t = e.y + e.h,
        e.hw = e.w / 2,
        e.hh = e.h / 2,
        e.cx = e.x + e.hw,
        e.cy = e.y + e.hh
    }
    ;
    init(e, t, r, n, o, l) {
        let c = this.hasInitialized;
        this.colliderRectList.length = 0,
        this.density = e,
        this.fNumX = Math.ceil(t / n) + 1,
        this.fNumY = Math.ceil(r / n) + 1,
        this.h = Math.max(t / this.fNumX, r / this.fNumY),
        this.fInvSpacing = 1 / this.h;
        var u = this.fNumX * this.fNumY;
        this.tankInnerWidth = (this.fNumX - 2) * this.h,
        this.tankInnerHeight = (this.fNumY - 2) * this.h,
        (!c || u > this.cellType.length) && (this.u = new Float32Array(u),
        this.v = new Float32Array(u),
        this.du = new Float32Array(u),
        this.dv = new Float32Array(u),
        this.prevU = new Float32Array(u),
        this.prevV = new Float32Array(u),
        this.p = new Int8Array(u),
        this.s = new Int8Array(u),
        this.cellType = new Int8Array(u),
        this.particleDensity = new Float32Array(u)),
        this.fNumCells = u;
        for (var f = 0; f < u; f++)
            this.u[f] = this.v[f] = this.du[f] = this.dv[f] = this.prevU[f] = this.prevV[f] = this.p[f] = this.s[f] = this.cellType[f] = this.particleDensity[f] = 0;
        this.particleRadius = o,
        this.pInvSpacing = 1 / (2.2 * o),
        this.pNumX = Math.floor(t * this.pInvSpacing) + 1,
        this.pNumY = Math.floor(r * this.pInvSpacing) + 1,
        this.particleRestDensity = 0;
        let p = this.pNumX * this.pNumY;
        if (!c || p > this.numCellParticles.length)
            this.numCellParticles = new Uint32Array(p),
            this.firstCellParticle = new Uint32Array(p + 1);
        else {
            for (var f = 0; f < p; f++)
                this.numCellParticles[f] = 0,
                this.firstCellParticle[f] = 0;
            this.firstCellParticle[p] = 0
        }
        this.pNumCells = p,
        this.particlePosOut = new Float32Array(2 * l),
        this.particlePos = new Float32Array(2 * l),
        this.particleInfo = new Float32Array(2 * l),
        (!c || l > this.particleDir.length / 2) && (this.particleDir = new Float32Array(2 * l),
        this.particlePrevPos = new Float32Array(2 * l),
        this.particleVel = new Float32Array(2 * l),
        this.cellParticleIds = new Uint32Array(l),
        this.particleStatuses = new Uint8Array(l));
        for (var f = 0; f < l; f++)
            this.particlePos[f * 2 + 0] = -1e4,
            this.particlePos[f * 2 + 1] = 0,
            this.particlePosOut[f * 2 + 0] = -1e4,
            this.particlePosOut[f * 2 + 1] = 0,
            this.particleInfo[f * 2 + 0] = 0,
            this.particleInfo[f * 2 + 1] = 0,
            this.particleDir[f * 2 + 0] = 0,
            this.particleDir[f * 2 + 1] = 0,
            this.particlePrevPos[f * 2 + 0] = -1e4,
            this.particlePrevPos[f * 2 + 1] = 0,
            this.particleVel[f * 2 + 0] = 0,
            this.particleVel[f * 2 + 1] = 0,
            this.cellParticleIds[f] = 0,
            this.particleStatuses[f] = 0;
        this.numParticles = l;
        for (var g = this.fNumY, f = 0; f < this.fNumX; f++)
            for (var v = 0; v < this.fNumY; v++) {
                var _ = 0;
                f > 0 && f < this.fNumX - 1 && v > 0 && v < this.fNumY - 1 && (_ = 1),
                this.s[f * g + v] = _
            }
        this.hasInitialized = !0
    }
    integrateParticles(e, t) {
        for (var r = 0; r < this.numParticles; r++)
            this.particleStatuses[r] && (this.particleVel[2 * r + 1] += e * t,
            this.particlePos[2 * r] += this.particleVel[2 * r] * e,
            this.particlePos[2 * r + 1] += this.particleVel[2 * r + 1] * e)
    }
    pushParticlesApart(e) {
        this.numCellParticles.fill(0);
        for (var t = 0; t < this.numParticles; t++)
            if (this.particleStatuses[t]) {
                var r = this.particlePos[2 * t]
                  , n = this.particlePos[2 * t + 1]
                  , o = clamp(Math.floor(r * this.pInvSpacing), 0, this.pNumX - 1)
                  , l = clamp(Math.floor(n * this.pInvSpacing), 0, this.pNumY - 1)
                  , c = o * this.pNumY + l;
                this.numCellParticles[c]++
            }
        for (var u = 0, t = 0; t < this.pNumCells; t++)
            u += this.numCellParticles[t],
            this.firstCellParticle[t] = u;
        this.firstCellParticle[this.pNumCells] = u;
        for (var t = 0; t < this.numParticles; t++)
            if (this.particleStatuses[t]) {
                var r = this.particlePos[2 * t]
                  , n = this.particlePos[2 * t + 1]
                  , o = clamp(Math.floor(r * this.pInvSpacing), 0, this.pNumX - 1)
                  , l = clamp(Math.floor(n * this.pInvSpacing), 0, this.pNumY - 1)
                  , c = o * this.pNumY + l;
                this.firstCellParticle[c]--,
                this.cellParticleIds[this.firstCellParticle[c]] = t
            }
        for (var f = 3 * this.particleRadius, p = f * f, g = 0; g < e; g++)
            for (var t = 0; t < this.numParticles; t++)
                if (this.particleStatuses[t])
                    for (var v = this.particlePos[2 * t], _ = this.particlePos[2 * t + 1], w = Math.floor(v * this.pInvSpacing), S = Math.floor(_ * this.pInvSpacing), b = Math.max(w - 1, 0), C = Math.max(S - 1, 0), R = Math.min(w + 1, this.pNumX - 1), T = Math.min(S + 1, this.pNumY - 1), o = b; o <= R; o++)
                        for (var l = C; l <= T; l++)
                            for (var c = o * this.pNumY + l, u = this.firstCellParticle[c], M = this.firstCellParticle[c + 1], P = u; P < M; P++) {
                                var I = this.cellParticleIds[P];
                                if (I != t && this.particleStatuses[I]) {
                                    var k = this.particlePos[2 * I]
                                      , A = this.particlePos[2 * I + 1]
                                      , O = k - v
                                      , W = A - _
                                      , Q = O * O + W * W;
                                    if (!(Q > p || Q == 0)) {
                                        var H = Math.sqrt(Q)
                                          , B = .5 * (f - H) / H;
                                        O *= B,
                                        W *= B,
                                        this.particlePos[2 * t] -= O,
                                        this.particlePos[2 * t + 1] -= W,
                                        this.particlePos[2 * I] += O,
                                        this.particlePos[2 * I + 1] += W
                                    }
                                }
                            }
    }
    handleParticleCollisions(e, t, r, n, o, l) {
        for (var c = 1 / this.fInvSpacing, u = this.particleRadius, f = n + u, p = f * f, g = c + u, v = (this.fNumX - 1) * c - u, _ = c + u, w = (this.fNumY - 1) * c - u, S = this.isFlushing, b = 0; b < this.numParticles; b++)
            if (this.particleStatuses[b]) {
                var C = this.particlePos[2 * b]
                  , R = this.particlePos[2 * b + 1]
                  , T = C - t
                  , M = R - r
                  , P = T * T + M * M;
                if (P < p) {
                    var I = Math.sqrt(P)
                      , k = (f - I) / I;
                    C += T * k,
                    R += M * k,
                    this.particleVel[2 * b] = o * 2,
                    this.particleVel[2 * b + 1] = l * 2
                }
                let A = C - this.particlePrevPos[2 * b]
                  , O = R - this.particlePrevPos[2 * b + 1]
                  , W = Math.sqrt(A * A + O * O);
                if (W > 0) {
                    let Q = A / W
                      , H = O / W
                      , B = 1 / (Math.abs(Q) > 1e-4 ? Q : 1e-4)
                      , D = 1 / (Math.abs(H) > 1e-4 ? H : 1e-4);
                    for (let q = 0; q < this.colliderRectList.length; q++) {
                        let V = this.colliderRectList[q];
                        if (C > V.l && C < V.r && R > V.b && R < V.t) {
                            let J = C - V.cx
                              , U = R - V.cy
                              , ce = J * B
                              , ee = U * D
                              , ne = Math.abs(B) * V.hw
                              , ae = Math.abs(D) * V.hh
                              , ve = Math.max(-ce - ne, -ee - ae);
                            C = C + Q * ve,
                            R = R + H * ve
                        }
                    }
                }
                C < g && (C = g,
                this.particleVel[2 * b] = 0),
                C > v && (C = v,
                this.particleVel[2 * b] = 0),
                R < _ && (S ? (C = -1e4,
                R = 0,
                this.particleStatuses[b] = 0) : (R = _,
                this.particleVel[2 * b + 1] = 0)),
                R > w && (R = w,
                this.particleVel[2 * b + 1] = 0),
                this.particlePos[2 * b] = C,
                this.particlePos[2 * b + 1] = R
            }
        for (var b = 0; b < this.numParticles; b++) {
            _v0.fromArray(this.particleVel, 2 * b);
            let O = _v0.length();
            if (O > 1e-5) {
                _v2.fromArray(this.particleDir, 2 * b),
                _v1.fromArray(this.particleInfo, 2 * b),
                _v1.y = math.mix(_v1.y, 0, 1 - Math.exp(-4 * e)),
                _v0.multiplyScalar(1 / O);
                let W = Math.atan2(_v0.y, _v0.x)
                  , Q = Math.atan2(_v2.y, _v2.x);
                _v1.y += O * math.normalizeAngle(W - Q),
                _v1.x += _v1.y * e,
                _v1.toArray(this.particleInfo, 2 * b),
                _v2.toArray(this.particleDir, 2 * b)
            }
            this.particlePrevPos[2 * b] = this.particlePos[2 * b],
            this.particlePrevPos[2 * b + 1] = this.particlePos[2 * b + 1]
        }
    }
    updateParticleDensity() {
        var e = this.fNumY
          , t = this.h
          , r = this.fInvSpacing
          , n = .5 * t
          , o = this.particleDensity;
        o.fill(0);
        for (var l = 0; l < this.numParticles; l++)
            if (this.particleStatuses[l]) {
                var c = this.particlePos[2 * l]
                  , u = this.particlePos[2 * l + 1];
                c = clamp(c, t, (this.fNumX - 1) * t),
                u = clamp(u, t, (this.fNumY - 1) * t);
                var f = Math.floor((c - n) * r)
                  , p = (c - n - f * t) * r
                  , g = Math.min(f + 1, this.fNumX - 2)
                  , v = Math.floor((u - n) * r)
                  , _ = (u - n - v * t) * r
                  , w = Math.min(v + 1, this.fNumY - 2)
                  , S = 1 - p
                  , b = 1 - _;
                f < this.fNumX && v < this.fNumY && (o[f * e + v] += S * b),
                g < this.fNumX && v < this.fNumY && (o[g * e + v] += p * b),
                g < this.fNumX && w < this.fNumY && (o[g * e + w] += p * _),
                f < this.fNumX && w < this.fNumY && (o[f * e + w] += S * _)
            }
        if (this.particleRestDensity == 0) {
            for (var C = 0, R = 0, l = 0; l < this.fNumCells; l++)
                this.cellType[l] == FLUID_CELL && (C += o[l],
                R++);
            R > 0 && (this.particleRestDensity = C / R)
        }
    }
    transferVelocities(e, t) {
        var r = this.fNumY
          , n = this.h
          , o = this.fInvSpacing
          , l = .5 * n;
        if (e) {
            this.prevU.set(this.u),
            this.prevV.set(this.v),
            this.du.fill(0),
            this.dv.fill(0),
            this.u.fill(0),
            this.v.fill(0);
            for (var c = 0; c < this.fNumCells; c++)
                this.cellType[c] = this.s[c] == 0 ? SOLID_CELL : AIR_CELL;
            for (var c = 0; c < this.numParticles; c++)
                if (this.particleStatuses[c]) {
                    var u = this.particlePos[2 * c]
                      , f = this.particlePos[2 * c + 1]
                      , p = clamp(Math.floor(u * o), 0, this.fNumX - 1)
                      , g = clamp(Math.floor(f * o), 0, this.fNumY - 1)
                      , v = p * r + g;
                    this.cellType[v] == AIR_CELL && (this.cellType[v] = FLUID_CELL)
                }
        }
        for (var _ = 0; _ < 2; _++) {
            for (var w = _ == 0 ? 0 : l, S = _ == 0 ? l : 0, b = _ == 0 ? this.u : this.v, C = _ == 0 ? this.prevU : this.prevV, R = _ == 0 ? this.du : this.dv, c = 0; c < this.numParticles; c++)
                if (this.particleStatuses[c]) {
                    var u = this.particlePos[2 * c]
                      , f = this.particlePos[2 * c + 1];
                    u = clamp(u, n, (this.fNumX - 1) * n),
                    f = clamp(f, n, (this.fNumY - 1) * n);
                    var T = Math.min(Math.floor((u - w) * o), this.fNumX - 2)
                      , M = (u - w - T * n) * o
                      , P = Math.min(T + 1, this.fNumX - 2)
                      , I = Math.min(Math.floor((f - S) * o), this.fNumY - 2)
                      , k = (f - S - I * n) * o
                      , A = Math.min(I + 1, this.fNumY - 2)
                      , O = 1 - M
                      , W = 1 - k
                      , Q = O * W
                      , H = M * W
                      , B = M * k
                      , D = O * k
                      , q = T * r + I
                      , V = P * r + I
                      , J = P * r + A
                      , U = T * r + A;
                    if (e) {
                        var ce = this.particleVel[2 * c + _];
                        b[q] += ce * Q,
                        R[q] += Q,
                        b[V] += ce * H,
                        R[V] += H,
                        b[J] += ce * B,
                        R[J] += B,
                        b[U] += ce * D,
                        R[U] += D
                    } else {
                        var ee = _ == 0 ? r : 1
                          , ne = this.cellType[q] != AIR_CELL || this.cellType[q - ee] != AIR_CELL ? 1 : 0
                          , ae = this.cellType[V] != AIR_CELL || this.cellType[V - ee] != AIR_CELL ? 1 : 0
                          , ve = this.cellType[J] != AIR_CELL || this.cellType[J - ee] != AIR_CELL ? 1 : 0
                          , Y = this.cellType[U] != AIR_CELL || this.cellType[U - ee] != AIR_CELL ? 1 : 0
                          , $ = this.particleVel[2 * c + _]
                          , R = ne * Q + ae * H + ve * B + Y * D;
                        if (R > 0) {
                            var L = (ne * Q * b[q] + ae * H * b[V] + ve * B * b[J] + Y * D * b[U]) / R
                              , N = (ne * Q * (b[q] - C[q]) + ae * H * (b[V] - C[V]) + ve * B * (b[J] - C[J]) + Y * D * (b[U] - C[U])) / R
                              , oe = $ + N;
                            this.particleVel[2 * c + _] = (1 - t) * L + t * oe
                        }
                    }
                }
            if (e) {
                for (var c = 0; c < b.length; c++)
                    R[c] > 0 && (b[c] /= R[c]);
                for (var c = 0; c < this.fNumX; c++)
                    for (var pe = 0; pe < this.fNumY; pe++) {
                        var K = this.cellType[c * r + pe] == SOLID_CELL;
                        (K || c > 0 && this.cellType[(c - 1) * r + pe] == SOLID_CELL) && (this.u[c * r + pe] = this.prevU[c * r + pe]),
                        (K || pe > 0 && this.cellType[c * r + pe - 1] == SOLID_CELL) && (this.v[c * r + pe] = this.prevV[c * r + pe])
                    }
            }
        }
    }
    solveIncompressibility(e, t, r, n=!0) {
        this.p.fill(0),
        this.prevU.set(this.u),
        this.prevV.set(this.v);
        for (var o = this.fNumY, l = this.density * this.h / t, c = 0; c < this.fNumCells; c++)
            this.u[c],
            this.v[c];
        for (var u = 0; u < e; u++)
            for (var c = 1; c < this.fNumX - 1; c++)
                for (var f = 1; f < this.fNumY - 1; f++)
                    if (this.cellType[c * o + f] == FLUID_CELL) {
                        var p = c * o + f
                          , g = (c - 1) * o + f
                          , v = (c + 1) * o + f
                          , _ = c * o + f - 1
                          , w = c * o + f + 1
                          , T = this.s[p]
                          , S = this.s[g]
                          , b = this.s[v]
                          , C = this.s[_]
                          , R = this.s[w]
                          , T = S + b + C + R;
                        if (T != 0) {
                            var M = this.u[v] - this.u[p] + this.v[w] - this.v[p];
                            if (this.particleRestDensity > 0 && n) {
                                var P = .5
                                  , I = this.particleDensity[c * o + f] - this.particleRestDensity;
                                I > 0 && (M = M - P * I)
                            }
                            var k = -M / T;
                            k *= r,
                            this.p[p] += l * k,
                            this.u[p] -= S * k,
                            this.u[v] += b * k,
                            this.v[p] -= C * k,
                            this.v[w] += R * k
                        }
                    }
    }
    resetParticles() {}
    simulate(e, t, r, n, o, l, c, u, f, p, g, v, _) {
        e = Math.min(e, 1 / 60);
        var w = 1
          , S = e / w;
        let b = Math.ceil(EMIT_RATE * e)
          , C = 0;
        for (var R = 0; R < w; R++) {
            for (let M = 0; M < this.numParticles && !(C / w >= b); M++)
                if (this.particleStatuses[M] == 0) {
                    let P = Math.random();
                    this.particlePos[2 * M + 0] = this.particlePrevPos[2 * M + 0] = this.particlePosOut[2 * M + 0] = math.mix(this.emitterPosA.x, this.emitterPosB.x, P) + (Math.random() - .5) * .01,
                    this.particlePos[2 * M + 1] = this.particlePrevPos[2 * M + 1] = this.particlePosOut[2 * M + 1] = math.mix(this.emitterPosA.y, this.emitterPosB.y, P) + (Math.random() - .5) * .01,
                    this.particleInfo[2 * M + 0] = Math.random() * Math.PI * 2,
                    this.particleInfo[2 * M + 1] = 0,
                    this.particleDir[2 * M + 0] = 0,
                    this.particleDir[2 * M + 1] = -1;
                    let I = (2 + Math.pow(Math.random(), 2) * 3) * t * .1;
                    this.particleVel[M * 2 + 0] = 0,
                    this.particleVel[M * 2 + 1] = I,
                    this.particleStatuses[M] = 1,
                    C++
                }
            this.integrateParticles(S, t),
            u && this.pushParticlesApart(o),
            this.handleParticleCollisions(S, f, p, g, v, _),
            this.transferVelocities(!0),
            this.updateParticleDensity(),
            this.solveIncompressibility(n, S, l, c),
            this.transferVelocities(!1, r);
            for (var T = 0; T < this.numParticles; T++)
                this.particlePosOut[2 * T] = this.particlePos[2 * T] + (this.particlePosOut[2 * T] - this.particlePrevPos[2 * T]) * .5,
                this.particlePosOut[2 * T + 1] = this.particlePos[2 * T + 1] + (this.particlePosOut[2 * T + 1] - this.particlePrevPos[2 * T + 1]) * .5
        }
    }
}
const flipSim = new FlipSim
  , vert = `#define GLSLIFY 1
attribute vec2 instancedPos;attribute vec2 instancedInfo;uniform vec2 u_tankOffset;uniform vec2 u_tankSize;uniform vec2 u_tankActualSize;uniform vec2 u_renderScale;uniform float u_radius;uniform float u_opacity;
#include <ufxVert>
#ifdef IS_TEXTURE
attribute vec4 instanceColorShape;varying vec3 v_color;varying vec3 v_colorMix;varying vec2 v_uv;
#endif
void main(){float angle=instancedInfo.x;float s=sin(angle);float c=cos(angle);mat2 m=mat2(c,-s,s,c);vec3 basePos=vec3((instancedPos-u_tankOffset)/u_tankActualSize-vec2(.5),0.0);basePos.y=-basePos.y;basePos.xy*=u_renderScale*2.;float particleSize=1.;
#ifdef IS_TEXTURE
float colorFract=fract(instanceColorShape.w/3.);v_color=instanceColorShape.rgb;v_colorMix=vec3(colorFract<0.25 ? 1. : 0.,abs(colorFract-.5)<0.25 ? 1. : 0.,colorFract>0.75 ? 1. : 0.);v_uv=uv;v_uv.x=(v_uv.x+floor(instanceColorShape.w/3.))/8.;
#else
particleSize+=min(1.,abs(instancedInfo.y)*0.01);
#endif
vec3 screenPos=getScreenPosition(basePos);screenPos.xy+=(m*position.xy)*u_radius*particleSize*u_renderScale.x*2.*u_opacity;gl_Position=projectionMatrix*modelViewMatrix*vec4(screenPos,1.0);}`
  , frag$3 = `#define GLSLIFY 1
#ifdef IS_TEXTURE
uniform sampler2D u_texture;varying vec3 v_color;varying vec3 v_colorMix;varying vec2 v_uv;
#else
uniform vec3 u_color;
#endif
void main(){
#ifdef IS_TEXTURE
float a=dot(v_colorMix,texture2D(u_texture,v_uv).rgb);gl_FragColor=vec4(v_color,a);
#else
gl_FragColor=vec4(u_color,1.);
#endif
}`;
let COLORS = ["#ff383c", "#0029ff", "#bb2bff", "#1eff5d", "#cfff0f", "#d6e4ec", "#bbcbda", "#7a8d9b", "#262229"];
class FlipAnimation {
    PRESSURE_ITERATION = 60;
    NUM_PARTICLES_ITERS = 4;
    OVER_RELAXATION = 1;
    FLIP_RATIO = 0;
    mesh;
    meshList = [];
    top = 0;
    height = 0;
    gravity = 0;
    isActive = !1;
    needsReset = !1;
    hasDown = !1;
    prevViewportWidth = 0;
    prevViewportHeight = 0;
    opacity = 1;
    colorHex;
    container = new Object3D;
    shapedContainer = new Object3D;
    texturedContainer = new Object3D;
    prevUseTextured = null;
    useTextured = !0;
    sharedUniforms = {
        u_tankOffset: {
            value: new Vector2
        },
        u_tankSize: {
            value: new Vector2
        },
        u_tankActualSize: {
            value: new Vector2
        },
        u_radius: {
            value: 0
        },
        u_opacity: {
            value: 0
        },
        u_renderScale: {
            value: new Vector2
        },
        u_color: {
            value: new Color("#1A2FFB")
        },
        u_texture: {
            value: null
        }
    };
    preInit() {
        let e = [];
        for (let n = 0; n < COLORS.length; n++)
            COLORS[n] = new Color(COLORS[n]);
        let t = new BufferGeometry;
        t.setAttribute("position", new BufferAttribute(new Float32Array([.0714286, -.5, 0, -.0714286, -.5, 0, .5, -.0714286, 0, .0714286, -.0714286, 0, -.0714286, -.0714286, 0, -.5, -.0714286, 0, .5, .0714286, 0, .0714286, .0714286, 0, -.0714286, .0714286, 0, -.5, .0714286, 0, .0714286, .5, 0, -.0714286, .5, 0]),3)),
        t.setIndex(new BufferAttribute(new Uint8Array([4, 5, 9, 0, 4, 3, 8, 7, 3, 7, 2, 3, 7, 6, 2, 11, 10, 7, 7, 8, 11, 3, 4, 8, 0, 1, 4, 4, 9, 8]),1)),
        e.push(t),
        e.push(new PlaneGeometry(.8,.8)),
        e.push(new CircleGeometry(.4,10)),
        e.push(new CircleGeometry(.5,3)),
        e.push(new PlaneGeometry(1.6,1.6));
        let r = properties.loader.add(settings.TEXTURE_PATH + "flip_texture.png", {
            type: "texture"
        }).content;
        this.sharedUniforms.u_texture.value = r;
        for (let n = 0; n < e.length; n++) {
            let o = e[n]
              , l = new InstancedBufferGeometry;
            for (let u in o.attributes)
                l.setAttribute(u, o.attributes[u]);
            l.index = o.index;
            let c = new UfxMesh({
                geometry: l,
                material: new ShaderMaterial({
                    uniforms: this.sharedUniforms,
                    vertexShader: vert,
                    fragmentShader: frag$3,
                    depthWrite: !1,
                    depthTest: !1,
                    side: DoubleSide
                })
            });
            c.material.extensions.derivatives = !0,
            c.frustumCulled = !1,
            n < e.length - 1 ? this.shapedContainer.add(c) : (this.texturedContainer.add(c),
            c.material.defines.IS_TEXTURE = !0,
            c.material.transparent = !0),
            this.meshList.push(c)
        }
        this.container.add(this.shapedContainer),
        this.container.add(this.texturedContainer),
        pageExtraSections.postUfxContainer.add(this.container)
    }
    init() {}
    reInitTank() {
        let e = properties.viewportWidth
          , t = properties.viewportHeight;
        scrollManager.syncDom(),
        this.capturedOffsetY = -scrollManager.scrollPixel + endSection.offsetY;
        let r = document.querySelector("#end-section-outer").getBoundingClientRect().top - this.capturedOffsetY
          , n = document.querySelector("#end-section-outer").getBoundingClientRect().bottom - this.capturedOffsetY
          , o = this.prevViewportWidth != e || this.prevViewportHeight != t || !flipSim.hasInitialized || this.prevUseTextured !== this.useTextured;
        this.prevUseTextured = this.useTextured,
        o && (this.prevViewportWidth = properties.viewportWidth,
        this.prevViewportHeight = properties.viewportHeight);
        var l = 2
          , c = l * t / e;
        let u = this.useTextured ? .4 : 1;
        var f = Math.ceil(math.fit(e, 320, 2560, 20, 90) * u)
          , p = this.tankWidth = 1 * l
          , g = this.tankHeight = 1 * c
          , v = p / f
          , _ = 1;
        this.gravity = Math.ceil(math.fit(e, 320, 2560, -15, -3)) * (this.useTextured ? 1.5 : 1);
        var w = .2 * v
          , S = Math.ceil(math.fit(e, 320, 2560, 20, 80) * u)
          , b = Math.ceil(S * t / e)
          , C = Math.ceil(S * b / (this.meshList.length - 1)) * (this.meshList.length - 1);
        o && flipSim.init(_, p, g, v, w, C),
        this.sharedUniforms.u_tankOffset.value.set(flipSim.h, flipSim.h),
        this.sharedUniforms.u_tankSize.value.set(p, g),
        this.sharedUniforms.u_tankActualSize.value.set(flipSim.tankInnerWidth, flipSim.tankInnerHeight),
        this.sharedUniforms.u_radius.value = w,
        this.sharedUniforms.u_renderScale.value.set(e / p, e / p * flipSim.tankInnerHeight / flipSim.tankInnerWidth);
        let R = r + n >> 1
          , T = e
          , M = flipSim.tankInnerHeight / flipSim.tankInnerWidth * T;
        r = R - M / 2,
        n = R + M / 2,
        this.top = r,
        this.height = M;
        let P = flipSim.particlePosOut.length / 2
          , I = Math.floor(P / (this.meshList.length - 1))
          , k = 0;
        for (let A = 0; A < this.meshList.length; A++) {
            let O = this.meshList[A];
            if (o) {
                let W;
                if (A < this.meshList.length - 1)
                    W = new InstancedInterleavedBuffer(flipSim.particlePosOut,2,4),
                    O.geometry.setAttribute("instancedPos", new InterleavedBufferAttribute(W,2,k * 2)),
                    O.geometry.attributes.instancedPos.usage = DynamicDrawUsage,
                    W.count /= 4,
                    W = new InstancedInterleavedBuffer(flipSim.particleInfo,2,4),
                    O.geometry.setAttribute("instancedInfo", new InterleavedBufferAttribute(W,2,k * 2)),
                    O.geometry.attributes.instancedInfo.usage = DynamicDrawUsage,
                    W.count /= 4,
                    k += I;
                else {
                    O.geometry.setAttribute("instancedPos", new InstancedBufferAttribute(flipSim.particlePosOut,2)),
                    O.geometry.attributes.instancedPos.usage = DynamicDrawUsage,
                    O.geometry.setAttribute("instancedInfo", new InstancedBufferAttribute(flipSim.particleInfo,2)),
                    O.geometry.attributes.instancedInfo.usage = DynamicDrawUsage;
                    let Q = flipSim.particlePosOut.length / 2
                      , H = new Float32Array(Q * 4);
                    for (let B = 0, D = 0; B < Q; B++,
                    D += 4) {
                        let q = B % 45;
                        q = q < 5 ? q : 5 + (q - 5) % 4;
                        let V = COLORS[q];
                        H[D + 0] = V.r,
                        H[D + 1] = V.g,
                        H[D + 2] = V.b,
                        H[D + 3] = ~~(B / 23) % 23
                    }
                    O.geometry.setAttribute("instanceColorShape", new InstancedBufferAttribute(H,4))
                }
                O.geometry._maxInstanceCount = flipSim.maxParticles
            }
            O.syncRect(0, r + this.capturedOffsetY, e, M, this.capturedOffsetY)
        }
        if (o && !this.useTextured) {
            let A = document.querySelector("#end-bottom");
            flipSim.addColliderRect(this.convertDomRectToTankRect(A.getBoundingClientRect()), -1, -1, -1, -1)
        }
        this.hasDown = !1
    }
    resize() {
        this.isActive && this.meshList.length > 0 ? this.reInitTank() : this.needsReset = !0,
        this.hasDown = !1
    }
    convertDomRectToTankRect(e) {
        let t = this.convertPixelXYToTankXY(e.left, e.bottom)
          , r = this.convertPixelSizeToTankSize(e.width, e.height);
        return {
            x: t.x,
            y: t.y,
            w: r.w,
            h: r.h
        }
    }
    convertPixelSizeToTankSize(e, t) {
        return {
            w: e / properties.viewportWidth * flipSim.tankInnerWidth,
            h: t / this.height * flipSim.tankInnerHeight
        }
    }
    convertPixelXYToTankXY(e, t) {
        let r = this.convertPixelSizeToTankSize(math.clamp(e, 0, properties.viewportWidth - 1), math.clamp(this.top + this.height - t - scrollManager.scrollPixel + endSection.offsetY, 0, properties.viewportHeight - 1));
        return {
            x: r.w + flipSim.h,
            y: r.h + flipSim.h
        }
    }
    update(e) {
        if (this.isActive) {
            if ((this.needsReset || this.prevUseTextured !== this.useTextured) && (this.needsReset = !1,
            this.reInitTank()),
            properties.hasInitialized) {
                this.useTextured ? (this.shapedContainer.visible = !1,
                this.texturedContainer.visible = !0) : (this.shapedContainer.visible = !0,
                this.texturedContainer.visible = !1);
                let t = -scrollManager.scrollPixel + endSection.offsetY;
                if (this.sharedUniforms.u_color.value.setStyle(this.colorHex),
                this.sharedUniforms.u_opacity.value = this.opacity,
                this.meshList[0].testViewport(t)) {
                    e = Math.max(1 / 120, e);
                    let r = !0
                      , n = !0
                      , o = this.convertPixelXYToTankXY(input.prevMousePixelXY.x, input.prevMousePixelXY.y)
                      , l = this.convertPixelXYToTankXY(input.mousePixelXY.x, input.mousePixelXY.y)
                      , c = l.x
                      , u = l.y
                      , f = (l.x - o.x) / e
                      , p = (l.y - o.y) / e
                      , g = 150 / properties.viewportWidth * (properties.useMobileLayout ? input.isDown ? .35 : 0 : math.fit(Math.sqrt(f * f + p * p), 0, 2, .2, 1));
                    input.isDown && !properties.useMobileLayout ? (c = -1e3,
                    u = -1e3,
                    this.hasDown = !0,
                    flipSim.isFlushing = !0,
                    flipSim.emitterPosA.copy(this.convertPixelXYToTankXY(input.prevMousePixelXY.x, input.prevMousePixelXY.y)),
                    flipSim.emitterPosB.copy(this.convertPixelXYToTankXY(input.mousePixelXY.x, input.mousePixelXY.y))) : (this.hasDown || flipSim.emitterPosA.copy(flipSim.emitterPosB.set(1, this.tankHeight * .5, 0)),
                    flipSim.isFlushing = !1),
                    flipSim.simulate(e, this.gravity, this.FLIP_RATIO, this.PRESSURE_ITERATION, this.NUM_PARTICLES_ITERS, this.OVER_RELAXATION, r, n, c, u, g, f, p);
                    for (let v = 0; v < this.meshList.length; v++) {
                        let _ = this.meshList[v];
                        _.geometry.attributes.instancedPos.needsUpdate = !0,
                        _.geometry.attributes.instancedInfo.needsUpdate = !0,
                        _.update(t),
                        _.visible = !0
                    }
                } else
                    for (let r = 0; r < this.meshList.length; r++) {
                        let n = this.meshList[r];
                        n.visible = !1
                    }
            }
        } else {
            this.needsReset = !0;
            for (let t = 0; t < this.meshList.length; t++) {
                let r = this.meshList[t];
                r.visible = !1
            }
        }
    }
}
const flipAnimation = new FlipAnimation;
class EndSection {
    domContainer;
    offsetY = 0;
    _needsReset = !0;
    ROLLUP_ANIMATION_DURATION = 1;
    ROLLUP_ANIMATION_INTERVAL = 2;
    activeRatio = 0;
    hoverRatio = 0;
    time = 0;
    isHover = !1;
    preInit() {
        this.domContainer = document.getElementById("end-section"),
        this.outerContainer = document.getElementById("end-section-outer"),
        this.domContent = document.getElementById("end-section-content"),
        this.domTitle = document.getElementById("end-section-title"),
        this.domTitleLink = document.getElementById("end-section-title-link"),
        this.domTitleTopDecoration = document.getElementById("end-section-title-top-decoration"),
        this.domTitleBottomLeftDecoration = document.getElementById("end-section-title-bottom-left-decoration"),
        this.domTitleBottomRightDecoration = document.getElementById("end-section-title-bottom-right-decoration"),
        this.domSubtitle = document.getElementById("end-section-subtitle-text"),
        this.domButton = document.getElementById("end-bottom"),
        this.domCrosses = Array.from(document.querySelectorAll(".end-section-content-cross")),
        flipAnimation.preInit()
    }
    init() {
        flipAnimation.init(),
        properties.useMobileLayout || (this.domTitle.addEventListener("mouseenter", this._onDomTitleMouseenter.bind(this)),
        this.domTitle.addEventListener("mouseleave", this._onDomTitleMouseleave.bind(this)))
    }
    resize(e, t) {
        this.domContent.style.transform = "translate3d(-50%,-50%,0) scale3d(1,1,1)",
        this._splitText(),
        this._needsReset = !0
    }
    update(e) {
        let t = scrollManager.getDomRange(this.domContainer)
          , r = t.isActive;
        pagesManager.scrollTargetPage && (flipAnimation.isActive = pagesManager.scrollTargetPage.hasEndVisual,
        flipAnimation.colorHex = pagesManager.scrollTargetPage.endVisualColor,
        flipAnimation.useTextured = pagesManager.scrollTargetPage.endVisualUseTextured,
        flipAnimation.container.visible = flipAnimation.isActive,
        flipAnimation.opacity = math.fit(pagesManager.scrollTargetPage.hideRatio, 0, .3, 1, 0));
        let n = math.fit(t.hideScreenOffset, -.75, 0, 0, 1)
          , o = math.mix(1, .9, n);
        if (this.offsetY = Math.max(0, -t.screenY),
        this.outerContainer.style.transform = `translate3d(0, ${this.offsetY - Math.max(0, t.hideScreenOffset) * properties.viewportHeight}px, 0)`,
        this.domContent.style.transform = `translate3d(-50%,-50%,0) scale3d(${o}, ${o}, ${o})`,
        r) {
            this._needsReset && this._reset();
            let l = pagesManager.scrollTargetPage ? pagesManager.scrollTargetPage.endSectionActiveThreshold : 1
              , c = t.showScreenOffset > l
              , u = this.time;
            this.activeRatio = math.saturate(this.activeRatio + (c ? e : -e)),
            this.hoverRatio = math.saturate(this.hoverRatio + (this.isHover && this.activeRatio == 1 ? e : -e)),
            this.time += e;
            let f = u % this.ROLLUP_ANIMATION_INTERVAL
              , p = this.time % this.ROLLUP_ANIMATION_INTERVAL;
            this.domTitle.style.pointerEvents = c && this.activeRatio > .75 ? "auto" : "none";
            for (let v = 0; v < this.domCrosses.length; v++) {
                let _ = v / (this.domCrosses.length - 1)
                  , w = math.fit(this.activeRatio, _ * .2, _ * .2 + .7, 0, 1, ease.lusion)
                  , S = this.domCrosses[v]
                  , b = math.fit(w, 0, 1, 0, 1, ease.lusion)
                  , C = math.fit(w, 0, 1, 0, 180, ease.lusion);
                S.style.transform = `scale(${b}) rotate(${C}deg)`
            }
            if (!properties.useMobileLayout)
                for (let v = 0; v < this.domSubtitle._splitted.words.length; v++) {
                    let _ = this.domSubtitle._splitted.words[v]
                      , w = v / (this.domSubtitle._splitted.words.length - 1)
                      , S = math.fit(this.activeRatio, w * .15, w * .15 + .75, 200, 0, ease.lusion)
                      , b = math.fit(this.activeRatio, w * .1, w * .1 + .8, 30, 0, ease.lusion);
                    _.style.transform = `translate3d(0, ${S}%, 0) rotate(${b}deg)`
                }
            for (let v = 0; v < this.domTitleLink._splitted.words.length; v++) {
                let _ = this.domTitleLink._splitted.words[v]
                  , w = v / (this.domTitleLink._splitted.words.length - 1);
                f > p && (_._randCharIndex = Math.floor(Math.random() * _._chars.length),
                _._ratio == 0 && (_._ratio = .001)),
                _._ratio > 0 && (_._ratio = math.saturate(_._ratio + (c ? e / this.ROLLUP_ANIMATION_DURATION : -e * 2)),
                _._ratio == 1 && (_._ratio = 0));
                for (let S = 0; S < _._chars.length; S++) {
                    let b = _._chars[S]
                      , C = S / (_._chars.length - 1)
                      , R = properties.viewportWidth >= settings.MOBILE_WIDTH ? math.fit(this.activeRatio, w * .15 + C * .15, w * .15 + C * .15 + .7, 100, 0, ease.lusion) : 0;
                    S === _._randCharIndex ? b._wrapper.style.transform = `translate3d(0, ${math.fit(_._ratio, w * .2, w * .2 + .8, 0, -100, ease.lusion)}%, 0)` : b._wrapper.style.transform = "translateZ(0)",
                    b.style.transform = `translate3d(0, ${R}%, 0)`
                }
            }
            this.domTitleTopDecoration.style.transform = `scale3d(${math.fit(this.hoverRatio, 0, .7, 0, 1, ease.cubicInOut)}, 1, 1)`;
            let g = math.fit(this.hoverRatio, .2, 1, 0, 1, ease.cubicInOut);
            this.domTitleBottomLeftDecoration.style.transform = `scale3d(${math.fit(g, 0, .35, 0, 1)}, 1, 1)`,
            this.domTitleBottomRightDecoration.style.transform = `scale3d(${math.fit(g, .4, 1, 0, 1)}, 1, 1)`
        } else
            this._needsReset = !0,
            flipAnimation.isActive = !1;
        flipAnimation.update(e)
    }
    _splitText() {
        if (properties.useMobileLayout)
            this.domSubtitle._splitted && this.domSubtitle._splitted.revert();
        else {
            this.domSubtitle._splitted = new SplitType(this.domSubtitle,{
                types: "lines, words"
            });
            for (let e = 0; e < this.domSubtitle._splitted.lines.length; e++) {
                let t = this.domSubtitle._splitted.lines[e]
                  , r = document.createElement("div");
                r.style.position = "relative",
                r.style.overflow = "hidden",
                r.append(t),
                this.domSubtitle.append(r)
            }
        }
        this.domTitleLink._splitted = new SplitType(this.domTitleLink,{
            types: "lines, words",
            lineClass: "end-section-title-link-line",
            wordClass: "end-section-title-link-word"
        });
        for (let e = 0; e < this.domTitleLink._splitted.lines.length; e++) {
            let t = this.domTitleLink._splitted.lines[e];
            e === 0 ? t.append(this.domTitleTopDecoration) : (t.append(this.domTitleBottomLeftDecoration),
            t.append(this.domTitleBottomRightDecoration))
        }
        for (let e = 0; e < this.domTitleLink._splitted.words.length; e++) {
            let t = this.domTitleLink._splitted.words[e]
              , r = new SplitType(t,{
                types: "chars"
            });
            t._chars = r.chars,
            t._ratio = 0;
            for (let n = 0; n < t._chars.length; n++) {
                let o = t._chars[n]
                  , l = o.cloneNode(!0)
                  , c = document.createElement("div");
                c.classList.add("char-wrapper"),
                c.style.display = "inline-block",
                o._wrapper = c,
                c.append(o),
                c.append(l),
                t.append(c)
            }
        }
    }
    _reset() {
        this._needsReset = !1,
        this.time = 0,
        this.hoverRatio = 0,
        this.activeRatio = 0;
        for (let e = 0; e < this.domTitleLink._splitted.words.length; e++) {
            let t = this.domTitleLink._splitted.words[e];
            for (let r = 0; r < t._chars.length; r++) {
                let n = t._chars[r];
                n._wrapper.style.transform = "translate3d(0, 0, 0)",
                n.style.transform = "translate3d(0, 0, 0)"
            }
        }
        flipAnimation.needsReset = !0
    }
    _onDomTitleMouseenter() {
        this.isHover = !0
    }
    _onDomTitleMouseleave() {
        this.isHover = !1
    }
}
const endSection = new EndSection;
class ScrollNavSection {
    domContainer;
    domText;
    overScrollRatio = 0;
    downWaitTime = 0;
    _needsReset = !0;
    path = "";
    preInit() {
        this.domContainer = document.getElementById("scroll-nav-section"),
        this.domText = document.getElementById("scroll-nav-text"),
        this.barInner = document.getElementById("scroll-nav-next-bar-inner")
    }
    init() {}
    resize(e, t) {}
    update(e) {
        let r = scrollManager.getDomRange(this.domContainer).isActive
          , n = scrollManager.scrollPixel >= scrollManager.contentSize * scrollManager.viewSizePixel - 5
          , o = (input.deltaDragScrollY + input.deltaWheel) * (scrollManager.isActive && pagesManager.isIdle ? 1 : 0);
        if (this.downWaitTime = o > 0 ? .3 : Math.max(0, this.downWaitTime - e),
        this.overScrollRatio = r ? math.saturate(this.overScrollRatio + e * (n && o > 0 ? 2 : this.downWaitTime > 0 ? 0 : o < 0 ? -5 : -.2) * (pagesManager.isIdle ? 1 : 0)) : 0,
        r) {
            let l = pagesManager.currRoute;
            this.barInner.style.transform = `scaleX(${this.overScrollRatio})`,
            scrollManager.isActive && pagesManager.isIdle && (this.path !== l.scrollNavPath && (this.path = l.scrollNavPath,
            this.domText.innerHTML = l.scrollNavText),
            this.overScrollRatio == 1 && routeManager.setPath(this.path))
        }
    }
}
const scrollNavSection = new ScrollNavSection;
class PageExtraSections {
    isActive = !0;
    domContainer;
    _needsResize = !1;
    preUfxContainer = new Object3D;
    postUfxContainer = new Object3D;
    preInit() {
        preUfx.scene.add(this.preUfxContainer),
        postUfx.scene.add(this.postUfxContainer),
        this.domContainer = document.querySelector("#page-extra-sections"),
        endSection.preInit(),
        footerSection.preInit(),
        scrollNavSection.preInit()
    }
    init() {
        endSection.init(),
        footerSection.init(),
        scrollNavSection.init()
    }
    resize(e, t) {
        this.preUfxContainer.visible = this.postUfxContainer.visible = !1,
        pagesManager.scrollTargetPage && (pagesManager.scrollTargetPage.hasExtraPages ? (this.preUfxContainer.visible = this.postUfxContainer.visible = !0,
        this._needsResize = !1,
        this.domContainer.style.display = "block",
        endSection.resize(e, t),
        footerSection.resize(e, t),
        scrollNavSection.resize(e, t)) : (this.domContainer.style.display = "none",
        this._needsResize = !0))
    }
    update(e) {
        this.preUfxContainer.visible = this.postUfxContainer.visible = !1,
        pagesManager.scrollTargetPage && (pagesManager.scrollTargetPage.hasExtraPages ? (this.preUfxContainer.visible = this.postUfxContainer.visible = !0,
        this._needsResize && this.resize(properties.viewportWidth, properties.viewportHeight),
        this.domContainer.style.display = "block",
        endSection.update(e),
        footerSection.update(e),
        scrollNavSection.update(e)) : (this.domContainer.style.display = "none",
        this._needsResize = !0))
    }
}
const pageExtraSections = new PageExtraSections;
let LOADING_RECTS = [1, 1, 1, 3, 2, 4, 2, 1, 6, 2, 1, 2, 7, 1, 1, 1, 7, 4, 1, 1, 8, 2, 1, 2, 11, 2, 1, 3, 13, 2, 1, 3, 12, 1, 1, 1, 16, 1, 2, 1, 18, 2, 1, 2, 16, 4, 2, 1, 22, 1, 1, 4, 26, 1, 1, 4, 27, 1, 1, 1, 28, 2, 1, 3, 32, 1, 1, 1, 33, 3, 1, 1, 31, 1, 1, 3, 32, 4, 2, 1];
class TransitionOverlay {
    contentShowRatio = 0;
    contentHideRatio = 1;
    loadBarRatio = 0;
    lineTransformRatio = 0;
    showTextRatio = 0;
    waitTextRatio = 0;
    hideTextRatio = 1;
    pixelWidth = 0;
    needsShowText = !1;
    needsHideText = !1;
    loadingTextAnimation = 0;
    onShowTextCompleted = new MinSignal$2;
    onHideTextCompleted = new MinSignal$2;
    init() {
        this.canvas = document.getElementById("transition-overlay"),
        this.ctx = this.canvas.getContext("2d")
    }
    resize(e, t) {
        this.canvas.width = e * settings.DPR,
        this.canvas.height = t * settings.DPR,
        this.canvas.style.width = e + "px",
        this.canvas.style.height = t + "px",
        this.pixelWidth = ~~Math.min(42, properties.viewportWidth / 30)
    }
    isReadyToHide() {}
    get activeRatio() {
        return Math.min(1 - this.contentShowRatio, this.contentHideRatio)
    }
    update(e) {
        if (this.activeRatio > 0) {
            let t = properties.viewportWidth
              , r = properties.viewportHeight
              , n = this.pixelWidth
              , o = this.loadBarRatio
              , l = this.lineTransformRatio
              , c = Math.sqrt(t * t + r * r) / n
              , u = this.ctx;
            u.save(),
            u.scale(settings.DPR, settings.DPR),
            u.fillStyle = "#000",
            u.fillRect(0, 0, t, r);
            let f = ease.expoInOut(1 - this.activeRatio)
              , p = (1 + f * c) * n;
            if (u.translate(t * .5, r * .5),
            u.rotate(f * (this.contentShowRatio == 0 ? -1 : 1)),
            u.translate(n * f * c, -n * .5 * f * c),
            u.scale(p, p),
            l == 0)
                u.fillStyle = "#333",
                u.fillRect(-2.5, -.5, 5, 1),
                u.fillStyle = "#fff",
                u.fillRect(-2.5, -.5, 5 * o, 1);
            else {
                u.fillStyle = "#fff",
                this.needsShowText && (this.showTextRatio = this.showTextRatio + e * 1.25,
                this.showTextRatio >= 1 && (this.showTextRatio = 1,
                this.needsShowText = !1,
                this.onShowTextCompleted.dispatch())),
                this.showTextRatio == 1 && (this.waitTextRatio = Math.min(1, this.waitTextRatio + e * 3),
                this.waitTextRatio == 1 && this.needsHideText && taskManager.percent == 1 && (this.hideTextRatio = this.hideTextRatio + e * 1.25,
                this.hideTextRatio >= 1 && (this.hideTextRatio = 1,
                this.needsHideText = !1,
                this.onHideTextCompleted.dispatch())));
                let g = this.showTextRatio
                  , v = this.hideTextRatio
                  , _ = math.fit(Math.min(g, 1 - v), 0, .5, 1, .2, ease.expoInOut)
                  , w = (ease.expoInOut(g) + ease.expoInOut(v)) * -15;
                if (g > 0 && v < 1) {
                    u.scale(_, _),
                    u.translate(-l, 1.5 * l),
                    u.translate(w, 0),
                    u.save(),
                    u.translate(-1.5, -4.5),
                    u.beginPath();
                    for (let S = 0, b = LOADING_RECTS.length / 4, C = 0; S < b; S++,
                    C += 4) {
                        u.fillStyle = "#fff";
                        let R = LOADING_RECTS[C + 0]
                          , T = LOADING_RECTS[C + 1]
                          , M = LOADING_RECTS[C + 2]
                          , P = LOADING_RECTS[C + 3]
                          , I = S / (b - 1)
                          , k = math.fit(g, I * .5, .5 + I * .5, 0, 1, ease.expoIn) * math.fit(v, I * .5, .5 + I * .5, 1, 0, ease.expoOut);
                        g < 1 ? S < 2 && (k = 1) : S >= b - 2 && (k = 1),
                        u.rect(R + (1 - k) * M * .5, T + (1 - k) * P * .5, M * k, P * k)
                    }
                    u.closePath(),
                    u.fill(),
                    u.restore()
                } else
                    u.translate(-l, 1.5 * l),
                    u.save(),
                    u.translate(.5, -.5),
                    u.rotate(l * Math.PI * .5),
                    u.globalCompositeOperation = "xor",
                    u.fillRect(-3, 0, 3, 1),
                    u.globalCompositeOperation = "source-over",
                    u.globalAlpha = 1 - f,
                    u.fillRect(-3, 0, 3, 1),
                    u.restore(),
                    u.save(),
                    u.translate(.5, -.5),
                    u.globalCompositeOperation = "xor",
                    u.fillRect(0, 0, 2, 1),
                    u.globalCompositeOperation = "source-over",
                    u.globalAlpha = 1 - f,
                    u.fillRect(0, 0, 2, 1),
                    u.restore()
            }
            u.restore(),
            this.canvas.style.display = "block"
        } else
            this.canvas.style.display = "none"
    }
}
const transitionOverlay = new TransitionOverlay;
class PageManager {
    pages = {};
    pageList = [homePage, aboutPage, projectPage, projectsPage, playgroundPage];
    scrollTargetPage = null;
    domContainer = null;
    domInner = null;
    prevRoute = null;
    currRoute = null;
    _defaultRoute;
    _pendingRoute;
    _isHiding = !1;
    _isShowing = !1;
    _hasPreloaded = !0;
    isFirstRoute = !0;
    _needsShowLoading = !1;
    onIdled = new MinSignal$2;
    onScrollTargetChanged = new MinSignal$2;
    NEEDS_LOG = !1;
    constructor() {
        this._defaultRoute = new Route(void 0),
        this.prevRoute = this.currRoute = this._defaultRoute;
        for (let e = 0; e < this.pageList.length; e++) {
            let t = this.pageList[e];
            this.pages[t.id] = t,
            routeManager.addPath(t.path, t),
            preUfx.scene.add(t.preUfxContainer),
            postUfx.scene.add(t.postUfxContainer)
        }
        transitionOverlay.onShowTextCompleted.add(this._onShowTextComplete, this),
        transitionOverlay.onHideTextCompleted.add(this._onHideTextComplete, this),
        taskManager.onCompleted.add(this._onTaskComplete, this)
    }
    preInit() {
        this.domContainer = document.getElementById("page-container"),
        this.domContainerInner = document.getElementById("page-container-inner"),
        routeManager.onRouteChanged.add(this._onRouteChanged, this),
        this._onRouteChanged(routeManager.currRoute)
    }
    get isIdle() {
        return !this._isHiding && this._hasPreloaded && !this._isShowing && !this._needsShowLoading
    }
    _onRouteChanged(e) {
        if (!this.isIdle)
            this._pendingRoute = e;
        else if (this.currRoute !== e) {
            this.prevRoute = this.currRoute,
            this.currRoute = e;
            let t = this.currRoute.target;
            if (t.domContainer || (t.domContainer = this.currRoute.dom,
            this._log("preInit: " + this.currRoute.path),
            t.preInit(this.currRoute),
            properties.hasInitialized && !t.bypassShowingLoading && (this._needsShowLoading = !0)),
            properties.hasInitialized ? this._hasPreloaded = !1 : (this.scrollTargetPage = t,
            this.onScrollTargetChanged.dispatch(t)),
            this.currRoute.hasContentPreloaded || (this._log("preInitContent: " + this.currRoute.path),
            t.preInitContent(this.currRoute)),
            properties.hasInitialized) {
                transitionOverlay.showTextRatio = 0,
                transitionOverlay.waitTextRatio = 0,
                transitionOverlay.hideTextRatio = 0,
                transitionOverlay.needsShowText = !1,
                transitionOverlay.needsHideText = !1;
                let r = this.prevRoute.target;
                this._isHiding = !0,
                this._log("hide page", r.id),
                r.onHideStarted.dispatch(),
                r.hide(this.prevRoute, this.currRoute, () => {
                    this._isHiding = !1,
                    this._needsShowLoading ? transitionOverlay.needsShowText = !0 : this._hasPreloaded && this._onHideComplete()
                }
                ),
                r.useGenericTransition && audios.countPlay("page"),
                properties.loader.start(n => {
                    n == 1 && (this._hasPreloaded = !0,
                    this._isHiding || (this._needsShowLoading ? transitionOverlay.showTextRatio == 1 && this._onHideComplete() : this._onHideComplete()))
                }
                )
            }
        }
    }
    _onShowTextComplete() {
        this._hasPreloaded && this._onHideComplete()
    }
    _onHideTextComplete() {
        this._showPage()
    }
    _onTaskComplete() {
        this.isFirstRoute
    }
    init() {
        this._initPage()
    }
    _initPage() {
        let e = this.currRoute.target;
        e.hasInitialized || (this._log("init: " + this.currRoute.path),
        e.init(this.currRoute),
        e.hasInitialized = !0),
        this.currRoute.hasContentPreloaded || (this.currRoute.hasContentPreloaded = !0,
        this._log("initContent: " + this.currRoute.path),
        e.initContent(this.currRoute)),
        taskManager.start()
    }
    _onHideComplete() {
        if (this._initPage(),
        this.prevRoute.target) {
            let e = this.prevRoute.target;
            e.onHideCompleted.dispatch(),
            this._log("hide page complete: " + this.prevRoute.path),
            e.isActive = !1,
            e !== this.currRoute.target && (e.domContainer.remove(),
            e.preUfxContainer.visible = !1,
            e.postUfxContainer.visible = !1)
        }
        this._needsShowLoading ? transitionOverlay.needsHideText = !0 : this._showPage()
    }
    resize(e, t) {
        this.prevRoute.target && this.prevRoute.target.isActive && this.prevRoute.target !== this.currRoute.target && this.prevRoute.target.hasInitialized && this.prevRoute.target.resize(e, t),
        this.currRoute && this.currRoute.target.isActive && this.currRoute.target.resize(e, t)
    }
    start() {
        this._showPage()
    }
    _showPage() {
        this._isShowing = !0,
        this._needsShowLoading = !1;
        let e = this.currRoute.target;
        e.isActive = !0,
        properties.hasInitialized && e !== this.prevRoute.target && (this.domContainerInner.prepend(e.domContainer),
        e.time = 0),
        document.title = this.currRoute.title,
        this.scrollTargetPage = e,
        e.preUfxContainer.visible = !0,
        e.postUfxContainer.visible = !0,
        this.onScrollTargetChanged.dispatch(e),
        this._log("show page: " + this.currRoute.path),
        pageExtraSections.resize(properties.viewportWidth, properties.viewportHeight),
        scrollManager.resize(properties.viewportWidth, properties.viewportHeight),
        scrollManager.scrollToPixel(0, !0),
        e.resize(properties.viewportWidth, properties.viewportHeight),
        e.onShowStarted.dispatch(),
        e.show(this.prevRoute, this.currRoute, this._onShowComplete.bind(this)),
        e.useGenericTransition && audios.countPlay("page")
    }
    _onShowComplete() {
        if (transitionOverlay.contentShowRatio = 1,
        this._isShowing = !1,
        this.isFirstRoute = !1,
        this.currRoute.target.isFirstShown = !0,
        this.currRoute.target.onShowCompleted.dispatch(),
        this._log("==============="),
        this._pendingRoute) {
            let e = this._pendingRoute;
            this._pendingRoute = null,
            this._onRouteChanged(e)
        } else
            this.onIdled.dispatch();
        properties.isContactFromProjectPage && (properties.isContactFromProjectPage = !1,
        scrollManager.scrollTo("footer-section", 0, !1))
    }
    update(e) {
        if (this.prevRoute.target && this.prevRoute.target.isActive && this.prevRoute.target !== this.currRoute.target && this.prevRoute.target.hasInitialized) {
            let t = this.prevRoute.target;
            t.time += e,
            t.update(e)
        }
        if (this.currRoute && this.currRoute.target.isActive) {
            let t = this.currRoute.target;
            t.time += e,
            t.update(e)
        }
        if (!this.isFirstRoute) {
            (this._isHiding || !this._hasPreloaded) && !this._isShowing && this.prevRoute.target.useGenericTransition && (transitionOverlay.contentHideRatio = this.prevRoute.target.hideRatio,
            transitionOverlay.contentShowRatio = 0),
            this._isShowing && this.currRoute.target && this.currRoute.target.useGenericTransition && (transitionOverlay.contentHideRatio = 1,
            transitionOverlay.contentShowRatio = this.currRoute.target.showRatio);
            let t = 1;
            this.prevRoute != this.currRoute && (this._isHiding && !this.prevRoute.target.useGenericTransition && (t *= math.fit(this.prevRoute.target.hideRatio, 0, .5, 1, 0)),
            this._isShowing && !this.currRoute.target.useGenericTransition && (t *= math.fit(this.currRoute.target.showRatio, .5, 1, 0, 1))),
            this.domContainer.style.opacity = t
        }
    }
    _log(e) {}
}
const pagesManager = new PageManager;
class ScrollPane {
    lockOnDirection = !0;
    isActive = !1;
    x;
    y;
    viewDom;
    contentDom;
    isVertical = !0;
    targetScrollPixel = 0;
    scrollViewDelta = 0;
    viewWidthPixel = 0;
    viewHeightPixel = 0;
    contentSize = 0;
    contentSizePixel = 0;
    scrollView = 0;
    progress = 0;
    minScrollPixel = .1;
    viewSizePixel = 1;
    scrollMultiplier = (browser$1.isMobile,
    1);
    domRanges = new Map;
    useResizeObserver = !0;
    tick = -1;
    lastResizeTick = -1;
    resizeObserveTick = -1;
    hasResizeObserved = !1;
    autoScrollSpeed = 0;
    autoScrollRatio = 0;
    skipAutoScroll = !1;
    dragHistory = [];
    dragHistoryMaxTime = .1;
    isWheelScrolling = !1;
    frictionCoeffFrom = 2.1;
    frictionCoeffTo = 1.9;
    frictionCoeffWeightDivisor = 5;
    minVelocity = -1;
    wheelEaseCoeff = 12;
    scrollPixel = 0;
    init(e={}) {
        Object.assign(this, e),
        this.contentDom && this.useResizeObserver && window.ResizeObserver && new ResizeObserver(this._onResizeObserve.bind(this)).observe(this.contentDom),
        document.documentElement.addEventListener("keydown", t => {
            this.isMoveable && (this.isVertical ? t.key === "ArrowUp" ? this.scrollToPixel(this.scrollPixel - 100) : t.key === "ArrowDown" && this.scrollToPixel(this.scrollPixel + 100) : t.key === "ArrowLeft" ? this.scrollToPixel(this.scrollPixel - 100) : t.key === "ArrowRight" && this.scrollToPixel(this.scrollPixel + 100),
            t.key === "PageUp" ? this.scrollToPixel(this.scrollPixel - this.viewSizePixel) : t.key === "PageDown" && this.scrollToPixel(this.scrollPixel + this.viewSizePixel))
        }
        )
    }
    _onResizeObserve() {
        this.hasResizeObserved = !0,
        this.resizeObserveTick = this.tick
    }
    getDomRange(e, t=0, r=!1) {
        let n = this.domRanges.get(e);
        return n || this.domRanges.set(e, n = new ScrollDomRange(e,this.isVertical)),
        n.update(this.scrollPixel, this.viewSizePixel, t, r),
        n
    }
    scrollTo(e, t=0, r=!1) {
        if (e = typeof e == "string" ? document.getElementById(e) : e,
        e) {
            let n = this.getDomRange(e);
            this.scrollToPixel(n.top + t * this.viewSizePixel, r)
        }
    }
    scrollToPixel(e=0, t=!1) {
        e = this._clampScrollPixel(e),
        t ? (this.resetScroll(e),
        this.progress = this.contentSize > 0 ? e / this.contentSizePixel : 0) : (this.resetScroll(this.scrollPixel),
        this.targetScrollPixel = e,
        this.isWheelScrolling = !0,
        this.skipAutoScroll = !0),
        this.syncDom()
    }
    getEaseInOutOffset(e, t, r=0, n=.5) {
        let o = 1.5 + n
          , l = (o - 1) * 2 + r
          , c = 0
          , u = o
          , f = u + r
          , p = f + o
          , g = t * p / l
          , v = e + g * .5 - t * .5
          , _ = Math.min(1, v / g);
        if (_ > 0) {
            let S = _ * p;
            var w = S;
            if (S > c && S <= u) {
                let b = (S - c) / (u - c);
                w = math.cubicBezier(c, (u - c) / 3 + c, 1, 1, b)
            } else if (S > u && S <= f)
                w = 1;
            else if (S > f && S <= p) {
                let b = (S - f) / (p - f);
                w = math.cubicBezier(1, 1, -(p - f) / 3 + 2, 2, b)
            } else
                S > p && (w = S - l);
            return (S - w) / l * t
        }
        return 0
    }
    resize(e, t) {
        if (this.domRanges.forEach(n => {
            n.needsUpdate = !0
        }
        ),
        this.viewDom) {
            let n = this.viewDom.getBoundingClientRect();
            e = n.width,
            t = n.height
        }
        this.viewWidthPixel = e,
        this.viewHeightPixel = t;
        let r = this.isVertical ? t : e;
        if (this.contentDom) {
            let n = this.contentDom.getBoundingClientRect();
            this.contentSize = Math.max(0, (this.isVertical ? n.height : n.width) / r - 1)
        }
        this.contentSizePixel = Math.floor(this.contentSize * r),
        this.targetScrollPixel = this.contentSizePixel * this.progress,
        this.resetScroll(this.targetScrollPixel),
        this.viewSizePixel = r,
        this.lastResizeTick = this.tick,
        this.syncDom()
    }
    _clampScrollPixel(e) {
        return math.clamp(e, 0, this.contentSizePixel)
    }
    resetScroll(e) {
        this.targetScrollPixel = this.scrollPixel = e,
        this.velocityPixel = 0,
        this.dragHistory.length = 0
    }
    update(e, t) {
        this.hasResizeObserved && (this.hasResizeObserved = !1,
        this.resizeObserveTick !== this.lastResizeTick && this.resize(this.viewWidthPixel, this.viewHeightPixel));
        let r = this.scrollView
          , n = input.isDown && (!this.lockOnDirection && (input.isDragScrollingY || input.isDragScrollingX) || this.isVertical && input.isDragScrollingY || !this.isVertical && input.isDragScrollingX)
          , o = 0;
        if (input.isDown && !input.wasDown && (this.dragHistory.length = 0),
        this.isMoveable) {
            let l = 0;
            this.isVertical ? input.isWheelScrolling || input.isDragScrollingY ? l = input.deltaScrollY : !this.lockOnDirection && input.isDragScrollingX && (l = -input.deltaPixelXY.y + input.deltaWheel) : input.isWheelScrolling || input.isDragScrollingX ? l = input.deltaScrollX : !this.lockOnDirection && input.isDragScrollingY && (l = -input.deltaPixelXY.x + input.deltaWheel),
            input.isWheelScrolling && (this.isWheelScrolling = !0),
            l !== 0 && (this.skipAutoScroll = !1),
            this.autoScrollRatio = math.saturate(this.autoScrollRatio + (Math.abs(this.autoScrollSpeed) > 0 && l == 0 ? e : -1));
            let c = this.autoScrollSpeed * this.viewSizePixel * e * (this.skipAutoScroll ? 0 : this.autoScrollRatio)
              , u = properties.time;
            if (n) {
                for (this.dragHistory.push({
                    time: u,
                    deltaTime: e,
                    deltaPixel: l
                }); this.dragHistory.length > 0 && u - this.dragHistory[0].time > this.dragHistoryMaxTime; )
                    this.dragHistory.shift();
                this.targetScrollPixel = this.scrollPixel,
                this.isWheelScrolling = !1,
                o = l
            } else if (input.isDown && this.resetScroll(this.scrollPixel),
            this.isWheelScrolling) {
                this.dragHistory.length = 0,
                this.velocityPixel = 0,
                this.targetScrollPixel += l,
                this.targetScrollPixel = this._clampScrollPixel(this.targetScrollPixel);
                let f = this.targetScrollPixel - this.scrollPixel;
                o = f * (1 - Math.exp(-this.wheelEaseCoeff * e)),
                Math.abs(f) < this.minScrollPixel && (o = f,
                this.isWheelScrolling = !1)
            } else {
                if (this.dragHistory.length > 0) {
                    let g = 0
                      , v = 0;
                    for (let _ = 0; _ < this.dragHistory.length; _++) {
                        let w = this.dragHistory[_];
                        if (w.time > 0) {
                            let S = w.deltaPixel / w.deltaTime
                              , b = w.deltaTime
                              , C = this.dragHistory.length == 1 ? 1 : (w.time - this.dragHistory[0].time) / this.dragHistoryMaxTime
                              , R = b * C;
                            v += S * R,
                            g += R
                        }
                    }
                    this.velocityPixel = v / g,
                    this.dragHistory.length = 0
                }
                let p = -math.mix(this.frictionCoeffFrom, this.frictionCoeffTo, math.clamp(Math.abs(this.velocityPixel / this.viewSizePixel / this.frictionCoeffWeightDivisor), 0, 1)) * this.velocityPixel;
                this.velocityPixel += p * e,
                o = this.velocityPixel * e
            }
            this.targetScrollPixel += c,
            this.scrollPixel += c
        }
        this.scrollPixel = this._clampScrollPixel(this.scrollPixel + o),
        this.scrollView = this.scrollPixel / this.viewSizePixel,
        this.scrollViewDelta = this.scrollView - r,
        this.progress = this.contentSize > 0 ? this.scrollPixel / this.contentSizePixel : 0,
        Math.abs(this.targetScrollPixel - this.scrollPixel) < this.minScrollPixel && (this.scrollPixel = this.targetScrollPixel),
        Math.abs(this.velocityPixel) <= this.minVelocity && (this.velocityPixel = 0),
        this.isScrolling = this.targetScrollPixel !== this.scrollPixel || Math.abs(this.velocityPixel) > 0,
        this.syncDom(),
        this.tick++
    }
    syncDom() {
        this.contentDom && (this.x = 0,
        this.y = 0,
        this.isVertical ? this.y = -this.scrollPixel : this.x = -this.scrollPixel,
        this.contentDom.style.transform = `translate3d(${this.x}px, ${this.y}px, 0px)`)
    }
    get isMoveable() {
        return this.isActive && !videoOverlay.isOpened && pagesManager.isIdle && !header.menu.opened && this.contentSize > 0 && (!this.viewDom || input.hasThroughElem(this.viewDom, "down"))
    }
}
class ScrollManager extends ScrollPane {
    domScrollIndicator;
    domScrollIndicatorHeight = 1;
    domScrollIndicatorBar;
    scrollIndicatorActiveRatio = 0;
    lastMouseInteractiveTime = -1 / 0;
    isIndicatorActive = void 0;
    easedScrollStrength = 0;
    frameIdx = -1;
    MIN_BAR_SCALE_Y = 2 / 10;
    init() {
        super.init({
            contentDom: document.getElementById("page-container"),
            domScrollIndicator: document.getElementById("scroll-indicator"),
            domScrollIndicatorBar: document.getElementById("scroll-indicator-bar")
        })
    }
    resize(e, t) {
        super.resize(e, t),
        this.domScrollIndicatorHeight = this.domScrollIndicator.getBoundingClientRect().height
    }
    update(e) {
        super.update(e, this.scrollValue),
        this.easedScrollStrength += Math.abs(this.scrollViewDelta),
        this.easedScrollStrength += (0 - this.easedScrollStrength) * (1 - Math.exp(-10 * e)),
        this.easedScrollStrength = Math.min(this.easedScrollStrength, 1),
        Math.abs(this.scrollViewDelta) > 0 ? (this.lastMouseInteractiveTime = properties.time,
        this.isIndicatorActive = !0) : properties.time > this.lastMouseInteractiveTime + .5 && (this.isIndicatorActive = !1),
        this.scrollIndicatorActiveRatio = math.clamp(this.scrollIndicatorActiveRatio + (this.isIndicatorActive ? 2 : -2) * e, 0, 1),
        this.domScrollIndicator.style.opacity = this.scrollIndicatorActiveRatio;
        let r = 1
          , n = 0;
        this.contentSize > 0 && (r = Math.max(this.MIN_BAR_SCALE_Y, 1 / (1 + this.contentSize)),
        n = this.scrollView / this.contentSize * (1 - r)),
        this.domScrollIndicatorBar.style.height = this.domScrollIndicatorHeight * r + "px",
        this.domScrollIndicatorBar.style.transform = "translate3d(0," + this.domScrollIndicatorHeight * n + "px,0)",
        this.frameIdx++
    }
    get isMoveable() {
        return super.isMoveable
    }
}
const scrollManager = new ScrollManager;
let _geom;
class Postprocessing {
    width = 1;
    height = 1;
    scene = null;
    camera = null;
    resolution = new Vector2(0,0);
    texelSize = new Vector2(0,0);
    aspect = new Vector2(1,1);
    onBeforeSceneRendered = new MinSignal$2;
    onAfterSceneRendered = new MinSignal$2;
    onAfterRendered = new MinSignal$2;
    sceneRenderTarget = null;
    fromRenderTarget = null;
    toRenderTarget = null;
    useDepthTexture = !0;
    depthTexture = null;
    fromTexture = null;
    toTexture = null;
    sceneTexture = null;
    mesh = null;
    queue = [];
    sharedUniforms = {};
    geom;
    hasSizeChanged = !0;
    init(e) {
        if (Object.assign(this, e),
        _geom ? this.geom = _geom : (this.geom = _geom = new BufferGeometry,
        this.geom.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0, 4, -1, 0, -1, 4, 0]),3)),
        this.geom.setAttribute("a_uvClamp", new BufferAttribute(new Float32Array([0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]),4))),
        this.sceneFlatRenderTarget = fboHelper.createRenderTarget(1, 1),
        this.sceneFlatRenderTarget.depthBuffer = !0,
        this.sceneMsRenderTarget = fboHelper.createMultisampleRenderTarget(1, 1),
        this.sceneMsRenderTarget.depthBuffer = !0,
        this.fromRenderTarget = fboHelper.createRenderTarget(1, 1),
        this.toRenderTarget = this.fromRenderTarget.clone(),
        this.useDepthTexture = !!this.useDepthTexture && fboHelper.renderer && (fboHelper.renderer.capabilities.isWebGL2 || fboHelper.renderer.extensions.get("WEBGL_depth_texture")),
        this.fromTexture = this.fromRenderTarget.texture,
        this.toTexture = this.toRenderTarget.texture,
        this.sceneRenderTarget = this.sceneMsRenderTarget,
        this.sceneTexture = this.sceneMsRenderTarget.texture,
        this.mesh = new Mesh,
        this.sharedUniforms = Object.assign(this.sharedUniforms, {
            u_sceneTexture: {
                value: this.sceneTexture
            },
            u_fromTexture: {
                value: null
            },
            u_toTexture: {
                value: null
            },
            u_sceneDepthTexture: {
                value: null
            },
            u_cameraNear: {
                value: 0
            },
            u_cameraFar: {
                value: 1
            },
            u_cameraFovRad: {
                value: 1
            },
            u_resolution: {
                value: this.resolution
            },
            u_texelSize: {
                value: this.texelSize
            },
            u_aspect: {
                value: this.aspect
            }
        }),
        this.useDepthTexture && fboHelper.renderer) {
            const t = new DepthTexture(this.resolution.width,this.resolution.height);
            fboHelper.renderer.capabilities.isWebGL2 ? t.type = UnsignedIntType : (t.format = DepthStencilFormat,
            t.type = UnsignedInt248Type),
            t.minFilter = NearestFilter,
            t.magFilter = NearestFilter,
            this.sceneFlatRenderTarget.depthTexture = t,
            this.sceneMsRenderTarget.depthTexture = t,
            this.depthTexture = this.sharedUniforms.u_sceneDepthTexture.value = t
        }
    }
    swap() {
        const e = this.fromRenderTarget;
        this.fromRenderTarget = this.toRenderTarget,
        this.toRenderTarget = e,
        this.fromTexture = this.fromRenderTarget.texture,
        this.toTexture = this.toRenderTarget.texture,
        this.sharedUniforms.u_fromTexture.value = this.fromTexture,
        this.sharedUniforms.u_toTexture.value = this.toTexture
    }
    setSize(e, t) {
        if (this.width !== e || this.height !== t) {
            this.hasSizeChanged = !0,
            this.width = e,
            this.height = t,
            this.resolution.set(e, t),
            this.texelSize.set(1 / e, 1 / t);
            const r = t / Math.sqrt(e * e + t * t) * 2;
            this.aspect.set(e / t * r, r),
            this.sceneFlatRenderTarget.setSize(e, t),
            this.sceneMsRenderTarget.setSize(e, t),
            this.fromRenderTarget.setSize(e, t),
            this.toRenderTarget.setSize(e, t)
        }
    }
    dispose() {
        this.fromRenderTarget && this.fromRenderTarget.dispose(),
        this.toRenderTarget && this.toRenderTarget.dispose(),
        this.sceneMsRenderTarget && this.sceneMsRenderTarget.dispose(),
        this.sceneFlatRenderTarget && this.sceneFlatRenderTarget.dispose()
    }
    _filterQueue(e) {
        return e.enabled && e.needsRender()
    }
    renderMaterial(e, t) {
        this.mesh.material = e,
        fboHelper.renderMesh(this.mesh, t)
    }
    checkSceneRt() {
        this.sceneRenderTarget = properties.isSmaaEnabled ? this.sceneFlatRenderTarget : this.sceneMsRenderTarget,
        this.sceneTexture = this.sceneRenderTarget.texture,
        this.sharedUniforms.u_sceneTexture.value = this.sceneTexture
    }
    render(e, t, r) {
        if (!fboHelper.renderer)
            return;
        this.scene = e,
        this.camera = t,
        this.mesh.geometry = this.geom;
        const n = this.queue.filter(this._filterQueue)
          , o = this.sharedUniforms;
        if (n.sort( (l, c) => l.renderOrder == c.renderOrder ? 0 : l.renderOrder - c.renderOrder),
        this.checkSceneRt(),
        o.u_cameraNear.value = t.near,
        o.u_cameraFar.value = t.far,
        o.u_cameraFovRad.value = t.fov / 180 * Math.PI,
        this.onBeforeSceneRendered.dispatch(),
        n.length) {
            fboHelper.renderer.setRenderTarget(this.sceneRenderTarget),
            fboHelper.renderer.render(e, t),
            fboHelper.renderer.setRenderTarget(null),
            fboHelper.copy(this.sceneRenderTarget.texture, this.fromRenderTarget),
            this.onAfterSceneRendered.dispatch(this.sceneRenderTarget);
            const l = fboHelper.getColorState();
            fboHelper.renderer.autoClear = !1;
            for (let c = 0, u = n.length; c < u; c++) {
                const f = c === u - 1 && r
                  , p = n[c];
                p.setPostprocessing(this),
                p.render(this, f)
            }
            fboHelper.setColorState(l)
        } else
            fboHelper.renderer.render(e, t),
            this.onAfterSceneRendered.dispatch();
        this.onAfterRendered.dispatch(),
        this.hasSizeChanged = !1
    }
}
const smaaBlendVert = `#define GLSLIFY 1
attribute vec3 position;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[2];void SMAANeighborhoodBlendingVS(vec2 texcoord){v_offsets[0]=texcoord.xyxy+u_texelSize.xyxy*vec4(-1.0,0.0,0.0,1.0);v_offsets[1]=texcoord.xyxy+u_texelSize.xyxy*vec4(1.0,0.0,0.0,-1.0);}void main(){v_uv=position.xy*0.5+0.5;SMAANeighborhoodBlendingVS(v_uv);gl_Position=vec4(position,1.0);}`
  , smaaBlendFrag = `#define GLSLIFY 1
uniform sampler2D u_weightsTexture;uniform sampler2D u_texture;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[2];vec4 SMAANeighborhoodBlendingPS(vec2 texcoord,vec4 offset[2],sampler2D colorTex,sampler2D blendTex){vec4 a;a.xz=texture2D(blendTex,texcoord).xz;a.y=texture2D(blendTex,offset[1].zw).g;a.w=texture2D(blendTex,offset[1].xy).a;if(dot(a,vec4(1.0,1.0,1.0,1.0))<1e-5){return texture2D(colorTex,texcoord,0.0);}else{vec2 offset;offset.x=a.a>a.b ? a.a :-a.b;offset.y=a.g>a.r ?-a.g : a.r;if(abs(offset.x)>abs(offset.y)){offset.y=0.0;}else{offset.x=0.0;}vec4 C=texture2D(colorTex,texcoord,0.0);texcoord+=sign(offset)*u_texelSize;vec4 Cop=texture2D(colorTex,texcoord,0.0);float s=abs(offset.x)>abs(offset.y)? abs(offset.x): abs(offset.y);C.xyz=pow(abs(C.xyz),vec3(2.2));Cop.xyz=pow(abs(Cop.xyz),vec3(2.2));vec4 mixed=mix(C,Cop,s);mixed.xyz=pow(abs(mixed.xyz),vec3(1.0/2.2));return mixed;}}void main(){gl_FragColor=SMAANeighborhoodBlendingPS(v_uv,v_offsets,u_texture,u_weightsTexture);}`
  , smaaEdgesVert = `#define GLSLIFY 1
attribute vec3 position;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[3];void SMAAEdgeDetectionVS(vec2 texcoord){v_offsets[0]=texcoord.xyxy+u_texelSize.xyxy*vec4(-1.0,0.0,0.0,1.0);v_offsets[1]=texcoord.xyxy+u_texelSize.xyxy*vec4(1.0,0.0,0.0,-1.0);v_offsets[2]=texcoord.xyxy+u_texelSize.xyxy*vec4(-2.0,0.0,0.0,2.0);}void main(){v_uv=position.xy*0.5+0.5;SMAAEdgeDetectionVS(v_uv);gl_Position=vec4(position,1.0);}`
  , smaaEdgesFrag = `#define GLSLIFY 1
uniform sampler2D u_texture;varying vec2 v_uv;varying vec4 v_offsets[3];vec4 SMAAColorEdgeDetectionPS(vec2 texcoord,vec4 offset[3],sampler2D colorTex){vec2 threshold=vec2(SMAA_THRESHOLD,SMAA_THRESHOLD);vec4 delta;vec3 C=texture2D(colorTex,texcoord).rgb;vec3 Cleft=texture2D(colorTex,offset[0].xy).rgb;vec3 t=abs(C-Cleft);delta.x=max(max(t.r,t.g),t.b);vec3 Ctop=texture2D(colorTex,offset[0].zw).rgb;t=abs(C-Ctop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0,1.0))==0.0)discard;vec3 Cright=texture2D(colorTex,offset[1].xy).rgb;t=abs(C-Cright);delta.z=max(max(t.r,t.g),t.b);vec3 Cbottom=texture2D(colorTex,offset[1].zw).rgb;t=abs(C-Cbottom);delta.w=max(max(t.r,t.g),t.b);float maxDelta=max(max(max(delta.x,delta.y),delta.z),delta.w);vec3 Cleftleft=texture2D(colorTex,offset[2].xy).rgb;t=abs(C-Cleftleft);delta.z=max(max(t.r,t.g),t.b);vec3 Ctoptop=texture2D(colorTex,offset[2].zw).rgb;t=abs(C-Ctoptop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(max(maxDelta,delta.z),delta.w);edges.xy*=step(0.5*maxDelta,delta.xy);return vec4(edges,0.0,0.0);}void main(){gl_FragColor=SMAAColorEdgeDetectionPS(v_uv,v_offsets,u_texture);}`
  , smaaWeightsVert = `#define GLSLIFY 1
attribute vec3 position;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[3];varying vec2 v_pixcoord;void SMAABlendingWeightCalculationVS(vec2 texcoord){v_pixcoord=texcoord/u_texelSize;v_offsets[0]=texcoord.xyxy+u_texelSize.xyxy*vec4(-0.25,0.125,1.25,0.125);v_offsets[1]=texcoord.xyxy+u_texelSize.xyxy*vec4(-0.125,0.25,-0.125,-1.25);v_offsets[2]=vec4(v_offsets[0].xz,v_offsets[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*u_texelSize.xxyy*float(SMAA_MAX_SEARCH_STEPS);}void main(){v_uv=position.xy*0.5+0.5;SMAABlendingWeightCalculationVS(v_uv);gl_Position=vec4(position,1.0);}`
  , smaaWeightsFrag = `#define GLSLIFY 1
#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * u_texelSize, 0.0 )
uniform sampler2D u_edgesTexture;uniform sampler2D u_areaTexture;uniform sampler2D u_searchTexture;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[3];varying vec2 v_pixcoord;vec2 round(vec2 x){return sign(x)*floor(abs(x)+0.5);}float SMAASearchLength(sampler2D searchTex,vec2 e,float bias,float scale){e.r=bias+e.r*scale;return 255.0*texture2D(searchTex,e,0.0).r;}float SMAASearchXLeft(sampler2D edgesTex,sampler2D searchTex,vec2 texcoord,float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<SMAA_MAX_SEARCH_STEPS;i++){e=texture2D(edgesTex,texcoord,0.0).rg;texcoord-=vec2(2.0,0.0)*u_texelSize;if(!(texcoord.x>end&&e.g>0.8281&&e.r==0.0))break;}texcoord.x+=0.25*u_texelSize.x;texcoord.x+=u_texelSize.x;texcoord.x+=2.0*u_texelSize.x;texcoord.x-=u_texelSize.x*SMAASearchLength(searchTex,e,0.0,0.5);return texcoord.x;}float SMAASearchXRight(sampler2D edgesTex,sampler2D searchTex,vec2 texcoord,float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<SMAA_MAX_SEARCH_STEPS;i++){e=texture2D(edgesTex,texcoord,0.0).rg;texcoord+=vec2(2.0,0.0)*u_texelSize;if(!(texcoord.x<end&&e.g>0.8281&&e.r==0.0))break;}texcoord.x-=0.25*u_texelSize.x;texcoord.x-=u_texelSize.x;texcoord.x-=2.0*u_texelSize.x;texcoord.x+=u_texelSize.x*SMAASearchLength(searchTex,e,0.5,0.5);return texcoord.x;}float SMAASearchYUp(sampler2D edgesTex,sampler2D searchTex,vec2 texcoord,float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<SMAA_MAX_SEARCH_STEPS;i++){e=texture2D(edgesTex,texcoord,0.0).rg;texcoord+=vec2(0.0,2.0)*u_texelSize;if(!(texcoord.y>end&&e.r>0.8281&&e.g==0.0))break;}texcoord.y-=0.25*u_texelSize.y;texcoord.y-=u_texelSize.y;texcoord.y-=2.0*u_texelSize.y;texcoord.y+=u_texelSize.y*SMAASearchLength(searchTex,e.gr,0.0,0.5);return texcoord.y;}float SMAASearchYDown(sampler2D edgesTex,sampler2D searchTex,vec2 texcoord,float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<SMAA_MAX_SEARCH_STEPS;i++){e=texture2D(edgesTex,texcoord,0.0).rg;texcoord-=vec2(0.0,2.0)*u_texelSize;if(!(texcoord.y<end&&e.r>0.8281&&e.g==0.0))break;}texcoord.y+=0.25*u_texelSize.y;texcoord.y+=u_texelSize.y;texcoord.y+=2.0*u_texelSize.y;texcoord.y-=u_texelSize.y*SMAASearchLength(searchTex,e.gr,0.5,0.5);return texcoord.y;}vec2 SMAAArea(sampler2D areaTex,vec2 dist,float e1,float e2,float offset){vec2 texcoord=float(SMAA_AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texcoord=SMAA_AREATEX_PIXEL_SIZE*texcoord+(0.5*SMAA_AREATEX_PIXEL_SIZE);texcoord.y+=SMAA_AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTex,texcoord,0.0).rg;}vec4 SMAABlendingWeightCalculationPS(vec2 texcoord,vec2 pixcoord,vec4 offset[3],sampler2D edgesTex,sampler2D areaTex,sampler2D searchTex,ivec4 subsampleIndices){vec4 weights=vec4(0.0,0.0,0.0,0.0);vec2 e=texture2D(edgesTex,texcoord).rg;if(e.g>0.0){vec2 d;vec2 coords;coords.x=SMAASearchXLeft(edgesTex,searchTex,offset[0].xy,offset[2].x);coords.y=offset[1].y;d.x=coords.x;float e1=texture2D(edgesTex,coords,0.0).r;coords.x=SMAASearchXRight(edgesTex,searchTex,offset[0].zw,offset[2].y);d.y=coords.x;d=d/u_texelSize.x-pixcoord.x;vec2 sqrt_d=sqrt(abs(d));coords.y-=1.0*u_texelSize.y;float e2=SMAASampleLevelZeroOffset(edgesTex,coords,ivec2(1,0)).r;weights.rg=SMAAArea(areaTex,sqrt_d,e1,e2,float(subsampleIndices.y));}if(e.r>0.0){vec2 d;vec2 coords;coords.y=SMAASearchYUp(edgesTex,searchTex,offset[1].xy,offset[2].z);coords.x=offset[0].x;d.x=coords.y;float e1=texture2D(edgesTex,coords,0.0).g;coords.y=SMAASearchYDown(edgesTex,searchTex,offset[1].zw,offset[2].w);d.y=coords.y;d=d/u_texelSize.y-pixcoord.y;vec2 sqrt_d=sqrt(abs(d));coords.y-=1.0*u_texelSize.y;float e2=SMAASampleLevelZeroOffset(edgesTex,coords,ivec2(0,1)).g;weights.ba=SMAAArea(areaTex,sqrt_d,e1,e2,float(subsampleIndices.x));}return weights;}void main(){gl_FragColor=SMAABlendingWeightCalculationPS(v_uv,v_pixcoord,v_offsets,u_edgesTexture,u_areaTexture,u_searchTexture,ivec4(0.0));}`;
class Smaa extends PostEffect {
    edgesRenderTarget = null;
    weightsRenderTarget = null;
    edgesMaterial = null;
    weightsMaterial = null;
    renderOrder = 500;
    init(e) {
        Object.assign(this, {
            sharedUniforms: {
                u_areaTexture: {
                    value: null
                },
                u_searchTexture: {
                    value: null
                }
            }
        }, e),
        super.init(),
        this.weightsRenderTarget = fboHelper.createRenderTarget(1, 1),
        this.edgesRenderTarget = fboHelper.createRenderTarget(1, 1),
        this.edgesMaterial = new RawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_texelSize: null
            },
            vertexShader: fboHelper.precisionPrefix + smaaEdgesVert,
            fragmentShader: fboHelper.precisionPrefix + smaaEdgesFrag,
            defines: {
                SMAA_THRESHOLD: "0.1"
            },
            blending: NoBlending,
            depthTest: !1,
            depthWrite: !1
        }),
        this.weightsMaterial = new RawShaderMaterial({
            uniforms: {
                u_edgesTexture: {
                    value: this.edgesRenderTarget.texture
                },
                u_areaTexture: this.sharedUniforms.u_areaTexture,
                u_searchTexture: this.sharedUniforms.u_searchTexture,
                u_texelSize: null
            },
            vertexShader: fboHelper.precisionPrefix + smaaWeightsVert,
            fragmentShader: fboHelper.precisionPrefix + smaaWeightsFrag,
            defines: {
                SMAA_MAX_SEARCH_STEPS: "8",
                SMAA_AREATEX_MAX_DISTANCE: "16",
                SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )",
                SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )"
            },
            transparent: !0,
            blending: NoBlending,
            depthTest: !1,
            depthWrite: !1
        }),
        this.material = fboHelper.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_weightsTexture: {
                    value: this.weightsRenderTarget.texture
                },
                u_texelSize: null
            },
            vertexShader: fboHelper.precisionPrefix + smaaBlendVert,
            fragmentShader: fboHelper.precisionPrefix + smaaBlendFrag
        })
    }
    setTextures(e, t) {
        const r = this.sharedUniforms.u_areaTexture.value = this._createTexture(e);
        r.minFilter = LinearFilter;
        const n = this.sharedUniforms.u_searchTexture.value = this._createTexture(t);
        n.magFilter = NearestFilter,
        n.minFilter = NearestFilter
    }
    updateTextures() {
        this.sharedUniforms.u_areaTexture.value.needsUpdate = !0,
        this.sharedUniforms.u_searchTexture.value.needsUpdate = !0
    }
    setPostprocessing(e) {
        super.setPostprocessing(e);
        const t = e.width
          , r = e.height;
        this.edgesRenderTarget.setSize(t, r),
        this.weightsRenderTarget.setSize(t, r)
    }
    dispose() {
        this.edgesRenderTarget && this.edgesRenderTarget.dispose(),
        this.weightsRenderTarget && this.weightsRenderTarget.dispose()
    }
    needsRender() {
        return this.enabled && !this.sharedUniforms.u_areaTexture.value.needsUpdate && properties.isSmaaEnabled
    }
    render(e, t) {
        const r = fboHelper.getColorState();
        this.sharedUniforms.u_searchTexture.value || console.warn("You need to use Smaa.setImages() to set the smaa textures manually and assign to this class.");
        const n = fboHelper.renderer;
        n && (n.autoClear = !0,
        n.setClearColor(0, 0)),
        this.edgesMaterial.uniforms.u_texelSize = this.weightsMaterial.uniforms.u_texelSize = this.material.uniforms.u_texelSize = e.sharedUniforms.u_texelSize,
        this.edgesMaterial.uniforms.u_texture.value = e.fromTexture,
        e.renderMaterial(this.edgesMaterial, this.edgesRenderTarget),
        e.renderMaterial(this.weightsMaterial, this.weightsRenderTarget),
        fboHelper.setColorState(r),
        this.material.uniforms.u_texture.value = e.fromTexture,
        super.render(e, t)
    }
    _createTexture(e) {
        const t = new Texture(e);
        return t.generateMipmaps = !1,
        t.flipY = !1,
        t
    }
}
const frag$2 = `#define GLSLIFY 1
varying vec2 v_uv;uniform sampler2D u_texture;uniform float u_saturation;uniform sampler2D u_blurTexture0;
#if ITERATION > 1
uniform sampler2D u_blurTexture1;
#endif
#if ITERATION > 2
uniform sampler2D u_blurTexture2;
#endif
#if ITERATION > 3
uniform sampler2D u_blurTexture3;
#endif
#if ITERATION > 4
uniform sampler2D u_blurTexture4;
#endif
uniform float u_bloomWeights[ITERATION];
#include <common>
vec3 dithering(vec3 color){float grid_position=rand(gl_FragCoord.xy);vec3 dither_shift_RGB=vec3(0.25/255.0,-0.25/255.0,0.25/255.0);dither_shift_RGB=mix(2.0*dither_shift_RGB,-2.0*dither_shift_RGB,grid_position);return color+dither_shift_RGB;}void main(){vec4 c=texture2D(u_texture,v_uv);gl_FragColor=c+(u_bloomWeights[0]*texture2D(u_blurTexture0,v_uv)
#if ITERATION > 1
+u_bloomWeights[1]*texture2D(u_blurTexture1,v_uv)
#endif
#if ITERATION > 2
+u_bloomWeights[2]*texture2D(u_blurTexture2,v_uv)
#endif
#if ITERATION > 3
+u_bloomWeights[3]*texture2D(u_blurTexture3,v_uv)
#endif
#if ITERATION > 4
+u_bloomWeights[4]*texture2D(u_blurTexture4,v_uv)
#endif
);gl_FragColor.rgb=mix(vec3(dot(gl_FragColor.rgb,vec3(0.299,0.587,0.114))),gl_FragColor.rgb,u_saturation);gl_FragColor.rgb=dithering(gl_FragColor.rgb);gl_FragColor.a=1.0;}`
  , highPassFrag = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform float u_luminosityThreshold;uniform float u_smoothWidth;uniform float u_amount;
#ifdef USE_HALO
uniform vec2 u_texelSize;uniform vec2 u_aspect;uniform float u_haloWidth;uniform float u_haloRGBShift;uniform float u_haloStrength;uniform float u_haloMaskInner;uniform float u_haloMaskOuter;
#ifdef USE_LENS_DIRT
uniform sampler2D u_dirtTexture;uniform vec2 u_dirtAspect;
#endif
#endif
#ifdef USE_CONVOLUTION
uniform float u_convolutionBuffer;
#endif
varying vec2 v_uv;void main(){vec2 uv=v_uv;
#ifdef USE_CONVOLUTION
uv=(uv-0.5)*(1.0+u_convolutionBuffer)+0.5;
#endif
vec4 texel=texture2D(u_texture,uv);vec3 luma=vec3(0.299,0.587,0.114);float v=dot(texel.xyz,luma);float alpha=texel.a*u_amount;gl_FragColor=vec4(texel.rgb*alpha,1.0);
#ifdef USE_HALO
vec2 toCenter=(uv-0.5)*u_aspect;vec2 ghostUv=1.0-(toCenter+0.5);vec2 ghostVec=(vec2(0.5)-ghostUv);vec2 direction=normalize(ghostVec);vec2 haloVec=direction*u_haloWidth;float weight=length(vec2(0.5)-fract(ghostUv+haloVec));weight=pow(1.0-weight,3.0);vec3 distortion=vec3(-u_texelSize.x,0.0,u_texelSize.x)*u_haloRGBShift;float zoomBlurRatio=fract(atan(toCenter.y,toCenter.x)*40.0)*0.05+0.95;ghostUv*=zoomBlurRatio;vec2 haloUv=ghostUv+haloVec;vec3 halo=vec3(texture2D(u_texture,haloUv+direction*distortion.r).r,texture2D(u_texture,haloUv+direction*distortion.g).g,texture2D(u_texture,haloUv+direction*distortion.b).b)*u_haloStrength*smoothstep(u_haloMaskInner,u_haloMaskOuter,length(toCenter));
#ifdef USE_LENS_DIRT
vec2 dirtUv=(uv-0.5)*u_dirtAspect+0.5;vec3 dirt=texture2D(u_dirtTexture,dirtUv).rgb;gl_FragColor.rgb+=(halo+alpha+0.05*dirt)*dirt;
#else
gl_FragColor.rgb+=halo;
#endif
#endif
#ifdef USE_CONVOLUTION
gl_FragColor.rgb*=max(abs(uv.x-0.5),abs(uv.y-0.5))>0.5 ? 0. : 1.;
#endif
}`
  , blurFrag = `#define GLSLIFY 1
varying vec2 v_uv;uniform sampler2D u_texture;uniform vec2 u_resolution;uniform vec2 u_direction;float gaussianPdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}void main(){vec2 invSize=1.0/u_resolution;float fSigma=float(SIGMA);float weightSum=gaussianPdf(0.0,fSigma);vec3 diffuseSum=texture2D(u_texture,v_uv).rgb*weightSum;for(int i=1;i<KERNEL_RADIUS;i++){float x=float(i);float w=gaussianPdf(x,fSigma);vec2 uvOffset=u_direction*invSize*x;vec3 sample1=texture2D(u_texture,v_uv+uvOffset).rgb;vec3 sample2=texture2D(u_texture,v_uv-uvOffset).rgb;diffuseSum+=(sample1+sample2)*w;weightSum+=2.0*w;}gl_FragColor=vec4(diffuseSum/weightSum,1.0);}`
  , fftFrag = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec2 u_texelSize;uniform float u_subtransformSize;uniform float u_normalization;uniform bool u_isForward;const float TWOPI=6.283185307179586;void main(){
#ifdef HORIZTONAL
float index=gl_FragCoord.x-.5;
#else
float index=gl_FragCoord.y-.5;
#endif
float evenIndex=floor(index/u_subtransformSize)*(u_subtransformSize*0.5)+mod(index,u_subtransformSize*0.5);
#ifdef HORIZTONAL
vec2 evenPos=vec2(evenIndex,gl_FragCoord.y)*u_texelSize;vec2 oddPos=evenPos+vec2(.5,0.);
#else
vec2 evenPos=vec2(gl_FragCoord.x,evenIndex)*u_texelSize;vec2 oddPos=evenPos+vec2(0.,.5);
#endif
vec4 even=texture2D(u_texture,evenPos);vec4 odd=texture2D(u_texture,oddPos);float twiddleArgument=(u_isForward ? TWOPI :-TWOPI)*(index/u_subtransformSize);vec2 twiddle=vec2(cos(twiddleArgument),sin(twiddleArgument));gl_FragColor=(even+vec4(twiddle.x*odd.xy-twiddle.y*odd.zw,twiddle.y*odd.xy+twiddle.x*odd.zw))*u_normalization;}`
  , convolutionSrcFrag = `#define GLSLIFY 1
uniform vec2 u_aspect;uniform sampler2D u_texture;varying vec2 v_uv;void main(){vec2 toCenter=(fract(v_uv+0.5)-0.5)*u_aspect;vec2 rotToCenter=mat2(0.7071067811865476,-0.7071067811865476,0.7071067811865476,0.7071067811865476)*toCenter;float res=exp(-length(toCenter)*1.0)*0.05+exp(-length(toCenter)*7.5)*0.5+exp(-length(toCenter)*25.0)*1.+exp(-length(toCenter*vec2(1.0,10.0))*30.0)*20.+exp(-length(toCenter*vec2(1.0,20.0))*60.0)*300.+exp(-length(toCenter*vec2(10.0,1.0))*30.0)*20.+exp(-length(toCenter*vec2(20.0,1.0))*60.0)*300.+exp(-length(rotToCenter*vec2(1.0,8.0))*37.5)*12.+exp(-length(rotToCenter*vec2(1.0,20.0))*75.0)*300.+exp(-length(rotToCenter*vec2(20.0,1.0))*75.0)*300.;gl_FragColor=vec4(res,res,0.,0.);}`
  , convolutionMixFrag = `#define GLSLIFY 1
varying vec2 v_uv;uniform sampler2D u_texture;uniform sampler2D u_kernelTexture;void main(){vec4 a=texture2D(u_texture,v_uv);vec4 b=texture2D(u_kernelTexture,v_uv);gl_FragColor=vec4(a.xy*b.xy-a.zw*b.zw,a.xy*b.zw+a.zw*b.xy);}`
  , convolutionCacheFrag = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform float u_amount;uniform float u_saturation;varying vec2 v_uv;void main(){gl_FragColor=texture2D(u_texture,v_uv)*u_amount;gl_FragColor.rgb=mix(vec3(dot(gl_FragColor.rgb,vec3(0.299,0.587,0.114))),gl_FragColor.rgb,u_saturation);}`
  , convolutionFrag = `#define GLSLIFY 1
varying vec2 v_uv;uniform sampler2D u_texture;uniform sampler2D u_bloomTexture;uniform float u_convolutionBuffer;
#include <common>
vec3 dithering(vec3 color){float grid_position=rand(gl_FragCoord.xy);vec3 dither_shift_RGB=vec3(0.25/255.0,-0.25/255.0,0.25/255.0);dither_shift_RGB=mix(2.0*dither_shift_RGB,-2.0*dither_shift_RGB,grid_position);return color+dither_shift_RGB;}void main(){vec4 c=texture2D(u_texture,v_uv);vec2 bloomUv=(v_uv-0.5)/(1.0+u_convolutionBuffer)+0.5;gl_FragColor=c+texture2D(u_bloomTexture,bloomUv);gl_FragColor.rgb=dithering(gl_FragColor.rgb);gl_FragColor.a=1.0;}`;
class Bloom extends PostEffect {
    ITERATION = 5;
    USE_CONVOLUTION = !0;
    USE_HD = !0;
    USE_LENS_DIRT = !1;
    amount = 1;
    radius = 0;
    threshold = .1;
    smoothWidth = 1;
    highPassMultiplier = 1;
    haloWidth = .8;
    haloRGBShift = .03;
    haloStrength = .21;
    haloMaskInner = .3;
    haloMaskOuter = .5;
    highPassMaterial;
    highPassRenderTarget;
    fftHMaterial;
    fftVMaterial;
    srcMaterial;
    convolutionSrcFrag = convolutionSrcFrag;
    srcSize = 256;
    srcRT;
    fftCacheRT1;
    fftCacheRT2;
    fftSrcRT;
    fftBloomOutCacheMaterial;
    fftBloomOutCacheRT;
    convolutionMixMaterial;
    convolutionMixDownScale = 1;
    convolutionBuffer = .1;
    renderTargetsHorizontal = [];
    renderTargetsVertical = [];
    blurMaterials = [];
    saturation = 1;
    renderOrder = 10;
    directionX = new Vector2(1,0);
    directionY = new Vector2(0,1);
    fftSrcRT;
    init(e) {
        Object.assign(this, e),
        super.init();
        let t = HalfFloatType;
        if (this.highPassRenderTarget = fboHelper.createRenderTarget(1, 1, !this.USE_HD, t),
        this.highPassMaterial = fboHelper.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_luminosityThreshold: {
                    value: 1
                },
                u_smoothWidth: {
                    value: 1
                },
                u_amount: {
                    value: 1
                },
                u_haloWidth: {
                    value: 1
                },
                u_haloRGBShift: {
                    value: 1
                },
                u_haloStrength: {
                    value: 1
                },
                u_haloMaskInner: {
                    value: 1
                },
                u_haloMaskOuter: {
                    value: 1
                },
                u_texelSize: null,
                u_aspect: {
                    value: new Vector2
                },
                u_dirtTexture: {
                    value: null
                },
                u_dirtAspect: {
                    value: new Vector2
                }
            },
            fragmentShader: highPassFrag
        }),
        this.highPassMaterial.defines.USE_LENS_DIRT = this.USE_LENS_DIRT,
        this.USE_CONVOLUTION)
            this.highPassMaterial.defines.USE_CONVOLUTION = !0,
            this.highPassMaterial.uniforms.u_convolutionBuffer = {
                value: .15
            },
            this.fftSrcRT = fboHelper.createRenderTarget(1, 1, !0, t),
            this.fftCacheRT1 = fboHelper.createRenderTarget(1, 1, !0, t),
            this.fftCacheRT2 = this.fftCacheRT1.clone(),
            this.fftBloomOutCacheRT = fboHelper.createRenderTarget(1, 1),
            this.srcMaterial = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_aspect: {
                        value: new Vector2
                    }
                },
                fragmentShader: this.convolutionSrcFrag
            }),
            this.fftHMaterial = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_texelSize: {
                        value: new Vector2
                    },
                    u_subtransformSize: {
                        value: 0
                    },
                    u_normalization: {
                        value: 0
                    },
                    u_isForward: {
                        value: 0
                    }
                },
                fragmentShader: fftFrag
            }),
            this.fftHMaterial.defines.HORIZTONAL = !0,
            this.fftVMaterial = fboHelper.createRawShaderMaterial({
                uniforms: this.fftHMaterial.uniforms,
                fragmentShader: fftFrag
            }),
            this.convolutionMixMaterial = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_kernelTexture: {
                        value: this.fftSrcRT.texture
                    }
                },
                fragmentShader: convolutionMixFrag
            }),
            this.fftBloomOutCacheMaterial = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_amount: {
                        value: 0
                    },
                    u_saturation: {
                        value: 0
                    }
                },
                fragmentShader: convolutionCacheFrag
            }),
            this.material = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_bloomTexture: {
                        value: this.fftBloomOutCacheRT.texture
                    },
                    u_convolutionBuffer: this.highPassMaterial.uniforms.u_convolutionBuffer
                },
                fragmentShader: convolutionFrag,
                blending: NoBlending
            });
        else {
            for (let r = 0; r < this.ITERATION; r++) {
                this.renderTargetsHorizontal.push(fboHelper.createRenderTarget(1, 1, !1, t)),
                this.renderTargetsVertical.push(fboHelper.createRenderTarget(1, 1, !1, t));
                const n = 3 + r * 2;
                this.blurMaterials[r] = fboHelper.createRawShaderMaterial({
                    uniforms: {
                        u_texture: {
                            value: null
                        },
                        u_resolution: {
                            value: new Vector2
                        },
                        u_direction: {
                            value: null
                        }
                    },
                    fragmentShader: blurFrag,
                    defines: {
                        KERNEL_RADIUS: n,
                        SIGMA: n
                    }
                })
            }
            this.material = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_bloomStrength: {
                        value: 1
                    },
                    u_bloomWeights: {
                        value: []
                    },
                    u_saturation: {
                        value: 0
                    }
                },
                fragmentShader: frag$2,
                blending: NoBlending,
                defines: {
                    ITERATION: this.ITERATION
                }
            });
            for (let r = 0; r < this.ITERATION; r++)
                this.material.uniforms["u_blurTexture" + r] = {
                    value: this.renderTargetsVertical[r].texture
                }
        }
    }
    setDirtTexture(e) {
        this.highPassMaterial.uniforms.u_dirtTexture.value = e
    }
    setPostprocessing(e) {
        const t = e.width
          , r = e.height;
        if (this.USE_CONVOLUTION) {
            let n = math.powerTwoCeiling(t / 2) >> this.convolutionMixDownScale
              , o = math.powerTwoCeiling(r / 2) >> this.convolutionMixDownScale;
            if (this.highPassRenderTarget.setSize(n, o),
            n !== this.fftCacheRT1.width || o !== this.fftCacheRT1.height) {
                this.fftSrcRT.setSize(n, o),
                this.fftCacheRT1.setSize(n, o),
                this.fftCacheRT2.setSize(n, o),
                this.fftBloomOutCacheRT.setSize(n, o);
                let l = r / Math.max(t, r);
                this.srcMaterial.uniforms.u_aspect.value.set(t / r * l, l),
                fboHelper.render(this.srcMaterial, this.fftCacheRT1),
                this.renderFFT(this.fftCacheRT1, this.fftSrcRT, !0)
            }
        } else {
            let n = Math.ceil(t / 2)
              , o = Math.ceil(r / 2);
            this.highPassRenderTarget.setSize(n, o),
            super.setPostprocessing(e);
            for (let l = 0; l < this.ITERATION; l++)
                this.renderTargetsHorizontal[l].setSize(n, o),
                this.renderTargetsVertical[l].setSize(n, o),
                this.blurMaterials[l].uniforms.u_resolution.value.set(n, o),
                n = Math.ceil(n / 2),
                o = Math.ceil(o / 2)
        }
    }
    dispose() {
        if (!this.USE_CONVOLUTION) {
            this.highPassRenderTarget && this.highPassRenderTarget.dispose();
            for (let e = 0; e < this.ITERATION; e++)
                this.renderTargetsHorizontal[e] && this.renderTargetsHorizontal[e].dispose(),
                this.renderTargetsVertical[e] && this.renderTargetsVertical[e].dispose()
        }
    }
    needsRender() {
        return !!this.amount
    }
    renderFFT(e, t, r) {
        let n = e.width
          , o = e.height
          , l = Math.round(Math.log(n) / Math.log(2))
          , c = Math.round(Math.log(o) / Math.log(2))
          , u = l + c
          , f = u % 2 === 0;
        this.fftHMaterial;
        let p = this.fftHMaterial.uniforms;
        for (let g = 0; g < u; g++) {
            let v = g < l;
            p.u_texture.value = e.texture,
            p.u_normalization.value = g === 0 ? 1 / Math.sqrt(n * o) : 1,
            p.u_isForward.value = !!r,
            p.u_texelSize.value.set(1 / n, 1 / o),
            p.u_subtransformSize.value = Math.pow(2, (v ? g : g - l) + 1),
            fboHelper.render(v ? this.fftHMaterial : this.fftVMaterial, t);
            let _ = e;
            e = t,
            t = _
        }
        f && fboHelper.copy(e.texture, t)
    }
    render(e, t=!1) {
        let r = properties.postprocessing.width
          , n = properties.postprocessing.height;
        this.highPassMaterial.uniforms.u_texture.value = e.fromTexture,
        this.highPassMaterial.uniforms.u_luminosityThreshold.value = this.threshold,
        this.highPassMaterial.uniforms.u_smoothWidth.value = this.smoothWidth,
        this.highPassMaterial.uniforms.u_amount.value = this.highPassMultiplier,
        this.highPassMaterial.uniforms.u_haloWidth.value = this.haloWidth,
        this.highPassMaterial.uniforms.u_haloRGBShift.value = this.haloRGBShift * r,
        this.highPassMaterial.uniforms.u_haloStrength.value = this.haloStrength,
        this.highPassMaterial.uniforms.u_haloMaskInner.value = this.haloMaskInner,
        this.highPassMaterial.uniforms.u_haloMaskOuter.value = this.haloMaskOuter,
        this.highPassMaterial.uniforms.u_texelSize = e.sharedUniforms.u_texelSize,
        this.highPassMaterial.uniforms.u_aspect = e.sharedUniforms.u_aspect;
        let o = this.haloStrength > 0
          , l = n / Math.sqrt(r * r + n * n) * 2;
        if (this.highPassMaterial.uniforms.u_aspect.value.set(r / n * l, l),
        l = n / Math.max(r, n),
        this.highPassMaterial.uniforms.u_dirtAspect.value.set(r / n * l, l),
        this.highPassMaterial.defines.USE_HALO !== o && (this.highPassMaterial.defines.USE_HALO = o,
        this.highPassMaterial.needsUpdate = !0),
        this.USE_CONVOLUTION && (this.highPassMaterial.uniforms.u_convolutionBuffer.value = this.convolutionBuffer),
        e.renderMaterial(this.highPassMaterial, this.highPassRenderTarget),
        this.USE_CONVOLUTION) {
            fboHelper.copy(this.highPassRenderTarget.texture, this.fftCacheRT1),
            this.renderFFT(this.fftCacheRT1, this.fftCacheRT2, !0),
            this.convolutionMixMaterial.uniforms.u_texture.value = this.fftCacheRT2.texture,
            fboHelper.render(this.convolutionMixMaterial, this.fftCacheRT1),
            this.renderFFT(this.fftCacheRT1, this.fftCacheRT2, !1);
            let c = this.amount * 1024;
            c = c / Math.pow(math.powerTwoCeilingBase(this.fftCacheRT1.width * this.fftCacheRT1.height), 4) * .85,
            this.fftBloomOutCacheMaterial.uniforms.u_amount.value = c,
            this.fftBloomOutCacheMaterial.uniforms.u_saturation.value = this.saturation,
            this.fftBloomOutCacheMaterial.uniforms.u_texture.value = this.fftCacheRT2.texture,
            e.renderMaterial(this.fftBloomOutCacheMaterial, this.fftBloomOutCacheRT),
            super.render(e, t)
        } else {
            let c = this.highPassRenderTarget;
            for (let u = 0; u < this.ITERATION; u++) {
                const f = this.blurMaterials[u];
                f.uniforms.u_texture.value = c.texture,
                f.uniforms.u_direction.value = this.directionX,
                e.renderMaterial(f, this.renderTargetsHorizontal[u]),
                f.uniforms.u_texture.value = this.renderTargetsHorizontal[u].texture,
                f.uniforms.u_direction.value = this.directionY,
                e.renderMaterial(f, this.renderTargetsVertical[u]),
                c = this.renderTargetsVertical[u]
            }
            this.material.uniforms.u_texture.value = e.fromTexture,
            this.material.uniforms.u_saturation.value = math.mix(1, this.saturation, .5);
            for (let u = 0; u < this.ITERATION; u++) {
                const f = (this.ITERATION - u) / this.ITERATION;
                this.material.uniforms.u_bloomWeights.value[u] = this.amount * (f + (1.2 - f * 2) * this.radius) / Math.pow(2, this.ITERATION - u - 1)
            }
            super.render(e, t)
        }
    }
}
const frag$1 = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform sampler2D u_screenPaintTexture;uniform vec2 u_screenPaintTexelSize;uniform float u_amount;uniform float u_rgbShift;uniform float u_multiplier;uniform float u_colorMultiplier;uniform float u_shade;varying vec2 v_uv;
#include <getBlueNoise>
void main(){vec3 bnoise=getBlueNoise(gl_FragCoord.xy+vec2(17.,29.));vec4 data=texture2D(u_screenPaintTexture,v_uv);float weight=(data.z+data.w)*0.5;vec2 vel=(0.5-data.xy-0.001)*2.*weight;vec4 color=vec4(0.0);vec2 velocity=vel*u_amount/4.0*u_screenPaintTexelSize*u_multiplier;vec2 uv=v_uv+bnoise.xy*velocity;for(int i=0;i<9;i++){color+=texture2D(u_texture,uv);uv+=velocity;}color/=9.;color.rgb+=sin(vec3(vel.x+vel.y)*40.0+vec3(0.0,2.0,4.0)*u_rgbShift)*smoothstep(0.4,-0.9,weight)*u_shade*max(abs(vel.x),abs(vel.y))*u_colorMultiplier;gl_FragColor=color;}`;
class ScreenPaintDistortion extends PostEffect {
    screenPaint = null;
    amount = 20;
    rgbShift = 1;
    multiplier = 1.25;
    colorMultiplier = 1;
    shade = 1.25;
    renderOrder = 75;
    init(e) {
        if (Object.assign(this, e),
        super.init(),
        !this.screenPaint)
            throw new Error("screenPaint is required");
        this.material = fboHelper.createRawShaderMaterial({
            uniforms: Object.assign({
                u_texture: {
                    value: null
                },
                u_screenPaintTexture: this.screenPaint.sharedUniforms.u_currPaintTexture,
                u_screenPaintTexelSize: this.screenPaint.sharedUniforms.u_paintTexelSize,
                u_amount: {
                    value: 0
                },
                u_rgbShift: {
                    value: 0
                },
                u_multiplier: {
                    value: 0
                },
                u_colorMultiplier: {
                    value: 0
                },
                u_shade: {
                    value: 0
                }
            }, blueNoise.sharedUniforms),
            fragmentShader: frag$1
        })
    }
    needsRender(e) {
        return this.amount > 0
    }
    syncCamera(e) {
        this.needsSync = !0,
        e && (e.matrixWorldInverse.decompose(this._position, this._quaternion, this._scale),
        this.projectionViewMatrix.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
        this.projectionViewInverseMatrix.copy(this.projectionViewMatrix).invert()),
        this.prevProjectionViewMatrix.copy(this.projectionViewMatrix)
    }
    render(e, t=!1) {
        this.material.uniforms.u_amount.value = this.amount,
        this.material.uniforms.u_rgbShift.value = this.rgbShift,
        this.material.uniforms.u_multiplier.value = this.multiplier,
        this.material.uniforms.u_colorMultiplier.value = this.colorMultiplier,
        this.material.uniforms.u_shade.value = this.shade,
        super.render(e, t)
    }
}
const fragmentShader = `#define GLSLIFY 1
varying vec2 v_uv;uniform sampler2D u_texture;uniform vec3 u_bgColor;uniform float u_opacity;uniform float u_vignetteFrom;uniform float u_vignetteTo;uniform vec2 u_vignetteAspect;uniform vec3 u_vignetteColor;uniform float u_saturation;uniform float u_contrast;uniform float u_brightness;uniform vec3 u_tintColor;uniform float u_tintOpacity;uniform float u_ditherSeed;float hash13(vec3 p3){p3=fract(p3*.1031);p3+=dot(p3,p3.yzx+33.33);return fract((p3.x+p3.y)*p3.z);}vec3 screen(vec3 cb,vec3 cs){return cb+cs-(cb*cs);}vec3 colorDodge(vec3 cb,vec3 cs){return mix(min(vec3(1.0),cb/(1.0-cs)),vec3(1.0),step(vec3(1.0),cs));}void main(){vec2 uv=v_uv;vec3 color=texture2D(u_texture,uv).rgb;float luma=dot(color,vec3(0.299,0.587,0.114));color=mix(vec3(luma),color,1.0+u_saturation);color=0.5+(1.0+u_contrast)*(color-0.5);color+=u_brightness;color=mix(color,screen(colorDodge(color,u_tintColor),u_tintColor),u_tintOpacity);float d=length((uv-0.5)*u_vignetteAspect)*2.0;color=mix(color,u_vignetteColor,smoothstep(u_vignetteFrom,u_vignetteTo,d));gl_FragColor=vec4(mix(u_bgColor,color,u_opacity)+hash13(vec3(gl_FragCoord.xy,u_ditherSeed))/255.0,1.0);}`;
class Final extends PostEffect {
    vignetteFrom = .6;
    vignetteTo = 1.6;
    vignetteAspect = new Vector2;
    vignetteColor = new Color;
    saturation = 1;
    contrast = 0;
    brightness = 1;
    tintColor = new Color;
    tintOpacity = 1;
    bgColor = new Color;
    opacity = 1;
    isActive = !1;
    renderOrder = 30;
    init(e) {
        Object.assign(this, e),
        super.init(),
        this.material = fboHelper.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_vignetteFrom: {
                    value: 0
                },
                u_vignetteTo: {
                    value: 0
                },
                u_vignetteAspect: {
                    value: this.vignetteAspect
                },
                u_vignetteColor: {
                    value: this.vignetteColor
                },
                u_saturation: {
                    value: 0
                },
                u_contrast: {
                    value: 0
                },
                u_brightness: {
                    value: 0
                },
                u_tintColor: {
                    value: this.tintColor
                },
                u_tintOpacity: {
                    value: 0
                },
                u_bgColor: {
                    value: this.bgColor
                },
                u_opacity: {
                    value: 0
                },
                u_ditherSeed: {
                    value: 0
                }
            },
            fragmentShader
        })
    }
    needsRender() {
        return this.isActive
    }
    render(e, t=!1) {
        const r = e.width
          , n = e.height;
        let o = this.material.uniforms;
        o.u_vignetteFrom.value = this.vignetteFrom,
        o.u_vignetteTo.value = this.vignetteTo;
        const l = n / Math.sqrt(r * r + n * n);
        this.vignetteAspect.set(r / n * l, l),
        o.u_saturation.value = this.saturation - 1,
        o.u_contrast.value = this.contrast,
        o.u_brightness.value = this.brightness - 1,
        o.u_tintOpacity.value = this.tintOpacity,
        o.u_opacity.value = this.opacity,
        o.u_ditherSeed.value = Math.random() * 1e3,
        super.render(e, t)
    }
}
const easuFrag = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec2 u_inResolution;uniform vec2 u_outResolution;vec3 FsrEasuCF(vec2 p){return texture2D(u_texture,p).rgb;}void FsrEasuCon(out vec4 con0,out vec4 con1,out vec4 con2,out vec4 con3,vec2 inputViewportInPixels,vec2 inputSizeInPixels,vec2 outputSizeInPixels){con0=vec4(inputViewportInPixels.x/outputSizeInPixels.x,inputViewportInPixels.y/outputSizeInPixels.y,.5*inputViewportInPixels.x/outputSizeInPixels.x-.5,.5*inputViewportInPixels.y/outputSizeInPixels.y-.5);con1=vec4(1,1,1,-1)/inputSizeInPixels.xyxy;con2=vec4(-1,2,1,2)/inputSizeInPixels.xyxy;con3=vec4(0,4,0,0)/inputSizeInPixels.xyxy;}void FsrEasuTapF(inout vec3 aC,inout float aW,vec2 off,vec2 dir,vec2 len,float lob,float clp,vec3 c){vec2 v=vec2(dot(off,dir),dot(off,vec2(-dir.y,dir.x)));v*=len;float d2=min(dot(v,v),clp);float wB=.4*d2-1.;float wA=lob*d2-1.;wB*=wB;wA*=wA;wB=1.5625*wB-.5625;float w=wB*wA;aC+=c*w;aW+=w;}void FsrEasuSetF(inout vec2 dir,inout float len,float w,float lA,float lB,float lC,float lD,float lE){float lenX=max(abs(lD-lC),abs(lC-lB));float dirX=lD-lB;dir.x+=dirX*w;lenX=clamp(abs(dirX)/lenX,0.,1.);lenX*=lenX;len+=lenX*w;float lenY=max(abs(lE-lC),abs(lC-lA));float dirY=lE-lA;dir.y+=dirY*w;lenY=clamp(abs(dirY)/lenY,0.,1.);lenY*=lenY;len+=lenY*w;}void FsrEasuF(out vec3 pix,vec2 ip,vec4 con0,vec4 con1,vec4 con2,vec4 con3){vec2 pp=ip*con0.xy+con0.zw;vec2 fp=floor(pp);pp-=fp;vec2 p0=fp*con1.xy+con1.zw;vec2 p1=p0+con2.xy;vec2 p2=p0+con2.zw;vec2 p3=p0+con3.xy;vec4 off=vec4(-.5,.5,-.5,.5)*con1.xxyy;vec3 bC=FsrEasuCF(p0+off.xw);float bL=bC.g+0.5*(bC.r+bC.b);vec3 cC=FsrEasuCF(p0+off.yw);float cL=cC.g+0.5*(cC.r+cC.b);vec3 iC=FsrEasuCF(p1+off.xw);float iL=iC.g+0.5*(iC.r+iC.b);vec3 jC=FsrEasuCF(p1+off.yw);float jL=jC.g+0.5*(jC.r+jC.b);vec3 fC=FsrEasuCF(p1+off.yz);float fL=fC.g+0.5*(fC.r+fC.b);vec3 eC=FsrEasuCF(p1+off.xz);float eL=eC.g+0.5*(eC.r+eC.b);vec3 kC=FsrEasuCF(p2+off.xw);float kL=kC.g+0.5*(kC.r+kC.b);vec3 lC=FsrEasuCF(p2+off.yw);float lL=lC.g+0.5*(lC.r+lC.b);vec3 hC=FsrEasuCF(p2+off.yz);float hL=hC.g+0.5*(hC.r+hC.b);vec3 gC=FsrEasuCF(p2+off.xz);float gL=gC.g+0.5*(gC.r+gC.b);vec3 oC=FsrEasuCF(p3+off.yz);float oL=oC.g+0.5*(oC.r+oC.b);vec3 nC=FsrEasuCF(p3+off.xz);float nL=nC.g+0.5*(nC.r+nC.b);vec2 dir=vec2(0.);float len=0.;FsrEasuSetF(dir,len,(1.-pp.x)*(1.-pp.y),bL,eL,fL,gL,jL);FsrEasuSetF(dir,len,pp.x*(1.-pp.y),cL,fL,gL,hL,kL);FsrEasuSetF(dir,len,(1.-pp.x)*pp.y,fL,iL,jL,kL,nL);FsrEasuSetF(dir,len,pp.x*pp.y,gL,jL,kL,lL,oL);vec2 dir2=dir*dir;float dirR=dir2.x+dir2.y;bool zro=dirR<(1./32768.);dirR=inversesqrt(dirR);dirR=zro ? 1. : dirR;dir.x=zro ? 1. : dir.x;dir*=vec2(dirR);len=len*.5;len*=len;float stretch=dot(dir,dir)/(max(abs(dir.x),abs(dir.y)));vec2 len2=vec2(1.+(stretch-1.0)*len,1.-.5*len);float lob=.5-.29*len;float clp=1./lob;vec3 min4=min(min(fC,gC),min(jC,kC));vec3 max4=max(max(fC,gC),max(jC,kC));vec3 aC=vec3(0);float aW=0.;FsrEasuTapF(aC,aW,vec2(0.,-1.)-pp,dir,len2,lob,clp,bC);FsrEasuTapF(aC,aW,vec2(1.,-1.)-pp,dir,len2,lob,clp,cC);FsrEasuTapF(aC,aW,vec2(-1.,1.)-pp,dir,len2,lob,clp,iC);FsrEasuTapF(aC,aW,vec2(0.,1.)-pp,dir,len2,lob,clp,jC);FsrEasuTapF(aC,aW,vec2(0.,0.)-pp,dir,len2,lob,clp,fC);FsrEasuTapF(aC,aW,vec2(-1.,0.)-pp,dir,len2,lob,clp,eC);FsrEasuTapF(aC,aW,vec2(1.,1.)-pp,dir,len2,lob,clp,kC);FsrEasuTapF(aC,aW,vec2(2.,1.)-pp,dir,len2,lob,clp,lC);FsrEasuTapF(aC,aW,vec2(2.,0.)-pp,dir,len2,lob,clp,hC);FsrEasuTapF(aC,aW,vec2(1.,0.)-pp,dir,len2,lob,clp,gC);FsrEasuTapF(aC,aW,vec2(1.,2.)-pp,dir,len2,lob,clp,oC);FsrEasuTapF(aC,aW,vec2(0.,2.)-pp,dir,len2,lob,clp,nC);pix=min(max4,max(min4,aC/aW));}void main(){vec3 c;vec4 con0,con1,con2,con3;FsrEasuCon(con0,con1,con2,con3,u_inResolution,u_inResolution,u_outResolution);FsrEasuF(c,gl_FragCoord.xy,con0,con1,con2,con3);gl_FragColor=vec4(c.xyz,1);}`
  , frag = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec2 u_outResolution;uniform float u_sharpness;
#define FSR_RCAS_LIMIT (0.25-(1.0/16.0))
vec4 FsrRcasLoadF(vec2 p);void FsrRcasCon(out float con,float sharpness){con=exp2(-sharpness);}vec3 FsrRcasF(vec2 ip,float con){vec2 sp=vec2(ip);vec3 b=FsrRcasLoadF(sp+vec2(0,-1)).rgb;vec3 d=FsrRcasLoadF(sp+vec2(-1,0)).rgb;vec3 e=FsrRcasLoadF(sp).rgb;vec3 f=FsrRcasLoadF(sp+vec2(1,0)).rgb;vec3 h=FsrRcasLoadF(sp+vec2(0,1)).rgb;float bL=b.g+.5*(b.b+b.r);float dL=d.g+.5*(d.b+d.r);float eL=e.g+.5*(e.b+e.r);float fL=f.g+.5*(f.b+f.r);float hL=h.g+.5*(h.b+h.r);float nz=.25*(bL+dL+fL+hL)-eL;nz=clamp(abs(nz)/(max(max(bL,dL),max(eL,max(fL,hL)))-min(min(bL,dL),min(eL,min(fL,hL)))),0.,1.);nz=1.-.5*nz;vec3 mn4=min(b,min(f,h));vec3 mx4=max(b,max(f,h));vec2 peakC=vec2(1.,-4.);vec3 hitMin=mn4/(4.*mx4);vec3 hitMax=(peakC.x-mx4)/(4.*mn4+peakC.y);vec3 lobeRGB=max(-hitMin,hitMax);float lobe=max(-FSR_RCAS_LIMIT,min(max(lobeRGB.r,max(lobeRGB.g,lobeRGB.b)),0.))*con;
#ifdef FSR_RCAS_DENOISE
lobe*=nz;
#endif
return(lobe*(b+d+h+f)+e)/(4.*lobe+1.);}vec4 FsrRcasLoadF(vec2 p){return texture2D(u_texture,p/u_outResolution.xy);}void main(){vec2 uv=gl_FragCoord.xy/u_outResolution.xy;float con;FsrRcasCon(con,u_sharpness);vec3 col=FsrRcasF(gl_FragCoord.xy,con);gl_FragColor=vec4(col,1.);}`;
let Fsr$1 = class {
    sharpness = 1;
    _easuMaterial;
    _material;
    _inResolution = new Vector2;
    _outResolution = new Vector2;
    _cacheRenderTarget = null;
    constructor() {
        this._cacheRenderTarget = fboHelper.createRenderTarget(1, 1),
        this._easuMaterial = fboHelper.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_inResolution: {
                    value: this._inResolution
                },
                u_outResolution: {
                    value: this._outResolution
                }
            },
            fragmentShader: easuFrag
        }),
        this._material = fboHelper.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: this._cacheRenderTarget.texture
                },
                u_outResolution: this._easuMaterial.uniforms.u_outResolution,
                u_sharpness: {
                    value: 0
                }
            },
            fragmentShader: frag
        })
    }
    render(e, t) {
        let r = e.image.width
          , n = e.image.height;
        this._material.uniforms.u_sharpness.value = this.sharpness,
        (this._inResolution.width !== r || this._inResolution.height !== n) && this._inResolution.set(r, n);
        let o, l;
        t ? (o = t.width,
        l = t.height) : (o = fboHelper.renderer.domElement.width,
        l = fboHelper.renderer.domElement.height),
        (this._outResolution.width !== o || this._outResolution.height !== l) && (this._outResolution.set(o, l),
        this._cacheRenderTarget.setSize(o, l)),
        this._easuMaterial.uniforms.u_texture.value = e,
        fboHelper.render(this._easuMaterial, this._cacheRenderTarget),
        t || (fboHelper.renderer.setRenderTarget(null),
        fboHelper.renderer.setViewport(0, 0, this._outResolution.x, this._outResolution.y)),
        fboHelper.render(this._material, t)
    }
}
;
class Fsr extends PostEffect {
    sharpness = 1;
    fsr;
    renderOrder = 2e3;
    init(e) {
        Object.assign(this, e),
        super.init(),
        this.fsr = new Fsr$1
    }
    render(e, t=!1) {
        this.fsr.sharpness = this.sharpness,
        this.fsr.render(e.fromTexture, t ? null : e.toRenderTarget),
        e.swap()
    }
}
const XHRItem = properties.loader.ITEM_CLASSES.xhr;
class BufItem extends XHRItem {
    constructor(e, t) {
        super(e, {
            ...t,
            responseType: "arraybuffer"
        })
    }
    retrieve() {
        return !1
    }
    _onLoad() {
        if (!this.content) {
            const e = this.xmlhttp.response;
            let t = new Uint32Array(e,0,1)[0]
              , r = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(e,4,t)))
              , n = r.vertexCount
              , o = r.indexCount
              , l = 4 + t
              , c = new BufferGeometry
              , u = r.attributes
              , f = !1
              , p = {};
            for (let _ = 0, w = u.length; _ < w; _++) {
                let S = u[_], b = S.id, C = b === "indices" ? o : n, R = S.componentSize, T = window[S.storageType], M = new T(e,l,C * R), P = T.BYTES_PER_ELEMENT, I;
                if (S.needsPack) {
                    let k = S.packedComponents
                      , A = k.length
                      , O = S.storageType.indexOf("Int") === 0
                      , W = 1 << P * 8
                      , Q = O ? W * .5 : 0
                      , H = 1 / W;
                    I = new Float32Array(C * R);
                    for (let B = 0, D = 0; B < C; B++)
                        for (let q = 0; q < A; q++) {
                            let V = k[q];
                            I[D] = (M[D] + Q) * H * V.delta + V.from,
                            D++
                        }
                } else
                    p[b] = l,
                    I = M;
                b === "normal" && (f = !0),
                b === "indices" ? c.setIndex(new BufferAttribute(I,1)) : c.setAttribute(b, new BufferAttribute(I,R)),
                l += C * R * P
            }
            let g = r.meshType
              , v = [];
            if (r.sceneData) {
                let _ = r.sceneData
                  , w = new Object3D
                  , S = []
                  , b = g === "Mesh" ? 3 : g === "LineSegments" ? 2 : 1;
                for (let C = 0, R = _.length; C < R; C++) {
                    let T = _[C], M;
                    if (T.vertexCount == 0)
                        M = new Object3D;
                    else {
                        let P = new BufferGeometry
                          , I = c.index
                          , k = I.array
                          , A = k.constructor
                          , O = A.BYTES_PER_ELEMENT;
                        P.setIndex(new BufferAttribute(new k.constructor(k.buffer,T.faceIndex * I.itemSize * O * b + (p.indices || 0),T.faceCount * I.itemSize * b),I.itemSize));
                        for (let W = 0, Q = P.index.array.length; W < Q; W++)
                            P.index.array[W] -= T.vertexIndex;
                        for (let W in c.attributes)
                            I = c.attributes[W],
                            k = I.array,
                            A = k.constructor,
                            O = A.BYTES_PER_ELEMENT,
                            P.setAttribute(W, new BufferAttribute(new k.constructor(k.buffer,T.vertexIndex * I.itemSize * O + (p[W] || 0),T.vertexCount * I.itemSize),I.itemSize));
                        g === "Mesh" ? M = new Mesh(P,new MeshNormalMaterial({
                            flatShading: !f
                        })) : g === "LineSegments" ? M = new LineSegments(P,new LineBasicMaterial) : M = new Points(P,new PointsMaterial({
                            sizeAttenuation: !1,
                            size: 2
                        })),
                        S.push(M)
                    }
                    T.parentIndex > -1 ? v[T.parentIndex].add(M) : w.add(M),
                    M.position.fromArray(T.position),
                    M.quaternion.fromArray(T.quaternion),
                    M.scale.fromArray(T.scale),
                    M.name = T.name,
                    M.userData.material = T.material,
                    v[C] = M
                }
                c.userData.meshList = S,
                c.userData.sceneObject = w
            }
            this.content = c
        }
        this.xmlhttp = void 0,
        super._onLoad(this)
    }
}
BufItem.type = "buf";
BufItem.extensions = ["buf"];
BufItem.responseType = "arraybuffer";
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var durl = function(a) {
    return URL.createObjectURL(new Blob([a],{
        type: "text/javascript"
    }))
};
try {
    URL.revokeObjectURL(durl(""))
} catch (a) {
    durl = function(e) {
        return "data:application/javascript;charset=UTF-8," + encodeURI(e)
    }
}
var u8 = Uint8Array
  , u16 = Uint16Array
  , u32 = Uint32Array
  , fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
  , fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
  , clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  , freb = function(a, e) {
    for (var t = new u16(31), r = 0; r < 31; ++r)
        t[r] = e += 1 << a[r - 1];
    for (var n = new u32(t[30]), r = 1; r < 30; ++r)
        for (var o = t[r]; o < t[r + 1]; ++o)
            n[o] = o - t[r] << 5 | r;
    return [t, n]
}
  , _a = freb(fleb, 2)
  , fl = _a[0]
  , revfl = _a[1];
fl[28] = 258,
revfl[258] = 28;
var _b = freb(fdeb, 0)
  , fd = _b[0]
  , rev = new u16(32768);
for (var i = 0; i < 32768; ++i) {
    var x = (i & 43690) >>> 1 | (i & 21845) << 1;
    x = (x & 52428) >>> 2 | (x & 13107) << 2,
    x = (x & 61680) >>> 4 | (x & 3855) << 4,
    rev[i] = ((x & 65280) >>> 8 | (x & 255) << 8) >>> 1
}
var hMap = function(a, e, t) {
    for (var r = a.length, n = 0, o = new u16(e); n < r; ++n)
        ++o[a[n] - 1];
    var l = new u16(e);
    for (n = 0; n < e; ++n)
        l[n] = l[n - 1] + o[n - 1] << 1;
    var c;
    if (t) {
        c = new u16(1 << e);
        var u = 15 - e;
        for (n = 0; n < r; ++n)
            if (a[n])
                for (var f = n << 4 | a[n], p = e - a[n], g = l[a[n] - 1]++ << p, v = g | (1 << p) - 1; g <= v; ++g)
                    c[rev[g] >>> u] = f
    } else
        for (c = new u16(r),
        n = 0; n < r; ++n)
            a[n] && (c[n] = rev[l[a[n] - 1]++] >>> 15 - a[n]);
    return c
}
  , flt = new u8(288);
for (var i = 0; i < 144; ++i)
    flt[i] = 8;
for (var i = 144; i < 256; ++i)
    flt[i] = 9;
for (var i = 256; i < 280; ++i)
    flt[i] = 7;
for (var i = 280; i < 288; ++i)
    flt[i] = 8;
var fdt = new u8(32);
for (var i = 0; i < 32; ++i)
    fdt[i] = 5;
var flrm = hMap(flt, 9, 1)
  , fdrm = hMap(fdt, 5, 1)
  , max = function(a) {
    for (var e = a[0], t = 1; t < a.length; ++t)
        a[t] > e && (e = a[t]);
    return e
}
  , bits = function(a, e, t) {
    var r = e / 8 | 0;
    return (a[r] | a[r + 1] << 8) >> (e & 7) & t
}
  , bits16 = function(a, e) {
    var t = e / 8 | 0;
    return (a[t] | a[t + 1] << 8 | a[t + 2] << 16) >> (e & 7)
}
  , shft = function(a) {
    return (a / 8 | 0) + (a & 7 && 1)
}
  , slc = function(a, e, t) {
    (e == null || e < 0) && (e = 0),
    (t == null || t > a.length) && (t = a.length);
    var r = new (a instanceof u16 ? u16 : a instanceof u32 ? u32 : u8)(t - e);
    return r.set(a.subarray(e, t)),
    r
}
  , inflt = function(a, e, t) {
    var r = a.length;
    if (!r || t && !t.l && r < 5)
        return e || new u8(0);
    var n = !e || t
      , o = !t || t.i;
    t || (t = {}),
    e || (e = new u8(r * 3));
    var l = function(L) {
        var N = e.length;
        if (L > N) {
            var oe = new u8(Math.max(N * 2, L));
            oe.set(e),
            e = oe
        }
    }
      , c = t.f || 0
      , u = t.p || 0
      , f = t.b || 0
      , p = t.l
      , g = t.d
      , v = t.m
      , _ = t.n
      , w = r * 8;
    do {
        if (!p) {
            t.f = c = bits(a, u, 1);
            var S = bits(a, u + 1, 3);
            if (u += 3,
            S)
                if (S == 1)
                    p = flrm,
                    g = fdrm,
                    v = 9,
                    _ = 5;
                else if (S == 2) {
                    var T = bits(a, u, 31) + 257
                      , M = bits(a, u + 10, 15) + 4
                      , P = T + bits(a, u + 5, 31) + 1;
                    u += 14;
                    for (var I = new u8(P), k = new u8(19), A = 0; A < M; ++A)
                        k[clim[A]] = bits(a, u + A * 3, 7);
                    u += M * 3;
                    for (var O = max(k), W = (1 << O) - 1, Q = hMap(k, O, 1), A = 0; A < P; ) {
                        var H = Q[bits(a, u, W)];
                        u += H & 15;
                        var b = H >>> 4;
                        if (b < 16)
                            I[A++] = b;
                        else {
                            var B = 0
                              , D = 0;
                            for (b == 16 ? (D = 3 + bits(a, u, 3),
                            u += 2,
                            B = I[A - 1]) : b == 17 ? (D = 3 + bits(a, u, 7),
                            u += 3) : b == 18 && (D = 11 + bits(a, u, 127),
                            u += 7); D--; )
                                I[A++] = B
                        }
                    }
                    var q = I.subarray(0, T)
                      , V = I.subarray(T);
                    v = max(q),
                    _ = max(V),
                    p = hMap(q, v, 1),
                    g = hMap(V, _, 1)
                } else
                    throw "invalid block type";
            else {
                var b = shft(u) + 4
                  , C = a[b - 4] | a[b - 3] << 8
                  , R = b + C;
                if (R > r) {
                    if (o)
                        throw "unexpected EOF";
                    break
                }
                n && l(f + C),
                e.set(a.subarray(b, R), f),
                t.b = f += C,
                t.p = u = R * 8;
                continue
            }
            if (u > w) {
                if (o)
                    throw "unexpected EOF";
                break
            }
        }
        n && l(f + 131072);
        for (var J = (1 << v) - 1, U = (1 << _) - 1, ce = u; ; ce = u) {
            var B = p[bits16(a, u) & J]
              , ee = B >>> 4;
            if (u += B & 15,
            u > w) {
                if (o)
                    throw "unexpected EOF";
                break
            }
            if (!B)
                throw "invalid length/literal";
            if (ee < 256)
                e[f++] = ee;
            else if (ee == 256) {
                ce = u,
                p = null;
                break
            } else {
                var ne = ee - 254;
                if (ee > 264) {
                    var A = ee - 257
                      , ae = fleb[A];
                    ne = bits(a, u, (1 << ae) - 1) + fl[A],
                    u += ae
                }
                var ve = g[bits16(a, u) & U]
                  , Y = ve >>> 4;
                if (!ve)
                    throw "invalid distance";
                u += ve & 15;
                var V = fd[Y];
                if (Y > 3) {
                    var ae = fdeb[Y];
                    V += bits16(a, u) & (1 << ae) - 1,
                    u += ae
                }
                if (u > w) {
                    if (o)
                        throw "unexpected EOF";
                    break
                }
                n && l(f + 131072);
                for (var $ = f + ne; f < $; f += 4)
                    e[f] = e[f - V],
                    e[f + 1] = e[f + 1 - V],
                    e[f + 2] = e[f + 2 - V],
                    e[f + 3] = e[f + 3 - V];
                f = $
            }
        }
        t.l = p,
        t.p = ce,
        t.b = f,
        p && (c = 1,
        t.m = v,
        t.d = g,
        t.n = _)
    } while (!c);
    return f == e.length ? e : slc(e, 0, f)
}
  , et = new u8(0)
  , zlv = function(a) {
    if ((a[0] & 15) != 8 || a[0] >>> 4 > 7 || (a[0] << 8 | a[1]) % 31)
        throw "invalid zlib data";
    if (a[1] & 32)
        throw "invalid zlib data: preset dictionaries not supported"
};
function unzlibSync(a, e) {
    return inflt((zlv(a),
    a.subarray(2, -4)), e)
}
var td = typeof TextDecoder < "u" && new TextDecoder
  , tds = 0;
try {
    td.decode(et, {
        stream: !0
    }),
    tds = 1
} catch (a) {}
class EXRLoader extends DataTextureLoader {
    constructor(e) {
        super(e),
        this.type = HalfFloatType
    }
    parse(e) {
        const O = Math.pow(2.7182818, 2.2);
        function W(E, F) {
            let X = 0;
            for (let me = 0; me < 65536; ++me)
                (me == 0 || E[me >> 3] & 1 << (me & 7)) && (F[X++] = me);
            const ie = X - 1;
            for (; X < 65536; )
                F[X++] = 0;
            return ie
        }
        function Q(E) {
            for (let F = 0; F < 16384; F++)
                E[F] = {},
                E[F].len = 0,
                E[F].lit = 0,
                E[F].p = null
        }
        const H = {
            l: 0,
            c: 0,
            lc: 0
        };
        function B(E, F, X, ie, me) {
            for (; X < E; )
                F = F << 8 | Xe(ie, me),
                X += 8;
            X -= E,
            H.l = F >> X & (1 << E) - 1,
            H.c = F,
            H.lc = X
        }
        const D = new Array(59);
        function q(E) {
            for (let X = 0; X <= 58; ++X)
                D[X] = 0;
            for (let X = 0; X < 65537; ++X)
                D[E[X]] += 1;
            let F = 0;
            for (let X = 58; X > 0; --X) {
                const ie = F + D[X] >> 1;
                D[X] = F,
                F = ie
            }
            for (let X = 0; X < 65537; ++X) {
                const ie = E[X];
                ie > 0 && (E[X] = ie | D[ie]++ << 6)
            }
        }
        function V(E, F, X, ie, me, ue) {
            const ye = F;
            let Pe = 0
              , De = 0;
            for (; ie <= me; ie++) {
                if (ye.value - F.value > X)
                    return !1;
                B(6, Pe, De, E, ye);
                const Re = H.l;
                if (Pe = H.c,
                De = H.lc,
                ue[ie] = Re,
                Re == 63) {
                    if (ye.value - F.value > X)
                        throw new Error("Something wrong with hufUnpackEncTable");
                    B(8, Pe, De, E, ye);
                    let Fe = H.l + 6;
                    if (Pe = H.c,
                    De = H.lc,
                    ie + Fe > me + 1)
                        throw new Error("Something wrong with hufUnpackEncTable");
                    for (; Fe--; )
                        ue[ie++] = 0;
                    ie--
                } else if (Re >= 59) {
                    let Fe = Re - 59 + 2;
                    if (ie + Fe > me + 1)
                        throw new Error("Something wrong with hufUnpackEncTable");
                    for (; Fe--; )
                        ue[ie++] = 0;
                    ie--
                }
            }
            q(ue)
        }
        function J(E) {
            return E & 63
        }
        function U(E) {
            return E >> 6
        }
        function ce(E, F, X, ie) {
            for (; F <= X; F++) {
                const me = U(E[F])
                  , ue = J(E[F]);
                if (me >> ue)
                    throw new Error("Invalid table entry");
                if (ue > 14) {
                    const ye = ie[me >> ue - 14];
                    if (ye.len)
                        throw new Error("Invalid table entry");
                    if (ye.lit++,
                    ye.p) {
                        const Pe = ye.p;
                        ye.p = new Array(ye.lit);
                        for (let De = 0; De < ye.lit - 1; ++De)
                            ye.p[De] = Pe[De]
                    } else
                        ye.p = new Array(1);
                    ye.p[ye.lit - 1] = F
                } else if (ue) {
                    let ye = 0;
                    for (let Pe = 1 << 14 - ue; Pe > 0; Pe--) {
                        const De = ie[(me << 14 - ue) + ye];
                        if (De.len || De.p)
                            throw new Error("Invalid table entry");
                        De.len = ue,
                        De.lit = F,
                        ye++
                    }
                }
            }
            return !0
        }
        const ee = {
            c: 0,
            lc: 0
        };
        function ne(E, F, X, ie) {
            E = E << 8 | Xe(X, ie),
            F += 8,
            ee.c = E,
            ee.lc = F
        }
        const ae = {
            c: 0,
            lc: 0
        };
        function ve(E, F, X, ie, me, ue, ye, Pe, De) {
            if (E == F) {
                ie < 8 && (ne(X, ie, me, ue),
                X = ee.c,
                ie = ee.lc),
                ie -= 8;
                let Re = X >> ie;
                if (Re = new Uint8Array([Re])[0],
                Pe.value + Re > De)
                    return !1;
                const Fe = ye[Pe.value - 1];
                for (; Re-- > 0; )
                    ye[Pe.value++] = Fe
            } else if (Pe.value < De)
                ye[Pe.value++] = E;
            else
                return !1;
            ae.c = X,
            ae.lc = ie
        }
        function Y(E) {
            return E & 65535
        }
        function $(E) {
            const F = Y(E);
            return F > 32767 ? F - 65536 : F
        }
        const L = {
            a: 0,
            b: 0
        };
        function N(E, F) {
            const X = $(E)
              , me = $(F)
              , ue = X + (me & 1) + (me >> 1)
              , ye = ue
              , Pe = ue - me;
            L.a = ye,
            L.b = Pe
        }
        function oe(E, F) {
            const X = Y(E)
              , ie = Y(F)
              , me = X - (ie >> 1) & 65535
              , ue = ie + me - 32768 & 65535;
            L.a = ue,
            L.b = me
        }
        function pe(E, F, X, ie, me, ue, ye) {
            const Pe = ye < 16384
              , De = X > me ? me : X;
            let Re = 1, Fe, Be;
            for (; Re <= De; )
                Re <<= 1;
            for (Re >>= 1,
            Fe = Re,
            Re >>= 1; Re >= 1; ) {
                Be = 0;
                const Le = Be + ue * (me - Fe)
                  , Je = ue * Re
                  , je = ue * Fe
                  , $e = ie * Re
                  , Ze = ie * Fe;
                let rt, ut, ot, ft;
                for (; Be <= Le; Be += je) {
                    let at = Be;
                    const it = Be + ie * (X - Fe);
                    for (; at <= it; at += Ze) {
                        const dt = at + $e
                          , _t = at + Je
                          , mt = _t + $e;
                        Pe ? (N(E[at + F], E[_t + F]),
                        rt = L.a,
                        ot = L.b,
                        N(E[dt + F], E[mt + F]),
                        ut = L.a,
                        ft = L.b,
                        N(rt, ut),
                        E[at + F] = L.a,
                        E[dt + F] = L.b,
                        N(ot, ft),
                        E[_t + F] = L.a,
                        E[mt + F] = L.b) : (oe(E[at + F], E[_t + F]),
                        rt = L.a,
                        ot = L.b,
                        oe(E[dt + F], E[mt + F]),
                        ut = L.a,
                        ft = L.b,
                        oe(rt, ut),
                        E[at + F] = L.a,
                        E[dt + F] = L.b,
                        oe(ot, ft),
                        E[_t + F] = L.a,
                        E[mt + F] = L.b)
                    }
                    if (X & Re) {
                        const dt = at + Je;
                        Pe ? N(E[at + F], E[dt + F]) : oe(E[at + F], E[dt + F]),
                        rt = L.a,
                        E[dt + F] = L.b,
                        E[at + F] = rt
                    }
                }
                if (me & Re) {
                    let at = Be;
                    const it = Be + ie * (X - Fe);
                    for (; at <= it; at += Ze) {
                        const dt = at + $e;
                        Pe ? N(E[at + F], E[dt + F]) : oe(E[at + F], E[dt + F]),
                        rt = L.a,
                        E[dt + F] = L.b,
                        E[at + F] = rt
                    }
                }
                Fe = Re,
                Re >>= 1
            }
            return Be
        }
        function K(E, F, X, ie, me, ue, ye, Pe, De) {
            let Re = 0
              , Fe = 0;
            const Be = ye
              , Le = Math.trunc(ie.value + (me + 7) / 8);
            for (; ie.value < Le; )
                for (ne(Re, Fe, X, ie),
                Re = ee.c,
                Fe = ee.lc; Fe >= 14; ) {
                    const je = Re >> Fe - 14 & 16383
                      , $e = F[je];
                    if ($e.len)
                        Fe -= $e.len,
                        ve($e.lit, ue, Re, Fe, X, ie, Pe, De, Be),
                        Re = ae.c,
                        Fe = ae.lc;
                    else {
                        if (!$e.p)
                            throw new Error("hufDecode issues");
                        let Ze;
                        for (Ze = 0; Ze < $e.lit; Ze++) {
                            const rt = J(E[$e.p[Ze]]);
                            for (; Fe < rt && ie.value < Le; )
                                ne(Re, Fe, X, ie),
                                Re = ee.c,
                                Fe = ee.lc;
                            if (Fe >= rt && U(E[$e.p[Ze]]) == (Re >> Fe - rt & (1 << rt) - 1)) {
                                Fe -= rt,
                                ve($e.p[Ze], ue, Re, Fe, X, ie, Pe, De, Be),
                                Re = ae.c,
                                Fe = ae.lc;
                                break
                            }
                        }
                        if (Ze == $e.lit)
                            throw new Error("hufDecode issues")
                    }
                }
            const Je = 8 - me & 7;
            for (Re >>= Je,
            Fe -= Je; Fe > 0; ) {
                const je = F[Re << 14 - Fe & 16383];
                if (je.len)
                    Fe -= je.len,
                    ve(je.lit, ue, Re, Fe, X, ie, Pe, De, Be),
                    Re = ae.c,
                    Fe = ae.lc;
                else
                    throw new Error("hufDecode issues")
            }
            return !0
        }
        function Se(E, F, X, ie, me, ue) {
            const ye = {
                value: 0
            }
              , Pe = X.value
              , De = Ge(F, X)
              , Re = Ge(F, X);
            X.value += 4;
            const Fe = Ge(F, X);
            if (X.value += 4,
            De < 0 || De >= 65537 || Re < 0 || Re >= 65537)
                throw new Error("Something wrong with HUF_ENCSIZE");
            const Be = new Array(65537)
              , Le = new Array(16384);
            Q(Le);
            const Je = ie - (X.value - Pe);
            if (V(E, X, Je, De, Re, Be),
            Fe > 8 * (ie - (X.value - Pe)))
                throw new Error("Something wrong with hufUncompress");
            ce(Be, De, Re, Le),
            K(Be, Le, E, X, Fe, Re, ue, me, ye)
        }
        function Ce(E, F, X) {
            for (let ie = 0; ie < X; ++ie)
                F[ie] = E[F[ie]]
        }
        function Te(E) {
            for (let F = 1; F < E.length; F++) {
                const X = E[F - 1] + E[F] - 128;
                E[F] = X
            }
        }
        function we(E, F) {
            let X = 0
              , ie = Math.floor((E.length + 1) / 2)
              , me = 0;
            const ue = E.length - 1;
            for (; !(me > ue || (F[me++] = E[X++],
            me > ue)); )
                F[me++] = E[ie++]
        }
        function Ae(E) {
            let F = E.byteLength;
            const X = new Array;
            let ie = 0;
            const me = new DataView(E);
            for (; F > 0; ) {
                const ue = me.getInt8(ie++);
                if (ue < 0) {
                    const ye = -ue;
                    F -= ye + 1;
                    for (let Pe = 0; Pe < ye; Pe++)
                        X.push(me.getUint8(ie++))
                } else {
                    const ye = ue;
                    F -= 2;
                    const Pe = me.getUint8(ie++);
                    for (let De = 0; De < ye + 1; De++)
                        X.push(Pe)
                }
            }
            return X
        }
        function Ne(E, F, X, ie, me, ue) {
            let ye = new DataView(ue.buffer);
            const Pe = X[E.idx[0]].width
              , De = X[E.idx[0]].height
              , Re = 3
              , Fe = Math.floor(Pe / 8)
              , Be = Math.ceil(Pe / 8)
              , Le = Math.ceil(De / 8)
              , Je = Pe - (Be - 1) * 8
              , je = De - (Le - 1) * 8
              , $e = {
                value: 0
            }
              , Ze = new Array(Re)
              , rt = new Array(Re)
              , ut = new Array(Re)
              , ot = new Array(Re)
              , ft = new Array(Re);
            for (let it = 0; it < Re; ++it)
                ft[it] = F[E.idx[it]],
                Ze[it] = it < 1 ? 0 : Ze[it - 1] + Be * Le,
                rt[it] = new Float32Array(64),
                ut[it] = new Uint16Array(64),
                ot[it] = new Uint16Array(Be * 64);
            for (let it = 0; it < Le; ++it) {
                let dt = 8;
                it == Le - 1 && (dt = je);
                let _t = 8;
                for (let lt = 0; lt < Be; ++lt) {
                    lt == Be - 1 && (_t = Je);
                    for (let ht = 0; ht < Re; ++ht)
                        ut[ht].fill(0),
                        ut[ht][0] = me[Ze[ht]++],
                        Ue($e, ie, ut[ht]),
                        le(ut[ht], rt[ht]),
                        Z(rt[ht]);
                    He(rt);
                    for (let ht = 0; ht < Re; ++ht)
                        Ke(rt[ht], ot[ht], lt * 64)
                }
                let mt = 0;
                for (let lt = 0; lt < Re; ++lt) {
                    const ht = X[E.idx[lt]].type;
                    for (let St = 8 * it; St < 8 * it + dt; ++St) {
                        mt = ft[lt][St];
                        for (let Tt = 0; Tt < Fe; ++Tt) {
                            const yt = Tt * 64 + (St & 7) * 8;
                            ye.setUint16(mt + 0 * 2 * ht, ot[lt][yt + 0], !0),
                            ye.setUint16(mt + 1 * 2 * ht, ot[lt][yt + 1], !0),
                            ye.setUint16(mt + 2 * 2 * ht, ot[lt][yt + 2], !0),
                            ye.setUint16(mt + 3 * 2 * ht, ot[lt][yt + 3], !0),
                            ye.setUint16(mt + 4 * 2 * ht, ot[lt][yt + 4], !0),
                            ye.setUint16(mt + 5 * 2 * ht, ot[lt][yt + 5], !0),
                            ye.setUint16(mt + 6 * 2 * ht, ot[lt][yt + 6], !0),
                            ye.setUint16(mt + 7 * 2 * ht, ot[lt][yt + 7], !0),
                            mt += 8 * 2 * ht
                        }
                    }
                    if (Fe != Be)
                        for (let St = 8 * it; St < 8 * it + dt; ++St) {
                            const Tt = ft[lt][St] + 8 * Fe * 2 * ht
                              , yt = Fe * 64 + (St & 7) * 8;
                            for (let Ct = 0; Ct < _t; ++Ct)
                                ye.setUint16(Tt + Ct * 2 * ht, ot[lt][yt + Ct], !0)
                        }
                }
            }
            const at = new Uint16Array(Pe);
            ye = new DataView(ue.buffer);
            for (let it = 0; it < Re; ++it) {
                X[E.idx[it]].decoded = !0;
                const dt = X[E.idx[it]].type;
                if (X[it].type == 2)
                    for (let _t = 0; _t < De; ++_t) {
                        const mt = ft[it][_t];
                        for (let lt = 0; lt < Pe; ++lt)
                            at[lt] = ye.getUint16(mt + lt * 2 * dt, !0);
                        for (let lt = 0; lt < Pe; ++lt)
                            ye.setFloat32(mt + lt * 2 * dt, re(at[lt]), !0)
                    }
            }
        }
        function Ue(E, F, X) {
            let ie, me = 1;
            for (; me < 64; )
                ie = F[E.value],
                ie == 65280 ? me = 64 : ie >> 8 == 255 ? me += ie & 255 : (X[me] = ie,
                me++),
                E.value++
        }
        function le(E, F) {
            F[0] = re(E[0]),
            F[1] = re(E[1]),
            F[2] = re(E[5]),
            F[3] = re(E[6]),
            F[4] = re(E[14]),
            F[5] = re(E[15]),
            F[6] = re(E[27]),
            F[7] = re(E[28]),
            F[8] = re(E[2]),
            F[9] = re(E[4]),
            F[10] = re(E[7]),
            F[11] = re(E[13]),
            F[12] = re(E[16]),
            F[13] = re(E[26]),
            F[14] = re(E[29]),
            F[15] = re(E[42]),
            F[16] = re(E[3]),
            F[17] = re(E[8]),
            F[18] = re(E[12]),
            F[19] = re(E[17]),
            F[20] = re(E[25]),
            F[21] = re(E[30]),
            F[22] = re(E[41]),
            F[23] = re(E[43]),
            F[24] = re(E[9]),
            F[25] = re(E[11]),
            F[26] = re(E[18]),
            F[27] = re(E[24]),
            F[28] = re(E[31]),
            F[29] = re(E[40]),
            F[30] = re(E[44]),
            F[31] = re(E[53]),
            F[32] = re(E[10]),
            F[33] = re(E[19]),
            F[34] = re(E[23]),
            F[35] = re(E[32]),
            F[36] = re(E[39]),
            F[37] = re(E[45]),
            F[38] = re(E[52]),
            F[39] = re(E[54]),
            F[40] = re(E[20]),
            F[41] = re(E[22]),
            F[42] = re(E[33]),
            F[43] = re(E[38]),
            F[44] = re(E[46]),
            F[45] = re(E[51]),
            F[46] = re(E[55]),
            F[47] = re(E[60]),
            F[48] = re(E[21]),
            F[49] = re(E[34]),
            F[50] = re(E[37]),
            F[51] = re(E[47]),
            F[52] = re(E[50]),
            F[53] = re(E[56]),
            F[54] = re(E[59]),
            F[55] = re(E[61]),
            F[56] = re(E[35]),
            F[57] = re(E[36]),
            F[58] = re(E[48]),
            F[59] = re(E[49]),
            F[60] = re(E[57]),
            F[61] = re(E[58]),
            F[62] = re(E[62]),
            F[63] = re(E[63])
        }
        function Z(E) {
            const F = .5 * Math.cos(.7853975)
              , X = .5 * Math.cos(3.14159 / 16)
              , ie = .5 * Math.cos(3.14159 / 8)
              , me = .5 * Math.cos(3 * 3.14159 / 16)
              , ue = .5 * Math.cos(5 * 3.14159 / 16)
              , ye = .5 * Math.cos(3 * 3.14159 / 8)
              , Pe = .5 * Math.cos(7 * 3.14159 / 16)
              , De = new Array(4)
              , Re = new Array(4)
              , Fe = new Array(4)
              , Be = new Array(4);
            for (let Le = 0; Le < 8; ++Le) {
                const Je = Le * 8;
                De[0] = ie * E[Je + 2],
                De[1] = ye * E[Je + 2],
                De[2] = ie * E[Je + 6],
                De[3] = ye * E[Je + 6],
                Re[0] = X * E[Je + 1] + me * E[Je + 3] + ue * E[Je + 5] + Pe * E[Je + 7],
                Re[1] = me * E[Je + 1] - Pe * E[Je + 3] - X * E[Je + 5] - ue * E[Je + 7],
                Re[2] = ue * E[Je + 1] - X * E[Je + 3] + Pe * E[Je + 5] + me * E[Je + 7],
                Re[3] = Pe * E[Je + 1] - ue * E[Je + 3] + me * E[Je + 5] - X * E[Je + 7],
                Fe[0] = F * (E[Je + 0] + E[Je + 4]),
                Fe[3] = F * (E[Je + 0] - E[Je + 4]),
                Fe[1] = De[0] + De[3],
                Fe[2] = De[1] - De[2],
                Be[0] = Fe[0] + Fe[1],
                Be[1] = Fe[3] + Fe[2],
                Be[2] = Fe[3] - Fe[2],
                Be[3] = Fe[0] - Fe[1],
                E[Je + 0] = Be[0] + Re[0],
                E[Je + 1] = Be[1] + Re[1],
                E[Je + 2] = Be[2] + Re[2],
                E[Je + 3] = Be[3] + Re[3],
                E[Je + 4] = Be[3] - Re[3],
                E[Je + 5] = Be[2] - Re[2],
                E[Je + 6] = Be[1] - Re[1],
                E[Je + 7] = Be[0] - Re[0]
            }
            for (let Le = 0; Le < 8; ++Le)
                De[0] = ie * E[16 + Le],
                De[1] = ye * E[16 + Le],
                De[2] = ie * E[48 + Le],
                De[3] = ye * E[48 + Le],
                Re[0] = X * E[8 + Le] + me * E[24 + Le] + ue * E[40 + Le] + Pe * E[56 + Le],
                Re[1] = me * E[8 + Le] - Pe * E[24 + Le] - X * E[40 + Le] - ue * E[56 + Le],
                Re[2] = ue * E[8 + Le] - X * E[24 + Le] + Pe * E[40 + Le] + me * E[56 + Le],
                Re[3] = Pe * E[8 + Le] - ue * E[24 + Le] + me * E[40 + Le] - X * E[56 + Le],
                Fe[0] = F * (E[Le] + E[32 + Le]),
                Fe[3] = F * (E[Le] - E[32 + Le]),
                Fe[1] = De[0] + De[3],
                Fe[2] = De[1] - De[2],
                Be[0] = Fe[0] + Fe[1],
                Be[1] = Fe[3] + Fe[2],
                Be[2] = Fe[3] - Fe[2],
                Be[3] = Fe[0] - Fe[1],
                E[0 + Le] = Be[0] + Re[0],
                E[8 + Le] = Be[1] + Re[1],
                E[16 + Le] = Be[2] + Re[2],
                E[24 + Le] = Be[3] + Re[3],
                E[32 + Le] = Be[3] - Re[3],
                E[40 + Le] = Be[2] - Re[2],
                E[48 + Le] = Be[1] - Re[1],
                E[56 + Le] = Be[0] - Re[0]
        }
        function He(E) {
            for (let F = 0; F < 64; ++F) {
                const X = E[0][F]
                  , ie = E[1][F]
                  , me = E[2][F];
                E[0][F] = X + 1.5747 * me,
                E[1][F] = X - .1873 * ie - .4682 * me,
                E[2][F] = X + 1.8556 * ie
            }
        }
        function Ke(E, F, X) {
            for (let ie = 0; ie < 64; ++ie)
                F[X + ie] = DataUtils.toHalfFloat(j(E[ie]))
        }
        function j(E) {
            return E <= 1 ? Math.sign(E) * Math.pow(Math.abs(E), 2.2) : Math.sign(E) * Math.pow(O, Math.abs(E) - 1)
        }
        function z(E) {
            return new DataView(E.array.buffer,E.offset.value,E.size)
        }
        function ge(E) {
            const F = E.viewer.buffer.slice(E.offset.value, E.offset.value + E.size)
              , X = new Uint8Array(Ae(F))
              , ie = new Uint8Array(X.length);
            return Te(X),
            we(X, ie),
            new DataView(ie.buffer)
        }
        function Ee(E) {
            const F = E.array.slice(E.offset.value, E.offset.value + E.size)
              , X = unzlibSync(F)
              , ie = new Uint8Array(X.length);
            return Te(X),
            we(X, ie),
            new DataView(ie.buffer)
        }
        function Oe(E) {
            const F = E.viewer
              , X = {
                value: E.offset.value
            }
              , ie = new Uint16Array(E.width * E.scanlineBlockSize * (E.channels * E.type))
              , me = new Uint8Array(8192);
            let ue = 0;
            const ye = new Array(E.channels);
            for (let je = 0; je < E.channels; je++)
                ye[je] = {},
                ye[je].start = ue,
                ye[je].end = ye[je].start,
                ye[je].nx = E.width,
                ye[je].ny = E.lines,
                ye[je].size = E.type,
                ue += ye[je].nx * ye[je].ny * ye[je].size;
            const Pe = Ie(F, X)
              , De = Ie(F, X);
            if (De >= 8192)
                throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
            if (Pe <= De)
                for (let je = 0; je < De - Pe + 1; je++)
                    me[je + Pe] = Qe(F, X);
            const Re = new Uint16Array(65536)
              , Fe = W(me, Re)
              , Be = Ge(F, X);
            Se(E.array, F, X, Be, ie, ue);
            for (let je = 0; je < E.channels; ++je) {
                const $e = ye[je];
                for (let Ze = 0; Ze < ye[je].size; ++Ze)
                    pe(ie, $e.start + Ze, $e.nx, $e.size, $e.ny, $e.nx * $e.size, Fe)
            }
            Ce(Re, ie, ue);
            let Le = 0;
            const Je = new Uint8Array(ie.buffer.byteLength);
            for (let je = 0; je < E.lines; je++)
                for (let $e = 0; $e < E.channels; $e++) {
                    const Ze = ye[$e]
                      , rt = Ze.nx * Ze.size
                      , ut = new Uint8Array(ie.buffer,Ze.end * 2,rt * 2);
                    Je.set(ut, Le),
                    Le += rt * 2,
                    Ze.end += rt
                }
            return new DataView(Je.buffer)
        }
        function ze(E) {
            const F = E.array.slice(E.offset.value, E.offset.value + E.size)
              , X = unzlibSync(F)
              , ie = E.lines * E.channels * E.width
              , me = E.type == 1 ? new Uint16Array(ie) : new Uint32Array(ie);
            let ue = 0
              , ye = 0;
            const Pe = new Array(4);
            for (let De = 0; De < E.lines; De++)
                for (let Re = 0; Re < E.channels; Re++) {
                    let Fe = 0;
                    switch (E.type) {
                    case 1:
                        Pe[0] = ue,
                        Pe[1] = Pe[0] + E.width,
                        ue = Pe[1] + E.width;
                        for (let Be = 0; Be < E.width; ++Be) {
                            const Le = X[Pe[0]++] << 8 | X[Pe[1]++];
                            Fe += Le,
                            me[ye] = Fe,
                            ye++
                        }
                        break;
                    case 2:
                        Pe[0] = ue,
                        Pe[1] = Pe[0] + E.width,
                        Pe[2] = Pe[1] + E.width,
                        ue = Pe[2] + E.width;
                        for (let Be = 0; Be < E.width; ++Be) {
                            const Le = X[Pe[0]++] << 24 | X[Pe[1]++] << 16 | X[Pe[2]++] << 8;
                            Fe += Le,
                            me[ye] = Fe,
                            ye++
                        }
                        break
                    }
                }
            return new DataView(me.buffer)
        }
        function te(E) {
            const F = E.viewer
              , X = {
                value: E.offset.value
            }
              , ie = new Uint8Array(E.width * E.lines * (E.channels * E.type * 2))
              , me = {
                version: tt(F, X),
                unknownUncompressedSize: tt(F, X),
                unknownCompressedSize: tt(F, X),
                acCompressedSize: tt(F, X),
                dcCompressedSize: tt(F, X),
                rleCompressedSize: tt(F, X),
                rleUncompressedSize: tt(F, X),
                rleRawSize: tt(F, X),
                totalAcUncompressedCount: tt(F, X),
                totalDcUncompressedCount: tt(F, X),
                acCompression: tt(F, X)
            };
            if (me.version < 2)
                throw new Error("EXRLoader.parse: " + fe.compression + " version " + me.version + " is unsupported");
            const ue = new Array;
            let ye = Ie(F, X) - 2;
            for (; ye > 0; ) {
                const $e = be(F.buffer, X)
                  , Ze = Qe(F, X)
                  , rt = Ze >> 2 & 3
                  , ut = (Ze >> 4) - 1
                  , ot = new Int8Array([ut])[0]
                  , ft = Qe(F, X);
                ue.push({
                    name: $e,
                    index: ot,
                    type: ft,
                    compression: rt
                }),
                ye -= $e.length + 3
            }
            const Pe = fe.channels
              , De = new Array(E.channels);
            for (let $e = 0; $e < E.channels; ++$e) {
                const Ze = De[$e] = {}
                  , rt = Pe[$e];
                Ze.name = rt.name,
                Ze.compression = 0,
                Ze.decoded = !1,
                Ze.type = rt.pixelType,
                Ze.pLinear = rt.pLinear,
                Ze.width = E.width,
                Ze.height = E.lines
            }
            const Re = {
                idx: new Array(3)
            };
            for (let $e = 0; $e < E.channels; ++$e) {
                const Ze = De[$e];
                for (let rt = 0; rt < ue.length; ++rt) {
                    const ut = ue[rt];
                    Ze.name == ut.name && (Ze.compression = ut.compression,
                    ut.index >= 0 && (Re.idx[ut.index] = $e),
                    Ze.offset = $e)
                }
            }
            let Fe, Be, Le;
            if (me.acCompressedSize > 0)
                switch (me.acCompression) {
                case 0:
                    Fe = new Uint16Array(me.totalAcUncompressedCount),
                    Se(E.array, F, X, me.acCompressedSize, Fe, me.totalAcUncompressedCount);
                    break;
                case 1:
                    const $e = E.array.slice(X.value, X.value + me.totalAcUncompressedCount)
                      , Ze = unzlibSync($e);
                    Fe = new Uint16Array(Ze.buffer),
                    X.value += me.totalAcUncompressedCount;
                    break
                }
            if (me.dcCompressedSize > 0) {
                const $e = {
                    array: E.array,
                    offset: X,
                    size: me.dcCompressedSize
                };
                Be = new Uint16Array(Ee($e).buffer),
                X.value += me.dcCompressedSize
            }
            if (me.rleRawSize > 0) {
                const $e = E.array.slice(X.value, X.value + me.rleCompressedSize)
                  , Ze = unzlibSync($e);
                Le = Ae(Ze.buffer),
                X.value += me.rleCompressedSize
            }
            let Je = 0;
            const je = new Array(De.length);
            for (let $e = 0; $e < je.length; ++$e)
                je[$e] = new Array;
            for (let $e = 0; $e < E.lines; ++$e)
                for (let Ze = 0; Ze < De.length; ++Ze)
                    je[Ze].push(Je),
                    Je += De[Ze].width * E.type * 2;
            Ne(Re, je, De, Fe, Be, ie);
            for (let $e = 0; $e < De.length; ++$e) {
                const Ze = De[$e];
                if (!Ze.decoded)
                    switch (Ze.compression) {
                    case 2:
                        let rt = 0
                          , ut = 0;
                        for (let ot = 0; ot < E.lines; ++ot) {
                            let ft = je[$e][rt];
                            for (let at = 0; at < Ze.width; ++at) {
                                for (let it = 0; it < 2 * Ze.type; ++it)
                                    ie[ft++] = Le[ut + it * Ze.width * Ze.height];
                                ut++
                            }
                            rt++
                        }
                        break;
                    case 1:
                    default:
                        throw new Error("EXRLoader.parse: unsupported channel compression")
                    }
            }
            return new DataView(ie.buffer)
        }
        function be(E, F) {
            const X = new Uint8Array(E);
            let ie = 0;
            for (; X[F.value + ie] != 0; )
                ie += 1;
            const me = new TextDecoder().decode(X.slice(F.value, F.value + ie));
            return F.value = F.value + ie + 1,
            me
        }
        function xe(E, F, X) {
            const ie = new TextDecoder().decode(new Uint8Array(E).slice(F.value, F.value + X));
            return F.value = F.value + X,
            ie
        }
        function ke(E, F) {
            const X = Ve(E, F)
              , ie = Ge(E, F);
            return [X, ie]
        }
        function qe(E, F) {
            const X = Ge(E, F)
              , ie = Ge(E, F);
            return [X, ie]
        }
        function Ve(E, F) {
            const X = E.getInt32(F.value, !0);
            return F.value = F.value + 4,
            X
        }
        function Ge(E, F) {
            const X = E.getUint32(F.value, !0);
            return F.value = F.value + 4,
            X
        }
        function Xe(E, F) {
            const X = E[F.value];
            return F.value = F.value + 1,
            X
        }
        function Qe(E, F) {
            const X = E.getUint8(F.value);
            return F.value = F.value + 1,
            X
        }
        const tt = function(E, F) {
            const X = Number(E.getBigInt64(F.value, !0));
            return F.value += 8,
            X
        };
        function nt(E, F) {
            const X = E.getFloat32(F.value, !0);
            return F.value += 4,
            X
        }
        function se(E, F) {
            return DataUtils.toHalfFloat(nt(E, F))
        }
        function re(E) {
            const F = (E & 31744) >> 10
              , X = E & 1023;
            return (E >> 15 ? -1 : 1) * (F ? F === 31 ? X ? NaN : 1 / 0 : Math.pow(2, F - 15) * (1 + X / 1024) : 6103515625e-14 * (X / 1024))
        }
        function Ie(E, F) {
            const X = E.getUint16(F.value, !0);
            return F.value += 2,
            X
        }
        function We(E, F) {
            return re(Ie(E, F))
        }
        function Ye(E, F, X, ie) {
            const me = X.value
              , ue = [];
            for (; X.value < me + ie - 1; ) {
                const ye = be(F, X)
                  , Pe = Ve(E, X)
                  , De = Qe(E, X);
                X.value += 3;
                const Re = Ve(E, X)
                  , Fe = Ve(E, X);
                ue.push({
                    name: ye,
                    pixelType: Pe,
                    pLinear: De,
                    xSampling: Re,
                    ySampling: Fe
                })
            }
            return X.value += 1,
            ue
        }
        function st(E, F) {
            const X = nt(E, F)
              , ie = nt(E, F)
              , me = nt(E, F)
              , ue = nt(E, F)
              , ye = nt(E, F)
              , Pe = nt(E, F)
              , De = nt(E, F)
              , Re = nt(E, F);
            return {
                redX: X,
                redY: ie,
                greenX: me,
                greenY: ue,
                blueX: ye,
                blueY: Pe,
                whiteX: De,
                whiteY: Re
            }
        }
        function pt(E, F) {
            const X = ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"]
              , ie = Qe(E, F);
            return X[ie]
        }
        function gt(E, F) {
            const X = Ge(E, F)
              , ie = Ge(E, F)
              , me = Ge(E, F)
              , ue = Ge(E, F);
            return {
                xMin: X,
                yMin: ie,
                xMax: me,
                yMax: ue
            }
        }
        function bt(E, F) {
            const X = ["INCREASING_Y"]
              , ie = Qe(E, F);
            return X[ie]
        }
        function ct(E, F) {
            const X = nt(E, F)
              , ie = nt(E, F);
            return [X, ie]
        }
        function xt(E, F) {
            const X = nt(E, F)
              , ie = nt(E, F)
              , me = nt(E, F);
            return [X, ie, me]
        }
        function vt(E, F, X, ie, me) {
            if (ie === "string" || ie === "stringvector" || ie === "iccProfile")
                return xe(F, X, me);
            if (ie === "chlist")
                return Ye(E, F, X, me);
            if (ie === "chromaticities")
                return st(E, X);
            if (ie === "compression")
                return pt(E, X);
            if (ie === "box2i")
                return gt(E, X);
            if (ie === "lineOrder")
                return bt(E, X);
            if (ie === "float")
                return nt(E, X);
            if (ie === "v2f")
                return ct(E, X);
            if (ie === "v3f")
                return xt(E, X);
            if (ie === "int")
                return Ve(E, X);
            if (ie === "rational")
                return ke(E, X);
            if (ie === "timecode")
                return qe(E, X);
            if (ie === "preview")
                return X.value += me,
                "skipped";
            X.value += me
        }
        function Mt(E, F, X) {
            const ie = {};
            if (E.getUint32(0, !0) != 20000630)
                throw new Error("THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.");
            ie.version = E.getUint8(4);
            const me = E.getUint8(5);
            ie.spec = {
                singleTile: !!(me & 2),
                longName: !!(me & 4),
                deepFormat: !!(me & 8),
                multiPart: !!(me & 16)
            },
            X.value = 8;
            let ue = !0;
            for (; ue; ) {
                const ye = be(F, X);
                if (ye == 0)
                    ue = !1;
                else {
                    const Pe = be(F, X)
                      , De = Ge(E, X)
                      , Re = vt(E, F, X, Pe, De);
                    Re === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${Pe}'.`) : ie[ye] = Re
                }
            }
            if (me & -5)
                throw console.error("EXRHeader:", ie),
                new Error("THREE.EXRLoader: provided file is currently unsupported.");
            return ie
        }
        function Rt(E, F, X, ie, me) {
            const ue = {
                size: 0,
                viewer: F,
                array: X,
                offset: ie,
                width: E.dataWindow.xMax - E.dataWindow.xMin + 1,
                height: E.dataWindow.yMax - E.dataWindow.yMin + 1,
                channels: E.channels.length,
                bytesPerLine: null,
                lines: null,
                inputSize: null,
                type: E.channels[0].pixelType,
                uncompress: null,
                getter: null,
                format: null,
                encoding: null
            };
            switch (E.compression) {
            case "NO_COMPRESSION":
                ue.lines = 1,
                ue.uncompress = z;
                break;
            case "RLE_COMPRESSION":
                ue.lines = 1,
                ue.uncompress = ge;
                break;
            case "ZIPS_COMPRESSION":
                ue.lines = 1,
                ue.uncompress = Ee;
                break;
            case "ZIP_COMPRESSION":
                ue.lines = 16,
                ue.uncompress = Ee;
                break;
            case "PIZ_COMPRESSION":
                ue.lines = 32,
                ue.uncompress = Oe;
                break;
            case "PXR24_COMPRESSION":
                ue.lines = 16,
                ue.uncompress = ze;
                break;
            case "DWAA_COMPRESSION":
                ue.lines = 32,
                ue.uncompress = te;
                break;
            case "DWAB_COMPRESSION":
                ue.lines = 256,
                ue.uncompress = te;
                break;
            default:
                throw new Error("EXRLoader.parse: " + E.compression + " is unsupported")
            }
            if (ue.scanlineBlockSize = ue.lines,
            ue.type == 1)
                switch (me) {
                case FloatType:
                    ue.getter = We,
                    ue.inputSize = 2;
                    break;
                case HalfFloatType:
                    ue.getter = Ie,
                    ue.inputSize = 2;
                    break
                }
            else if (ue.type == 2)
                switch (me) {
                case FloatType:
                    ue.getter = nt,
                    ue.inputSize = 4;
                    break;
                case HalfFloatType:
                    ue.getter = se,
                    ue.inputSize = 4
                }
            else
                throw new Error("EXRLoader.parse: unsupported pixelType " + ue.type + " for " + E.compression + ".");
            ue.blockCount = (E.dataWindow.yMax + 1) / ue.scanlineBlockSize;
            for (let Pe = 0; Pe < ue.blockCount; Pe++)
                tt(F, ie);
            ue.outputChannels = ue.channels == 3 ? 4 : ue.channels;
            const ye = ue.width * ue.height * ue.outputChannels;
            switch (me) {
            case FloatType:
                ue.byteArray = new Float32Array(ye),
                ue.channels < ue.outputChannels && ue.byteArray.fill(1, 0, ye);
                break;
            case HalfFloatType:
                ue.byteArray = new Uint16Array(ye),
                ue.channels < ue.outputChannels && ue.byteArray.fill(15360, 0, ye);
                break;
            default:
                console.error("THREE.EXRLoader: unsupported type: ", me);
                break
            }
            return ue.bytesPerLine = ue.width * ue.inputSize * ue.channels,
            ue.outputChannels == 4 ? (ue.format = RGBAFormat,
            ue.encoding = LinearEncoding) : (ue.format = RedFormat,
            ue.encoding = LinearEncoding),
            ue
        }
        const wt = new DataView(e)
          , Pt = new Uint8Array(e)
          , G = {
            value: 0
        }
          , fe = Mt(wt, e, G)
          , de = Rt(fe, wt, Pt, G, this.type)
          , he = {
            value: 0
        }
          , Me = {
            R: 0,
            G: 1,
            B: 2,
            A: 3,
            Y: 0
        };
        for (let E = 0; E < de.height / de.scanlineBlockSize; E++) {
            const F = Ge(wt, G);
            de.size = Ge(wt, G),
            de.lines = F + de.scanlineBlockSize > de.height ? de.height - F : de.scanlineBlockSize;
            const ie = de.size < de.lines * de.bytesPerLine ? de.uncompress(de) : z(de);
            G.value += de.size;
            for (let me = 0; me < de.scanlineBlockSize; me++) {
                const ue = me + E * de.scanlineBlockSize;
                if (ue >= de.height)
                    break;
                for (let ye = 0; ye < de.channels; ye++) {
                    const Pe = Me[fe.channels[ye].name];
                    for (let De = 0; De < de.width; De++) {
                        he.value = (me * (de.channels * de.width) + ye * de.width + De) * de.inputSize;
                        const Re = (de.height - 1 - ue) * (de.width * de.outputChannels) + De * de.outputChannels + Pe;
                        de.byteArray[Re] = de.getter(ie, he)
                    }
                }
            }
        }
        return {
            header: fe,
            width: de.width,
            height: de.height,
            data: de.byteArray,
            format: de.format,
            encoding: de.encoding,
            type: this.type
        }
    }
    setDataType(e) {
        return this.type = e,
        this
    }
    load(e, t, r, n) {
        function o(l, c) {
            l.encoding = c.encoding,
            l.minFilter = LinearFilter,
            l.magFilter = LinearFilter,
            l.generateMipmaps = !1,
            l.flipY = !1,
            t && t(l, c)
        }
        return super.load(e, o, r, n)
    }
}
const AnyItem$2 = properties.loader.ITEM_CLASSES.any;
class EXRItem extends AnyItem$2 {
    constructor(e, t) {
        super(e, {
            ...t,
            responseType: "type"
        }),
        this.EXRLoader = new EXRLoader
    }
    retrieve() {
        return !1
    }
    _onLoad(e) {
        this.content = e,
        super._onLoad(this)
    }
    loadFunc() {
        this.EXRLoader.load(this.url, this._onLoad.bind(this), this._onGLTFLoading.bind(this))
    }
    _onGLTFLoading(e) {
        this.hasLoading && this.loadingSignal.dispatch(e.loaded / e.total)
    }
}
EXRItem.type = "exr";
EXRItem.extensions = ["exr"];
const ImageItem = properties.loader.ITEM_CLASSES.image;
class TextureItem extends ImageItem {
    constructor(e, t) {
        let r = t.content || new Texture(new Image);
        switch (t.content = r.image,
        r.size = new Vector2,
        r.minFilter = t.minFilter || LinearMipMapLinearFilter,
        r.minFilter) {
        case NearestMipMapNearestFilter:
        case NearestMipMapLinearFilter:
        case LinearMipMapNearestFilter:
        case LinearMipMapLinearFilter:
            r.generateMipmaps = !0,
            r.anisotropy = t.anisotropy || properties.renderer.capabilities.getMaxAnisotropy();
            break;
        default:
            r.generateMipmaps = !1
        }
        r.flipY = t.flipY === void 0 ? !0 : t.flipY,
        t.wrap ? r.wrapS = r.wrapT = t.wrap : (t.wrapS && (r.wrapS = t.wrapS),
        t.wrapT && (r.wrapT = t.wrapT)),
        super(e, t),
        this.content = r
    }
    retrieve() {
        return !1
    }
    load() {
        this.isStartLoaded = !0;
        let e = this.content.image;
        e.onload = this.boundOnLoad,
        e.src = this.url
    }
    _onLoad() {
        delete this.content.image.onload,
        this.width = this.content.image.width,
        this.height = this.content.image.height,
        this.content.size.set(this.width, this.height),
        this.content.needsUpdate = !0,
        taskManager.add(this.content),
        this.onPost ? this.onPost.call(this, this.content, this.onPostLoadingSignal) : this._onLoadComplete()
    }
}
TextureItem.type = "texture";
TextureItem.extensions = [];
const AnyItem$1 = properties.loader.ITEM_CLASSES.any;
class ThreeLoaderItem extends AnyItem$1 {
    constructor(e, t) {
        t.loadFunc = () => {}
        ,
        t.hasLoading = t.hasLoading === void 0 ? !0 : t.hasLoading,
        super(e, t),
        !t.loader && console && (console.error || console.log)("loader is required."),
        this.loadFunc = this._loadFunc.bind(this)
    }
    _loadFunc(e, t, r) {
        this.loader.load(e, this._onLoaderLoad.bind(this, t), this._onLoaderLoading.bind(this, r))
    }
    _onLoaderLoad(e, t) {
        this.content = t,
        e(t)
    }
    _onLoaderLoading(e, t) {
        e.dispatch(t.loaded / t.total)
    }
}
ThreeLoaderItem.type = "three-loader";
ThreeLoaderItem.extensions = [];
const shader = `#define GLSLIFY 1
uniform vec2 u_glPositionOffset;vec4 glPositionOffset(vec4 glPosition){return glPosition+vec4(u_glPositionOffset*glPosition.w,0.0,0.0);}`;
class GlPositionOffset {
    offset = new Vector2;
    sharedUniforms = {
        u_glPositionOffset: {
            value: null
        }
    };
    init() {
        this.sharedUniforms.u_glPositionOffset.value = this.offset,
        shaderHelper.addChunk("glPositionOffset", shader)
    }
    setOffset(e, t) {
        return this.offset.set(e, t)
    }
}
const glPositionOffset = new GlPositionOffset;
class Support {
    isSupported() {
        return properties._isSupportedDevice = !0,
        properties._isSupportedBrowser = (browser$1.isChrome || browser$1.isSafari || browser$1.isEdge || browser$1.isFirefox || browser$1.isOpera) && !browser$1.isIE,
        properties._isSupportedWebGL = this.checkSupportWebGL(),
        properties._isSupportedWebGL
    }
    checkSupportWebGL() {
        if (!(properties.canvas instanceof HTMLCanvasElement))
            return !1;
        if (settings.USE_WEBGL2 && window.WebGL2RenderingContext)
            try {
                return properties.gl = properties.canvas.getContext("webgl2", properties.webglOpts),
                settings.RENDER_TARGET_FLOAT_TYPE = HalfFloatType,
                settings.DATA_FLOAT_TYPE = FloatType,
                !0
            } catch (e) {
                return console.error(e),
                !1
            }
        if (settings.USE_WEBGL2 = !1,
        window.WebGLRenderingContext)
            try {
                let e = properties.gl = properties.canvas.getContext("webgl", properties.webglOpts) || properties.canvas.getContext("experimental-webgl", properties.webglOpts);
                if ((e.getExtension("OES_texture_float") || e.getExtension("OES_texture_half_float")) && e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS))
                    settings.RENDER_TARGET_FLOAT_TYPE = browser$1.isIOS || e.getExtension("OES_texture_half_float") ? HalfFloatType : FloatType,
                    settings.DATA_FLOAT_TYPE = FloatType;
                else
                    return settings.USE_FLOAT_PACKING = !0,
                    settings.RENDER_TARGET_FLOAT_TYPE = settings.DATA_FLOAT_TYPE = UnsignedByteType,
                    !1;
                return !0
            } catch (e) {
                return console.error(e),
                !1
            }
        return !1
    }
}
const support = new Support
  , textureBicubicShader = `#define GLSLIFY 1
vec4 cubic(float v){vec4 n=vec4(1.0,2.0,3.0,4.0)-v;vec4 s=n*n*n;float x=s.x;float y=s.y-4.0*s.x;float z=s.z-4.0*s.y+6.0*s.x;float w=6.0-x-y-z;return vec4(x,y,z,w);}vec4 textureBicubic(sampler2D t,vec2 texCoords,vec2 textureSize){vec2 invTexSize=1.0/textureSize;texCoords=texCoords*textureSize-0.5;vec2 fxy=fract(texCoords);texCoords-=fxy;vec4 xcubic=cubic(fxy.x);vec4 ycubic=cubic(fxy.y);vec4 c=texCoords.xxyy+vec2(-0.5,1.5).xyxy;vec4 s=vec4(xcubic.xz+xcubic.yw,ycubic.xz+ycubic.yw);vec4 offset=c+vec4(xcubic.yw,ycubic.yw)/s;offset*=invTexSize.xxyy;vec4 sample0=texture2D(t,offset.xz);vec4 sample1=texture2D(t,offset.yz);vec4 sample2=texture2D(t,offset.xw);vec4 sample3=texture2D(t,offset.yw);float sx=s.x/(s.x+s.y);float sy=s.z/(s.z+s.w);return mix(mix(sample3,sample2,sx),mix(sample1,sample0,sx),sy);}vec4 textureBicubic(sampler2D t,vec2 texCoords,vec2 textureSize,vec4 clampRect){vec2 invTexSize=1.0/textureSize;texCoords=texCoords*textureSize-0.5;vec2 fxy=fract(texCoords);texCoords-=fxy;vec4 xcubic=cubic(fxy.x);vec4 ycubic=cubic(fxy.y);vec4 c=texCoords.xxyy+vec2(-0.5,1.5).xyxy;vec4 s=vec4(xcubic.xz+xcubic.yw,ycubic.xz+ycubic.yw);vec4 offset=c+vec4(xcubic.yw,ycubic.yw)/s;offset*=invTexSize.xxyy;vec4 sample0=texture2D(t,clamp(offset.xz,clampRect.xy,clampRect.zw));vec4 sample1=texture2D(t,clamp(offset.yz,clampRect.xy,clampRect.zw));vec4 sample2=texture2D(t,clamp(offset.xw,clampRect.xy,clampRect.zw));vec4 sample3=texture2D(t,clamp(offset.yw,clampRect.xy,clampRect.zw));float sx=s.x/(s.x+s.y);float sy=s.z/(s.z+s.w);return mix(mix(sample3,sample2,sx),mix(sample1,sample0,sx),sy);}`;
class App {
    initEngine() {
        if (properties.canvas = document.getElementById("canvas"),
        properties.isSupported = support.isSupported(),
        properties.isSupported) {
            properties.loader.register(BufItem),
            properties.loader.register(EXRItem),
            properties.loader.register(TextureItem),
            properties.loader.register(ThreeLoaderItem),
            properties.renderer = new WebGLRenderer({
                canvas: properties.canvas,
                context: properties.gl,
                premultipliedAlpha: !1
            }),
            properties.scene = new Scene,
            properties.camera = new PerspectiveCamera(45,1,.1,200),
            properties.scene.add(properties.camera),
            properties.sharedUniforms.u_resolution.value = properties.resolution = new Vector2,
            properties.sharedUniforms.u_viewportResolution.value = properties.viewportResolution = new Vector2,
            properties.sharedUniforms.u_bgColor.value = properties.bgColor = new Color,
            shaderHelper.addChunk("textureBicubic", textureBicubicShader),
            fboHelper.init(properties.renderer, settings.RENDER_TARGET_FLOAT_TYPE),
            textureHelper.init(),
            properties.postprocessing = new Postprocessing,
            properties.postprocessing.init(),
            blueNoise.preInit(),
            glPositionOffset.init(),
            screenPaint.init(),
            properties.smaa = new Smaa,
            properties.smaa.init(),
            properties.smaa.setTextures(properties.loader.add(settings.TEXTURE_PATH + "smaa-area.png", {
                weight: 32
            }).content, properties.loader.add(settings.TEXTURE_PATH + "smaa-search.png", {
                weight: .1
            }).content),
            properties.postprocessing.queue.push(properties.smaa);
            let e = !browser$1.isMobile || settings.USE_HD;
            properties.bloom = new Bloom,
            properties.bloom.init({
                USE_CONVOLUTION: e,
                USE_HD: e
            }),
            properties.postprocessing.queue.push(properties.bloom),
            properties.screenPaintDistortion = new ScreenPaintDistortion,
            properties.screenPaintDistortion.init({
                screenPaint
            }),
            properties.postprocessing.queue.push(properties.screenPaintDistortion),
            properties.final = new Final,
            properties.final.init(),
            properties.postprocessing.queue.push(properties.final),
            settings.UP_SCALE > 1 && (properties.upscaler = new Fsr,
            properties.upscaler.init(),
            properties.postprocessing.queue.push(properties.upscaler)),
            preUfx.init(),
            properties.postprocessing.queue.push(preUfx),
            postUfx.init(),
            properties.postprocessing.queue.push(postUfx)
        }
    }
    preInit() {
        settings.WEBGL_OFF || (cameraControls.preInit(),
        visuals.preInit(),
        audios.preInit())
    }
    init() {
        settings.WEBGL_OFF || (properties.smaa && properties.smaa.updateTextures(),
        cameraControls.init(),
        visuals.init(),
        audios.init(),
        settings.IS_DEV === !1 && (console.clear && console.clear(),
        console.log("%c Created by Lusion: https://lusion.co/", "border:2px solid gray; padding:5px; font-family:monospace; font-size:11px;")))
    }
    start() {
        visuals.start()
    }
    resize(e, t) {
        settings.WEBGL_OFF || (properties.renderer.setSize(e, t),
        properties.canvas.style.width = `${properties.viewportWidth}px`,
        properties.canvas.style.height = `${properties.viewportHeight}px`,
        properties.camera.aspect = properties.width / properties.height,
        properties.sharedUniforms.u_aspect.value = properties.camera.aspect,
        properties.camera.updateProjectionMatrix(),
        properties.postprocessing.setSize(properties.width, properties.height),
        screenPaint.resize(properties.width, properties.height),
        visuals.resize(properties.width, properties.height))
    }
    preUpdate(e=0) {
        visuals.deactivateAll()
    }
    update(e=0) {
        settings.WEBGL_OFF || (properties.time = properties.sharedUniforms.u_time.value += e,
        properties.deltaTime = properties.sharedUniforms.u_deltaTime.value = e,
        visuals.syncProperties(e),
        blueNoise.update(e),
        screenPaint.update(e),
        cameraControls.update(e),
        visuals.update(e),
        audios.update(e),
        properties.renderer.setClearColor(properties.bgColor, properties.clearAlpha),
        properties.bgColor.setStyle(properties.bgColorHex),
        aboutPageHeroEfxPrepass.isActive = aboutHero.isActive,
        aboutPageHeroEfx.isActive = aboutHero.isActive,
        goalTunnelEfx.isActive = goalTunnels.isActive,
        properties.bloom.amount = properties.bloomAmount,
        properties.bloom.radius = properties.bloomRadius,
        properties.bloom.threshold = properties.bloomThreshold,
        properties.bloom.smoothWidth = properties.bloomSmoothWidth,
        properties.bloom.haloWidth = properties.haloWidth,
        properties.bloom.haloRGBShift = properties.haloRGBShift,
        properties.bloom.haloStrength = properties.haloStrength,
        properties.bloom.haloMaskInner = properties.haloMaskInner,
        properties.bloom.haloMaskOuter = properties.haloMaskOuter,
        properties.bloom.saturation = properties.bloomSaturation,
        properties.bloom.highPassMultiplier = properties.bloomHighPassMultiplier * (properties.bloom.USE_CONVOLUTION ? 1 : 1.5),
        properties.final.isActive = properties.useFinal,
        properties.final.vignetteFrom = properties.vignetteFrom,
        properties.final.vignetteTo = properties.vignetteTo,
        properties.final.vignetteColor.setStyle(properties.vignetteColorHex),
        properties.final.saturation = properties.saturation,
        properties.final.contrast = properties.contrast,
        properties.final.brightness = properties.brightness,
        properties.final.tintColor.setStyle(properties.tintColorHex),
        properties.final.tintOpacity = properties.tintOpacity,
        properties.final.bgColor.setStyle(properties.bgColorHex),
        properties.final.opacity = properties.opacity,
        screenPaint.needsMouseDown = properties.screenPaintNeedsMouseDown,
        screenPaint.minRadius = 0,
        screenPaint.maxRadius = Math.max(40, properties.viewportWidth / 20),
        screenPaint.radiusDistanceRange = properties.screenPaintRadiusDistanceRange,
        screenPaint.pushStrength = properties.screenPaintPushStrength,
        screenPaint.velocityDissipation = properties.screenPaintVelocityDissipation,
        screenPaint.weight1Dissipation = properties.screenPaintWeight1Dissipation,
        screenPaint.weight2Dissipation = properties.screenPaintWeight2Dissipation,
        screenPaint.useNoise = properties.screenPaintUseNoise,
        screenPaint.curlScale = properties.screenPaintCurlScale,
        screenPaint.curlStrength = properties.screenPaintCurlStrength,
        properties.screenPaintDistortion.amount = properties.screenPaintDistortionAmount,
        properties.screenPaintDistortion.rgbShift = properties.screenPaintDistortionRGBShift,
        properties.screenPaintDistortion.colorMultiplier = properties.screenPaintDistortionColorMultiplier,
        properties.screenPaintDistortion.multiplier = properties.screenPaintDistortionMultiplier,
        properties.upscaler && (properties.upscaler.sharpness = properties.upscalerSharpness),
        transitionOverlay.activeRatio < 1 && properties.postprocessing.render(visuals.currentStage3D, properties.camera, !0),
        window.__debugTexture && fboHelper.debugTo(window.__debugTexture))
    }
}
const app = new App;
class Preloader {
    percentTarget = 0;
    percent = 0;
    percentToStart = 0;
    DELAY = 1.5;
    MIN_PRELOAD_DURATION = 1;
    PERCENT_BETWEEN_INIT_AND_START = .3;
    MIN_DURATION_BETWEEN_INIT_AND_START = .25;
    HIDE_DURATION = .5;
    isActive = !1;
    lineTransformTime = 0;
    digitsWidth = 0;
    preInit() {
        this.domContainer = document.getElementById("preloader"),
        this.domDigitsContainer = document.getElementById("preloader-percent-digits"),
        this.domDigits = document.querySelectorAll(".preloader-percent-digit");
        for (let e = 0; e < this.domDigits.length; e++) {
            let t = this.domDigits[e];
            t._domNums = t.querySelectorAll(".preloader-percent-digit-num"),
            t._easedVal = 0
        }
    }
    init() {}
    show(e, t) {
        this._initCallback = e,
        this._startCallback = t,
        this.isActive = !0,
        properties.loader.start(r => {
            this.percentTarget = r
        }
        )
    }
    hide() {}
    resize(e, t, r) {
        r !== !0 && (this.digitsWidth = this.domDigitsContainer.offsetWidth)
    }
    update(e) {
        if (!this.isActive)
            return;
        this.percent = Math.min(this.percentTarget, this.percent + (settings.SKIP_ANIMATION ? 1 : this.percentTarget > this.percent ? e : 0) / this.MIN_PRELOAD_DURATION),
        this.percentTarget == 1 && (properties.hasInitialized || this._initCallback(),
        this.percentToStart = settings.SKIP_ANIMATION ? 1 : Math.min(taskManager.percent, this.percentToStart + e / this.MIN_DURATION_BETWEEN_INIT_AND_START));
        let t = this.percentToStart * this.PERCENT_BETWEEN_INIT_AND_START + this.percent * (1 - this.PERCENT_BETWEEN_INIT_AND_START)
          , r = 0;
        t == 1 && (this.lineTransformTime += settings.SKIP_ANIMATION ? 1 : e,
        r = ease.expoInOut(math.saturate(this.lineTransformTime))),
        r == 1 && !properties.hasStarted && this._startCallback();
        let n = settings.SKIP_ANIMATION ? +properties.hasStarted : math.saturate(properties.startTime);
        for (let o = 0; o < this.domDigits.length; o++) {
            let l = this.domDigits[o]
              , c = Math.floor(t * 100 / Math.pow(10, this.domDigits.length - o - 1));
            l._easedVal = math.mix(l._easedVal, c, 1 - Math.exp(-7 * e)),
            c - l._easedVal < .01 && (l._easedVal = c);
            let u = l._easedVal % 10
              , f = Math.floor(u)
              , p = Math.ceil(u) % 10
              , g = u - f;
            l._domNums[0].innerHTML = f,
            l._domNums[1].innerHTML = p,
            l.style.transform = "translateY(" + -(g - ease.expoInOut(math.saturate(n * 1.2 - .2 * o / (this.domDigits.length - 1)))) * 50 + "%) translateY(-0.05em)"
        }
        transitionOverlay.loadBarRatio = t,
        transitionOverlay.lineTransformRatio = r,
        transitionOverlay.contentShowRatio = n,
        n == 1 && (this.domContainer.style.display = "none",
        this.isActive = !1)
    }
}
const preloader = new Preloader;
class Links {
    links = [];
    preInit() {
        Array.from(document.querySelectorAll(".is-link")).forEach(t => {
            const r = {
                el: t,
                canvas: document.createElement("canvas"),
                context: null,
                ratio: 0,
                animating: !1,
                color: t.classList.contains("is-email") ? "#000000" : "#ffffff"
            };
            r.context = r.canvas.getContext("2d"),
            r.el.style.position = "relative",
            r.el.style.width = "fit-content",
            r.canvas.style.position = "absolute",
            r.canvas.style.left = "0",
            r.canvas.style.top = "0",
            r.canvas.style.pointerEvents = "none",
            r.el.append(r.canvas),
            this.links.push(r)
        }
        )
    }
    init() {
        this.links.forEach(e => {
            e.el.addEventListener("mouseenter", this._onLinkMouseenter.bind(this)),
            e.el.addEventListener("mouseleave", this._onLinkMouseleave.bind(this))
        }
        )
    }
    resize() {
        this.links.forEach(e => {
            const t = e.el.getBoundingClientRect();
            e._width = t.width,
            e._height = t.height,
            e.canvas.width = e._width * settings.DPR,
            e.canvas.height = e._height * settings.DPR,
            e.canvas.style.width = e._width + "px",
            e.canvas.style.height = e._height + "px"
        }
        )
    }
    update(e) {
        this.links.forEach(t => {
            let r = t.ratio;
            if (t.ratio = math.saturate(t.ratio + (t.animating ? 1 : -1) * e * 3),
            t.ratio !== 0 || r !== t.ratio) {
                const n = ease.quadInOut(t.ratio)
                  , o = ease.quadOut(Math.abs(t.ratio * 2 - 1));
                t.context.save(),
                t.context.scale(settings.DPR, settings.DPR),
                t.context.lineWidth = 2,
                t.context.strokeStyle = t.color,
                t.context.clearRect(0, 0, t._width, t._height),
                t.context.beginPath(),
                t.context.moveTo(0, t._height - t.context.lineWidth / 2),
                t.context.arcTo(t._width * n, t._height - t.context.lineWidth / 2, t._width * n, t._height - t.context.lineWidth / 2 - 1, 30 * (1 - o)),
                t.context.stroke(),
                t.context.restore()
            }
        }
        )
    }
    _onLinkMouseenter(e) {
        const t = this.links.filter(r => r.el === e.target)[0];
        t.animating = !0
    }
    _onLinkMouseleave(e) {
        const t = this.links.filter(r => r.el === e.target)[0];
        t.animating = !1
    }
}
const links = new Links;
new Color;
class UI {
    domSectionsContainer = document.querySelector("#page-container");
    preInit() {
        settings.WEBGL_OFF || document.documentElement.classList.add("is-ready"),
        transitionOverlay.init(),
        preloader.preInit(),
        header.preInit(),
        links.preInit(),
        pageExtraSections.preInit()
    }
    preload(e, t) {
        preloader.show(e, t)
    }
    init() {
        header.init(),
        links.init(),
        pageExtraSections.init()
    }
    start() {
        preloader.hide(),
        header.show()
    }
    resize(e, t, r) {
        transitionOverlay.resize(e, t),
        preloader.resize(e, t, r),
        links.resize(e, t),
        header.resize(e, t),
        pageExtraSections.resize(e, t),
        videoOverlay.resize(e, t);
        const o = getComputedStyle(document.documentElement).getPropertyValue("--global-border-radius").split("px")[0];
        properties.globalRadius = properties.sharedUniforms.u_globalRadius.value = parseInt(o)
    }
    update(e) {
        preloader.update(e),
        transitionOverlay.update(e),
        links.update(e),
        header.update(e),
        pageExtraSections.update(e),
        videoOverlay.update(e)
    }
}
const ui = new UI
  , AnyItem = properties.loader.ITEM_CLASSES.any;
class FontItem extends AnyItem {
    constructor(e, t) {
        FontItem.dom || FontItem.initDom(),
        t.loadFunc = () => {}
        ,
        t.hasLoading = t.hasLoading === void 0 ? !0 : t.hasLoading,
        t.refText = "refing something...",
        t.refFontSize = t.refFontSize || 120,
        t.refFont = "Helvetica, Arial, FreeSans, Garuda, sans-serif",
        t.interval = t.interval || 20,
        t.refTextWidth = 0,
        super(e, t),
        this.loadFunc = this._loadFunc.bind(this)
    }
    static dom;
    static initDom() {
        let e = document.createElement("dom");
        e.style.position = "fixed",
        e.style.left = e.style.top = 0,
        e.style.visibility = "hidden",
        document.body.appendChild(e),
        FontItem.dom = e
    }
    _loadFunc(e, t, r) {
        let n = e.split(",")
          , o = [];
        for (let g = 0; g < n.length; g++)
            o.push(n[g].trim());
        n = this.refFont.split(":");
        let l = n[0], c = n[1] || "normal", u = n[2] || "normal", f, p = o.length;
        f = setInterval( () => {
            n = o[0].split(":"),
            l = n[0],
            c = n[1] || "normal",
            u = n[2] || "normal";
            let g = this._getTextWidth(l, c, u, this.refFont)
              , v = this._getTextWidth(this.refFont, c, u, this.refFont);
            g !== v && (o.shift(),
            r.dispatch((p - o.length) / p),
            o.length === 0 && (clearInterval(f),
            t()))
        }
        , this.interval)
    }
    _getTextWidth = (e, t, r, n) => {
        let o = FontItem.dom;
        return o.style.fontFamily = '"' + e + '"' + (n ? ", " + n : ""),
        o.style.fontWeight = t,
        o.style.fontStyle = r,
        o.innerHTML = this.refText,
        o.getBoundingClientRect().width
    }
    ;
    _onLoaderLoad(e, t) {
        this.content = t,
        e(t)
    }
    _onLoaderLoading(e, t) {
        e.dispatch(t.loaded / t.total)
    }
}
FontItem.type = "font";
FontItem.extensions = [];
let dateTime = performance.now()
  , _needsResize = !1;
function preRun() {
    for (const [a,e] of Object.entries(settings.CROSS_ORIGINS))
        properties.loader.setCrossOrigin(a, e);
    routeManager.init(),
    properties.loader.register(FontItem),
    properties.loader.add("Aeonik:400", {
        type: "font"
    }),
    properties.loader.start(a => {
        a === 1 && run()
    }
    )
}
function run() {
    let a = properties.viewportWidth = window.innerWidth
      , e = properties.viewportHeight = window.innerHeight;
    properties.viewportResolution = new Vector2(a,e),
    properties.width = a,
    properties.height = e,
    properties.loader.add("Aeonik:500,Aeonik:400:italic,IBMPlexMono:400,IBMPlexMono:500,LusionMono:400", {
        type: "font"
    }),
    app.initEngine(),
    input.preInit(),
    scrollManager.init(),
    pagesManager.preInit(),
    ui.preInit(),
    app.preInit(),
    window.addEventListener("resize", onResize),
    _onResize(),
    loop(),
    ui.preload(init, start)
}
function init() {
    input.init(),
    pagesManager.init(),
    ui.init(),
    app.init(),
    properties.hasInitialized = !0
}
function start() {
    ui.start(),
    pagesManager.start(),
    app.start(),
    properties.hasStarted = !0,
    _onResize(!0),
    scrollManager.isActive = !0,
    settings.JUMP_SECTION !== "" && scrollManager.scrollTo(settings.JUMP_SECTION, settings.JUMP_OFFSET, !0)
}
function onResize() {
    _needsResize = !0
}
function _onResize(a) {
    let e = properties.viewportWidth = window.innerWidth
      , t = properties.viewportHeight = window.innerHeight;
    properties.viewportResolution.set(e, window.innerHeight),
    properties.useMobileLayout = e <= settings.MOBILE_WIDTH,
    document.documentElement.style.setProperty("--vh", t * .01 + "px");
    let r = e * settings.DPR
      , n = t * settings.DPR;
    if (settings.USE_PIXEL_LIMIT === !0 && r * n > settings.MAX_PIXEL_COUNT) {
        let o = r / n;
        n = Math.sqrt(settings.MAX_PIXEL_COUNT / o),
        r = Math.ceil(n * o),
        n = Math.ceil(n)
    }
    properties.width = r,
    properties.height = n,
    properties.webglDPR = properties.width / e,
    properties.resolution.set(properties.width, properties.height),
    a || input.resize(),
    scrollManager.resize(e, t),
    pagesManager.resize(e, t),
    ui.resize(e, t, a),
    app.resize(Math.ceil(r * properties.upscalerAmount), Math.ceil(n * properties.upscalerAmount)),
    scrollManager.resize(e, t)
}
function update(a) {
    scrollManager.autoScrollSpeed = properties.autoScrollSpeed,
    window.__AUTO_SCROLL__ && (scrollManager.autoScrollSpeed = window.__AUTO_SCROLL__),
    taskManager.update(),
    properties.reset(),
    app.preUpdate(a),
    input.update(a),
    scrollManager.update(a),
    pagesManager.update(a),
    ui.update(a),
    app.update(a),
    input.postUpdate(a)
}
function loop() {
    window.requestAnimationFrame(loop);
    let a = performance.now()
      , e = (a - dateTime) / 1e3;
    dateTime = a,
    e = Math.min(e, 1 / 20),
    _needsResize && _onResize(),
    properties.hasStarted && (properties.startTime += e),
    Tween.autoUpdate(e),
    update(e),
    _needsResize = !1
}
preRun();
Object.assign || document.documentElement.classList.add("not-supported not-supported--browser");
document.documentElement.classList.remove("no-js");
/(ipad|iphone|android)/i.test((navigator.userAgent || navigator.vendor).toLowerCase()) ? document.documentElement.classList.add("is-mobile") : document.documentElement.classList.add("is-desktop");
function preventZoom(a) {
    a.preventDefault(),
    document.body.style.zoom = 1
}
window.addEventListener("wheel", a => a.preventDefault(), {
    passive: !1
});
document.addEventListener("gesturestart", a => preventZoom(a));
document.addEventListener("gesturechange", a => preventZoom(a));
document.addEventListener("gestureend", a => preventZoom(a));
