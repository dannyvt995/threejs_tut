{
    "analyses": [
        {
            "analyserName": "Commands",
            "bindVertexArray": 6,
            "clear": 1,
            "drawArrays": 2,
            "drawElements": 4,
            "uniform3fv": 1,
            "uniformMatrix3fv": 3,
            "uniformMatrix4fv": 3,
            "useProgram": 4
        },
        {
            "analyserName": "CommandsSummary",
            "clear": 1,
            "draw": 6,
            "total": 24
        },
        {
            "analyserName": "Primitives",
            "lineLoop": 0,
            "lineStrip": 2,
            "lines": 54,
            "points": 0,
            "total": 180038,
            "triangleFan": 0,
            "triangleStrip": 0,
            "triangles": 179982
        }
    ],
    "canvas": {
        "browserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
        "clientHeight": 870,
        "clientWidth": 1745,
        "height": 870,
        "width": 1745
    },
    "commands": [
        {
            "ClearState": {
                "COLOR_CLEAR_VALUE": [
                    0.0470588244497776,
                    0.05882352963089943,
                    0.08627451211214066,
                    1
                ],
                "DEPTH_CLEAR_VALUE": 1,
                "STENCIL_CLEAR_VALUE": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    300,
                    150
                ],
                "SCISSOR_TEST": false
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "Canvas COLOR_ATTACHMENT",
                        "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAAAzRJREFUeF7t1MEJACAQA0H9C/7sv1MF29i5Dm4SMtc+dzgCBJIC0wAkc/c0gS9gABSBQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYYEHgPqXUMPclfYAAAAASUVORK5CYII=",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": null
            },
            "commandArguments": [
                17664
            ],
            "commandEndTime": 1732773744416.1,
            "endTime": 1732773744432.8,
            "id": 0,
            "name": "clear",
            "stackTrace": [
                "WebGLRenderer.clear (https://unpkg.com/three@0.149.0/build/three.module.js:27494:7)",
                "Object.render (https://unpkg.com/three@0.149.0/build/three.module.js:13918:13)",
                "WebGLRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:27963:14)",
                "animate (http://127.0.0.1:5501/solution_depse.html:181:16)"
            ],
            "startTime": 1732773744416.1,
            "status": 0,
            "text": "clear: DEPTH_BUFFER_BIT, STENCIL_BUFFER_BIT, COLOR_BUFFER_BIT"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_CustomData": {
                        "length": 20849,
                        "programStatus": {
                            "LINK_STATUS": true,
                            "VALIDATE_STATUS": false
                        },
                        "shaders": [
                            {
                                "COMPILE_STATUS": true,
                                "name": "LineBasicMaterial",
                                "shaderType": "VERTEX_SHADER",
                                "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                            },
                            {
                                "COMPILE_STATUS": true,
                                "name": "LineBasicMaterial",
                                "shaderType": "FRAGMENT_SHADER",
                                "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                            }
                        ]
                    },
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLProgram - ID: 0",
                        "id": 0,
                        "typeName": "WebGLProgram"
                    }
                }
            ],
            "commandEndTime": 1732773744432.9,
            "endTime": 1732773744433.4,
            "id": 1,
            "name": "useProgram",
            "stackTrace": [
                "Object.useProgram (https://unpkg.com/three@0.149.0/build/three.module.js:21720:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28554:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773744432.9,
            "status": 0,
            "text": "useProgram: WebGLProgram - ID: 0"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 0",
                        "id": 0,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773744433.4,
            "endTime": 1732773744433.6,
            "id": 2,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773744433.4,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 0"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 72,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 0",
                                "id": 0,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 72,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 72,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 1",
                                "id": 1,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 72,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 3,
                        "name": "color",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "frameBuffer": null,
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 20849,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "LineBasicMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "LineBasicMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 0",
                            "id": 0,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "LineBasicMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "LineBasicMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 29",
                                "id": 29,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.999994158744812,
                            -0.00003970626858063042,
                            0.0034170825965702534,
                            0,
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598,
                            0,
                            -0.0034173133317381144,
                            -0.011619079858064651,
                            0.9999266862869263,
                            0,
                            -3.0878077872387166e-15,
                            0,
                            -15001.1005859375,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 30",
                                "id": 30,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0006519198650494218,
                            0,
                            0,
                            0,
                            0,
                            0.0013075864408165216,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 31",
                                "id": 31,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "diffuse",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            1,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 32",
                                "id": 32,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "opacity",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    300,
                    150
                ],
                "SCISSOR_TEST": false
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "8",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "Canvas COLOR_ATTACHMENT",
                        "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAAA9ZJREFUeF7t1DFKBGEYA9DZ7QTBzrt6Gc/jVey1sFLGyi4rbJW8Bbufwbx85PL49Px9+BEgMClwMQCTvQtN4FfAADgEAsMCBmC4fNEJGAA3QGBYwAAMly86AQPgBggMCxiA4fJFJ2AA3ACBYQEDMFy+6AQMgBsgMCxgAIbLF52AAXADBIYFDMBw+aITMABugMCwgAEYLl90AgbADRAYFjAAw+WLTsAAuAECwwIGYLh80QkYADdAYFjAAAyXLzoBA+AGCAwLGIDh8kUnYADcAIFhAQMwXL7oBAyAGyAwLGAAhssXnYABcAMEhgUMwHD5ohMwAG6AwLCAARguX3QCBsANEBgWMADD5YtOwAC4AQLDAgZguHzRCRgAN0BgWMAADJcvOgED4AYIDAsYgOHyRSdgANwAgWEBAzBcvugEDIAbIDAsYACGyxedgAFwAwSGBQzAcPmiEzAAboDAsIABGC5fdAIGwA0QGBYwAMPli07AALgBAsMCBmC4fNEJGAA3QGBYwAAMly86AQPgBggMCxiA4fJFJ2AA3ACBYQEDMFy+6AQMgBsgMCxgAIbLF52AAXADBIYFDMBw+aITMABugMCwgAEYLv+M/vL1eRyX4/a/6z/e3vLde3zvHt84/9fzO+fvz/feP67H69tD7ZUYgNpqBSOQBQxANvKCQK2AAaitVjACWcAAZCMvCNQKGIDaagUjkAUMQDbygkCtgAGorVYwAlnAAGQjLwjUChiA2moFI5AFDEA28oJArYABqK1WMAJZwABkIy8I1AoYgNpqBSOQBQxANvKCQK2AAaitVjACWcAAZCMvCNQKGIDaagUjkAUMQDbygkCtgAGorVYwAlnAAGQjLwjUChiA2moFI5AFDEA28oJArYABqK1WMAJZwABkIy8I1AoYgNpqBSOQBQxANvKCQK2AAaitVjACWcAAZCMvCNQKGIDaagUjkAUMQDbygkCtgAGorVYwAlnAAGQjLwjUChiA2moFI5AFDEA28oJArYABqK1WMAJZwABkIy8I1AoYgNpqBSOQBQxANvKCQK2AAaitVjACWcAAZCMvCNQKGIDaagUjkAUMQDbygkCtgAGorVYwAlnAAGQjLwjUChiA2moFI5AFDEA28oJArYABqK1WMAJZwABkIy8I1AoYgNpqBSOQBQxANvKCQK2AAaitVjACWcAAZCMvCNQKGIDaagUjkAUMQDbygkCtgAGorVYwAlnAAGQjLwjUChiA2moFI5AFDEA28oJArYABqK1WMAJZwABkIy8I1AoYgNpqBSOQBQxANvKCQK2AAaitVjACWeAHZzidUJA6qY4AAAAASUVORK5CYII=",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": null
            },
            "commandArguments": [
                1,
                0,
                6
            ],
            "commandEndTime": 1732773744433.6,
            "endTime": 1732773744453.9,
            "id": 3,
            "name": "drawArrays",
            "stackTrace": [
                "WebGLBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:14729:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773744433.6,
            "status": 0,
            "text": "drawArrays: LINES, 0 indices, 6"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_CustomData": {
                        "length": 20813,
                        "programStatus": {
                            "LINK_STATUS": true,
                            "VALIDATE_STATUS": false
                        },
                        "shaders": [
                            {
                                "COMPILE_STATUS": true,
                                "name": "LineBasicMaterial",
                                "shaderType": "VERTEX_SHADER",
                                "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _transformed2614 = vec3_ctor(_position);\nfloat4 _mvPosition2615 = vec4_ctor(_transformed2614, 1.0);\n(_mvPosition2615 = mul(transpose(_modelViewMatrix), _mvPosition2615));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2615));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                            },
                            {
                                "COMPILE_STATUS": true,
                                "name": "LineBasicMaterial",
                                "shaderType": "FRAGMENT_SHADER",
                                "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2617 = vec4_ctor(_diffuse, _opacity);\nfloat _specularStrength2618 = {0};\n(_specularStrength2618 = 1.0);\n_ReflectedLight _reflectedLight2619 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2619._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2619._indirectDiffuse *= _diffuseColor2617.xyz);\nfloat3 _outgoingLight2620 = _reflectedLight2619._indirectDiffuse;\n(_diffuseColor2617.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2620, _diffuseColor2617.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                            }
                        ]
                    },
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLProgram - ID: 1",
                        "id": 1,
                        "typeName": "WebGLProgram"
                    }
                }
            ],
            "commandEndTime": 1732773744453.9,
            "endTime": 1732773744454.3,
            "id": 4,
            "name": "useProgram",
            "stackTrace": [
                "Object.useProgram (https://unpkg.com/three@0.149.0/build/three.module.js:21720:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28554:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773744453.9,
            "status": 0,
            "text": "useProgram: WebGLProgram - ID: 1"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 1",
                        "id": 1,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773744454.3,
            "endTime": 1732773744454.4,
            "id": 5,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773744454.3,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 1"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 24,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 2",
                                "id": 2,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 24,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "frameBuffer": null,
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 20813,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "LineBasicMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _transformed2614 = vec3_ctor(_position);\nfloat4 _mvPosition2615 = vec4_ctor(_transformed2614, 1.0);\n(_mvPosition2615 = mul(transpose(_modelViewMatrix), _mvPosition2615));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2615));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "LineBasicMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2617 = vec4_ctor(_diffuse, _opacity);\nfloat _specularStrength2618 = {0};\n(_specularStrength2618 = 1.0);\n_ReflectedLight _reflectedLight2619 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2619._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2619._indirectDiffuse *= _diffuseColor2617.xyz);\nfloat3 _outgoingLight2620 = _reflectedLight2619._indirectDiffuse;\n(_diffuseColor2617.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2620, _diffuseColor2617.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 1",
                            "id": 1,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "LineBasicMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _transformed2614 = vec3_ctor(_position);\nfloat4 _mvPosition2615 = vec4_ctor(_transformed2614, 1.0);\n(_mvPosition2615 = mul(transpose(_modelViewMatrix), _mvPosition2615));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2615));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "LineBasicMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2617 = vec4_ctor(_diffuse, _opacity);\nfloat _specularStrength2618 = {0};\n(_specularStrength2618 = 1.0);\n_ReflectedLight _reflectedLight2619 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2619._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2619._indirectDiffuse *= _diffuseColor2617.xyz);\nfloat3 _outgoingLight2620 = _reflectedLight2619._indirectDiffuse;\n(_diffuseColor2617.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2620, _diffuseColor2617.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 33",
                                "id": 33,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.5351841449737549,
                            0.009815105237066746,
                            -0.8446784019470215,
                            0,
                            0.7206006646156311,
                            0.5164910554885864,
                            0.4625706970691681,
                            0,
                            1510.9722900390625,
                            -2934.94287109375,
                            923.2409057617188,
                            0,
                            -1510.9722900390625,
                            2934.94287109375,
                            -15924.3408203125,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 34",
                                "id": 34,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0006519198650494218,
                            0,
                            0,
                            0,
                            0,
                            0.0013075864408165216,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 35",
                                "id": 35,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "diffuse",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            1,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 36",
                                "id": 36,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "opacity",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    300,
                    150
                ],
                "SCISSOR_TEST": false
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "8",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "Canvas COLOR_ATTACHMENT",
                        "src": "data:image/png;base64,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",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": null
            },
            "commandArguments": [
                3,
                0,
                2
            ],
            "commandEndTime": 1732773744454.4,
            "endTime": 1732773744489.3,
            "id": 6,
            "name": "drawArrays",
            "stackTrace": [
                "WebGLBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:14729:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773744454.4,
            "status": 0,
            "text": "drawArrays: LINE_STRIP, 0 indices, 2"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_CustomData": {
                        "length": 20849,
                        "programStatus": {
                            "LINK_STATUS": true,
                            "VALIDATE_STATUS": false
                        },
                        "shaders": [
                            {
                                "COMPILE_STATUS": true,
                                "name": "MeshBasicMaterial",
                                "shaderType": "VERTEX_SHADER",
                                "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                            },
                            {
                                "COMPILE_STATUS": true,
                                "name": "MeshBasicMaterial",
                                "shaderType": "FRAGMENT_SHADER",
                                "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                            }
                        ]
                    },
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLProgram - ID: 2",
                        "id": 2,
                        "typeName": "WebGLProgram"
                    }
                }
            ],
            "commandEndTime": 1732773744489.3,
            "endTime": 1732773744489.6,
            "id": 7,
            "name": "useProgram",
            "stackTrace": [
                "Object.useProgram (https://unpkg.com/three@0.149.0/build/three.module.js:21720:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28554:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773744489.3,
            "status": 0,
            "text": "useProgram: WebGLProgram - ID: 2"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 2",
                        "id": 2,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773744489.6,
            "endTime": 1732773744489.7,
            "id": 8,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773744489.6,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 2"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 288,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 3",
                                "id": 3,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 288,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 288,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 6",
                                "id": 6,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 288,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 3,
                        "name": "color",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "elementArray": {
                    "arrayBuffer": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 96,
                            "target": "ELEMENT_ARRAY_BUFFER",
                            "usage": 35044
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLBuffer - ID: 13",
                            "id": 13,
                            "typeName": "WebGLBuffer"
                        }
                    }
                },
                "frameBuffer": null,
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 20849,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "MeshBasicMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "MeshBasicMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 2",
                            "id": 2,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "MeshBasicMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "MeshBasicMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 37",
                                "id": 37,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.999994158744812,
                            -0.00003970626858063042,
                            0.0034170825965702534,
                            0,
                            -0.0034173133317381144,
                            -0.011519086547195911,
                            0.999927818775177,
                            0,
                            -3.417313223508245e-7,
                            -0.999933660030365,
                            -0.011519155465066433,
                            0,
                            -3.0878010109751386e-15,
                            0.9999324679374695,
                            -15001.0888671875,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 38",
                                "id": 38,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0006519198650494218,
                            0,
                            0,
                            0,
                            0,
                            0.0013075864408165216,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 39",
                                "id": 39,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "diffuse",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            1,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 40",
                                "id": 40,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "opacity",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    300,
                    150
                ],
                "SCISSOR_TEST": false
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "8",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "Canvas COLOR_ATTACHMENT",
                        "src": "data:image/png;base64,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",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": null
            },
            "commandArguments": [
                1,
                48,
                5123,
                0
            ],
            "commandEndTime": 1732773744489.7,
            "endTime": 1732773744507.5,
            "id": 9,
            "name": "drawElements",
            "stackTrace": [
                "WebGLIndexedBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:16593:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773744489.7,
            "status": 0,
            "text": "drawElements: LINES, 48 indices, UNSIGNED_SHORT, 0"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_CustomData": {
                        "length": 55495,
                        "programStatus": {
                            "LINK_STATUS": true,
                            "VALIDATE_STATUS": false
                        },
                        "shaders": [
                            {
                                "COMPILE_STATUS": true,
                                "name": "MeshPhongMaterial",
                                "shaderType": "VERTEX_SHADER",
                                "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshPhongMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PHONG\nvarying vec3 vViewPosition;\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\nuniform float3x3 _normalMatrix : register(c8);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2616 = vec3_ctor(_normal);\nfloat3 _transformedNormal2617 = _objectNormal2616;\n(_transformedNormal2617 = mul(transpose(_normalMatrix), _transformedNormal2617));\n(_vNormal = normalize(_transformedNormal2617));\nfloat3 _transformed2618 = vec3_ctor(_position);\nfloat4 _mvPosition2619 = vec4_ctor(_transformed2618, 1.0);\n(_mvPosition2619 = mul(transpose(_modelViewMatrix), _mvPosition2619));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2619));\n(_vViewPosition = (-_mvPosition2619.xyz));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                            },
                            {
                                "COMPILE_STATUS": true,
                                "name": "MeshPhongMaterial",
                                "shaderType": "FRAGMENT_SHADER",
                                "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshPhongMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\n#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t\n#endif\n#if ( 1 > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t\n\t\tdirectionalLight = directionalLights[ 0 ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( 0 < 0 )\n\t\tdirectionalLightShadow = directionalLightShadows[ 0 ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( 0, directionalShadowMap[ 0 ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( 1 > 0 )\n\t\t\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif\n#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_26;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_27;\n    float pad_28;\n    float pad_29;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_30;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_31;\n    float pad_32;\n    float pad_33;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform bool _isOrthographic : register(c4);\nuniform float3 _diffuse : register(c5);\nuniform float3 _emissive : register(c6);\nuniform float3 _specular : register(c7);\nuniform float _shininess : register(c8);\nuniform float _opacity : register(c9);\nuniform float3 _ambientLightColor : register(c10);\nuniform float3 _lightProbe[9] : register(c11);\nuniform _DirectionalLight _directionalLights[1] : register(c20);\nuniform _HemisphereLight _hemisphereLights[1] : register(c22);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2663 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2663)) + (_f90 * _fresnel2663));\n}\nfloat f_G_BlinnPhong_Implicit()\n{\nreturn 0.25;\n}\nfloat f_D_BlinnPhong(const float _shininess, const float _dotNH)\n{\nreturn ((0.31830987 * ((_shininess * 0.5) + 1.0)) * pow(_dotNH, _shininess));\n}\nfloat3 f_BRDF_BlinnPhong(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _specularColor, const float _shininess)\n{\nfloat3 _halfDir2750 = normalize((_lightDir + _viewDir));\nfloat _dotNH2751 = clamp(dot(_normal, _halfDir2750), 0.0, 1.0);\nfloat _dotVH2752 = clamp(dot(_viewDir, _halfDir2750), 0.0, 1.0);\nfloat3 _F2753 = f_F_Schlick(_specularColor, 1.0, _dotVH2752);\nfloat _G2754 = f_G_BlinnPhong_Implicit();\nfloat _D2755 = f_D_BlinnPhong(_shininess, _dotNH2751);\nreturn (_F2753 * (_G2754 * _D2755));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2762 = _normal.x;\nfloat _y2763 = _normal.y;\nfloat _z2764 = _normal.z;\nfloat3 _result2765 = (_shCoefficients[0] * 0.88622701);\n(_result2765 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2763));\n(_result2765 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2764));\n(_result2765 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2762));\n(_result2765 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2762) * _y2763));\n(_result2765 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2763) * _z2764));\n(_result2765 += (_shCoefficients[6] * (((0.74312502 * _z2764) * _z2764) - 0.24770799)));\n(_result2765 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2762) * _z2764));\n(_result2765 += ((_shCoefficients[8] * 0.42904299) * ((_x2762 * _x2762) - (_y2763 * _y2763))));\nreturn _result2765;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2769 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2770 = f_shGetIrradianceAt(_worldNormal2769, _lightProbe);\nreturn _irradiance2770;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2773 = _ambientLightColor;\nreturn _irradiance2773;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2795 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2796 = ((0.5 * _dotNL2795) + 0.5);\nfloat3 _irradiance2797 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2796);\nreturn _irradiance2797;\n}\n;\nvoid f_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2807 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2808 = (_dotNL2807 * _directLight._color);\n(_reflectedLight._directDiffuse += (_irradiance2808 * f_BRDF_Lambert(_material._diffuseColor)));\n(_reflectedLight._directSpecular += ((_irradiance2808 * f_BRDF_BlinnPhong(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularShininess)) * _material._specularStrength));\n}\nvoid f_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2819 = vec4_ctor(_diffuse, _opacity);\n_ReflectedLight _reflectedLight2820 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 _totalEmissiveRadiance2821 = _emissive;\nfloat _specularStrength2822 = {0};\n(_specularStrength2822 = 1.0);\nfloat3 _normal2824 = normalize(_vNormal);\n_BlinnPhongMaterial _material2826 = {0, 0, 0, 0, 0, 0, 0, 0};\n(_material2826._diffuseColor = _diffuseColor2819.xyz);\n(_material2826._specularColor = _specular);\n(_material2826._specularShininess = _shininess);\n(_material2826._specularStrength = _specularStrength2822);\n_GeometricContext _geometry2827 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry2827._position = (-_vViewPosition));\n(_geometry2827._normal = _normal2824);\nfloat3 sb11 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sb11 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sb11 = normalize(_vViewPosition));\n}\n(_geometry2827._viewDir = sb11);\n_IncidentLight _directLight2828 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight2829 = {0, 0, 0, 0, 0, 0};\n(_directionalLight2829 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight2829, _geometry2827, _directLight2828);\nf_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(_directLight2828, _geometry2827, _material2826, _reflectedLight2820);\nfloat3 _irradiance2831 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance2831 += f_getLightProbeIrradiance(_lightProbe, _geometry2827._normal));\n(_irradiance2831 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry2827._normal));\nf_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(_irradiance2831, _geometry2827, _material2826, _reflectedLight2820);\nfloat3 _outgoingLight2832 = ((((_reflectedLight2820._directDiffuse + _reflectedLight2820._indirectDiffuse) + _reflectedLight2820._directSpecular) + _reflectedLight2820._indirectSpecular) + _totalEmissiveRadiance2821);\n(_diffuseColor2819.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2832, _diffuseColor2819.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                            }
                        ]
                    },
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLProgram - ID: 3",
                        "id": 3,
                        "typeName": "WebGLProgram"
                    }
                }
            ],
            "commandEndTime": 1732773744507.6,
            "endTime": 1732773744508,
            "id": 10,
            "name": "useProgram",
            "stackTrace": [
                "Object.useProgram (https://unpkg.com/three@0.149.0/build/three.module.js:21720:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28554:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773744507.6,
            "status": 0,
            "text": "useProgram: WebGLProgram - ID: 3"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 23",
                        "id": 23,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                {
                    "0": 0,
                    "1": 0,
                    "2": 0,
                    "3": 0,
                    "4": 0,
                    "5": 0,
                    "6": 0,
                    "7": 0,
                    "8": 0,
                    "9": 0,
                    "10": 0,
                    "11": 0,
                    "12": 0,
                    "13": 0,
                    "14": 0,
                    "15": 0,
                    "16": 0,
                    "17": 0,
                    "18": 0,
                    "19": 0,
                    "20": 0,
                    "21": 0,
                    "22": 0,
                    "23": 0,
                    "24": 0,
                    "25": 0,
                    "26": 0
                }
            ],
            "commandEndTime": 1732773744508,
            "endTime": 1732773744508.2,
            "id": 11,
            "name": "uniform3fv",
            "stackTrace": [
                "PureArrayUniform.setValueV3fArray [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17760:5)",
                "WebGLUniforms.upload (https://unpkg.com/three@0.149.0/build/three.module.js:18187:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28724:18)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773744508,
            "status": 0,
            "text": "uniform3fv: WebGLUniformLocation - ID: 23, [..(27)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 12",
                        "id": 12,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                false,
                {
                    "0": 0.6046777963638306,
                    "1": -5.889223098754883,
                    "2": -1.5922852754592896,
                    "3": 0,
                    "4": -1.4427422285079956,
                    "5": -1.6927427053451538,
                    "6": 5.712886333465576,
                    "7": 0,
                    "8": -5.927631378173828,
                    "9": -0.18875853717327118,
                    "10": -1.5529038906097412,
                    "11": 0,
                    "12": 1397.0211181640625,
                    "13": 716.829833984375,
                    "14": -15538.130859375,
                    "15": 1
                }
            ],
            "commandEndTime": 1732773744508.2,
            "endTime": 1732773744508.3,
            "id": 12,
            "name": "uniformMatrix4fv",
            "stackTrace": [
                "SingleUniform.setValueM4 [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17409:6)",
                "WebGLUniforms.setValue (https://unpkg.com/three@0.149.0/build/three.module.js:18165:28)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28743:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773744508.2,
            "status": 0,
            "text": "uniformMatrix4fv: WebGLUniformLocation - ID: 12, false, [..(16)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 15",
                        "id": 15,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                false,
                {
                    "0": 0.01608872227370739,
                    "1": -0.1566951423883438,
                    "2": -0.042366091161966324,
                    "3": -0.03838718309998512,
                    "4": -0.04503897204995155,
                    "5": 0.15200333297252655,
                    "6": -0.15771707892417908,
                    "7": -0.005022317171096802,
                    "8": -0.041318267583847046
                }
            ],
            "commandEndTime": 1732773744508.3,
            "endTime": 1732773744508.3,
            "id": 13,
            "name": "uniformMatrix3fv",
            "stackTrace": [
                "SingleUniform.setValueM3 [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17382:6)",
                "WebGLUniforms.setValue (https://unpkg.com/three@0.149.0/build/three.module.js:18165:28)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28744:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773744508.3,
            "status": 0,
            "text": "uniformMatrix3fv: WebGLUniformLocation - ID: 15, false, [..(9)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 3",
                        "id": 3,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773744508.3,
            "endTime": 1732773744508.4,
            "id": 14,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773744508.3,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 3"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 268644,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 7",
                                "id": 7,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 268644,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 268644,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 8",
                                "id": 8,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 268644,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 1,
                        "name": "normal",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "elementArray": {
                    "arrayBuffer": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 239976,
                            "target": "ELEMENT_ARRAY_BUFFER",
                            "usage": 35044
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLBuffer - ID: 14",
                            "id": 14,
                            "typeName": "WebGLBuffer"
                        }
                    }
                },
                "frameBuffer": null,
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 55495,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "MeshPhongMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshPhongMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PHONG\nvarying vec3 vViewPosition;\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\nuniform float3x3 _normalMatrix : register(c8);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2616 = vec3_ctor(_normal);\nfloat3 _transformedNormal2617 = _objectNormal2616;\n(_transformedNormal2617 = mul(transpose(_normalMatrix), _transformedNormal2617));\n(_vNormal = normalize(_transformedNormal2617));\nfloat3 _transformed2618 = vec3_ctor(_position);\nfloat4 _mvPosition2619 = vec4_ctor(_transformed2618, 1.0);\n(_mvPosition2619 = mul(transpose(_modelViewMatrix), _mvPosition2619));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2619));\n(_vViewPosition = (-_mvPosition2619.xyz));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "MeshPhongMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshPhongMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\n#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t\n#endif\n#if ( 1 > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t\n\t\tdirectionalLight = directionalLights[ 0 ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( 0 < 0 )\n\t\tdirectionalLightShadow = directionalLightShadows[ 0 ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( 0, directionalShadowMap[ 0 ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( 1 > 0 )\n\t\t\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif\n#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_26;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_27;\n    float pad_28;\n    float pad_29;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_30;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_31;\n    float pad_32;\n    float pad_33;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform bool _isOrthographic : register(c4);\nuniform float3 _diffuse : register(c5);\nuniform float3 _emissive : register(c6);\nuniform float3 _specular : register(c7);\nuniform float _shininess : register(c8);\nuniform float _opacity : register(c9);\nuniform float3 _ambientLightColor : register(c10);\nuniform float3 _lightProbe[9] : register(c11);\nuniform _DirectionalLight _directionalLights[1] : register(c20);\nuniform _HemisphereLight _hemisphereLights[1] : register(c22);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2663 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2663)) + (_f90 * _fresnel2663));\n}\nfloat f_G_BlinnPhong_Implicit()\n{\nreturn 0.25;\n}\nfloat f_D_BlinnPhong(const float _shininess, const float _dotNH)\n{\nreturn ((0.31830987 * ((_shininess * 0.5) + 1.0)) * pow(_dotNH, _shininess));\n}\nfloat3 f_BRDF_BlinnPhong(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _specularColor, const float _shininess)\n{\nfloat3 _halfDir2750 = normalize((_lightDir + _viewDir));\nfloat _dotNH2751 = clamp(dot(_normal, _halfDir2750), 0.0, 1.0);\nfloat _dotVH2752 = clamp(dot(_viewDir, _halfDir2750), 0.0, 1.0);\nfloat3 _F2753 = f_F_Schlick(_specularColor, 1.0, _dotVH2752);\nfloat _G2754 = f_G_BlinnPhong_Implicit();\nfloat _D2755 = f_D_BlinnPhong(_shininess, _dotNH2751);\nreturn (_F2753 * (_G2754 * _D2755));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2762 = _normal.x;\nfloat _y2763 = _normal.y;\nfloat _z2764 = _normal.z;\nfloat3 _result2765 = (_shCoefficients[0] * 0.88622701);\n(_result2765 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2763));\n(_result2765 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2764));\n(_result2765 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2762));\n(_result2765 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2762) * _y2763));\n(_result2765 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2763) * _z2764));\n(_result2765 += (_shCoefficients[6] * (((0.74312502 * _z2764) * _z2764) - 0.24770799)));\n(_result2765 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2762) * _z2764));\n(_result2765 += ((_shCoefficients[8] * 0.42904299) * ((_x2762 * _x2762) - (_y2763 * _y2763))));\nreturn _result2765;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2769 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2770 = f_shGetIrradianceAt(_worldNormal2769, _lightProbe);\nreturn _irradiance2770;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2773 = _ambientLightColor;\nreturn _irradiance2773;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2795 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2796 = ((0.5 * _dotNL2795) + 0.5);\nfloat3 _irradiance2797 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2796);\nreturn _irradiance2797;\n}\n;\nvoid f_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2807 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2808 = (_dotNL2807 * _directLight._color);\n(_reflectedLight._directDiffuse += (_irradiance2808 * f_BRDF_Lambert(_material._diffuseColor)));\n(_reflectedLight._directSpecular += ((_irradiance2808 * f_BRDF_BlinnPhong(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularShininess)) * _material._specularStrength));\n}\nvoid f_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2819 = vec4_ctor(_diffuse, _opacity);\n_ReflectedLight _reflectedLight2820 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 _totalEmissiveRadiance2821 = _emissive;\nfloat _specularStrength2822 = {0};\n(_specularStrength2822 = 1.0);\nfloat3 _normal2824 = normalize(_vNormal);\n_BlinnPhongMaterial _material2826 = {0, 0, 0, 0, 0, 0, 0, 0};\n(_material2826._diffuseColor = _diffuseColor2819.xyz);\n(_material2826._specularColor = _specular);\n(_material2826._specularShininess = _shininess);\n(_material2826._specularStrength = _specularStrength2822);\n_GeometricContext _geometry2827 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry2827._position = (-_vViewPosition));\n(_geometry2827._normal = _normal2824);\nfloat3 sb11 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sb11 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sb11 = normalize(_vViewPosition));\n}\n(_geometry2827._viewDir = sb11);\n_IncidentLight _directLight2828 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight2829 = {0, 0, 0, 0, 0, 0};\n(_directionalLight2829 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight2829, _geometry2827, _directLight2828);\nf_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(_directLight2828, _geometry2827, _material2826, _reflectedLight2820);\nfloat3 _irradiance2831 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance2831 += f_getLightProbeIrradiance(_lightProbe, _geometry2827._normal));\n(_irradiance2831 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry2827._normal));\nf_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(_irradiance2831, _geometry2827, _material2826, _reflectedLight2820);\nfloat3 _outgoingLight2832 = ((((_reflectedLight2820._directDiffuse + _reflectedLight2820._indirectDiffuse) + _reflectedLight2820._directSpecular) + _reflectedLight2820._indirectSpecular) + _totalEmissiveRadiance2821);\n(_diffuseColor2819.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2832, _diffuseColor2819.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 3",
                            "id": 3,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "MeshPhongMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshPhongMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PHONG\nvarying vec3 vViewPosition;\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\nuniform float3x3 _normalMatrix : register(c8);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2616 = vec3_ctor(_normal);\nfloat3 _transformedNormal2617 = _objectNormal2616;\n(_transformedNormal2617 = mul(transpose(_normalMatrix), _transformedNormal2617));\n(_vNormal = normalize(_transformedNormal2617));\nfloat3 _transformed2618 = vec3_ctor(_position);\nfloat4 _mvPosition2619 = vec4_ctor(_transformed2618, 1.0);\n(_mvPosition2619 = mul(transpose(_modelViewMatrix), _mvPosition2619));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2619));\n(_vViewPosition = (-_mvPosition2619.xyz));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "MeshPhongMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshPhongMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\n#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t\n#endif\n#if ( 1 > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t\n\t\tdirectionalLight = directionalLights[ 0 ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( 0 < 0 )\n\t\tdirectionalLightShadow = directionalLightShadows[ 0 ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( 0, directionalShadowMap[ 0 ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( 1 > 0 )\n\t\t\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif\n#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_26;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_27;\n    float pad_28;\n    float pad_29;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_30;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_31;\n    float pad_32;\n    float pad_33;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform bool _isOrthographic : register(c4);\nuniform float3 _diffuse : register(c5);\nuniform float3 _emissive : register(c6);\nuniform float3 _specular : register(c7);\nuniform float _shininess : register(c8);\nuniform float _opacity : register(c9);\nuniform float3 _ambientLightColor : register(c10);\nuniform float3 _lightProbe[9] : register(c11);\nuniform _DirectionalLight _directionalLights[1] : register(c20);\nuniform _HemisphereLight _hemisphereLights[1] : register(c22);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2663 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2663)) + (_f90 * _fresnel2663));\n}\nfloat f_G_BlinnPhong_Implicit()\n{\nreturn 0.25;\n}\nfloat f_D_BlinnPhong(const float _shininess, const float _dotNH)\n{\nreturn ((0.31830987 * ((_shininess * 0.5) + 1.0)) * pow(_dotNH, _shininess));\n}\nfloat3 f_BRDF_BlinnPhong(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _specularColor, const float _shininess)\n{\nfloat3 _halfDir2750 = normalize((_lightDir + _viewDir));\nfloat _dotNH2751 = clamp(dot(_normal, _halfDir2750), 0.0, 1.0);\nfloat _dotVH2752 = clamp(dot(_viewDir, _halfDir2750), 0.0, 1.0);\nfloat3 _F2753 = f_F_Schlick(_specularColor, 1.0, _dotVH2752);\nfloat _G2754 = f_G_BlinnPhong_Implicit();\nfloat _D2755 = f_D_BlinnPhong(_shininess, _dotNH2751);\nreturn (_F2753 * (_G2754 * _D2755));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2762 = _normal.x;\nfloat _y2763 = _normal.y;\nfloat _z2764 = _normal.z;\nfloat3 _result2765 = (_shCoefficients[0] * 0.88622701);\n(_result2765 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2763));\n(_result2765 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2764));\n(_result2765 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2762));\n(_result2765 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2762) * _y2763));\n(_result2765 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2763) * _z2764));\n(_result2765 += (_shCoefficients[6] * (((0.74312502 * _z2764) * _z2764) - 0.24770799)));\n(_result2765 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2762) * _z2764));\n(_result2765 += ((_shCoefficients[8] * 0.42904299) * ((_x2762 * _x2762) - (_y2763 * _y2763))));\nreturn _result2765;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2769 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2770 = f_shGetIrradianceAt(_worldNormal2769, _lightProbe);\nreturn _irradiance2770;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2773 = _ambientLightColor;\nreturn _irradiance2773;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2795 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2796 = ((0.5 * _dotNL2795) + 0.5);\nfloat3 _irradiance2797 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2796);\nreturn _irradiance2797;\n}\n;\nvoid f_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2807 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2808 = (_dotNL2807 * _directLight._color);\n(_reflectedLight._directDiffuse += (_irradiance2808 * f_BRDF_Lambert(_material._diffuseColor)));\n(_reflectedLight._directSpecular += ((_irradiance2808 * f_BRDF_BlinnPhong(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularShininess)) * _material._specularStrength));\n}\nvoid f_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2819 = vec4_ctor(_diffuse, _opacity);\n_ReflectedLight _reflectedLight2820 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 _totalEmissiveRadiance2821 = _emissive;\nfloat _specularStrength2822 = {0};\n(_specularStrength2822 = 1.0);\nfloat3 _normal2824 = normalize(_vNormal);\n_BlinnPhongMaterial _material2826 = {0, 0, 0, 0, 0, 0, 0, 0};\n(_material2826._diffuseColor = _diffuseColor2819.xyz);\n(_material2826._specularColor = _specular);\n(_material2826._specularShininess = _shininess);\n(_material2826._specularStrength = _specularStrength2822);\n_GeometricContext _geometry2827 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry2827._position = (-_vViewPosition));\n(_geometry2827._normal = _normal2824);\nfloat3 sb11 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sb11 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sb11 = normalize(_vViewPosition));\n}\n(_geometry2827._viewDir = sb11);\n_IncidentLight _directLight2828 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight2829 = {0, 0, 0, 0, 0, 0};\n(_directionalLight2829 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight2829, _geometry2827, _directLight2828);\nf_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(_directLight2828, _geometry2827, _material2826, _reflectedLight2820);\nfloat3 _irradiance2831 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance2831 += f_getLightProbeIrradiance(_lightProbe, _geometry2827._normal));\n(_irradiance2831 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry2827._normal));\nf_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(_irradiance2831, _geometry2827, _material2826, _reflectedLight2820);\nfloat3 _outgoingLight2832 = ((((_reflectedLight2820._directDiffuse + _reflectedLight2820._indirectDiffuse) + _reflectedLight2820._directSpecular) + _reflectedLight2820._indirectSpecular) + _totalEmissiveRadiance2821);\n(_diffuseColor2819.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2832, _diffuseColor2819.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 41",
                                "id": 41,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.6046777963638306,
                            -5.889223098754883,
                            -1.5922852754592896,
                            0,
                            -1.4427422285079956,
                            -1.6927427053451538,
                            5.712886333465576,
                            0,
                            -5.927631378173828,
                            -0.18875853717327118,
                            -1.5529038906097412,
                            0,
                            1397.0211181640625,
                            716.829833984375,
                            -15538.130859375,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 42",
                                "id": 42,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0006519198650494218,
                            0,
                            0,
                            0,
                            0,
                            0.0013075864408165216,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 43",
                                "id": 43,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "viewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.999994158744812,
                            -0.00003970626858063042,
                            0.0034170825965702534,
                            0,
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598,
                            0,
                            -0.0034173133317381144,
                            -0.011619079858064651,
                            0.9999266862869263,
                            0,
                            -3.0878077872387166e-15,
                            0,
                            -15001.1005859375,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 44",
                                "id": 44,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "normalMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT3",
                        "value": [
                            0.01608872227370739,
                            -0.1566951423883438,
                            -0.042366091161966324,
                            -0.03838718309998512,
                            -0.04503897204995155,
                            0.15200333297252655,
                            -0.15771707892417908,
                            -0.005022317171096802,
                            -0.041318267583847046
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 45",
                                "id": 45,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "isOrthographic",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": true
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 46",
                                "id": 46,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "diffuse",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 47",
                                "id": 47,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "emissive",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0,
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 48",
                                "id": 48,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "specular",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0.06666667014360428,
                            0.06666667014360428,
                            0.06666667014360428
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 49",
                                "id": 49,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "shininess",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 30
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 50",
                                "id": 50,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "opacity",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 51",
                                "id": 51,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "ambientLightColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0,
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 52",
                                "id": 52,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "lightProbe",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 9,
                        "type": "FLOAT_VEC3",
                        "values": [
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 53",
                                "id": 53,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "directionalLights[0].direction",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            -0.440809041261673,
                            0.8562363386154175,
                            -0.26934507489204407
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 54",
                                "id": 54,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "directionalLights[0].color",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            2.880840539932251,
                            2.880840539932251,
                            2.880840539932251
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 55",
                                "id": 55,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].direction",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 56",
                                "id": 56,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].skyColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            2.092608690261841,
                            2.092608690261841,
                            2.092608690261841
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 57",
                                "id": 57,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].groundColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1.2892849445343018,
                            1.2892849445343018,
                            1.2892849445343018
                        ]
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    300,
                    150
                ],
                "SCISSOR_TEST": false
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "8",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "Canvas COLOR_ATTACHMENT",
                        "src": "data:image/png;base64,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",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": null
            },
            "commandArguments": [
                4,
                59994,
                5125,
                0
            ],
            "commandEndTime": 1732773744508.4,
            "endTime": 1732773744528.3,
            "id": 15,
            "name": "drawElements",
            "stackTrace": [
                "WebGLIndexedBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:16593:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773744508.4,
            "status": 0,
            "text": "drawElements: TRIANGLES, 59994 indices, UNSIGNED_INT, 0"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 12",
                        "id": 12,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                false,
                {
                    "0": 0.19756315648555756,
                    "1": -5.928686618804932,
                    "2": -1.5477728843688965,
                    "3": 0,
                    "4": 1.5279496908187866,
                    "5": 1.5473250150680542,
                    "6": -5.731937885284424,
                    "7": 0,
                    "8": 5.933826446533203,
                    "9": -0.20104138553142548,
                    "10": 1.5274958610534668,
                    "11": 0,
                    "12": -1272.02490234375,
                    "13": -940.5895385742188,
                    "14": -14455.302734375,
                    "15": 1
                }
            ],
            "commandEndTime": 1732773744528.3,
            "endTime": 1732773744528.3,
            "id": 16,
            "name": "uniformMatrix4fv",
            "stackTrace": [
                "SingleUniform.setValueM4 [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17409:6)",
                "WebGLUniforms.setValue (https://unpkg.com/three@0.149.0/build/three.module.js:18165:28)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28743:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773744528.3,
            "status": 0,
            "text": "uniformMatrix4fv: WebGLUniformLocation - ID: 12, false, [..(16)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 15",
                        "id": 15,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                false,
                {
                    "0": 0.0052565825171768665,
                    "1": -0.1577451378107071,
                    "2": -0.04118174687027931,
                    "3": 0.04065430909395218,
                    "4": 0.04116982966661453,
                    "5": -0.15251022577285767,
                    "6": 0.15788190066814423,
                    "7": -0.005349128041416407,
                    "8": 0.040642235428094864
                }
            ],
            "commandEndTime": 1732773744528.3,
            "endTime": 1732773744528.4,
            "id": 17,
            "name": "uniformMatrix3fv",
            "stackTrace": [
                "SingleUniform.setValueM3 [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17382:6)",
                "WebGLUniforms.setValue (https://unpkg.com/three@0.149.0/build/three.module.js:18165:28)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28744:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773744528.3,
            "status": 0,
            "text": "uniformMatrix3fv: WebGLUniformLocation - ID: 15, false, [..(9)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 4",
                        "id": 4,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773744528.4,
            "endTime": 1732773744528.5,
            "id": 18,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773744528.4,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 4"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 268644,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 10",
                                "id": 10,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 268644,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 268644,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 11",
                                "id": 11,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 268644,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 1,
                        "name": "normal",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "elementArray": {
                    "arrayBuffer": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 239976,
                            "target": "ELEMENT_ARRAY_BUFFER",
                            "usage": 35044
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLBuffer - ID: 15",
                            "id": 15,
                            "typeName": "WebGLBuffer"
                        }
                    }
                },
                "frameBuffer": null,
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 55495,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "MeshPhongMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshPhongMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PHONG\nvarying vec3 vViewPosition;\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\nuniform float3x3 _normalMatrix : register(c8);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2616 = vec3_ctor(_normal);\nfloat3 _transformedNormal2617 = _objectNormal2616;\n(_transformedNormal2617 = mul(transpose(_normalMatrix), _transformedNormal2617));\n(_vNormal = normalize(_transformedNormal2617));\nfloat3 _transformed2618 = vec3_ctor(_position);\nfloat4 _mvPosition2619 = vec4_ctor(_transformed2618, 1.0);\n(_mvPosition2619 = mul(transpose(_modelViewMatrix), _mvPosition2619));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2619));\n(_vViewPosition = (-_mvPosition2619.xyz));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "MeshPhongMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshPhongMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\n#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t\n#endif\n#if ( 1 > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t\n\t\tdirectionalLight = directionalLights[ 0 ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( 0 < 0 )\n\t\tdirectionalLightShadow = directionalLightShadows[ 0 ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( 0, directionalShadowMap[ 0 ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( 1 > 0 )\n\t\t\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif\n#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_26;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_27;\n    float pad_28;\n    float pad_29;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_30;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_31;\n    float pad_32;\n    float pad_33;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform bool _isOrthographic : register(c4);\nuniform float3 _diffuse : register(c5);\nuniform float3 _emissive : register(c6);\nuniform float3 _specular : register(c7);\nuniform float _shininess : register(c8);\nuniform float _opacity : register(c9);\nuniform float3 _ambientLightColor : register(c10);\nuniform float3 _lightProbe[9] : register(c11);\nuniform _DirectionalLight _directionalLights[1] : register(c20);\nuniform _HemisphereLight _hemisphereLights[1] : register(c22);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2663 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2663)) + (_f90 * _fresnel2663));\n}\nfloat f_G_BlinnPhong_Implicit()\n{\nreturn 0.25;\n}\nfloat f_D_BlinnPhong(const float _shininess, const float _dotNH)\n{\nreturn ((0.31830987 * ((_shininess * 0.5) + 1.0)) * pow(_dotNH, _shininess));\n}\nfloat3 f_BRDF_BlinnPhong(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _specularColor, const float _shininess)\n{\nfloat3 _halfDir2750 = normalize((_lightDir + _viewDir));\nfloat _dotNH2751 = clamp(dot(_normal, _halfDir2750), 0.0, 1.0);\nfloat _dotVH2752 = clamp(dot(_viewDir, _halfDir2750), 0.0, 1.0);\nfloat3 _F2753 = f_F_Schlick(_specularColor, 1.0, _dotVH2752);\nfloat _G2754 = f_G_BlinnPhong_Implicit();\nfloat _D2755 = f_D_BlinnPhong(_shininess, _dotNH2751);\nreturn (_F2753 * (_G2754 * _D2755));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2762 = _normal.x;\nfloat _y2763 = _normal.y;\nfloat _z2764 = _normal.z;\nfloat3 _result2765 = (_shCoefficients[0] * 0.88622701);\n(_result2765 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2763));\n(_result2765 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2764));\n(_result2765 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2762));\n(_result2765 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2762) * _y2763));\n(_result2765 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2763) * _z2764));\n(_result2765 += (_shCoefficients[6] * (((0.74312502 * _z2764) * _z2764) - 0.24770799)));\n(_result2765 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2762) * _z2764));\n(_result2765 += ((_shCoefficients[8] * 0.42904299) * ((_x2762 * _x2762) - (_y2763 * _y2763))));\nreturn _result2765;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2769 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2770 = f_shGetIrradianceAt(_worldNormal2769, _lightProbe);\nreturn _irradiance2770;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2773 = _ambientLightColor;\nreturn _irradiance2773;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2795 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2796 = ((0.5 * _dotNL2795) + 0.5);\nfloat3 _irradiance2797 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2796);\nreturn _irradiance2797;\n}\n;\nvoid f_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2807 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2808 = (_dotNL2807 * _directLight._color);\n(_reflectedLight._directDiffuse += (_irradiance2808 * f_BRDF_Lambert(_material._diffuseColor)));\n(_reflectedLight._directSpecular += ((_irradiance2808 * f_BRDF_BlinnPhong(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularShininess)) * _material._specularStrength));\n}\nvoid f_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2819 = vec4_ctor(_diffuse, _opacity);\n_ReflectedLight _reflectedLight2820 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 _totalEmissiveRadiance2821 = _emissive;\nfloat _specularStrength2822 = {0};\n(_specularStrength2822 = 1.0);\nfloat3 _normal2824 = normalize(_vNormal);\n_BlinnPhongMaterial _material2826 = {0, 0, 0, 0, 0, 0, 0, 0};\n(_material2826._diffuseColor = _diffuseColor2819.xyz);\n(_material2826._specularColor = _specular);\n(_material2826._specularShininess = _shininess);\n(_material2826._specularStrength = _specularStrength2822);\n_GeometricContext _geometry2827 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry2827._position = (-_vViewPosition));\n(_geometry2827._normal = _normal2824);\nfloat3 sb11 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sb11 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sb11 = normalize(_vViewPosition));\n}\n(_geometry2827._viewDir = sb11);\n_IncidentLight _directLight2828 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight2829 = {0, 0, 0, 0, 0, 0};\n(_directionalLight2829 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight2829, _geometry2827, _directLight2828);\nf_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(_directLight2828, _geometry2827, _material2826, _reflectedLight2820);\nfloat3 _irradiance2831 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance2831 += f_getLightProbeIrradiance(_lightProbe, _geometry2827._normal));\n(_irradiance2831 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry2827._normal));\nf_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(_irradiance2831, _geometry2827, _material2826, _reflectedLight2820);\nfloat3 _outgoingLight2832 = ((((_reflectedLight2820._directDiffuse + _reflectedLight2820._indirectDiffuse) + _reflectedLight2820._directSpecular) + _reflectedLight2820._indirectSpecular) + _totalEmissiveRadiance2821);\n(_diffuseColor2819.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2832, _diffuseColor2819.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 3",
                            "id": 3,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "MeshPhongMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshPhongMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PHONG\nvarying vec3 vViewPosition;\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\nuniform float3x3 _normalMatrix : register(c8);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2616 = vec3_ctor(_normal);\nfloat3 _transformedNormal2617 = _objectNormal2616;\n(_transformedNormal2617 = mul(transpose(_normalMatrix), _transformedNormal2617));\n(_vNormal = normalize(_transformedNormal2617));\nfloat3 _transformed2618 = vec3_ctor(_position);\nfloat4 _mvPosition2619 = vec4_ctor(_transformed2618, 1.0);\n(_mvPosition2619 = mul(transpose(_modelViewMatrix), _mvPosition2619));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2619));\n(_vViewPosition = (-_mvPosition2619.xyz));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "MeshPhongMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshPhongMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\n#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t\n#endif\n#if ( 1 > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t\n\t\tdirectionalLight = directionalLights[ 0 ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( 0 < 0 )\n\t\tdirectionalLightShadow = directionalLightShadows[ 0 ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( 0, directionalShadowMap[ 0 ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( 1 > 0 )\n\t\t\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif\n#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_26;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_27;\n    float pad_28;\n    float pad_29;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_30;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_31;\n    float pad_32;\n    float pad_33;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform bool _isOrthographic : register(c4);\nuniform float3 _diffuse : register(c5);\nuniform float3 _emissive : register(c6);\nuniform float3 _specular : register(c7);\nuniform float _shininess : register(c8);\nuniform float _opacity : register(c9);\nuniform float3 _ambientLightColor : register(c10);\nuniform float3 _lightProbe[9] : register(c11);\nuniform _DirectionalLight _directionalLights[1] : register(c20);\nuniform _HemisphereLight _hemisphereLights[1] : register(c22);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2663 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2663)) + (_f90 * _fresnel2663));\n}\nfloat f_G_BlinnPhong_Implicit()\n{\nreturn 0.25;\n}\nfloat f_D_BlinnPhong(const float _shininess, const float _dotNH)\n{\nreturn ((0.31830987 * ((_shininess * 0.5) + 1.0)) * pow(_dotNH, _shininess));\n}\nfloat3 f_BRDF_BlinnPhong(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _specularColor, const float _shininess)\n{\nfloat3 _halfDir2750 = normalize((_lightDir + _viewDir));\nfloat _dotNH2751 = clamp(dot(_normal, _halfDir2750), 0.0, 1.0);\nfloat _dotVH2752 = clamp(dot(_viewDir, _halfDir2750), 0.0, 1.0);\nfloat3 _F2753 = f_F_Schlick(_specularColor, 1.0, _dotVH2752);\nfloat _G2754 = f_G_BlinnPhong_Implicit();\nfloat _D2755 = f_D_BlinnPhong(_shininess, _dotNH2751);\nreturn (_F2753 * (_G2754 * _D2755));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2762 = _normal.x;\nfloat _y2763 = _normal.y;\nfloat _z2764 = _normal.z;\nfloat3 _result2765 = (_shCoefficients[0] * 0.88622701);\n(_result2765 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2763));\n(_result2765 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2764));\n(_result2765 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2762));\n(_result2765 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2762) * _y2763));\n(_result2765 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2763) * _z2764));\n(_result2765 += (_shCoefficients[6] * (((0.74312502 * _z2764) * _z2764) - 0.24770799)));\n(_result2765 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2762) * _z2764));\n(_result2765 += ((_shCoefficients[8] * 0.42904299) * ((_x2762 * _x2762) - (_y2763 * _y2763))));\nreturn _result2765;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2769 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2770 = f_shGetIrradianceAt(_worldNormal2769, _lightProbe);\nreturn _irradiance2770;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2773 = _ambientLightColor;\nreturn _irradiance2773;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2795 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2796 = ((0.5 * _dotNL2795) + 0.5);\nfloat3 _irradiance2797 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2796);\nreturn _irradiance2797;\n}\n;\nvoid f_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2807 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2808 = (_dotNL2807 * _directLight._color);\n(_reflectedLight._directDiffuse += (_irradiance2808 * f_BRDF_Lambert(_material._diffuseColor)));\n(_reflectedLight._directSpecular += ((_irradiance2808 * f_BRDF_BlinnPhong(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularShininess)) * _material._specularStrength));\n}\nvoid f_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2819 = vec4_ctor(_diffuse, _opacity);\n_ReflectedLight _reflectedLight2820 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 _totalEmissiveRadiance2821 = _emissive;\nfloat _specularStrength2822 = {0};\n(_specularStrength2822 = 1.0);\nfloat3 _normal2824 = normalize(_vNormal);\n_BlinnPhongMaterial _material2826 = {0, 0, 0, 0, 0, 0, 0, 0};\n(_material2826._diffuseColor = _diffuseColor2819.xyz);\n(_material2826._specularColor = _specular);\n(_material2826._specularShininess = _shininess);\n(_material2826._specularStrength = _specularStrength2822);\n_GeometricContext _geometry2827 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry2827._position = (-_vViewPosition));\n(_geometry2827._normal = _normal2824);\nfloat3 sb11 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sb11 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sb11 = normalize(_vViewPosition));\n}\n(_geometry2827._viewDir = sb11);\n_IncidentLight _directLight2828 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight2829 = {0, 0, 0, 0, 0, 0};\n(_directionalLight2829 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight2829, _geometry2827, _directLight2828);\nf_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(_directLight2828, _geometry2827, _material2826, _reflectedLight2820);\nfloat3 _irradiance2831 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance2831 += f_getLightProbeIrradiance(_lightProbe, _geometry2827._normal));\n(_irradiance2831 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry2827._normal));\nf_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(_irradiance2831, _geometry2827, _material2826, _reflectedLight2820);\nfloat3 _outgoingLight2832 = ((((_reflectedLight2820._directDiffuse + _reflectedLight2820._indirectDiffuse) + _reflectedLight2820._directSpecular) + _reflectedLight2820._indirectSpecular) + _totalEmissiveRadiance2821);\n(_diffuseColor2819.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2832, _diffuseColor2819.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 58",
                                "id": 58,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.19756315648555756,
                            -5.928686618804932,
                            -1.5477728843688965,
                            0,
                            1.5279496908187866,
                            1.5473250150680542,
                            -5.731937885284424,
                            0,
                            5.933826446533203,
                            -0.20104138553142548,
                            1.5274958610534668,
                            0,
                            -1272.02490234375,
                            -940.5895385742188,
                            -14455.302734375,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 59",
                                "id": 59,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0006519198650494218,
                            0,
                            0,
                            0,
                            0,
                            0.0013075864408165216,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 60",
                                "id": 60,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "viewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.999994158744812,
                            -0.00003970626858063042,
                            0.0034170825965702534,
                            0,
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598,
                            0,
                            -0.0034173133317381144,
                            -0.011619079858064651,
                            0.9999266862869263,
                            0,
                            -3.0878077872387166e-15,
                            0,
                            -15001.1005859375,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 61",
                                "id": 61,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "normalMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT3",
                        "value": [
                            0.0052565825171768665,
                            -0.1577451378107071,
                            -0.04118174687027931,
                            0.04065430909395218,
                            0.04116982966661453,
                            -0.15251022577285767,
                            0.15788190066814423,
                            -0.005349128041416407,
                            0.040642235428094864
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 62",
                                "id": 62,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "isOrthographic",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": true
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 63",
                                "id": 63,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "diffuse",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 64",
                                "id": 64,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "emissive",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0,
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 65",
                                "id": 65,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "specular",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0.06666667014360428,
                            0.06666667014360428,
                            0.06666667014360428
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 66",
                                "id": 66,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "shininess",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 30
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 67",
                                "id": 67,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "opacity",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 68",
                                "id": 68,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "ambientLightColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0,
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 69",
                                "id": 69,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "lightProbe",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 9,
                        "type": "FLOAT_VEC3",
                        "values": [
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 70",
                                "id": 70,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "directionalLights[0].direction",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            -0.440809041261673,
                            0.8562363386154175,
                            -0.26934507489204407
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 71",
                                "id": 71,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "directionalLights[0].color",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            2.880840539932251,
                            2.880840539932251,
                            2.880840539932251
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 72",
                                "id": 72,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].direction",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 73",
                                "id": 73,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].skyColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            2.092608690261841,
                            2.092608690261841,
                            2.092608690261841
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 74",
                                "id": 74,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].groundColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1.2892849445343018,
                            1.2892849445343018,
                            1.2892849445343018
                        ]
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    300,
                    150
                ],
                "SCISSOR_TEST": false
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "8",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "Canvas COLOR_ATTACHMENT",
                        "src": "data:image/png;base64,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",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": null
            },
            "commandArguments": [
                4,
                59994,
                5125,
                0
            ],
            "commandEndTime": 1732773744528.5,
            "endTime": 1732773744550.9,
            "id": 19,
            "name": "drawElements",
            "stackTrace": [
                "WebGLIndexedBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:16593:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773744528.5,
            "status": 0,
            "text": "drawElements: TRIANGLES, 59994 indices, UNSIGNED_INT, 0"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 12",
                        "id": 12,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                false,
                {
                    "0": -0.17278172075748444,
                    "1": -6.0916852951049805,
                    "2": -0.6674374938011169,
                    "3": 0,
                    "4": -5.998056888580322,
                    "5": 0.03126350790262222,
                    "6": 1.267395257949829,
                    "7": 0,
                    "8": -1.2559516429901123,
                    "9": 0.6887299418449402,
                    "10": -5.960888385772705,
                    "11": 0,
                    "12": 1966.127197265625,
                    "13": -1432.659423828125,
                    "14": -17335.462890625,
                    "15": 1
                }
            ],
            "commandEndTime": 1732773744551,
            "endTime": 1732773744551.2,
            "id": 20,
            "name": "uniformMatrix4fv",
            "stackTrace": [
                "SingleUniform.setValueM4 [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17409:6)",
                "WebGLUniforms.setValue (https://unpkg.com/three@0.149.0/build/three.module.js:18165:28)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28743:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773744550.9,
            "status": 0,
            "text": "uniformMatrix4fv: WebGLUniformLocation - ID: 12, false, [..(16)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 15",
                        "id": 15,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                false,
                {
                    "0": -0.004597220104187727,
                    "1": -0.16208207607269287,
                    "2": -0.017758576199412346,
                    "3": -0.15959088504314423,
                    "4": 0.0008318312466144562,
                    "5": 0.03372171148657799,
                    "6": -0.0334172323346138,
                    "7": 0.01832510530948639,
                    "8": -0.15860195457935333
                }
            ],
            "commandEndTime": 1732773744551.2,
            "endTime": 1732773744551.2,
            "id": 21,
            "name": "uniformMatrix3fv",
            "stackTrace": [
                "SingleUniform.setValueM3 [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17382:6)",
                "WebGLUniforms.setValue (https://unpkg.com/three@0.149.0/build/three.module.js:18165:28)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28744:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773744551.2,
            "status": 0,
            "text": "uniformMatrix3fv: WebGLUniformLocation - ID: 15, false, [..(9)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 5",
                        "id": 5,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773744551.2,
            "endTime": 1732773744551.2,
            "id": 22,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773744551.2,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 5"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 268644,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 16",
                                "id": 16,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 268644,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 268644,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 17",
                                "id": 17,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 268644,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 1,
                        "name": "normal",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "elementArray": {
                    "arrayBuffer": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 239976,
                            "target": "ELEMENT_ARRAY_BUFFER",
                            "usage": 35044
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLBuffer - ID: 19",
                            "id": 19,
                            "typeName": "WebGLBuffer"
                        }
                    }
                },
                "frameBuffer": null,
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 55495,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "MeshPhongMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshPhongMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PHONG\nvarying vec3 vViewPosition;\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\nuniform float3x3 _normalMatrix : register(c8);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2616 = vec3_ctor(_normal);\nfloat3 _transformedNormal2617 = _objectNormal2616;\n(_transformedNormal2617 = mul(transpose(_normalMatrix), _transformedNormal2617));\n(_vNormal = normalize(_transformedNormal2617));\nfloat3 _transformed2618 = vec3_ctor(_position);\nfloat4 _mvPosition2619 = vec4_ctor(_transformed2618, 1.0);\n(_mvPosition2619 = mul(transpose(_modelViewMatrix), _mvPosition2619));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2619));\n(_vViewPosition = (-_mvPosition2619.xyz));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "MeshPhongMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshPhongMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\n#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t\n#endif\n#if ( 1 > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t\n\t\tdirectionalLight = directionalLights[ 0 ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( 0 < 0 )\n\t\tdirectionalLightShadow = directionalLightShadows[ 0 ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( 0, directionalShadowMap[ 0 ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( 1 > 0 )\n\t\t\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif\n#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_26;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_27;\n    float pad_28;\n    float pad_29;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_30;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_31;\n    float pad_32;\n    float pad_33;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform bool _isOrthographic : register(c4);\nuniform float3 _diffuse : register(c5);\nuniform float3 _emissive : register(c6);\nuniform float3 _specular : register(c7);\nuniform float _shininess : register(c8);\nuniform float _opacity : register(c9);\nuniform float3 _ambientLightColor : register(c10);\nuniform float3 _lightProbe[9] : register(c11);\nuniform _DirectionalLight _directionalLights[1] : register(c20);\nuniform _HemisphereLight _hemisphereLights[1] : register(c22);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2663 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2663)) + (_f90 * _fresnel2663));\n}\nfloat f_G_BlinnPhong_Implicit()\n{\nreturn 0.25;\n}\nfloat f_D_BlinnPhong(const float _shininess, const float _dotNH)\n{\nreturn ((0.31830987 * ((_shininess * 0.5) + 1.0)) * pow(_dotNH, _shininess));\n}\nfloat3 f_BRDF_BlinnPhong(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _specularColor, const float _shininess)\n{\nfloat3 _halfDir2750 = normalize((_lightDir + _viewDir));\nfloat _dotNH2751 = clamp(dot(_normal, _halfDir2750), 0.0, 1.0);\nfloat _dotVH2752 = clamp(dot(_viewDir, _halfDir2750), 0.0, 1.0);\nfloat3 _F2753 = f_F_Schlick(_specularColor, 1.0, _dotVH2752);\nfloat _G2754 = f_G_BlinnPhong_Implicit();\nfloat _D2755 = f_D_BlinnPhong(_shininess, _dotNH2751);\nreturn (_F2753 * (_G2754 * _D2755));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2762 = _normal.x;\nfloat _y2763 = _normal.y;\nfloat _z2764 = _normal.z;\nfloat3 _result2765 = (_shCoefficients[0] * 0.88622701);\n(_result2765 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2763));\n(_result2765 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2764));\n(_result2765 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2762));\n(_result2765 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2762) * _y2763));\n(_result2765 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2763) * _z2764));\n(_result2765 += (_shCoefficients[6] * (((0.74312502 * _z2764) * _z2764) - 0.24770799)));\n(_result2765 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2762) * _z2764));\n(_result2765 += ((_shCoefficients[8] * 0.42904299) * ((_x2762 * _x2762) - (_y2763 * _y2763))));\nreturn _result2765;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2769 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2770 = f_shGetIrradianceAt(_worldNormal2769, _lightProbe);\nreturn _irradiance2770;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2773 = _ambientLightColor;\nreturn _irradiance2773;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2795 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2796 = ((0.5 * _dotNL2795) + 0.5);\nfloat3 _irradiance2797 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2796);\nreturn _irradiance2797;\n}\n;\nvoid f_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2807 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2808 = (_dotNL2807 * _directLight._color);\n(_reflectedLight._directDiffuse += (_irradiance2808 * f_BRDF_Lambert(_material._diffuseColor)));\n(_reflectedLight._directSpecular += ((_irradiance2808 * f_BRDF_BlinnPhong(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularShininess)) * _material._specularStrength));\n}\nvoid f_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2819 = vec4_ctor(_diffuse, _opacity);\n_ReflectedLight _reflectedLight2820 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 _totalEmissiveRadiance2821 = _emissive;\nfloat _specularStrength2822 = {0};\n(_specularStrength2822 = 1.0);\nfloat3 _normal2824 = normalize(_vNormal);\n_BlinnPhongMaterial _material2826 = {0, 0, 0, 0, 0, 0, 0, 0};\n(_material2826._diffuseColor = _diffuseColor2819.xyz);\n(_material2826._specularColor = _specular);\n(_material2826._specularShininess = _shininess);\n(_material2826._specularStrength = _specularStrength2822);\n_GeometricContext _geometry2827 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry2827._position = (-_vViewPosition));\n(_geometry2827._normal = _normal2824);\nfloat3 sb11 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sb11 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sb11 = normalize(_vViewPosition));\n}\n(_geometry2827._viewDir = sb11);\n_IncidentLight _directLight2828 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight2829 = {0, 0, 0, 0, 0, 0};\n(_directionalLight2829 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight2829, _geometry2827, _directLight2828);\nf_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(_directLight2828, _geometry2827, _material2826, _reflectedLight2820);\nfloat3 _irradiance2831 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance2831 += f_getLightProbeIrradiance(_lightProbe, _geometry2827._normal));\n(_irradiance2831 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry2827._normal));\nf_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(_irradiance2831, _geometry2827, _material2826, _reflectedLight2820);\nfloat3 _outgoingLight2832 = ((((_reflectedLight2820._directDiffuse + _reflectedLight2820._indirectDiffuse) + _reflectedLight2820._directSpecular) + _reflectedLight2820._indirectSpecular) + _totalEmissiveRadiance2821);\n(_diffuseColor2819.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2832, _diffuseColor2819.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 3",
                            "id": 3,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "MeshPhongMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshPhongMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PHONG\nvarying vec3 vViewPosition;\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\nuniform float3x3 _normalMatrix : register(c8);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2616 = vec3_ctor(_normal);\nfloat3 _transformedNormal2617 = _objectNormal2616;\n(_transformedNormal2617 = mul(transpose(_normalMatrix), _transformedNormal2617));\n(_vNormal = normalize(_transformedNormal2617));\nfloat3 _transformed2618 = vec3_ctor(_position);\nfloat4 _mvPosition2619 = vec4_ctor(_transformed2618, 1.0);\n(_mvPosition2619 = mul(transpose(_modelViewMatrix), _mvPosition2619));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2619));\n(_vViewPosition = (-_mvPosition2619.xyz));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "MeshPhongMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshPhongMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\n#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t\n#endif\n#if ( 1 > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t\n\t\tdirectionalLight = directionalLights[ 0 ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( 0 < 0 )\n\t\tdirectionalLightShadow = directionalLightShadows[ 0 ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( 0, directionalShadowMap[ 0 ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( 1 > 0 )\n\t\t\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif\n#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_26;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_27;\n    float pad_28;\n    float pad_29;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_30;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_31;\n    float pad_32;\n    float pad_33;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform bool _isOrthographic : register(c4);\nuniform float3 _diffuse : register(c5);\nuniform float3 _emissive : register(c6);\nuniform float3 _specular : register(c7);\nuniform float _shininess : register(c8);\nuniform float _opacity : register(c9);\nuniform float3 _ambientLightColor : register(c10);\nuniform float3 _lightProbe[9] : register(c11);\nuniform _DirectionalLight _directionalLights[1] : register(c20);\nuniform _HemisphereLight _hemisphereLights[1] : register(c22);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2663 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2663)) + (_f90 * _fresnel2663));\n}\nfloat f_G_BlinnPhong_Implicit()\n{\nreturn 0.25;\n}\nfloat f_D_BlinnPhong(const float _shininess, const float _dotNH)\n{\nreturn ((0.31830987 * ((_shininess * 0.5) + 1.0)) * pow(_dotNH, _shininess));\n}\nfloat3 f_BRDF_BlinnPhong(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _specularColor, const float _shininess)\n{\nfloat3 _halfDir2750 = normalize((_lightDir + _viewDir));\nfloat _dotNH2751 = clamp(dot(_normal, _halfDir2750), 0.0, 1.0);\nfloat _dotVH2752 = clamp(dot(_viewDir, _halfDir2750), 0.0, 1.0);\nfloat3 _F2753 = f_F_Schlick(_specularColor, 1.0, _dotVH2752);\nfloat _G2754 = f_G_BlinnPhong_Implicit();\nfloat _D2755 = f_D_BlinnPhong(_shininess, _dotNH2751);\nreturn (_F2753 * (_G2754 * _D2755));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2762 = _normal.x;\nfloat _y2763 = _normal.y;\nfloat _z2764 = _normal.z;\nfloat3 _result2765 = (_shCoefficients[0] * 0.88622701);\n(_result2765 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2763));\n(_result2765 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2764));\n(_result2765 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2762));\n(_result2765 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2762) * _y2763));\n(_result2765 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2763) * _z2764));\n(_result2765 += (_shCoefficients[6] * (((0.74312502 * _z2764) * _z2764) - 0.24770799)));\n(_result2765 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2762) * _z2764));\n(_result2765 += ((_shCoefficients[8] * 0.42904299) * ((_x2762 * _x2762) - (_y2763 * _y2763))));\nreturn _result2765;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2769 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2770 = f_shGetIrradianceAt(_worldNormal2769, _lightProbe);\nreturn _irradiance2770;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2773 = _ambientLightColor;\nreturn _irradiance2773;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2795 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2796 = ((0.5 * _dotNL2795) + 0.5);\nfloat3 _irradiance2797 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2796);\nreturn _irradiance2797;\n}\n;\nvoid f_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2807 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2808 = (_dotNL2807 * _directLight._color);\n(_reflectedLight._directDiffuse += (_irradiance2808 * f_BRDF_Lambert(_material._diffuseColor)));\n(_reflectedLight._directSpecular += ((_irradiance2808 * f_BRDF_BlinnPhong(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularShininess)) * _material._specularStrength));\n}\nvoid f_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2819 = vec4_ctor(_diffuse, _opacity);\n_ReflectedLight _reflectedLight2820 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 _totalEmissiveRadiance2821 = _emissive;\nfloat _specularStrength2822 = {0};\n(_specularStrength2822 = 1.0);\nfloat3 _normal2824 = normalize(_vNormal);\n_BlinnPhongMaterial _material2826 = {0, 0, 0, 0, 0, 0, 0, 0};\n(_material2826._diffuseColor = _diffuseColor2819.xyz);\n(_material2826._specularColor = _specular);\n(_material2826._specularShininess = _shininess);\n(_material2826._specularStrength = _specularStrength2822);\n_GeometricContext _geometry2827 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry2827._position = (-_vViewPosition));\n(_geometry2827._normal = _normal2824);\nfloat3 sb11 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sb11 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sb11 = normalize(_vViewPosition));\n}\n(_geometry2827._viewDir = sb11);\n_IncidentLight _directLight2828 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight2829 = {0, 0, 0, 0, 0, 0};\n(_directionalLight2829 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight2829, _geometry2827, _directLight2828);\nf_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(_directLight2828, _geometry2827, _material2826, _reflectedLight2820);\nfloat3 _irradiance2831 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance2831 += f_getLightProbeIrradiance(_lightProbe, _geometry2827._normal));\n(_irradiance2831 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry2827._normal));\nf_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(_irradiance2831, _geometry2827, _material2826, _reflectedLight2820);\nfloat3 _outgoingLight2832 = ((((_reflectedLight2820._directDiffuse + _reflectedLight2820._indirectDiffuse) + _reflectedLight2820._directSpecular) + _reflectedLight2820._indirectSpecular) + _totalEmissiveRadiance2821);\n(_diffuseColor2819.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2832, _diffuseColor2819.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 75",
                                "id": 75,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            -0.17278172075748444,
                            -6.0916852951049805,
                            -0.6674374938011169,
                            0,
                            -5.998056888580322,
                            0.03126350790262222,
                            1.267395257949829,
                            0,
                            -1.2559516429901123,
                            0.6887299418449402,
                            -5.960888385772705,
                            0,
                            1966.127197265625,
                            -1432.659423828125,
                            -17335.462890625,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 76",
                                "id": 76,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0006519198650494218,
                            0,
                            0,
                            0,
                            0,
                            0.0013075864408165216,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 77",
                                "id": 77,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "viewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.999994158744812,
                            -0.00003970626858063042,
                            0.0034170825965702534,
                            0,
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598,
                            0,
                            -0.0034173133317381144,
                            -0.011619079858064651,
                            0.9999266862869263,
                            0,
                            -3.0878077872387166e-15,
                            0,
                            -15001.1005859375,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 78",
                                "id": 78,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "normalMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT3",
                        "value": [
                            -0.004597220104187727,
                            -0.16208207607269287,
                            -0.017758576199412346,
                            -0.15959088504314423,
                            0.0008318312466144562,
                            0.03372171148657799,
                            -0.0334172323346138,
                            0.01832510530948639,
                            -0.15860195457935333
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 79",
                                "id": 79,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "isOrthographic",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": true
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 80",
                                "id": 80,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "diffuse",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 81",
                                "id": 81,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "emissive",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0,
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 82",
                                "id": 82,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "specular",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0.06666667014360428,
                            0.06666667014360428,
                            0.06666667014360428
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 83",
                                "id": 83,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "shininess",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 30
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 84",
                                "id": 84,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "opacity",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 85",
                                "id": 85,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "ambientLightColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0,
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 86",
                                "id": 86,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "lightProbe",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 9,
                        "type": "FLOAT_VEC3",
                        "values": [
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 87",
                                "id": 87,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "directionalLights[0].direction",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            -0.440809041261673,
                            0.8562363386154175,
                            -0.26934507489204407
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 88",
                                "id": 88,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "directionalLights[0].color",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            2.880840539932251,
                            2.880840539932251,
                            2.880840539932251
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 89",
                                "id": 89,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].direction",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 90",
                                "id": 90,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].skyColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            2.092608690261841,
                            2.092608690261841,
                            2.092608690261841
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 91",
                                "id": 91,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].groundColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1.2892849445343018,
                            1.2892849445343018,
                            1.2892849445343018
                        ]
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    300,
                    150
                ],
                "SCISSOR_TEST": false
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "8",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "Canvas COLOR_ATTACHMENT",
                        "src": "data:image/png;base64,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",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": null
            },
            "commandArguments": [
                4,
                59994,
                5125,
                0
            ],
            "commandEndTime": 1732773744551.3,
            "endTime": 1732773744603.2,
            "id": 23,
            "name": "drawElements",
            "stackTrace": [
                "WebGLIndexedBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:16593:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773744551.2,
            "status": 0,
            "text": "drawElements: TRIANGLES, 59994 indices, UNSIGNED_INT, 0"
        }
    ],
    "context": {
        "capabilities": {
            "ALIASED_LINE_WIDTH_RANGE": [
                1,
                1
            ],
            "ALIASED_POINT_SIZE_RANGE": [
                1,
                1024
            ],
            "ALPHA_BITS": 8,
            "BLUE_BITS": 8,
            "DEPTH_BITS": 24,
            "GREEN_BITS": 8,
            "IMPLEMENTATION_COLOR_READ_FORMAT": "RGBA",
            "IMPLEMENTATION_COLOR_READ_TYPE": "UNSIGNED_BYTE",
            "LINE_WIDTH": 1,
            "MAX_3D_TEXTURE_SIZE": 2048,
            "MAX_ARRAY_TEXTURE_LAYERS": 2048,
            "MAX_CLIENT_WAIT_TIMEOUT_WEBGL": 0,
            "MAX_COLOR_ATTACHMENTS": 8,
            "MAX_COLOR_ATTACHMENTS_WEBGL": "Extension WEBGL_draw_buffers is unavailable.",
            "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS": 200704,
            "MAX_COMBINED_TEXTURE_IMAGE_UNITS": 32,
            "MAX_COMBINED_UNIFORM_BLOCKS": 24,
            "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS": 212992,
            "MAX_CUBE_MAP_TEXTURE_SIZE": 16384,
            "MAX_DRAW_BUFFERS": 8,
            "MAX_DRAW_BUFFERS_WEBGL": "Extension WEBGL_draw_buffers is unavailable.",
            "MAX_ELEMENTS_INDICES": 2147483647,
            "MAX_ELEMENTS_VERTICES": 2147483647,
            "MAX_ELEMENT_INDEX": 4294967294,
            "MAX_FRAGMENT_INPUT_COMPONENTS": 120,
            "MAX_FRAGMENT_UNIFORM_BLOCKS": 12,
            "MAX_FRAGMENT_UNIFORM_COMPONENTS": 4096,
            "MAX_FRAGMENT_UNIFORM_VECTORS": 1024,
            "MAX_PROGRAM_TEXEL_OFFSET": 7,
            "MAX_RENDERBUFFER_SIZE": 16384,
            "MAX_SAMPLES": 16,
            "MAX_SERVER_WAIT_TIMEOUT": 0,
            "MAX_TEXTURE_IMAGE_UNITS": 16,
            "MAX_TEXTURE_LOD_BIAS": 2,
            "MAX_TEXTURE_MAX_ANISOTROPY_EXT": 16,
            "MAX_TEXTURE_SIZE": 16384,
            "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS": 120,
            "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS": 4,
            "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS": 4,
            "MAX_UNIFORM_BLOCK_SIZE": 65536,
            "MAX_UNIFORM_BUFFER_BINDINGS": 24,
            "MAX_VARYING_COMPONENTS": 120,
            "MAX_VARYING_VECTORS": 30,
            "MAX_VERTEX_ATTRIBS": 16,
            "MAX_VERTEX_OUTPUT_COMPONENTS": 120,
            "MAX_VERTEX_TEXTURE_IMAGE_UNITS": 16,
            "MAX_VERTEX_UNIFORM_BLOCKS": 12,
            "MAX_VERTEX_UNIFORM_COMPONENTS": 16384,
            "MAX_VERTEX_UNIFORM_VECTORS": 4096,
            "MAX_VIEWPORT_DIMS": [
                32767,
                32767
            ],
            "MIN_PROGRAM_TEXEL_OFFSET": -8,
            "RED_BITS": 8,
            "RENDERER": "WebKit WebGL",
            "SAMPLES": 0,
            "SAMPLE_BUFFERS": 0,
            "SHADING_LANGUAGE_VERSION": "WebGL GLSL ES 3.00 (OpenGL ES GLSL ES 3.0 Chromium)",
            "STENCIL_BITS": 8,
            "SUBPIXEL_BITS": 4,
            "VENDOR": "WebKit",
            "VERSION": "WebGL 2.0 (OpenGL ES 3.0 Chromium)"
        },
        "compressedTextures": {
            "COMPRESSED_TEXTURE_FORMATS": [
                "COMPRESSED_RGB_S3TC_DXT1_EXT",
                "COMPRESSED_RGBA_S3TC_DXT1_EXT",
                "COMPRESSED_RGBA_S3TC_DXT3_EXT",
                "COMPRESSED_RGBA_S3TC_DXT5_EXT"
            ]
        },
        "contextAttributes": {
            "alpha": true,
            "antialias": false,
            "depth": true,
            "desynchronized": false,
            "failIfMajorPerformanceCaveat": false,
            "powerPreference": "default",
            "premultipliedAlpha": true,
            "preserveDrawingBuffer": false,
            "stencil": true,
            "xrCompatible": false
        },
        "extensions": {
            "EXT_color_buffer_float": true,
            "EXT_disjoint_timer_query": false,
            "EXT_disjoint_timer_query_webgl2": true,
            "EXT_texture_filter_anisotropic": true,
            "OES_texture_float_linear": true,
            "WEBGL_compressed_texture_astc": false,
            "WEBGL_compressed_texture_atc": false,
            "WEBGL_compressed_texture_etc": false,
            "WEBGL_compressed_texture_etc1": false,
            "WEBGL_compressed_texture_pvrtc": false,
            "WEBGL_compressed_texture_s3tc": true,
            "WEBGL_draw_instanced_base_vertex_base_instance": false,
            "WEBGL_multi_draw": true,
            "WEBGL_multi_draw_instanced_base_vertex_base_instance": false
        },
        "version": 2
    },
    "endState": {
        "AlignmentState": {
            "PACK_ALIGNMENT": 4,
            "PACK_ROW_LENGTH": 0,
            "PACK_SKIP_PIXELS": 0,
            "PACK_SKIP_ROWS": 0,
            "UNPACK_ALIGNMENT": 4,
            "UNPACK_COLORSPACE_CONVERSION_WEBGL": "BROWSER_DEFAULT_WEBGL",
            "UNPACK_FLIP_Y_WEBGL": false,
            "UNPACK_IMAGE_HEIGHT": 0,
            "UNPACK_PREMULTIPLY_ALPHA_WEBGL": false,
            "UNPACK_SKIP_IMAGES": 0,
            "UNPACK_SKIP_PIXELS": 0,
            "UNPACK_SKIP_ROWS": 0
        },
        "BlendState": {
            "BLEND": false,
            "BLEND_COLOR": [
                0,
                0,
                0,
                0
            ],
            "BLEND_DST_ALPHA": "ZERO",
            "BLEND_DST_RGB": "ZERO",
            "BLEND_EQUATION_ALPHA": "FUNC_ADD",
            "BLEND_EQUATION_RGB": "FUNC_ADD",
            "BLEND_SRC_ALPHA": "ONE",
            "BLEND_SRC_RGB": "ONE"
        },
        "ClearState": {
            "COLOR_CLEAR_VALUE": [
                0.0470588244497776,
                0.05882352963089943,
                0.08627451211214066,
                1
            ],
            "DEPTH_CLEAR_VALUE": 1,
            "STENCIL_CLEAR_VALUE": 0
        },
        "ColorState": {
            "COLOR_WRITEMASK": [
                true,
                true,
                true,
                true
            ]
        },
        "CoverageState": {
            "SAMPLE_ALPHA_TO_COVERAGE": false,
            "SAMPLE_COVERAGE": false,
            "SAMPLE_COVERAGE_INVERT": false,
            "SAMPLE_COVERAGE_VALUE": 1
        },
        "CullState": {
            "CULL_FACE": true,
            "CULL_FACE_MODE": "BACK"
        },
        "DepthState": {
            "DEPTH_FUNC": "LEQUAL",
            "DEPTH_RANGE": [
                0,
                1
            ],
            "DEPTH_TEST": true,
            "DEPTH_WRITEMASK": true
        },
        "DrawState": {
            "DITHER": true,
            "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
            "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
            "FRONT_FACE": "CCW",
            "RASTERIZER_DISCARD": false,
            "VIEWPORT": [
                0,
                0,
                1745,
                870
            ]
        },
        "MipmapHintState": {
            "GENERATE_MIPMAP_HINT": 4352
        },
        "PolygonOffsetState": {
            "POLYGON_OFFSET_FACTOR": 0,
            "POLYGON_OFFSET_FILL": false,
            "POLYGON_OFFSET_UNITS": 0
        },
        "ScissorState": {
            "SCISSOR_BOX": [
                0,
                0,
                300,
                150
            ],
            "SCISSOR_TEST": false
        },
        "StencilState": {
            "STENCIL_BACK_FAIL": "KEEP",
            "STENCIL_BACK_FUNC": "ALWAYS",
            "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
            "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
            "STENCIL_BACK_REF": 0,
            "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
            "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
            "STENCIL_BITS": "8",
            "STENCIL_FAIL": "KEEP",
            "STENCIL_FUNC": "ALWAYS",
            "STENCIL_PASS_DEPTH_FAIL": "KEEP",
            "STENCIL_PASS_DEPTH_PASS": "KEEP",
            "STENCIL_REF": 0,
            "STENCIL_TEST": false,
            "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
            "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
        },
        "VisualState": {
            "Attachments": [
                {
                    "attachmentName": "Canvas COLOR_ATTACHMENT",
                    "src": "data:image/png;base64,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",
                    "textureCubeMapFace": null,
                    "textureLayer": 0
                }
            ],
            "FrameBuffer": null
        }
    },
    "endTime": 1732773744646.6,
    "frameMemory": {
        "Buffer": 0,
        "Program": 0,
        "Renderbuffer": 0,
        "Texture2d": 0,
        "Texture3d": 0
    },
    "initState": {
        "AlignmentState": {
            "PACK_ALIGNMENT": 4,
            "PACK_ROW_LENGTH": 0,
            "PACK_SKIP_PIXELS": 0,
            "PACK_SKIP_ROWS": 0,
            "UNPACK_ALIGNMENT": 4,
            "UNPACK_COLORSPACE_CONVERSION_WEBGL": "BROWSER_DEFAULT_WEBGL",
            "UNPACK_FLIP_Y_WEBGL": false,
            "UNPACK_IMAGE_HEIGHT": 0,
            "UNPACK_PREMULTIPLY_ALPHA_WEBGL": false,
            "UNPACK_SKIP_IMAGES": 0,
            "UNPACK_SKIP_PIXELS": 0,
            "UNPACK_SKIP_ROWS": 0
        },
        "BlendState": {
            "BLEND": false,
            "BLEND_COLOR": [
                0,
                0,
                0,
                0
            ],
            "BLEND_DST_ALPHA": "ZERO",
            "BLEND_DST_RGB": "ZERO",
            "BLEND_EQUATION_ALPHA": "FUNC_ADD",
            "BLEND_EQUATION_RGB": "FUNC_ADD",
            "BLEND_SRC_ALPHA": "ONE",
            "BLEND_SRC_RGB": "ONE"
        },
        "ClearState": {
            "COLOR_CLEAR_VALUE": [
                0.0470588244497776,
                0.05882352963089943,
                0.08627451211214066,
                1
            ],
            "DEPTH_CLEAR_VALUE": 1,
            "STENCIL_CLEAR_VALUE": 0
        },
        "ColorState": {
            "COLOR_WRITEMASK": [
                true,
                true,
                true,
                true
            ]
        },
        "CoverageState": {
            "SAMPLE_ALPHA_TO_COVERAGE": false,
            "SAMPLE_COVERAGE": false,
            "SAMPLE_COVERAGE_INVERT": false,
            "SAMPLE_COVERAGE_VALUE": 1
        },
        "CullState": {
            "CULL_FACE": true,
            "CULL_FACE_MODE": "BACK"
        },
        "DepthState": {
            "DEPTH_FUNC": "LEQUAL",
            "DEPTH_RANGE": [
                0,
                1
            ],
            "DEPTH_TEST": true,
            "DEPTH_WRITEMASK": true
        },
        "DrawState": {
            "DITHER": true,
            "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
            "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
            "FRONT_FACE": "CCW",
            "RASTERIZER_DISCARD": false,
            "VIEWPORT": [
                0,
                0,
                1745,
                870
            ]
        },
        "MipmapHintState": {
            "GENERATE_MIPMAP_HINT": 4352
        },
        "PolygonOffsetState": {
            "POLYGON_OFFSET_FACTOR": 0,
            "POLYGON_OFFSET_FILL": false,
            "POLYGON_OFFSET_UNITS": 0
        },
        "ScissorState": {
            "SCISSOR_BOX": [
                0,
                0,
                300,
                150
            ],
            "SCISSOR_TEST": false
        },
        "StencilState": {
            "STENCIL_BACK_FAIL": "KEEP",
            "STENCIL_BACK_FUNC": "ALWAYS",
            "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
            "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
            "STENCIL_BACK_REF": 0,
            "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
            "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
            "STENCIL_BITS": "8",
            "STENCIL_FAIL": "KEEP",
            "STENCIL_FUNC": "ALWAYS",
            "STENCIL_PASS_DEPTH_FAIL": "KEEP",
            "STENCIL_PASS_DEPTH_PASS": "KEEP",
            "STENCIL_REF": 0,
            "STENCIL_TEST": false,
            "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
            "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
        },
        "VisualState": {
            "Attachments": [
                {
                    "attachmentName": "Canvas COLOR_ATTACHMENT",
                    "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAAAylJREFUeF7t1AERAAAIAjHpX9ogPxswOXaOAIGswLLJBSdA4AyAEhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAsYADCzxedgAHQAQJhAQMQfr7oBAyADhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAsYADCzxedgAHQAQJhAQMQfr7oBAyADhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAsYADCzxedgAHQAQJhAQMQfr7oBAyADhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAsYADCzxedgAHQAQJhAQMQfr7oBAyADhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAsYADCzxedgAHQAQJhAQMQfr7oBAyADhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAsYADCzxedgAHQAQJhAQMQfr7oBAyADhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAsYADCzxedgAHQAQJhAQMQfr7oBAyADhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAs8CPOAIDeEgbfAAAAAElFTkSuQmCC",
                    "textureCubeMapFace": null,
                    "textureLayer": 0
                }
            ],
            "FrameBuffer": null
        }
    },
    "listenCommandsEndTime": 1732773744603.4,
    "listenCommandsStartTime": 1732773744416,
    "memory": {
        "Buffer": {
            "0": 144,
            "1": 1914040,
            "2": 2870400
        },
        "Program": {
            "0": 20849,
            "1": 118006
        },
        "Renderbuffer": {},
        "Texture2d": {
            "0": 28
        },
        "Texture3d": {}
    },
    "startTime": 1732773744387.2
}