{
    "analyses": [
        {
            "analyserName": "Commands",
            "bindFramebuffer": 2,
            "bindTexture": 2,
            "bindVertexArray": 9,
            "clear": 2,
            "drawArrays": 4,
            "drawElements": 5,
            "generateMipmap": 1,
            "scissor": 2,
            "uniform1fv": 3,
            "uniform3fv": 3,
            "uniform4fv": 3,
            "useProgram": 9
        },
        {
            "analyserName": "CommandsSummary",
            "clear": 2,
            "draw": 9,
            "total": 45
        },
        {
            "analyserName": "Primitives",
            "lineLoop": 0,
            "lineStrip": 4,
            "lines": 108,
            "points": 0,
            "total": 180094,
            "triangleFan": 0,
            "triangleStrip": 0,
            "triangles": 179982
        }
    ],
    "canvas": {
        "browserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
        "clientHeight": 870,
        "clientWidth": 1745,
        "height": 870,
        "width": 1745
    },
    "commands": [
        {
            "ClearState": {
                "COLOR_CLEAR_VALUE": [
                    0.0470588244497776,
                    0.05882352963089943,
                    0.08627451211214066,
                    1
                ],
                "DEPTH_CLEAR_VALUE": 1,
                "STENCIL_CLEAR_VALUE": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    300,
                    150
                ],
                "SCISSOR_TEST": false
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "Canvas COLOR_ATTACHMENT",
                        "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAAAzRJREFUeF7t1MEJACAQA0H9C/7sv1MF29i5Dm4SMtc+dzgCBJIC0wAkc/c0gS9gABSBQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYYEHgPqXUMPclfYAAAAASUVORK5CYII=",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": null
            },
            "commandArguments": [
                17664
            ],
            "commandEndTime": 1732773587339.1,
            "endTime": 1732773587354.6,
            "id": 0,
            "name": "clear",
            "stackTrace": [
                "WebGLRenderer.clear (https://unpkg.com/three@0.149.0/build/three.module.js:27494:7)",
                "Object.render (https://unpkg.com/three@0.149.0/build/three.module.js:13918:13)",
                "WebGLRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:27963:14)",
                "animate (http://127.0.0.1:5501/solution_depse.html:181:16)"
            ],
            "startTime": 1732773587339.1,
            "status": 0,
            "text": "clear: DEPTH_BUFFER_BIT, STENCIL_BUFFER_BIT, COLOR_BUFFER_BIT"
        },
        {
            "commandArguments": [
                36160,
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLFramebuffer - ID: 0",
                        "id": 0,
                        "typeName": "WebGLFramebuffer"
                    }
                }
            ],
            "commandEndTime": 1732773587355.3,
            "endTime": 1732773587355.7,
            "id": 1,
            "name": "bindFramebuffer",
            "stackTrace": [
                "Object.bindFramebuffer (https://unpkg.com/three@0.149.0/build/three.module.js:21610:7)",
                "WebGLRenderer.setRenderTarget (https://unpkg.com/three@0.149.0/build/three.module.js:28926:34)",
                "renderTransmissionPass (https://unpkg.com/three@0.149.0/build/three.module.js:28209:9)",
                "renderScene (https://unpkg.com/three@0.149.0/build/three.module.js:28161:41)"
            ],
            "startTime": 1732773587355.3,
            "status": 0,
            "text": "bindFramebuffer: FRAMEBUFFER, WebGLFramebuffer - ID: 0"
        },
        {
            "commandArguments": [
                0,
                0,
                1745,
                870
            ],
            "commandEndTime": 1732773587355.8,
            "consumeCommandId": 3,
            "endTime": 1732773587356,
            "id": 2,
            "name": "scissor",
            "stackTrace": [
                "Object.scissor (https://unpkg.com/three@0.149.0/build/three.module.js:22266:7)",
                "WebGLRenderer.setRenderTarget (https://unpkg.com/three@0.149.0/build/three.module.js:28935:9)",
                "renderTransmissionPass (https://unpkg.com/three@0.149.0/build/three.module.js:28209:9)",
                "renderScene (https://unpkg.com/three@0.149.0/build/three.module.js:28161:41)"
            ],
            "startTime": 1732773587355.8,
            "status": 20,
            "text": "scissor: 0, 0, 1745, 870"
        },
        {
            "ClearState": {
                "COLOR_CLEAR_VALUE": [
                    0.0470588244497776,
                    0.05882352963089943,
                    0.08627451211214066,
                    1
                ],
                "DEPTH_CLEAR_VALUE": 1,
                "STENCIL_CLEAR_VALUE": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    1745,
                    870
                ],
                "SCISSOR_TEST": false,
                "disabledCommandIds": [
                    2
                ]
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "COLOR_ATTACHMENT0",
                        "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAAAzRJREFUeF7t1MEJACAQA0F9C/7sv1QF29i5Dm4SMtc+dzgCBJIC0wAkc/c0gS9gABSBQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYQEDEA7f6wQMgA4QCAsYgHD4XidgAHSAQFjAAITD9zoBA6ADBMICBiAcvtcJGAAdIBAWMADh8L1OwADoAIGwgAEIh+91AgZABwiEBQxAOHyvEzAAOkAgLGAAwuF7nYAB0AECYYEHDmGV0+TEN1oAAAAASUVORK5CYII=",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLFramebuffer - ID: 0",
                        "id": 0,
                        "typeName": "WebGLFramebuffer"
                    }
                },
                "FrameBufferStatus": "FRAMEBUFFER_COMPLETE"
            },
            "commandArguments": [
                17664
            ],
            "commandEndTime": 1732773587356,
            "endTime": 1732773587427.2,
            "id": 3,
            "name": "clear",
            "stackTrace": [
                "WebGLRenderer.clear (https://unpkg.com/three@0.149.0/build/three.module.js:27494:7)",
                "renderTransmissionPass (https://unpkg.com/three@0.149.0/build/three.module.js:28210:9)",
                "renderScene (https://unpkg.com/three@0.149.0/build/three.module.js:28161:41)",
                "WebGLRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:27983:4)"
            ],
            "startTime": 1732773587356,
            "status": 0,
            "text": "clear: DEPTH_BUFFER_BIT, STENCIL_BUFFER_BIT, COLOR_BUFFER_BIT"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_CustomData": {
                        "length": 20849,
                        "programStatus": {
                            "LINK_STATUS": true,
                            "VALIDATE_STATUS": false
                        },
                        "shaders": [
                            {
                                "COMPILE_STATUS": true,
                                "name": "LineBasicMaterial",
                                "shaderType": "VERTEX_SHADER",
                                "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD1;\n    float3 v0 : TEXCOORD0;\n};\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _color : TEXCOORD1;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _color = input._color;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.v0 = _vColor;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                            },
                            {
                                "COMPILE_STATUS": true,
                                "name": "LineBasicMaterial",
                                "shaderType": "FRAGMENT_SHADER",
                                "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD1;\n    float3 v0 : TEXCOORD0;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input){\n    _vColor = input.v0.xyz;\n\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                            }
                        ]
                    },
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLProgram - ID: 0",
                        "id": 0,
                        "typeName": "WebGLProgram"
                    }
                }
            ],
            "commandEndTime": 1732773587427.2,
            "endTime": 1732773587427.5,
            "id": 4,
            "name": "useProgram",
            "stackTrace": [
                "Object.useProgram (https://unpkg.com/three@0.149.0/build/three.module.js:21720:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28554:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587427.2,
            "status": 0,
            "text": "useProgram: WebGLProgram - ID: 0"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 0",
                        "id": 0,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773587427.5,
            "endTime": 1732773587427.6,
            "id": 5,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587427.5,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 0"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 72,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 0",
                                "id": 0,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 72,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 72,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 1",
                                "id": 1,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 72,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 3,
                        "name": "color",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "frameBuffer": {
                    "colorAttachments": [
                        {
                            "alphaSize": 16,
                            "blueSize": 16,
                            "componentType": "FLOAT",
                            "depthSize": 0,
                            "encoding": "LINEAR",
                            "format": "RGBA",
                            "greenSize": 16,
                            "height": 870,
                            "internalFormat": "RGBA16F",
                            "redSize": 16,
                            "stencilSize": 0,
                            "texture": {
                                "__SPECTOR_Object_CustomData": {
                                    "format": 6408,
                                    "height": 870,
                                    "internalFormat": 34842,
                                    "isCompressed": false,
                                    "length": 12145200,
                                    "target": "TEXTURE_2D",
                                    "type": 5131,
                                    "width": 1745
                                },
                                "__SPECTOR_Object_TAG": {
                                    "displayText": "WebGLTexture - ID: 2",
                                    "id": 2,
                                    "typeName": "WebGLTexture"
                                }
                            },
                            "textureCubeMapFace": "NONE",
                            "textureLayer": 0,
                            "textureLevel": 0,
                            "textureType": "HALF_FLOAT",
                            "type": "TEXTURE",
                            "width": 1745
                        }
                    ],
                    "depthAttachment": {
                        "alphaSize": 0,
                        "blueSize": 0,
                        "buffer": {
                            "__SPECTOR_Object_CustomData": {
                                "height": 870,
                                "internalFormat": 33189,
                                "length": 6072600,
                                "samples": 0,
                                "target": "RENDERBUFFER",
                                "width": 1745
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLRenderbuffer - ID: 0",
                                "id": 0,
                                "typeName": "WebGLRenderbuffer"
                            }
                        },
                        "componentType": "UNSIGNED_NORMALIZED_EXT",
                        "depthSize": 16,
                        "encoding": "LINEAR",
                        "greenSize": 0,
                        "height": 870,
                        "internalFormat": "DEPTH_COMPONENT16",
                        "msaaSamples": 0,
                        "redSize": 0,
                        "stencilSize": 0,
                        "type": "RENDERBUFFER",
                        "width": 1745
                    },
                    "frameBuffer": {
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLFramebuffer - ID: 0",
                            "id": 0,
                            "typeName": "WebGLFramebuffer"
                        }
                    }
                },
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 20849,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "LineBasicMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD1;\n    float3 v0 : TEXCOORD0;\n};\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _color : TEXCOORD1;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _color = input._color;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.v0 = _vColor;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "LineBasicMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD1;\n    float3 v0 : TEXCOORD0;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input){\n    _vColor = input.v0.xyz;\n\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 0",
                            "id": 0,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "LineBasicMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD1;\n    float3 v0 : TEXCOORD0;\n};\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _color : TEXCOORD1;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _color = input._color;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.v0 = _vColor;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "LineBasicMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD1;\n    float3 v0 : TEXCOORD0;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input){\n    _vColor = input.v0.xyz;\n\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 236",
                                "id": 236,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.999994158744812,
                            -0.00003970626858063042,
                            0.0034170825965702534,
                            0,
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598,
                            0,
                            -0.0034173133317381144,
                            -0.011619079858064651,
                            0.9999266862869263,
                            0,
                            -3.0878077872387166e-15,
                            0,
                            -15001.1005859375,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 237",
                                "id": 237,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0007603672565892339,
                            0,
                            0,
                            0,
                            0,
                            0.0015251043951138854,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 238",
                                "id": 238,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "diffuse",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            1,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 239",
                                "id": 239,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "opacity",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    1745,
                    870
                ],
                "SCISSOR_TEST": false
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "0",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "COLOR_ATTACHMENT0",
                        "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAAA+lJREFUeF7t1DFOA1EQA9DdOhIdl+UAXIpzpaACLSWhSOECyw+JJom+Zp5HPm8vr1+HPwIEJgVOBTCZu6UJ/AgoAIdAYFhAAQyHb3UCCsANEBgWUADD4VudgAJwAwSGBRTAcPhWJ6AA3ACBYQEFMBy+1QkoADdAYFhAAQyHb3UCCsANEBgWUADD4VudgAJwAwSGBRTAcPhWJ6AA3ACBYQEFMBy+1QkoADdAYFhAAQyHb3UCCsANEBgWUADD4VudgAJwAwSGBRTAcPhWJ6AA3ACBYQEFMBy+1QkoADdAYFhAAQyHb3UCCsANEBgWUADD4VudgAJwAwSGBRTAcPhWJ6AA3ACBYQEFMBy+1QkoADdAYFhAAQyHb3UCCsANEBgWUADD4VudgAJwAwSGBRTAcPhWJ6AA3ACBYQEFMBy+1QkoADdAYFhAAQyHb3UCCsANEBgWUADD4VudgAJwAwSGBRTAcPhWJ6AA3ACBYQEFMBy+1QkoADdAYFhAAQyHb3UCCsANEBgWUADD4VudgAJwAwSGBRTAcPhWJ6AA3ACBYQEFMBy+1QkoADdAYFhAAQyHb3UCCsANEBgWUADD4VudgAJwAwSGBRTAcPjX6m+f9+M4j8f/68u/Pv/92X//3TXvszOGfvv+cau5KgVQE5VBCeQFFEDe1IsEagQUQE1UBiWQF1AAeVMvEqgRUAA1URmUQF5AAeRNvUigRkAB1ERlUAJ5AQWQN/UigRoBBVATlUEJ5AUUQN7UiwRqBBRATVQGJZAXUAB5Uy8SqBFQADVRGZRAXkAB5E29SKBGQAHURGVQAnkBBZA39SKBGgEFUBOVQQnkBRRA3tSLBGoEFEBNVAYlkBdQAHlTLxKoEVAANVEZlEBeQAHkTb1IoEZAAdREZVACeQEFkDf1IoEaAQVQE5VBCeQFFEDe1IsEagQUQE1UBiWQF1AAeVMvEqgRUAA1URmUQF5AAeRNvUigRkAB1ERlUAJ5AQWQN/UigRoBBVATlUEJ5AUUQN7UiwRqBBRATVQGJZAXUAB5Uy8SqBFQADVRGZRAXkAB5E29SKBGQAHURGVQAnkBBZA39SKBGgEFUBOVQQnkBRRA3tSLBGoEFEBNVAYlkBdQAHlTLxKoEVAANVEZlEBeQAHkTb1IoEZAAdREZVACeQEFkDf1IoEaAQVQE5VBCeQFFEDe1IsEagQUQE1UBiWQF1AAeVMvEqgRUAA1URmUQF5AAeRNvUigRkAB1ERlUAJ5AQWQN/UigRoBBVATlUEJ5AUUQN7UiwRqBBRATVQGJZAXUAB5Uy8SqBFQADVRGZRAXkAB5E29SKBGQAHURGVQAnmBb1ZamdPOKiFDAAAAAElFTkSuQmCC",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLFramebuffer - ID: 0",
                        "id": 0,
                        "typeName": "WebGLFramebuffer"
                    }
                },
                "FrameBufferStatus": "FRAMEBUFFER_COMPLETE"
            },
            "commandArguments": [
                1,
                0,
                6
            ],
            "commandEndTime": 1732773587427.6,
            "endTime": 1732773587489.2,
            "id": 6,
            "name": "drawArrays",
            "stackTrace": [
                "WebGLBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:14729:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773587427.6,
            "status": 0,
            "text": "drawArrays: LINES, 0 indices, 6"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_CustomData": {
                        "length": 20813,
                        "programStatus": {
                            "LINK_STATUS": true,
                            "VALIDATE_STATUS": false
                        },
                        "shaders": [
                            {
                                "COMPILE_STATUS": true,
                                "name": "LineBasicMaterial",
                                "shaderType": "VERTEX_SHADER",
                                "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _transformed2614 = vec3_ctor(_position);\nfloat4 _mvPosition2615 = vec4_ctor(_transformed2614, 1.0);\n(_mvPosition2615 = mul(transpose(_modelViewMatrix), _mvPosition2615));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2615));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                            },
                            {
                                "COMPILE_STATUS": true,
                                "name": "LineBasicMaterial",
                                "shaderType": "FRAGMENT_SHADER",
                                "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2617 = vec4_ctor(_diffuse, _opacity);\nfloat _specularStrength2618 = {0};\n(_specularStrength2618 = 1.0);\n_ReflectedLight _reflectedLight2619 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2619._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2619._indirectDiffuse *= _diffuseColor2617.xyz);\nfloat3 _outgoingLight2620 = _reflectedLight2619._indirectDiffuse;\n(_diffuseColor2617.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2620, _diffuseColor2617.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                            }
                        ]
                    },
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLProgram - ID: 1",
                        "id": 1,
                        "typeName": "WebGLProgram"
                    }
                }
            ],
            "commandEndTime": 1732773587489.2,
            "endTime": 1732773587489.6,
            "id": 7,
            "name": "useProgram",
            "stackTrace": [
                "Object.useProgram (https://unpkg.com/three@0.149.0/build/three.module.js:21720:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28554:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587489.2,
            "status": 0,
            "text": "useProgram: WebGLProgram - ID: 1"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 1",
                        "id": 1,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773587489.6,
            "endTime": 1732773587489.7,
            "id": 8,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587489.6,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 1"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 24,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 2",
                                "id": 2,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 24,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "frameBuffer": {
                    "colorAttachments": [
                        {
                            "alphaSize": 16,
                            "blueSize": 16,
                            "componentType": "FLOAT",
                            "depthSize": 0,
                            "encoding": "LINEAR",
                            "format": "RGBA",
                            "greenSize": 16,
                            "height": 870,
                            "internalFormat": "RGBA16F",
                            "redSize": 16,
                            "stencilSize": 0,
                            "texture": {
                                "__SPECTOR_Object_CustomData": {
                                    "format": 6408,
                                    "height": 870,
                                    "internalFormat": 34842,
                                    "isCompressed": false,
                                    "length": 12145200,
                                    "target": "TEXTURE_2D",
                                    "type": 5131,
                                    "width": 1745
                                },
                                "__SPECTOR_Object_TAG": {
                                    "displayText": "WebGLTexture - ID: 2",
                                    "id": 2,
                                    "typeName": "WebGLTexture"
                                }
                            },
                            "textureCubeMapFace": "NONE",
                            "textureLayer": 0,
                            "textureLevel": 0,
                            "textureType": "HALF_FLOAT",
                            "type": "TEXTURE",
                            "width": 1745
                        }
                    ],
                    "depthAttachment": {
                        "alphaSize": 0,
                        "blueSize": 0,
                        "buffer": {
                            "__SPECTOR_Object_CustomData": {
                                "height": 870,
                                "internalFormat": 33189,
                                "length": 6072600,
                                "samples": 0,
                                "target": "RENDERBUFFER",
                                "width": 1745
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLRenderbuffer - ID: 0",
                                "id": 0,
                                "typeName": "WebGLRenderbuffer"
                            }
                        },
                        "componentType": "UNSIGNED_NORMALIZED_EXT",
                        "depthSize": 16,
                        "encoding": "LINEAR",
                        "greenSize": 0,
                        "height": 870,
                        "internalFormat": "DEPTH_COMPONENT16",
                        "msaaSamples": 0,
                        "redSize": 0,
                        "stencilSize": 0,
                        "type": "RENDERBUFFER",
                        "width": 1745
                    },
                    "frameBuffer": {
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLFramebuffer - ID: 0",
                            "id": 0,
                            "typeName": "WebGLFramebuffer"
                        }
                    }
                },
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 20813,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "LineBasicMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _transformed2614 = vec3_ctor(_position);\nfloat4 _mvPosition2615 = vec4_ctor(_transformed2614, 1.0);\n(_mvPosition2615 = mul(transpose(_modelViewMatrix), _mvPosition2615));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2615));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "LineBasicMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2617 = vec4_ctor(_diffuse, _opacity);\nfloat _specularStrength2618 = {0};\n(_specularStrength2618 = 1.0);\n_ReflectedLight _reflectedLight2619 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2619._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2619._indirectDiffuse *= _diffuseColor2617.xyz);\nfloat3 _outgoingLight2620 = _reflectedLight2619._indirectDiffuse;\n(_diffuseColor2617.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2620, _diffuseColor2617.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 1",
                            "id": 1,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "LineBasicMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _transformed2614 = vec3_ctor(_position);\nfloat4 _mvPosition2615 = vec4_ctor(_transformed2614, 1.0);\n(_mvPosition2615 = mul(transpose(_modelViewMatrix), _mvPosition2615));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2615));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "LineBasicMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2617 = vec4_ctor(_diffuse, _opacity);\nfloat _specularStrength2618 = {0};\n(_specularStrength2618 = 1.0);\n_ReflectedLight _reflectedLight2619 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2619._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2619._indirectDiffuse *= _diffuseColor2617.xyz);\nfloat3 _outgoingLight2620 = _reflectedLight2619._indirectDiffuse;\n(_diffuseColor2617.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2620, _diffuseColor2617.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 240",
                                "id": 240,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.5351841449737549,
                            0.009815105237066746,
                            -0.8446784019470215,
                            0,
                            0.7206006646156311,
                            0.5164910554885864,
                            0.4625706970691681,
                            0,
                            1510.9722900390625,
                            -2934.94287109375,
                            923.2409057617188,
                            0,
                            -1510.9722900390625,
                            2934.94287109375,
                            -15924.3408203125,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 241",
                                "id": 241,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0007603672565892339,
                            0,
                            0,
                            0,
                            0,
                            0.0015251043951138854,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 242",
                                "id": 242,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "diffuse",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            1,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 243",
                                "id": 243,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "opacity",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    1745,
                    870
                ],
                "SCISSOR_TEST": false
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "0",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "COLOR_ATTACHMENT0",
                        "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAABbVJREFUeF7t2E+IllUUBvA7sxWCWQS2ySAipP+ktgmipDZiUkjQMlq0KsoKw4JhICXRLGzVIloGIYVJm6QiaJMa/ScigmyTu1m1aDPFLGZRSYyX837fPff+Ajcy73mf8zsvD5MLW666+q/iv7kIvHDw2fLK0Vfn8m4vJbAusKAAfAgExhVQAHO+/Xun3ikP7390zim8flQBBTDq5e1NwP8CtPEN/PzTt+WGG29tI4wUQwn4DWCoc1uWwD8FFEAjX8Svv/xYrrt+eyNpxBhFQAGMcml7EriMgAJo6LM4c/pU2btvf0OJROldQAH0fmH7EfgfAQXQ2Odx5PBKOfTicmOpxOlVQAH0ell7EdiEgALYBNKsf+TBvXvKB2c+nPVrvW9AAQUw4NGtTGBDQAE0+i3ccvNN5bvvf2g0nVi9CCiAXi5pDwIVAgqgAs0jBHoRUAC9XNIeBCoEFEAFmkcI9CKgAHq5pD0IVAgogAo0jxDoRUAB9HJJexCoEFAAFWgeIdCLgALo5ZL2IFAhoAAq0DxCoBcBBdDLJe1BoEJAAVSgeYRALwIKIOElr9m6tfx+6VLC5CK3JqAAWruIPARmKKAAZogd+aoH7t9dPjr7ceRIswYUUAADHt3KBDYEFEDib+Hg8wfK0WMnEm8g+rwFFMC8L+D9BOYooADmiB/x6rfferM89vgTEaPMGFBAAQx4dCsT8G8AHX0DF774vOy46+6ONrLKrAT8BjArae8h0KCAAmjwKDWRTr5+vDz19HM1j3pmYAEFMPDxrU5AAXT0DZx+/92y76FHOtrIKlMLKICphc0n0LCAAmj4ODXRtm27tly8+FvNo54ZUEABDHh0KxPYEFAAHX4LO3feWc6f/7LDzawULaAAokXNI5BIQAEkOtaVRL3j9tvKV19/cyWP+NkBBRTAgEe3MgH/BjDAN7C4uFjW1tYG2NSKtQJ+A6iV8xyBDgQUQAdHtAKBWgEFUCvnOQIdCCiADo5oBQK1AgqgVi7Zc0tLS2V1dTVZanGnFlAAUwubT6BhAQXQ8HFEIzC1gAKYWth8Ag0LKICGjzNFtAPPPFlOvPbGFKPNTCigABIeTWQCUQIKIEoy0Zz77r2nfPLpZ4kSizqVgAKYStZcAgkEFECCI00RcdeuHeXcuQtTjDYzkYACSHQsUQlECyiAaNFE81aWXyrLKy8nSixqtIACiBZNNu/Qn3+UslD++2d9j8v9/b//rvWfW8+72YxBP3vk7JY0X4ECSHMqQQnECyiAeFMTCaQRUABpTiUogXgBBRBvaiKBNAIKIM2pBCUQL6AA4k1NJJBGQAGkOZWgBOIFFEC8qYkE0ggogDSnEpRAvIACiDc1kUAaAQWQ5lSCEogXUADxpiYSSCOgANKcSlAC8QIKIN7URAJpBBRAmlMJSiBeQAHEm5pIII2AAkhzKkEJxAsogHhTEwmkEVAAaU4lKIF4AQUQb2oigTQCCiDNqQQlEC+gAOJNTSSQRkABpDmVoATiBRRAvKmJBNIIKIA0pxKUQLyAAog3NZFAGgEFkOZUghKIF1AA8aYmEkgjoADSnEpQAvECCiDe1EQCaQQUQJpTCUogXkABxJuaSCCNgAJIcypBCcQLKIB4UxMJpBFQAGlOJSiBeAEFEG9qIoE0AgogzakEJRAvoADiTU0kkEZAAaQ5laAE4gUUQLypiQTSCCiANKcSlEC8gAKINzWRQBoBBZDmVIISiBdQAPGmJhJII6AA0pxKUALxAgog3tREAmkEFECaUwlKIF5AAcSbmkggjYACSHMqQQnECyiAeFMTCaQRUABpTiUogXgBBRBvaiKBNAIKIM2pBCUQL6AA4k1NJJBGQAGkOZWgBOIFFEC8qYkE0ggogDSnEpRAvIACiDc1kUAaAQWQ5lSCEogXUADxpiYSSCOgANKcSlAC8QIKIN7URAJpBBRAmlMJSiBe4G9aM+HT+F9s1gAAAABJRU5ErkJggg==",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLFramebuffer - ID: 0",
                        "id": 0,
                        "typeName": "WebGLFramebuffer"
                    }
                },
                "FrameBufferStatus": "FRAMEBUFFER_COMPLETE"
            },
            "commandArguments": [
                3,
                0,
                2
            ],
            "commandEndTime": 1732773587489.7,
            "endTime": 1732773587551.9,
            "id": 9,
            "name": "drawArrays",
            "stackTrace": [
                "WebGLBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:14729:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773587489.7,
            "status": 0,
            "text": "drawArrays: LINE_STRIP, 0 indices, 2"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_CustomData": {
                        "length": 20849,
                        "programStatus": {
                            "LINK_STATUS": true,
                            "VALIDATE_STATUS": false
                        },
                        "shaders": [
                            {
                                "COMPILE_STATUS": true,
                                "name": "MeshBasicMaterial",
                                "shaderType": "VERTEX_SHADER",
                                "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                            },
                            {
                                "COMPILE_STATUS": true,
                                "name": "MeshBasicMaterial",
                                "shaderType": "FRAGMENT_SHADER",
                                "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                            }
                        ]
                    },
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLProgram - ID: 2",
                        "id": 2,
                        "typeName": "WebGLProgram"
                    }
                }
            ],
            "commandEndTime": 1732773587551.9,
            "endTime": 1732773587552,
            "id": 10,
            "name": "useProgram",
            "stackTrace": [
                "Object.useProgram (https://unpkg.com/three@0.149.0/build/three.module.js:21720:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28554:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587551.9,
            "status": 0,
            "text": "useProgram: WebGLProgram - ID: 2"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 2",
                        "id": 2,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773587552,
            "endTime": 1732773587552.2,
            "id": 11,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587552,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 2"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 288,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 3",
                                "id": 3,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 288,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 288,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 6",
                                "id": 6,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 288,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 3,
                        "name": "color",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "elementArray": {
                    "arrayBuffer": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 96,
                            "target": "ELEMENT_ARRAY_BUFFER",
                            "usage": 35044
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLBuffer - ID: 13",
                            "id": 13,
                            "typeName": "WebGLBuffer"
                        }
                    }
                },
                "frameBuffer": {
                    "colorAttachments": [
                        {
                            "alphaSize": 16,
                            "blueSize": 16,
                            "componentType": "FLOAT",
                            "depthSize": 0,
                            "encoding": "LINEAR",
                            "format": "RGBA",
                            "greenSize": 16,
                            "height": 870,
                            "internalFormat": "RGBA16F",
                            "redSize": 16,
                            "stencilSize": 0,
                            "texture": {
                                "__SPECTOR_Object_CustomData": {
                                    "format": 6408,
                                    "height": 870,
                                    "internalFormat": 34842,
                                    "isCompressed": false,
                                    "length": 12145200,
                                    "target": "TEXTURE_2D",
                                    "type": 5131,
                                    "width": 1745
                                },
                                "__SPECTOR_Object_TAG": {
                                    "displayText": "WebGLTexture - ID: 2",
                                    "id": 2,
                                    "typeName": "WebGLTexture"
                                }
                            },
                            "textureCubeMapFace": "NONE",
                            "textureLayer": 0,
                            "textureLevel": 0,
                            "textureType": "HALF_FLOAT",
                            "type": "TEXTURE",
                            "width": 1745
                        }
                    ],
                    "depthAttachment": {
                        "alphaSize": 0,
                        "blueSize": 0,
                        "buffer": {
                            "__SPECTOR_Object_CustomData": {
                                "height": 870,
                                "internalFormat": 33189,
                                "length": 6072600,
                                "samples": 0,
                                "target": "RENDERBUFFER",
                                "width": 1745
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLRenderbuffer - ID: 0",
                                "id": 0,
                                "typeName": "WebGLRenderbuffer"
                            }
                        },
                        "componentType": "UNSIGNED_NORMALIZED_EXT",
                        "depthSize": 16,
                        "encoding": "LINEAR",
                        "greenSize": 0,
                        "height": 870,
                        "internalFormat": "DEPTH_COMPONENT16",
                        "msaaSamples": 0,
                        "redSize": 0,
                        "stencilSize": 0,
                        "type": "RENDERBUFFER",
                        "width": 1745
                    },
                    "frameBuffer": {
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLFramebuffer - ID: 0",
                            "id": 0,
                            "typeName": "WebGLFramebuffer"
                        }
                    }
                },
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 20849,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "MeshBasicMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "MeshBasicMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 2",
                            "id": 2,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "MeshBasicMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "MeshBasicMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 244",
                                "id": 244,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.999994158744812,
                            -0.00003970626858063042,
                            0.0034170825965702534,
                            0,
                            -0.0034173133317381144,
                            -0.011519086547195911,
                            0.999927818775177,
                            0,
                            -3.417313223508245e-7,
                            -0.999933660030365,
                            -0.011519155465066433,
                            0,
                            -3.0878010109751386e-15,
                            0.9999324679374695,
                            -15001.0888671875,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 245",
                                "id": 245,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0007603672565892339,
                            0,
                            0,
                            0,
                            0,
                            0.0015251043951138854,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 246",
                                "id": 246,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "diffuse",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            1,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 247",
                                "id": 247,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "opacity",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    1745,
                    870
                ],
                "SCISSOR_TEST": false
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "0",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "COLOR_ATTACHMENT0",
                        "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAABb1JREFUeF7t2M2rp2MYB/D7nO2UOgs1NkZJkvfMDKGE2GhMNClLLKyIQSOmTqeYTBhiZSFLpYnGZGNCysbMyHuSTubYmN35Dw7N4ixGk87cXc/vd1/3/VEWdJ7r+V6f6+nbmVnYdsml/xT/zEXgxQPPldcOvzmXd3spgXMCCwrAh0BgXAEFMOfbf3z0w/LwvkfnnMLrRxVQAKNe3t4E/BGgjW/gj99/KlddfUMbYaQYSsBvAEOd27IEzhdQAI18EWdWfytXXHlNI2nEGEVAAYxyaXsSuICAAmjoszh+7GjZs3dfQ4lE6V1AAfR+YfsR+B8BBdDY53Ho1ZXy0svLjaUSp1cBBdDrZe1FYAsCCmALSLP+kQf3PFA+Pf7ZrF/rfQMKKIABj25lApsCCqDRb+H6664tP//ya6PpxOpFQAH0ckl7EKgQUAAVaB4h0IuAAujlkvYgUCGgACrQPEKgFwEF0Msl7UGgQkABVKB5hEAvAgqgl0vag0CFgAKoQPMIgV4EFEAvl7QHgQoBBVCB5hECvQgogF4uaQ8CFQIKoALNIwR6EVAACS952fbt5e+zZxMmF7k1AQXQ2kXkITBDAQUwQ+zIV91/373l8xNfRI40a0ABBTDg0a1MYFNAAST+Fg68sL8cfv1I4g1En7eAApj3BbyfwBwFFMAc8SNe/cH775XHnngyYpQZAwoogAGPbmUC/g6go2/g9LfflJ233tnRRlaZlYDfAGYl7T0EGhRQAA0epSbSO2+/UZ5+5vmaRz0zsIACGPj4ViegADr6Bo598lHZ+9AjHW1klakFFMDUwuYTaFhAATR8nJpoO3ZcXtbW/qp51DMDCiiAAY9uZQKbAgqgw29h165byqlT33W4mZWiBRRAtKh5BBIJKIBEx7qYqDffdGP5/ocfL+YRPzuggAIY8OhWJuDvAAb4BhYXF8vGxsYAm1qxVsBvALVyniPQgYAC6OCIViBQK6AAauU8R6ADAQXQwRGtQKBWQAHUyiV7bmlpqayvrydLLe7UAgpgamHzCTQsoAAaPo5oBKYWUABTC5tPoGEBBdDwcaaItv/Zp8qRt96dYrSZCQUUQMKjiUwgSkABREkmmnPP3XeVL7/6OlFiUacSUABTyZpLIIGAAkhwpCki7t69s5w8eXqK0WYmElAAiY4lKoFoAQUQLZpo3srywbK88kqixKJGCyiAaNFE8+64/bby+NpqWf3zTCkL5fx/z+3x3/93of9u/efOZd5qxqCfPXRiW5qvQAGkOZWgBOIFFEC8qYkE0ggogDSnEpRAvIACiDc1kUAaAQWQ5lSCEogXUADxpiYSSCOgANKcSlAC8QIKIN7URAJpBBRAmlMJSiBeQAHEm5pIII2AAkhzKkEJxAsogHhTEwmkEVAAaU4lKIF4AQUQb2oigTQCCiDNqQQlEC+gAOJNTSSQRkABpDmVoATiBRRAvKmJBNIIKIA0pxKUQLyAAog3NZFAGgEFkOZUghKIF1AA8aYmEkgjoADSnEpQAvECCiDe1EQCaQQUQJpTCUogXkABxJuaSCCNgAJIcypBCcQLKIB4UxMJpBFQAGlOJSiBeAEFEG9qIoE0AgogzakEJRAvoADiTU0kkEZAAaQ5laAE4gUUQLypiQTSCCiANKcSlEC8gAKINzWRQBoBBZDmVIISiBdQAPGmJhJII6AA0pxKUALxAgog3tREAmkEFECaUwlKIF5AAcSbmkggjYACSHMqQQnECyiAeFMTCaQRUABpTiUogXgBBRBvaiKBNAIKIM2pBCUQL6AA4k1NJJBGQAGkOZWgBOIFFEC8qYkE0ggogDSnEpRAvIACiDc1kUAaAQWQ5lSCEogXUADxpiYSSCOgANKcSlAC8QIKIN7URAJpBBRAmlMJSiBeQAHEm5pIII2AAkhzKkEJxAsogHhTEwmkEVAAaU4lKIF4AQUQb2oigTQCCiDNqQQlEC/wLzkw5NMX6PehAAAAAElFTkSuQmCC",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLFramebuffer - ID: 0",
                        "id": 0,
                        "typeName": "WebGLFramebuffer"
                    }
                },
                "FrameBufferStatus": "FRAMEBUFFER_COMPLETE"
            },
            "commandArguments": [
                1,
                48,
                5123,
                0
            ],
            "commandEndTime": 1732773587552.2,
            "endTime": 1732773587611.9,
            "id": 12,
            "name": "drawElements",
            "stackTrace": [
                "WebGLIndexedBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:16593:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773587552.2,
            "status": 0,
            "text": "drawElements: LINES, 48 indices, UNSIGNED_SHORT, 0"
        },
        {
            "MipmapHintState": {
                "GENERATE_MIPMAP_HINT": 4352
            },
            "commandArguments": [
                3553
            ],
            "commandEndTime": 1732773587611.9,
            "endTime": 1732773587612.2,
            "id": 13,
            "name": "generateMipmap",
            "stackTrace": [
                "generateMipmap (https://unpkg.com/three@0.149.0/build/three.module.js:22599:7)",
                "WebGLTextures.updateRenderTargetMipmap (https://unpkg.com/three@0.149.0/build/three.module.js:24241:5)",
                "renderTransmissionPass (https://unpkg.com/three@0.149.0/build/three.module.js:28222:12)",
                "renderScene (https://unpkg.com/three@0.149.0/build/three.module.js:28161:41)"
            ],
            "startTime": 1732773587611.9,
            "status": 0,
            "text": "generateMipmap: TEXTURE_2D"
        },
        {
            "commandArguments": [
                3553,
                null
            ],
            "commandEndTime": 1732773587612.2,
            "endTime": 1732773587612.2,
            "id": 14,
            "name": "bindTexture",
            "stackTrace": [
                "Object.unbindTexture (https://unpkg.com/three@0.149.0/build/three.module.js:22111:7)",
                "WebGLTextures.updateRenderTargetMipmap (https://unpkg.com/three@0.149.0/build/three.module.js:24242:11)",
                "renderTransmissionPass (https://unpkg.com/three@0.149.0/build/three.module.js:28222:12)",
                "renderScene (https://unpkg.com/three@0.149.0/build/three.module.js:28161:41)"
            ],
            "startTime": 1732773587612.2,
            "status": 0,
            "text": "bindTexture: TEXTURE_2D, null"
        },
        {
            "commandArguments": [
                36160,
                null
            ],
            "commandEndTime": 1732773587612.2,
            "endTime": 1732773587612.3,
            "id": 15,
            "name": "bindFramebuffer",
            "stackTrace": [
                "Object.bindFramebuffer (https://unpkg.com/three@0.149.0/build/three.module.js:21610:7)",
                "WebGLRenderer.setRenderTarget (https://unpkg.com/three@0.149.0/build/three.module.js:28926:34)",
                "renderTransmissionPass (https://unpkg.com/three@0.149.0/build/three.module.js:28224:9)",
                "renderScene (https://unpkg.com/three@0.149.0/build/three.module.js:28161:41)"
            ],
            "startTime": 1732773587612.2,
            "status": 0,
            "text": "bindFramebuffer: FRAMEBUFFER, null"
        },
        {
            "commandArguments": [
                0,
                0,
                300,
                150
            ],
            "commandEndTime": 1732773587612.3,
            "consumeCommandId": 19,
            "endTime": 1732773587612.4,
            "id": 16,
            "name": "scissor",
            "stackTrace": [
                "Object.scissor (https://unpkg.com/three@0.149.0/build/three.module.js:22266:7)",
                "WebGLRenderer.setRenderTarget (https://unpkg.com/three@0.149.0/build/three.module.js:28935:9)",
                "renderTransmissionPass (https://unpkg.com/three@0.149.0/build/three.module.js:28224:9)",
                "renderScene (https://unpkg.com/three@0.149.0/build/three.module.js:28161:41)"
            ],
            "startTime": 1732773587612.3,
            "status": 20,
            "text": "scissor: 0, 0, 300, 150"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_CustomData": {
                        "length": 20849,
                        "programStatus": {
                            "LINK_STATUS": true,
                            "VALIDATE_STATUS": false
                        },
                        "shaders": [
                            {
                                "COMPILE_STATUS": true,
                                "name": "LineBasicMaterial",
                                "shaderType": "VERTEX_SHADER",
                                "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD1;\n    float3 v0 : TEXCOORD0;\n};\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _color : TEXCOORD1;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _color = input._color;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.v0 = _vColor;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                            },
                            {
                                "COMPILE_STATUS": true,
                                "name": "LineBasicMaterial",
                                "shaderType": "FRAGMENT_SHADER",
                                "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD1;\n    float3 v0 : TEXCOORD0;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input){\n    _vColor = input.v0.xyz;\n\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                            }
                        ]
                    },
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLProgram - ID: 0",
                        "id": 0,
                        "typeName": "WebGLProgram"
                    }
                }
            ],
            "commandEndTime": 1732773587612.4,
            "endTime": 1732773587612.5,
            "id": 17,
            "name": "useProgram",
            "stackTrace": [
                "Object.useProgram (https://unpkg.com/three@0.149.0/build/three.module.js:21720:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28554:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587612.4,
            "status": 0,
            "text": "useProgram: WebGLProgram - ID: 0"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 0",
                        "id": 0,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773587612.6,
            "endTime": 1732773587612.6,
            "id": 18,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587612.6,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 0"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 72,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 0",
                                "id": 0,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 72,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 72,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 1",
                                "id": 1,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 72,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 3,
                        "name": "color",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "frameBuffer": null,
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 20849,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "LineBasicMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD1;\n    float3 v0 : TEXCOORD0;\n};\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _color : TEXCOORD1;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _color = input._color;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.v0 = _vColor;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "LineBasicMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD1;\n    float3 v0 : TEXCOORD0;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input){\n    _vColor = input.v0.xyz;\n\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 0",
                            "id": 0,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "LineBasicMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD1;\n    float3 v0 : TEXCOORD0;\n};\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _color : TEXCOORD1;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _color = input._color;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.v0 = _vColor;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "LineBasicMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD1;\n    float3 v0 : TEXCOORD0;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input){\n    _vColor = input.v0.xyz;\n\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 248",
                                "id": 248,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.999994158744812,
                            -0.00003970626858063042,
                            0.0034170825965702534,
                            0,
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598,
                            0,
                            -0.0034173133317381144,
                            -0.011619079858064651,
                            0.9999266862869263,
                            0,
                            -3.0878077872387166e-15,
                            0,
                            -15001.1005859375,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 249",
                                "id": 249,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0007603672565892339,
                            0,
                            0,
                            0,
                            0,
                            0.0015251043951138854,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 250",
                                "id": 250,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "diffuse",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            1,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 251",
                                "id": 251,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "opacity",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    300,
                    150
                ],
                "SCISSOR_TEST": false,
                "disabledCommandIds": [
                    16
                ]
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "8",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "Canvas COLOR_ATTACHMENT",
                        "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAAA+lJREFUeF7t1DFKQ1EUBND/awU79+oKXFTWZWGlxGCdFCMyzAmIKcLl3jOPOZ9fXr8OHwIEJgVOBTCZu6MJ/AgoAA+BwLCAAhgO3+kEFIA3QGBYQAEMh+90AgrAGyAwLKAAhsN3OgEF4A0QGBZQAMPhO52AAvAGCAwLKIDh8J1OQAF4AwSGBRTAcPhOJ6AAvAECwwIKYDh8pxNQAN4AgWEBBTAcvtMJKABvgMCwgAIYDt/pBBSAN0BgWEABDIfvdAIKwBsgMCygAIbDdzoBBeANEBgWUADD4TudgALwBggMCyiA4fCdTkABeAMEhgUUwHD4TiegALwBAsMCCmA4fKcTUADeAIFhAQUwHL7TCSgAb4DAsIACGA7f6QQUgDdAYFhAAQyH73QCCsAbIDAsoACGw3c6AQXgDRAYFlAAw+E7nYAC8AYIDAsogOHwnU5AAXgDBIYFFMBw+E4noAC8AQLDAgpgOHynE1AA3gCBYQEFMBy+0wkoAG+AwLCAAhgO3+kEFIA3QGBYQAEMh+90AgrAGyAwLKAAhsN3OgEF4A0QGBZQAMPhO52AAvAGCAwLKIDh8J1OQAF4AwSGBRTAcPhOJ6AAvAECwwIKYDj86+lvnx/HcR63v+vn9/u9/3/x20dn/tfvHjR6vzzVvCoFUBOVRQnkBRRA3tREAjUCCqAmKosSyAsogLypiQRqBBRATVQWJZAXUAB5UxMJ1AgogJqoLEogL6AA8qYmEqgRUAA1UVmUQF5AAeRNTSRQI6AAaqKyKIG8gALIm5pIoEZAAdREZVECeQEFkDc1kUCNgAKoicqiBPICCiBvaiKBGgEFUBOVRQnkBRRA3tREAjUCCqAmKosSyAsogLypiQRqBBRATVQWJZAXUAB5UxMJ1AgogJqoLEogL6AA8qYmEqgRUAA1UVmUQF5AAeRNTSRQI6AAaqKyKIG8gALIm5pIoEZAAdREZVECeQEFkDc1kUCNgAKoicqiBPICCiBvaiKBGgEFUBOVRQnkBRRA3tREAjUCCqAmKosSyAsogLypiQRqBBRATVQWJZAXUAB5UxMJ1AgogJqoLEogL6AA8qYmEqgRUAA1UVmUQF5AAeRNTSRQI6AAaqKyKIG8gALIm5pIoEZAAdREZVECeQEFkDc1kUCNgAKoicqiBPICCiBvaiKBGgEFUBOVRQnkBRRA3tREAjUCCqAmKosSyAsogLypiQRqBBRATVQWJZAXUAB5UxMJ1AgogJqoLEogL6AA8qYmEqgRUAA1UVmUQF5AAeRNTSRQI6AAaqKyKIG8gALIm5pIoEZAAdREZVECeQEFkDc1kUCNgAKoicqiBPIC38dfm1B9N6RQAAAAAElFTkSuQmCC",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": null
            },
            "commandArguments": [
                1,
                0,
                6
            ],
            "commandEndTime": 1732773587612.6,
            "endTime": 1732773587631.3,
            "id": 19,
            "name": "drawArrays",
            "stackTrace": [
                "WebGLBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:14729:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773587612.6,
            "status": 0,
            "text": "drawArrays: LINES, 0 indices, 6"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_CustomData": {
                        "length": 20813,
                        "programStatus": {
                            "LINK_STATUS": true,
                            "VALIDATE_STATUS": false
                        },
                        "shaders": [
                            {
                                "COMPILE_STATUS": true,
                                "name": "LineBasicMaterial",
                                "shaderType": "VERTEX_SHADER",
                                "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _transformed2614 = vec3_ctor(_position);\nfloat4 _mvPosition2615 = vec4_ctor(_transformed2614, 1.0);\n(_mvPosition2615 = mul(transpose(_modelViewMatrix), _mvPosition2615));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2615));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                            },
                            {
                                "COMPILE_STATUS": true,
                                "name": "LineBasicMaterial",
                                "shaderType": "FRAGMENT_SHADER",
                                "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2617 = vec4_ctor(_diffuse, _opacity);\nfloat _specularStrength2618 = {0};\n(_specularStrength2618 = 1.0);\n_ReflectedLight _reflectedLight2619 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2619._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2619._indirectDiffuse *= _diffuseColor2617.xyz);\nfloat3 _outgoingLight2620 = _reflectedLight2619._indirectDiffuse;\n(_diffuseColor2617.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2620, _diffuseColor2617.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                            }
                        ]
                    },
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLProgram - ID: 1",
                        "id": 1,
                        "typeName": "WebGLProgram"
                    }
                }
            ],
            "commandEndTime": 1732773587631.3,
            "endTime": 1732773587635.2,
            "id": 20,
            "name": "useProgram",
            "stackTrace": [
                "Object.useProgram (https://unpkg.com/three@0.149.0/build/three.module.js:21720:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28554:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587631.3,
            "status": 0,
            "text": "useProgram: WebGLProgram - ID: 1"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 1",
                        "id": 1,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773587635.2,
            "endTime": 1732773587635.4,
            "id": 21,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587635.2,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 1"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 24,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 2",
                                "id": 2,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 24,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "frameBuffer": null,
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 20813,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "LineBasicMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _transformed2614 = vec3_ctor(_position);\nfloat4 _mvPosition2615 = vec4_ctor(_transformed2614, 1.0);\n(_mvPosition2615 = mul(transpose(_modelViewMatrix), _mvPosition2615));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2615));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "LineBasicMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2617 = vec4_ctor(_diffuse, _opacity);\nfloat _specularStrength2618 = {0};\n(_specularStrength2618 = 1.0);\n_ReflectedLight _reflectedLight2619 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2619._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2619._indirectDiffuse *= _diffuseColor2617.xyz);\nfloat3 _outgoingLight2620 = _reflectedLight2619._indirectDiffuse;\n(_diffuseColor2617.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2620, _diffuseColor2617.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 1",
                            "id": 1,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "LineBasicMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\n#define VERTEX_TEXTURES\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _transformed2614 = vec3_ctor(_position);\nfloat4 _mvPosition2615 = vec4_ctor(_transformed2614, 1.0);\n(_mvPosition2615 = mul(transpose(_modelViewMatrix), _mvPosition2615));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2615));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "LineBasicMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME LineBasicMaterial\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2617 = vec4_ctor(_diffuse, _opacity);\nfloat _specularStrength2618 = {0};\n(_specularStrength2618 = 1.0);\n_ReflectedLight _reflectedLight2619 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2619._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2619._indirectDiffuse *= _diffuseColor2617.xyz);\nfloat3 _outgoingLight2620 = _reflectedLight2619._indirectDiffuse;\n(_diffuseColor2617.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2620, _diffuseColor2617.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 252",
                                "id": 252,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.5351841449737549,
                            0.009815105237066746,
                            -0.8446784019470215,
                            0,
                            0.7206006646156311,
                            0.5164910554885864,
                            0.4625706970691681,
                            0,
                            1510.9722900390625,
                            -2934.94287109375,
                            923.2409057617188,
                            0,
                            -1510.9722900390625,
                            2934.94287109375,
                            -15924.3408203125,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 253",
                                "id": 253,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0007603672565892339,
                            0,
                            0,
                            0,
                            0,
                            0.0015251043951138854,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 254",
                                "id": 254,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "diffuse",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            1,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 255",
                                "id": 255,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "opacity",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    300,
                    150
                ],
                "SCISSOR_TEST": false
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "8",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "Canvas COLOR_ATTACHMENT",
                        "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAABbRJREFUeF7t2DuIXVUUBuA90ypoGolNRBARnwEzWolEtBJDCIpYio2NaJQEX+AIvkjQKDY2YimihBCxihjESidCfCIiiGlMFxsLm1GCTCGITg7rzD3/Pt9ASIq711n7+w8/N7N08SWX/dn8LETgyYNPtFcOvbqQZ3sogfMCSwrAi0BgvgIKYMHZH/3g3bbv3gcWvIXHz1VAAcw1efcm4L8A03gHfvzhq3b1NTdNYxlbzErAN4BZxe2yBP4poAAm8kb8/NP37cqrrp3INtaYi4ACmEvS7kngXwQUwIRei+PH3m979t43oY2s0ruAAug9Yfcj8B8CCmBir8dLL6y2p59dndhW1ulVQAH0mqx7EdiEgALYBNJWf2TPPXe34x9+tNWP9bwZCiiAGYbuygQ2BBTARN+FG66/rn3z7XcT3c5avQgogF6SdA8CAwQUwAA0Rwj0IqAAeknSPQgMEFAAA9AcIdCLgALoJUn3IDBAQAEMQHOEQC8CCqCXJN2DwAABBTAAzRECvQgogF6SdA8CAwQUwAA0Rwj0IqAAeknSPQgMEFAAA9AcIdCLgAIITPLy7dvbr2fPBm5u5akJKICpJWIfAlsooAC2ELvyUXfdeUc78fEnlSPNmqGAAphh6K5MYENAAQS/CwcP7G+HDh8JvoHVFy2gABadgOcTWKCAAlggfsWj33n7rfbgQw9XjDJjhgIKYIahuzIBvwPo6B1Y+/yztnLrbR3dyFW2SsA3gK2S9hwCExRQABMMZchKbxw53B7df2DIUWdmLKAAZhy+qxNQAB29A8eOvtf27ru/oxu5ytgCCmBsYfMJTFhAAUw4nCGrXbFjR/vlzJkhR52ZoYACmGHorkxgQ0ABdPgurOy6ua2d+rLDm7lStYACqBY1j0CQgAIICutCVt2588Z2+vTXF3LEZ2cooABmGLorE/A7gBm8A8vLy219fX0GN3XFoQK+AQyVc45ABwIKoIMQXYHAUAEFMFTOOQIdCCiADkJ0BQJDBRTAULmwc9u2XdrOnfstbGvrji2gAMYWNp/AhAUUwITDsRqBsQUUwNjC5hOYsIACmHA4Y6z2+GOPtNdef3OM0WYGCiiAwNCsTKBKQAFUSQbN2b379nby5KdBG1t1LAEFMJasuQQCBBRAQEhjrHjLyq72xdqpMUabGSSgAILCsiqBagEFUC0aNG/1uWfa6vMvBm1s1WoBBVAtGjbvqT9+b22p/f3n/M/Gv//v7zE+u9mZi/rcJo1ePnFRzFugAGKisiiBegEFUG9qIoEYAQUQE5VFCdQLKIB6UxMJxAgogJioLEqgXkAB1JuaSCBGQAHERGVRAvUCCqDe1EQCMQIKICYqixKoF1AA9aYmEogRUAAxUVmUQL2AAqg3NZFAjIACiInKogTqBRRAvamJBGIEFEBMVBYlUC+gAOpNTSQQI6AAYqKyKIF6AQVQb2oigRgBBRATlUUJ1AsogHpTEwnECCiAmKgsSqBeQAHUm5pIIEZAAcREZVEC9QIKoN7URAIxAgogJiqLEqgXUAD1piYSiBFQADFRWZRAvYACqDc1kUCMgAKIicqiBOoFFEC9qYkEYgQUQExUFiVQL6AA6k1NJBAjoABiorIogXoBBVBvaiKBGAEFEBOVRQnUCyiAelMTCcQIKICYqCxKoF5AAdSbmkggRkABxERlUQL1Agqg3tREAjECCiAmKosSqBdQAPWmJhKIEVAAMVFZlEC9gAKoNzWRQIyAAoiJyqIE6gUUQL2piQRiBBRATFQWJVAvoADqTU0kECOgAGKisiiBegEFUG9qIoEYAQUQE5VFCdQLKIB6UxMJxAgogJioLEqgXkAB1JuaSCBGQAHERGVRAvUCCqDe1EQCMQIKICYqixKoF1AA9aYmEogRUAAxUVmUQL2AAqg3NZFAjIACiInKogTqBRRAvamJBGIEFEBMVBYlUC/wF8qo41AyxaDvAAAAAElFTkSuQmCC",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": null
            },
            "commandArguments": [
                3,
                0,
                2
            ],
            "commandEndTime": 1732773587635.4,
            "endTime": 1732773587656.8,
            "id": 22,
            "name": "drawArrays",
            "stackTrace": [
                "WebGLBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:14729:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773587635.4,
            "status": 0,
            "text": "drawArrays: LINE_STRIP, 0 indices, 2"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_CustomData": {
                        "length": 20849,
                        "programStatus": {
                            "LINK_STATUS": true,
                            "VALIDATE_STATUS": false
                        },
                        "shaders": [
                            {
                                "COMPILE_STATUS": true,
                                "name": "MeshBasicMaterial",
                                "shaderType": "VERTEX_SHADER",
                                "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                            },
                            {
                                "COMPILE_STATUS": true,
                                "name": "MeshBasicMaterial",
                                "shaderType": "FRAGMENT_SHADER",
                                "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                            }
                        ]
                    },
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLProgram - ID: 2",
                        "id": 2,
                        "typeName": "WebGLProgram"
                    }
                }
            ],
            "commandEndTime": 1732773587656.8,
            "endTime": 1732773587657.2,
            "id": 23,
            "name": "useProgram",
            "stackTrace": [
                "Object.useProgram (https://unpkg.com/three@0.149.0/build/three.module.js:21720:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28554:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587656.8,
            "status": 0,
            "text": "useProgram: WebGLProgram - ID: 2"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 2",
                        "id": 2,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773587657.2,
            "endTime": 1732773587657.3,
            "id": 24,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587657.2,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 2"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 288,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 3",
                                "id": 3,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 288,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 288,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 6",
                                "id": 6,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 288,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 3,
                        "name": "color",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "elementArray": {
                    "arrayBuffer": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 96,
                            "target": "ELEMENT_ARRAY_BUFFER",
                            "usage": 35044
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLBuffer - ID: 13",
                            "id": 13,
                            "typeName": "WebGLBuffer"
                        }
                    }
                },
                "frameBuffer": null,
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 20849,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "MeshBasicMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "MeshBasicMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 2",
                            "id": 2,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "MeshBasicMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define VERTEX_TEXTURES\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif\n#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvoid main() {\n#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t#endif\nvec3 transformed = vec3( position );\n#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelViewMatrix : register(c0);\nuniform float4x4 _projectionMatrix : register(c4);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _color = {0, 0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\n(_vColor = float3(1.0, 1.0, 1.0));\n(_vColor *= _color);\nfloat3 _transformed2616 = vec3_ctor(_position);\nfloat4 _mvPosition2617 = vec4_ctor(_transformed2616, 1.0);\n(_mvPosition2617 = mul(transpose(_modelViewMatrix), _mvPosition2617));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2617));\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "MeshBasicMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME MeshBasicMaterial\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\nvoid main() {\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float3 _diffuse : register(c0);\nuniform float _opacity : register(c1);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vColor = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    uint dx_Misc : packoffset(c2.w);\n};\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\n;\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat4 _diffuseColor2618 = vec4_ctor(_diffuse, _opacity);\n(_diffuseColor2618.xyz *= _vColor);\nfloat _specularStrength2619 = {0};\n(_specularStrength2619 = 1.0);\n_ReflectedLight _reflectedLight2620 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n(_reflectedLight2620._indirectDiffuse += float3(1.0, 1.0, 1.0));\n(_reflectedLight2620._indirectDiffuse *= _diffuseColor2618.xyz);\nfloat3 _outgoingLight2621 = _reflectedLight2620._indirectDiffuse;\n(_diffuseColor2618.w = 1.0);\n(out_pc_fragColor = vec4_ctor(_outgoingLight2621, _diffuseColor2618.w));\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 256",
                                "id": 256,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.999994158744812,
                            -0.00003970626858063042,
                            0.0034170825965702534,
                            0,
                            -0.0034173133317381144,
                            -0.011519086547195911,
                            0.999927818775177,
                            0,
                            -3.417313223508245e-7,
                            -0.999933660030365,
                            -0.011519155465066433,
                            0,
                            -3.0878010109751386e-15,
                            0.9999324679374695,
                            -15001.0888671875,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 257",
                                "id": 257,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0007603672565892339,
                            0,
                            0,
                            0,
                            0,
                            0.0015251043951138854,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 258",
                                "id": 258,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "diffuse",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            1,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 259",
                                "id": 259,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "opacity",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    300,
                    150
                ],
                "SCISSOR_TEST": false
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "8",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "Canvas COLOR_ATTACHMENT",
                        "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAABb9JREFUeF7t2M2rlVUUB+B9nRaUk7CJEUREn0LeiiLCqFEkIkU0lCZNoiyUqKAb9IVSFk2aRMOIQsRoZCTRqK6BfRKRmE5yZn/BLS50B0HIuZv1nrPX3o8gTs67zlrP7+XH9S5dfsVVfxd/FiLw/MHnypuH3lrId/tSAusCSwrAi0BgXAEFsODsj376Udn7yOML3sLXjyqgAEZN3t0E/BegjXfgt1+/L9ffcFsby9hiKAE/AQwVt2MJ/FdAATTyRpz9/Zdy7XU3NrKNNUYRUACjJO1OAv8joAAaei2OH/uk7N7zaEMbWaV3AQXQe8LuI3AJAQXQ2Ovx+qsr5YWXVhrbyjq9CiiAXpN1F4EZBBTADEjz/sjuhx8qxz/7fN5f6/sGFFAAA4buZAIbAgqg0XfhlptvKj/+9HOj21mrFwEF0EuS7iBQIaAAKtA8QqAXAQXQS5LuIFAhoAAq0DxCoBcBBdBLku4gUCGgACrQPEKgFwEF0EuS7iBQIaAAKtA8QqAXAQXQS5LuIFAhoAAq0DxCoBcBBdBLku4gUCGgACrQPEKgFwEFkDDJq7dtK39euJBwcyu3JqAAWkvEPgTmKKAA5ogd+VUPPnB/OfHFl5EjzRpQQAEMGLqTCWwIKIDE78LBA/vLocNHEl9g9UULKIBFJ+D7CSxQQAEsED/iqz/84P2y74knI0aZMaCAAhgwdCcT8DuAjt6B1W++Lst33tvRRU6Zl4CfAOYl7XsINCigABoMpWald48cLk/vP1DzqGcGFlAAA4fvdAIKoKN34NjRj8uevY91dJFTphZQAFMLm0+gYQEF0HA4Natds317OXf+fM2jnhlQQAEMGLqTCWwIKIAO34XlnbeX1VPfdXiZk6IFFEC0qHkEEgkogERhbWbVHTtuLadP/7CZR3x2QAEFMGDoTibgdwADvANbtmwpa2trA1zqxFoBPwHUynmOQAcCCqCDEJ1AoFZAAdTKeY5ABwIKoIMQnUCgVkAB1Mole27r1ivLxYt/JdvaulMLKICphc0n0LCAAmg4HKsRmFpAAUwtbD6BhgUUQMPhTLHas888Vd5+570pRpuZUEABJAzNygSiBBRAlGSiObt23VdOnvwq0cZWnUpAAUwlay6BBAIKIEFIU6x4x/LO8u3qqSlGm5lIQAEkCsuqBKIFFEC0aKJ5Ky+/WFZeeS3RxlaNFlAA0aKJ5t1z911l37kz5czZP0pZ+nfx9X9n+bv+8Vk+t5m5s85c1OdmvOWNE5eleQsUQJqoLEogXkABxJuaSCCNgAJIE5VFCcQLKIB4UxMJpBFQAGmisiiBeAEFEG9qIoE0AgogTVQWJRAvoADiTU0kkEZAAaSJyqIE4gUUQLypiQTSCCiANFFZlEC8gAKINzWRQBoBBZAmKosSiBdQAPGmJhJII6AA0kRlUQLxAgog3tREAmkEFECaqCxKIF5AAcSbmkggjYACSBOVRQnECyiAeFMTCaQRUABporIogXgBBRBvaiKBNAIKIE1UFiUQL6AA4k1NJJBGQAGkicqiBOIFFEC8qYkE0ggogDRRWZRAvIACiDc1kUAaAQWQJiqLEogXUADxpiYSSCOgANJEZVEC8QIKIN7URAJpBBRAmqgsSiBeQAHEm5pIII2AAkgTlUUJxAsogHhTEwmkEVAAaaKyKIF4AQUQb2oigTQCCiBNVBYlEC+gAOJNTSSQRkABpInKogTiBRRAvKmJBNIIKIA0UVmUQLyAAog3NZFAGgEFkCYqixKIF1AA8aYmEkgjoADSRGVRAvECCiDe1EQCaQQUQJqoLEogXkABxJuaSCCNgAJIE5VFCcQLKIB4UxMJpBFQAGmisiiBeAEFEG9qIoE0AgogTVQWJRAvoADiTU0kkEZAAaSJyqIE4gUUQLypiQTSCCiANFFZlEC8gAKINzWRQBoBBZAmKosSiBdQAPGmJhJII6AA0kRlUQLxAv8AqaXmUBPuIaAAAAAASUVORK5CYII=",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": null
            },
            "commandArguments": [
                1,
                48,
                5123,
                0
            ],
            "commandEndTime": 1732773587657.3,
            "endTime": 1732773587682.4,
            "id": 25,
            "name": "drawElements",
            "stackTrace": [
                "WebGLIndexedBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:16593:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773587657.3,
            "status": 0,
            "text": "drawElements: LINES, 48 indices, UNSIGNED_SHORT, 0"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_CustomData": {
                        "length": 73183,
                        "programStatus": {
                            "LINK_STATUS": true,
                            "VALIDATE_STATUS": false
                        },
                        "shaders": [
                            {
                                "COMPILE_STATUS": true,
                                "name": "NodeMaterial",
                                "shaderType": "VERTEX_SHADER",
                                "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define LAMBERT 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS 4\n#define g99edc2ad720a4c61ab1a28da5fd57214_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define VERTEX_TEXTURES\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat neighbor_offset = 0.0001;\n\nuniform int frameIndex;\nuniform vec2 resolution;\nuniform mat4 previousModelViewMatrix;\nuniform mat4 previousProjectionMatrix;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifndef DOUBLE_SIDED\n   #define DOUBLE_SIDED\n#endif\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\n\n\n\n\n\nvoid main() {\n\n\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec3 displaced_position = position;\n\t\t\t\tvec3 displaced_normal = normal;\n\n\t\t\t\t#ifdef USE_LAYER_DISPLACE\n\t\t\t\t\tvec3 transformed;\n\t\t\t\t\tvec3 transformedNormal;\n\t\t\t\t#endif\n\t\t\t\t\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\nvec3 transformed = vec3( position );\n\t\t\t\t#endif\n\t\t\t\t\ntransformed = displaced_position;\ntransformedNormal = normalMatrix * displaced_normal;\n#ifndef FLAT_SHADED\n    vNormal = transformedNormal;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n\n\t\t\t\t\tvec3 diffuse = vec3( 1.0 );\n\t\t\t\t\tGeometricContext geometry;\n\t\t\t\t\tgeometry.position = mvPosition.xyz;\n\t\t\t\t\tgeometry.normal = normalize( transformedNormal );\n\t\t\t\t\tgeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\t\t\t\t\n\n\t\t\t\t\tGeometricContext backGeometry;\n\t\t\t\t\tbackGeometry.position = geometry.position;\n\t\t\t\t\tbackGeometry.normal = -geometry.normal;\n\t\t\t\t\tbackGeometry.viewDir = geometry.viewDir;\n\t\t\t\t\tvLightFront = vec3( 0.0 );\n\t\t\t\t\tvIndirectFront = vec3( 0.0 );\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\tvLightBack = vec3( 0.0 );\n\t\t\t\t\t\tvIndirectBack = vec3( 0.0 );\n\t\t\t\t\t#endif\n\t\t\t\t\tIncidentLight directLight;\n\t\t\t\t\tfloat dotNL;\n\t\t\t\t\tvec3 directLightColor_Diffuse;\n\t\t\t\t\tvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\t\t\t\t\tvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\t\t\t\t\t\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n\t\t\t\t\t#endif\n\t\t\t\t\t#if 0 > 0\n\t\t\t\t\t\t\n\t\t\t\t\t#endif\n\t\t\t\t\t#if 0 > 0\n\t\t\t\t\t\t\n\t\t\t\t\t#endif\n\t\t\t\t\t#if 1 > 0\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tgetDirectionalLightInfo( directionalLights[ 0 ], geometry, directLight );\n\t\t\t\t\t\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\t\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\t\t\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\n\t\t\t\t\t#endif\n\t\t\t\t\t#if 1 > 0\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ 0 ], backGeometry.normal );\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\n\t\t\t\t\t#endif\n\t\t\t\t\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\nvWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;\nvUv = uv;\nvPosition = transformed;\nvWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;\nvWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );\n\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_2;\n    float3 _normal;\n    float pad_3;\n    float3 _viewDir;\n    float pad_4;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_5;\n    float3 _normal;\n    float pad_6;\n    float3 _viewDir;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_8;\n    float3 _color;\n    float pad_9;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_10;\n    float3 _color;\n    float pad_11;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_12;\n    float3 _skyColor;\n    float pad_13;\n    float3 _groundColor;\n    float pad_14;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_15;\n    float3 _skyColor;\n    float pad_16;\n    float3 _groundColor;\n    float pad_17;\n};\n#pragma pack_matrix(column_major)\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\nuniform bool _isOrthographic : register(c20);\nuniform float3 _ambientLightColor : register(c21);\nuniform float3 _lightProbe[9] : register(c22);\nuniform _DirectionalLight _directionalLights[1] : register(c31);\nuniform _HemisphereLight _hemisphereLights[1] : register(c33);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vLightFront = {0, 0, 0};\nstatic  float3 _vIndirectFront = {0, 0, 0};\nstatic  float3 _vLightBack = {0, 0, 0};\nstatic  float3 _vIndirectBack = {0, 0, 0};\nstatic  float3 _vColor = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2794 = _normal.x;\nfloat _y2795 = _normal.y;\nfloat _z2796 = _normal.z;\nfloat3 _result2797 = (_shCoefficients[0] * 0.88622701);\n(_result2797 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2795));\n(_result2797 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2796));\n(_result2797 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2794));\n(_result2797 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2794) * _y2795));\n(_result2797 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2795) * _z2796));\n(_result2797 += (_shCoefficients[6] * (((0.74312502 * _z2796) * _z2796) - 0.24770799)));\n(_result2797 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2794) * _z2796));\n(_result2797 += ((_shCoefficients[8] * 0.42904299) * ((_x2794 * _x2794) - (_y2795 * _y2795))));\nreturn _result2797;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2801 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2802 = f_shGetIrradianceAt(_worldNormal2801, _lightProbe);\nreturn _irradiance2802;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2805 = _ambientLightColor;\nreturn _irradiance2805;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2827 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2828 = ((0.5 * _dotNL2827) + 0.5);\nfloat3 _irradiance2829 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2828);\nreturn _irradiance2829;\n}\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2837 = vec3_ctor(_normal);\nfloat3 _transformedNormal2838 = _objectNormal2837;\n(_transformedNormal2838 = mul(transpose(_normalMatrix), _transformedNormal2838));\nfloat3 _displaced_position2839 = _position;\nfloat3 _displaced_normal2840 = _normal;\n(_vNormal = normalize(_transformedNormal2838));\nfloat3 _transformed2841 = vec3_ctor(_position);\n(_transformed2841 = _displaced_position2839);\n(_transformedNormal2838 = mul(transpose(_normalMatrix), _displaced_normal2840));\n(_vNormal = _transformedNormal2838);\nfloat4 _mvPosition2842 = vec4_ctor(_transformed2841, 1.0);\n(_mvPosition2842 = mul(transpose(_modelViewMatrix), _mvPosition2842));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2842));\n(_vViewPosition = (-_mvPosition2842.xyz));\nfloat4 _worldPosition2843 = vec4_ctor(_transformed2841, 1.0);\n(_worldPosition2843 = mul(transpose(_modelMatrix), _worldPosition2843));\n_GeometricContext _geometry2845 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry2845._position = _mvPosition2842.xyz);\n(_geometry2845._normal = normalize(_transformedNormal2838));\nfloat3 sb22 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sb22 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sb22 = normalize((-_mvPosition2842.xyz)));\n}\n(_geometry2845._viewDir = sb22);\n_GeometricContext _backGeometry2846 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_backGeometry2846._position = _geometry2845._position);\n(_backGeometry2846._normal = (-_geometry2845._normal));\n(_backGeometry2846._viewDir = _geometry2845._viewDir);\n(_vLightFront = float3(0.0, 0.0, 0.0));\n(_vIndirectFront = float3(0.0, 0.0, 0.0));\n(_vLightBack = float3(0.0, 0.0, 0.0));\n(_vIndirectBack = float3(0.0, 0.0, 0.0));\n_IncidentLight _directLight2847 = {0, 0, 0, 0, 0, 0, 0};\nfloat _dotNL2848 = {0};\nfloat3 _directLightColor_Diffuse2849 = {0, 0, 0};\n(_vIndirectFront += f_getAmbientLightIrradiance(_ambientLightColor));\n(_vIndirectFront += f_getLightProbeIrradiance(_lightProbe, _geometry2845._normal));\n(_vIndirectBack += f_getAmbientLightIrradiance(_ambientLightColor));\n(_vIndirectBack += f_getLightProbeIrradiance(_lightProbe, _backGeometry2846._normal));\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLights[0], _geometry2845, _directLight2847);\n(_dotNL2848 = dot(_geometry2845._normal, _directLight2847._direction));\n(_directLightColor_Diffuse2849 = _directLight2847._color);\n(_vLightFront += (clamp(_dotNL2848, 0.0, 1.0) * _directLightColor_Diffuse2849));\n(_vLightBack += (clamp((-_dotNL2848), 0.0, 1.0) * _directLightColor_Diffuse2849));\n(_vIndirectFront += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry2845._normal));\n(_vIndirectBack += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _backGeometry2846._normal));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2841, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2841);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2838, _viewMatrix).xyz);\nfloat3 sb23 = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sb23 = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sb23 = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sb23);\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD10;\n    float4 gl_FragCoord : TEXCOORD11;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n    float3 v6 : TEXCOORD6;\n    float3 v7 : TEXCOORD7;\n    float3 v8 : TEXCOORD8;\n    float3 v9 : TEXCOORD9;\n};\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_2;\n    float3 _normal;\n    float pad_3;\n    float3 _viewDir;\n    float pad_4;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_5;\n    float3 _normal;\n    float pad_6;\n    float3 _viewDir;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_8;\n    float3 _color;\n    float pad_9;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_10;\n    float3 _color;\n    float pad_11;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_12;\n    float3 _skyColor;\n    float pad_13;\n    float3 _groundColor;\n    float pad_14;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_15;\n    float3 _skyColor;\n    float pad_16;\n    float3 _groundColor;\n    float pad_17;\n};\n#pragma pack_matrix(column_major)\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\nuniform bool _isOrthographic : register(c20);\nuniform float3 _ambientLightColor : register(c21);\nuniform float3 _lightProbe[9] : register(c22);\nuniform _DirectionalLight _directionalLights[1] : register(c31);\nuniform _HemisphereLight _hemisphereLights[1] : register(c33);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vLightFront = {0, 0, 0};\nstatic  float3 _vIndirectFront = {0, 0, 0};\nstatic  float3 _vLightBack = {0, 0, 0};\nstatic  float3 _vIndirectBack = {0, 0, 0};\nstatic  float3 _vColor = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2794 = _normal.x;\nfloat _y2795 = _normal.y;\nfloat _z2796 = _normal.z;\nfloat3 _result2797 = (_shCoefficients[0] * 0.88622701);\n(_result2797 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2795));\n(_result2797 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2796));\n(_result2797 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2794));\n(_result2797 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2794) * _y2795));\n(_result2797 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2795) * _z2796));\n(_result2797 += (_shCoefficients[6] * (((0.74312502 * _z2796) * _z2796) - 0.24770799)));\n(_result2797 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2794) * _z2796));\n(_result2797 += ((_shCoefficients[8] * 0.42904299) * ((_x2794 * _x2794) - (_y2795 * _y2795))));\nreturn _result2797;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2801 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2802 = f_shGetIrradianceAt(_worldNormal2801, _lightProbe);\nreturn _irradiance2802;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2805 = _ambientLightColor;\nreturn _irradiance2805;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2827 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2828 = ((0.5 * _dotNL2827) + 0.5);\nfloat3 _irradiance2829 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2828);\nreturn _irradiance2829;\n}\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _normal : TEXCOORD1;\n    float2 _uv : TEXCOORD2;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _normal = input._normal;\n    _uv = input._uv;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.gl_FragCoord = gl_Position;\n    output.v0 = _vViewPosition;\n    output.v1 = _vWPosition;\n    output.v2 = _vLightFront;\n    output.v3 = _vIndirectFront;\n    output.v4 = _vLightBack;\n    output.v5 = _vIndirectBack;\n    output.v6 = _vNormal;\n    output.v7 = _vPosition;\n    output.v8 = _vWNormal;\n    output.v9 = _vWorldViewDir;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2837 = vec3_ctor(_normal);\nfloat3 _transformedNormal2838 = _objectNormal2837;\n(_transformedNormal2838 = mul(transpose(_normalMatrix), _transformedNormal2838));\nfloat3 _displaced_position2839 = _position;\nfloat3 _displaced_normal2840 = _normal;\n(_vNormal = normalize(_transformedNormal2838));\nfloat3 _transformed2841 = vec3_ctor(_position);\n(_transformed2841 = _displaced_position2839);\n(_transformedNormal2838 = mul(transpose(_normalMatrix), _displaced_normal2840));\n(_vNormal = _transformedNormal2838);\nfloat4 _mvPosition2842 = vec4_ctor(_transformed2841, 1.0);\n(_mvPosition2842 = mul(transpose(_modelViewMatrix), _mvPosition2842));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2842));\n(_vViewPosition = (-_mvPosition2842.xyz));\nfloat4 _worldPosition2843 = vec4_ctor(_transformed2841, 1.0);\n(_worldPosition2843 = mul(transpose(_modelMatrix), _worldPosition2843));\n_GeometricContext _geometry2845 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry2845._position = _mvPosition2842.xyz);\n(_geometry2845._normal = normalize(_transformedNormal2838));\nfloat3 sb22 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sb22 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sb22 = normalize((-_mvPosition2842.xyz)));\n}\n(_geometry2845._viewDir = sb22);\n_GeometricContext _backGeometry2846 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_backGeometry2846._position = _geometry2845._position);\n(_backGeometry2846._normal = (-_geometry2845._normal));\n(_backGeometry2846._viewDir = _geometry2845._viewDir);\n(_vLightFront = float3(0.0, 0.0, 0.0));\n(_vIndirectFront = float3(0.0, 0.0, 0.0));\n(_vLightBack = float3(0.0, 0.0, 0.0));\n(_vIndirectBack = float3(0.0, 0.0, 0.0));\n_IncidentLight _directLight2847 = {0, 0, 0, 0, 0, 0, 0};\nfloat _dotNL2848 = {0};\nfloat3 _directLightColor_Diffuse2849 = {0, 0, 0};\n(_vIndirectFront += f_getAmbientLightIrradiance(_ambientLightColor));\n(_vIndirectFront += f_getLightProbeIrradiance(_lightProbe, _geometry2845._normal));\n(_vIndirectBack += f_getAmbientLightIrradiance(_ambientLightColor));\n(_vIndirectBack += f_getLightProbeIrradiance(_lightProbe, _backGeometry2846._normal));\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLights[0], _geometry2845, _directLight2847);\n(_dotNL2848 = dot(_geometry2845._normal, _directLight2847._direction));\n(_directLightColor_Diffuse2849 = _directLight2847._color);\n(_vLightFront += (clamp(_dotNL2848, 0.0, 1.0) * _directLightColor_Diffuse2849));\n(_vLightBack += (clamp((-_dotNL2848), 0.0, 1.0) * _directLightColor_Diffuse2849));\n(_vIndirectFront += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry2845._normal));\n(_vIndirectBack += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _backGeometry2846._normal));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2841, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2841);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2838, _viewMatrix).xyz);\nfloat3 sb23 = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sb23 = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sb23 = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sb23);\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                            },
                            {
                                "COMPILE_STATUS": true,
                                "name": "NodeMaterial",
                                "shaderType": "FRAGMENT_SHADER",
                                "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define LAMBERT 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS 4\n#define g99edc2ad720a4c61ab1a28da5fd57214_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define DITHERING\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat accumAlpha = 0.0;\nvoid accumulateAlpha(float alpha) {\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * alpha;\n\t\t\t\t}\n\nlayout(location = 1) out vec4 gVelocity;\n\nuniform int frameIndex;\nuniform vec2 resolution;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nconst vec2 haltonSequence[16] = vec2[16](\nvec2( 0.000000,-0.333334),\nvec2(-0.500000, 0.333334),\nvec2( 0.500000,-0.777778),\nvec2(-0.750000,-0.111112),\nvec2( 0.250000, 0.555556),\nvec2(-0.250000,-0.555556),\nvec2( 0.750000, 0.111112),\nvec2(-0.875000, 0.777778),\nvec2(0.125000, -0.925926),\nvec2(-0.375000, -0.259260),\nvec2(0.625000, 0.407408),\nvec2(-0.625000, -0.703704),\nvec2(0.375000, -0.037038),\nvec2(-0.125000, 0.629630),\nvec2(0.875000, -0.481482),\nvec2(-0.937500, 0.185186));\n\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n  const float goldenAngle = 2.399963f; // radians\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n  float theta = float(sampleIndex) * goldenAngle + angle;\n  float sine = sin(theta);\n  float cosine = cos(theta);\n  return vec2(cosine, sine) * r;\n}\n\n// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso\nfloat getNoiseInterleavedGradient(vec2 screenPos) {\n    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);\n    return fract(magic.z * fract(dot(screenPos, magic.xy)));\n}\n\n\nuniform float penumbraSize[5];\nuniform sampler2D aoMap;\nuniform bool aoEnabled;\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifndef DOUBLE_SIDED\n   #define DOUBLE_SIDED\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\nfloat getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\tDirectionalLightShadow directionalLight;\n\t\n\t#endif\n\t#if 0 > 0\n\tSpotLightShadow spotLight;\n\t\n\t#endif\n\t#if 0 > 0\n\tPointLightShadow pointLight;\n\t\n\t#endif\n\t#endif\n\treturn shadow;\n}\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\nuniform float nodeU0;\nuniform float nodeU1;\nuniform float nodeU2;\nuniform vec2 nodeU3;\nuniform sampler2D nodeU4;\nuniform sampler2D nodeU5;\nuniform vec2 nodeU6;\nuniform float nodeU7;\nuniform float nodeU8;\nuniform float nodeU9;\nuniform vec3 nodeU10;\nuniform vec3 nodeU11;\nuniform bool nodeU12;\nuniform float nodeU13;\nuniform int nodeU14;\nuniform vec3 nodeU15;\nuniform float nodeU16;\nuniform float nodeU17;\nuniform float nodeU18;\nuniform float nodeU19;\nuniform bool nodeU20;\nuniform float nodeU21;\nuniform int nodeU22;\nuniform float nodeU23;\nuniform int nodeU24;\nuniform float nodeU25;\nuniform vec3 nodeU26;\nuniform float nodeU27;\nuniform bool nodeU28;\nuniform float nodeU29;\n\nuniform vec4 nodeUA0[4];\nuniform float nodeUA1[4];\n\n\n\nfloat w0( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n        }\n    \n        float w1( float a ) {\n            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n        }\n    \n        float w2( float a ){\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n        }\n    \n        float w3( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * a * a );\n        }\n    \n        // g0 and g1 are the two amplitude functions\n        float g0( float a ) {\n            return w0( a ) + w1( a );\n        }\n    \n        float g1( float a ) {\n            return w2( a ) + w3( a );\n        }\n    \n        // h0 and h1 are the two offset functions\n        float h0( float a ) {\n            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n        }\n    \n        float h1( float a ) {\n            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n        }\n    \n        vec4 bicubic( sampler2D tex, vec2 vUv, vec4 texelSize, float lod ) {\n            vUv = vUv * texelSize.zw + 0.5;\n    \n            vec2 iuv = floor( vUv );\n            vec2 fuv = fract( vUv );\n    \n            float g0x = g0( fuv.x );\n            float g1x = g1( fuv.x );\n            float h0x = h0( fuv.x );\n            float h1x = h1( fuv.x );\n            float h0y = h0( fuv.y );\n            float h1y = h1( fuv.y );\n    \n            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n    \n            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + \n                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n        }\n\n        vec4 textureBicubic( sampler2D sampler, vec2 vUv, float lod ) {\n            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n            vec2 fLodSizeInv = 1.0 / fLodSize;\n            vec2 cLodSizeInv = 1.0 / cLodSize;\n            vec4 fSample = bicubic( sampler, vUv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n            vec4 cSample = bicubic( sampler, vUv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n            return mix( fSample, cSample, fract( lod ) );\n        }\nfloat applyIorToRoughness( float roughness, float ior ) {\n\t\t\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\t\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t\t\t}\nvec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {\n                // Slightly modified version of this:\n                // https://www.shadertoy.com/view/ltScRG\n\n\t\t\t\t// Special case for blur == 0.0\n\t\t\t\tif (lod == 0.0) {\n\t\t\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\t\treturn texture2DLodEXT( sp, U, 0.0).rgb;\n\t\t\t\t\t#else\n\t\t\t\t\treturn textureLod( sp, U, 0.0).rgb;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec2 texelSize = vec2(1.0) / resolution;\n                vec2 halton = haltonSequence[frameIndex];\n                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n                float temporalAngle  = temporalOffset * PI2;\n\t\t\t\tvec3 res = vec3(0.0);\n                vec2 vUv = vec2(0.0);\n                vec2 offset = vec2(0.0);\n                vec2 vogelSample = vec2(0.0);\n                for (int i = 0; i < NUM_SAMPLES; i++) {\n                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;\n                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20\n                    vUv = U + offset;\n                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, vUv, lod));\n                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {\n                        vUv = unrefractedU;\n                        lod = lod > 4.0 ? lod : lod / 2.0;\n                    }\n                    res += textureLod(sp, vUv, lod).rgb;\n                }\n                return res / float(NUM_SAMPLES);\n            }\nvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\t        // Direction of refracted light.\n\t\t        vec3 refractionVector = refract( -v,  n, 1.0 / ior );\n\t\t        \n\t\t\t\t// Compute rotation-independant scaling of the model matrix.\n\t\t        vec3 modelScale;\n\t\t        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\t        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\t        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t        // The thickness is specified in local space\n\t\t        return normalize( refractionVector ) * thickness * modelScale;\n\t        }\nfloat vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vPosition.x - origin.x) + n.y*(vPosition.y - origin.y) + n.z*(vPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vWPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nvec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {\n\t\t\t\t\tfloat fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );\n\n\t\t\t\t\tfloat lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;\n\t\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\t\treturn color;\n\t\t\t\t}\nvec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {\n\t\t\t\t// Threejs exports do not pass a depth map to this shader, so we have to fallback to the \"Threejs method of blurring\" - see\n\t\t\t\t// also the code in convertTransmission.ts, which runs during export\n\t\t\t\t#ifdef IS_THREEJS_EXPORT\n\t\t\t\t\tfloat lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);\n\t\t\t\t\treturn textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;\n\t\t\t\t#else\n\t\t\t\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t\t\t\tfloat lod = applyIorToRoughness(roughness, ior);\n\t\t\t\t\treturn blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);\n\t\t\t\t#endif\n\t\t\t}\nvec3 g99edc2ad720a4c61ab1a28da5fd57214_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS], float steps[g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {\n               vec4 color = colors[0];\n               #ifdef g99edc2ad720a4c61ab1a28da5fd57214_IS_VECTOR\n                   #ifdef g99edc2ad720a4c61ab1a28da5fd57214_LINEAR\n                       #ifdef g99edc2ad720a4c61ab1a28da5fd57214_WORLDSPACE\n                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);\n                       #else\n                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);\n                       #endif\n                   #else\n                       #ifdef g99edc2ad720a4c61ab1a28da5fd57214_WORLDSPACE\n                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);\n                       #else\n                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);\n                       #endif\n                   #endif\n               #else\n                   float dist = length(vWPosition - cameraPosition);\n\t\t\t       float depth = ( dist - near ) / ( far - near );\n               #endif\n\n\n              float p;\n              #ifdef g99edc2ad720a4c61ab1a28da5fd57214_SMOOTH\n\t\t\t\tfor ( int i = 1; i < g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS; i++ ) {\n\t\t\t\t\t\tp = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );\n\t\t\t\t\t\tcolor = mix(color, colors[i], smoothstep(0.0, 1.0, p));\n\t\t\t\t\t}\n              #else\n                for ( int i = 1; i < g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS; i++ ) {\n                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);\n                   color = mix(color, colors[i], p);\n                 }\n              #endif\n\n               float lalpha = alpha * color.a * mask;\n               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\t\t\t   \n               return color.rgb;\n\t\t\t}\nvec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\n\t\t\t\tvec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );\n\t\t\t\tvec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;\n\t\t\t\tunrefractedCoords += 1.0;\n\t\t\t\tunrefractedCoords /= 2.0;\n\n\t\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\t\treturn getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );\n    \t\t}\nvec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {\n                vec3 v = vec3(0.);\n                if (isOrthographic) {\n                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n                } else {\n                    v = normalize(vWPosition - cameraPosition);\n                }\n                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );\n                \n\t\t\t\tfloat lalpha = alpha * mask;\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * alpha;\n\n\t\t\t\treturn transmission;\n            }\n\nvoid main() {\n\nfloat gd359c5c981634998b9e2592c17d6c0b8_calpha;\nfloat g99edc2ad720a4c61ab1a28da5fd57214_calpha;\nfloat g4e59df6d89f2444db446421aa7681104_calpha;\n\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n\n\t\t\t\t// NOTE: gl_FrontFacing alternative using face normal estimation.\n\t\t\t\tvec3 viewdx = dFdx(vViewPosition);\n\t\t\t\tvec3 viewdy = dFdy(vViewPosition);\n\t\t\t\tvec3 faceNormal = normalize(cross(viewdx, viewdy));\n\t\t\t\tbool isFrontFacing = (dot(normal, faceNormal) >= 0.0);\n\t\t\t\t\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\nvec3 diffuseColor = spe_blend(spe_blend(transmission(nodeU0,nodeU1,nodeU2,nodeU3,nodeU4,nodeU5,nodeU6,normal,1.0,nodeU7,gd359c5c981634998b9e2592c17d6c0b8_calpha),g99edc2ad720a4c61ab1a28da5fd57214_sdepth(nodeU8,nodeU9,nodeU10,nodeU11,nodeUA0,nodeUA1,nodeU12,1.0,nodeU13,g99edc2ad720a4c61ab1a28da5fd57214_calpha),( g99edc2ad720a4c61ab1a28da5fd57214_calpha ),nodeU14),fresnel(nodeU15,nodeU16,nodeU17,nodeU18,nodeU19,nodeU20,1.0,nodeU21,nodeU22,g4e59df6d89f2444db446421aa7681104_calpha),( g4e59df6d89f2444db446421aa7681104_calpha ),nodeU22);\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n#ifdef ALPHATEST\nif ( nodeU25 <= ALPHATEST ) discard;\n#endif\n#ifdef DOUBLE_SIDED\n\treflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;\n#else\n\treflectedLight.indirectDiffuse += vIndirectFront;\n#endif\n#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif\nreflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n#ifdef DOUBLE_SIDED\n\treflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;\n#else\n\treflectedLight.directDiffuse = vLightFront;\n#endif\nreflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\nreflectedLight.directDiffuse += nodeU26 * nodeU27;\nvec3 ao = aoEnabled && nodeU28 ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);\nvec3 outgoingLight = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) ;\n\n\t\t\t\tif (outgoingLight != diffuseColor) {\n\t\t\t\t\tfloat lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );\n\t\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * nodeU23 * 1.0 * lightAccu;\n\t\t\t\t\toutgoingLight = spe_blend( diffuseColor, outgoingLight, nodeU23 * 1.0, nodeU24 );\n\n\t\t\t\t\toutgoingLight *= ao;\n\t\t\t\t}\n\t\t\t\t\ngl_FragColor = vec4( outgoingLight, accumAlpha * nodeU25 );\ngl_FragColor.a *= nodeU29;\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_8;\n    float3 _color;\n    float pad_9;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_10;\n    float3 _color;\n    float pad_11;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_12;\n    float3 _skyColor;\n    float pad_13;\n    float3 _groundColor;\n    float pad_14;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_15;\n    float3 _skyColor;\n    float pad_16;\n    float3 _groundColor;\n    float pad_17;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform bool _aoEnabled : register(c7);\nuniform float4x4 _modelMatrix : register(c8);\nuniform float4x4 _projectionMatrix : register(c12);\nuniform float _nodeU0 : register(c16);\nuniform float _nodeU1 : register(c17);\nuniform float _nodeU2 : register(c18);\nuniform float2 _nodeU3 : register(c19);\nuniform float2 _nodeU6 : register(c20);\nuniform float _nodeU7 : register(c21);\nuniform float _nodeU8 : register(c22);\nuniform float _nodeU9 : register(c23);\nuniform float3 _nodeU10 : register(c24);\nuniform float3 _nodeU11 : register(c25);\nuniform bool _nodeU12 : register(c26);\nuniform float _nodeU13 : register(c27);\nuniform int _nodeU14 : register(c28);\nuniform float3 _nodeU15 : register(c29);\nuniform float _nodeU16 : register(c30);\nuniform float _nodeU17 : register(c31);\nuniform float _nodeU18 : register(c32);\nuniform float _nodeU19 : register(c33);\nuniform bool _nodeU20 : register(c34);\nuniform float _nodeU21 : register(c35);\nuniform int _nodeU22 : register(c36);\nuniform float _nodeU23 : register(c37);\nuniform int _nodeU24 : register(c38);\nuniform float _nodeU25 : register(c39);\nuniform float3 _nodeU26 : register(c40);\nuniform float _nodeU27 : register(c41);\nuniform bool _nodeU28 : register(c42);\nuniform float _nodeU29 : register(c43);\nuniform float4 _nodeUA0[4] : register(c44);\nuniform float _nodeUA1[4] : register(c48);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vLightFront = {0, 0, 0};\nstatic  float3 _vIndirectFront = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vLightBack = {0, 0, 0};\nstatic  float3 _vIndirectBack = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\nstatic bool gl_FrontFacing = false;\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\n#define GL_USES_FRONT_FACING\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\nstatic float _accumAlpha = {0.0};\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\n;\n;\nfloat f_getShadowMask()\n{\nfloat _shadow2852 = {1.0};\nreturn _shadow2852;\n}\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2855 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2856 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2856 = lerp((2.0 * _dither_shift_RGB2856), (-2.0 * _dither_shift_RGB2856), _grid_position2855));\nreturn (_color + _dither_shift_RGB2856);\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2916 = floor(_vUv);\nfloat2 _fuv2917 = frac(_vUv);\nfloat _g0x2918 = f_g0(_fuv2917.x);\nfloat _g1x2919 = f_g1(_fuv2917.x);\nfloat _h0x2920 = f_h0(_fuv2917.x);\nfloat _h1x2921 = f_h1(_fuv2917.x);\nfloat _h0y2922 = f_h0(_fuv2917.y);\nfloat _h1y2923 = f_h1(_fuv2917.y);\nfloat2 _p02924 = ((vec2_ctor((_iuv2916.x + _h0x2920), (_iuv2916.y + _h0y2922)) - 0.5) * _texelSize.xy);\nfloat2 _p12925 = ((vec2_ctor((_iuv2916.x + _h1x2921), (_iuv2916.y + _h0y2922)) - 0.5) * _texelSize.xy);\nfloat2 _p22926 = ((vec2_ctor((_iuv2916.x + _h0x2920), (_iuv2916.y + _h1y2923)) - 0.5) * _texelSize.xy);\nfloat2 _p32927 = ((vec2_ctor((_iuv2916.x + _h1x2921), (_iuv2916.y + _h1y2923)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2917.y) * ((_g0x2918 * gl_texture2DLod(_tex, _p02924, _lod)) + (_g1x2919 * gl_texture2DLod(_tex, _p12925, _lod)))) + (f_g1(_fuv2917.y) * ((_g0x2918 * gl_texture2DLod(_tex, _p22926, _lod)) + (_g1x2919 * gl_texture2DLod(_tex, _p32927, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize2932 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize2933 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv2934 = (1.0 / _fLodSize2932);\nfloat2 _cLodSizeInv2935 = (1.0 / _cLodSize2933);\nfloat4 _fSample2936 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv2934, _fLodSize2932), floor(_lod));\nfloat4 _cSample2937 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv2935, _cLodSize2933), ceil(_lod));\nreturn lerp(_fSample2936, _cSample2937, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector2965 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale2966 = {0, 0, 0};\n(_modelScale2966.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale2966.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale2966.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector2965) * _thickness) * _modelScale2966);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist2985 = length((_vPosition - _origin));\nreturn ((_dist2985 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3002 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3003 = ((clamp(_fresnel3002, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3003 / clamp((_lalpha3003 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3003, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3003) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3013 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3013).xyz;\n}\nfloat3 f_g99edc2ad720a4c61ab1a28da5fd57214_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3025 = _colors[0];\nfloat _depth3026 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3027 = {0};\n{ for(int _i3028 = {1}; (_i3028 < 4); (_i3028++))\n{\n(_p3027 = clamp(((_depth3026 - _steps[(_i3028 - 1)]) / (_steps[_i3028] - _steps[(_i3028 - 1)])), 0.0, 1.0));\n(_color3025 = lerp(_color3025, _colors[_i3028], _p3027));\n}\n}\nfloat _lalpha3029 = ((_alpha * _color3025.w) * _mask);\n(_calpha = lerp((_lalpha3029 / clamp((_lalpha3029 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3029, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3029) * (1.0 - float_ctor(_isMask))));\nreturn _color3025.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3044 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3045 = (_position + _transmissionRay3044);\nfloat4 _ndcPos3046 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3045, 1.0));\nfloat2 _refractionCoords3047 = (_ndcPos3046.xy / _ndcPos3046.w);\n(_refractionCoords3047 += 1.0);\n(_refractionCoords3047 /= 2.0);\nfloat4 _ndcPosUnrefracted3048 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3049 = (_ndcPosUnrefracted3048.xy / _ndcPosUnrefracted3048.w);\n(_unrefractedCoords3049 += 1.0);\n(_unrefractedCoords3049 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3047, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3049, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3062 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3062 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3062 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3063 = f_getIBLVolumeRefraction(_vWNormal, (-_v3062), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3064 = (_alpha * _mask);\n(_calpha = (_lalpha3064 / clamp((_lalpha3064 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3063;\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat _gd359c5c981634998b9e2592c17d6c0b8_calpha3066 = {0};\nfloat _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067 = {0};\nfloat _g4e59df6d89f2444db446421aa7681104_calpha3068 = {0};\nfloat sc09 = {0};\nif (gl_FrontFacing)\n{\n(sc09 = 1.0);\n}\nelse\n{\n(sc09 = -1.0);\n}\nfloat _faceDirection3069 = sc09;\nfloat3 _normal3070 = normalize(_vNormal);\n(_normal3070 = (_normal3070 * _faceDirection3069));\nfloat3 _viewdx3072 = ddx(_vViewPosition);\nfloat3 _viewdy3073 = ddy(_vViewPosition);\nfloat3 _faceNormal3074 = normalize(cross(_viewdx3072, _viewdy3073));\nbool _isFrontFacing3075 = (dot(_normal3070, _faceNormal3074) >= 0.0);\nfloat3 _diffuseColor3076 = f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3070, 1.0, _nodeU7, _gd359c5c981634998b9e2592c17d6c0b8_calpha3066), f_g99edc2ad720a4c61ab1a28da5fd57214_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067), _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _g4e59df6d89f2444db446421aa7681104_calpha3068), _g4e59df6d89f2444db446421aa7681104_calpha3068, _nodeU22);\n_ReflectedLight _reflectedLight3077 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 sc0a = {0, 0, 0};\nif (_isFrontFacing3075)\n{\n(sc0a = _vIndirectFront);\n}\nelse\n{\n(sc0a = _vIndirectBack);\n}\n(_reflectedLight3077._indirectDiffuse += sc0a);\n(_reflectedLight3077._indirectDiffuse *= f_BRDF_Lambert(_diffuseColor3076.xyz));\nfloat3 sc0b = {0, 0, 0};\nif (_isFrontFacing3075)\n{\n(sc0b = _vLightFront);\n}\nelse\n{\n(sc0b = _vLightBack);\n}\n(_reflectedLight3077._directDiffuse = sc0b);\n(_reflectedLight3077._directDiffuse *= (f_BRDF_Lambert(_diffuseColor3076.xyz) * f_getShadowMask()));\n(_reflectedLight3077._directDiffuse += (_nodeU26 * _nodeU27));\nfloat3 sc0c = {0, 0, 0};\nif ((_aoEnabled && _nodeU28))\n{\n(sc0c = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc0c = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3078 = sc0c;\nfloat3 _outgoingLight3079 = (_reflectedLight3077._directDiffuse + _reflectedLight3077._indirectDiffuse);\nif (!all(_outgoingLight3079 == _diffuseColor3076))\n{\nfloat _lightAccu3080 = clamp(length((_reflectedLight3077._directSpecular + _reflectedLight3077._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU23) * 1.0) * _lightAccu3080));\n(_outgoingLight3079 = f_spe_blend_int(_diffuseColor3076, _outgoingLight3079, (_nodeU23 * 1.0), _nodeU24));\n(_outgoingLight3079 *= _ao3078);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3079, (_accumAlpha * _nodeU25)));\n(out_pc_fragColor.w *= _nodeU29);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD10;\n    float4 gl_FragCoord : TEXCOORD11;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n    float3 v6 : TEXCOORD6;\n    float3 v7 : TEXCOORD7;\n    float3 v8 : TEXCOORD8;\n    float3 v9 : TEXCOORD9;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_8;\n    float3 _color;\n    float pad_9;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_10;\n    float3 _color;\n    float pad_11;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_12;\n    float3 _skyColor;\n    float pad_13;\n    float3 _groundColor;\n    float pad_14;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_15;\n    float3 _skyColor;\n    float pad_16;\n    float3 _groundColor;\n    float pad_17;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform bool _aoEnabled : register(c7);\nuniform float4x4 _modelMatrix : register(c8);\nuniform float4x4 _projectionMatrix : register(c12);\nuniform float _nodeU0 : register(c16);\nuniform float _nodeU1 : register(c17);\nuniform float _nodeU2 : register(c18);\nuniform float2 _nodeU3 : register(c19);\nuniform float2 _nodeU6 : register(c20);\nuniform float _nodeU7 : register(c21);\nuniform float _nodeU8 : register(c22);\nuniform float _nodeU9 : register(c23);\nuniform float3 _nodeU10 : register(c24);\nuniform float3 _nodeU11 : register(c25);\nuniform bool _nodeU12 : register(c26);\nuniform float _nodeU13 : register(c27);\nuniform int _nodeU14 : register(c28);\nuniform float3 _nodeU15 : register(c29);\nuniform float _nodeU16 : register(c30);\nuniform float _nodeU17 : register(c31);\nuniform float _nodeU18 : register(c32);\nuniform float _nodeU19 : register(c33);\nuniform bool _nodeU20 : register(c34);\nuniform float _nodeU21 : register(c35);\nuniform int _nodeU22 : register(c36);\nuniform float _nodeU23 : register(c37);\nuniform int _nodeU24 : register(c38);\nuniform float _nodeU25 : register(c39);\nuniform float3 _nodeU26 : register(c40);\nuniform float _nodeU27 : register(c41);\nuniform bool _nodeU28 : register(c42);\nuniform float _nodeU29 : register(c43);\nuniform float4 _nodeUA0[4] : register(c44);\nuniform float _nodeUA1[4] : register(c48);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vLightFront = {0, 0, 0};\nstatic  float3 _vIndirectFront = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vLightBack = {0, 0, 0};\nstatic  float3 _vIndirectBack = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\nstatic bool gl_FrontFacing = false;\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\n#define GL_USES_FRONT_FACING\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\nstatic float _accumAlpha = {0.0};\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\n;\n;\nfloat f_getShadowMask()\n{\nfloat _shadow2852 = {1.0};\nreturn _shadow2852;\n}\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2855 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2856 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2856 = lerp((2.0 * _dither_shift_RGB2856), (-2.0 * _dither_shift_RGB2856), _grid_position2855));\nreturn (_color + _dither_shift_RGB2856);\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2916 = floor(_vUv);\nfloat2 _fuv2917 = frac(_vUv);\nfloat _g0x2918 = f_g0(_fuv2917.x);\nfloat _g1x2919 = f_g1(_fuv2917.x);\nfloat _h0x2920 = f_h0(_fuv2917.x);\nfloat _h1x2921 = f_h1(_fuv2917.x);\nfloat _h0y2922 = f_h0(_fuv2917.y);\nfloat _h1y2923 = f_h1(_fuv2917.y);\nfloat2 _p02924 = ((vec2_ctor((_iuv2916.x + _h0x2920), (_iuv2916.y + _h0y2922)) - 0.5) * _texelSize.xy);\nfloat2 _p12925 = ((vec2_ctor((_iuv2916.x + _h1x2921), (_iuv2916.y + _h0y2922)) - 0.5) * _texelSize.xy);\nfloat2 _p22926 = ((vec2_ctor((_iuv2916.x + _h0x2920), (_iuv2916.y + _h1y2923)) - 0.5) * _texelSize.xy);\nfloat2 _p32927 = ((vec2_ctor((_iuv2916.x + _h1x2921), (_iuv2916.y + _h1y2923)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2917.y) * ((_g0x2918 * gl_texture2DLod(_tex, _p02924, _lod)) + (_g1x2919 * gl_texture2DLod(_tex, _p12925, _lod)))) + (f_g1(_fuv2917.y) * ((_g0x2918 * gl_texture2DLod(_tex, _p22926, _lod)) + (_g1x2919 * gl_texture2DLod(_tex, _p32927, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize2932 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize2933 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv2934 = (1.0 / _fLodSize2932);\nfloat2 _cLodSizeInv2935 = (1.0 / _cLodSize2933);\nfloat4 _fSample2936 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv2934, _fLodSize2932), floor(_lod));\nfloat4 _cSample2937 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv2935, _cLodSize2933), ceil(_lod));\nreturn lerp(_fSample2936, _cSample2937, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector2965 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale2966 = {0, 0, 0};\n(_modelScale2966.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale2966.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale2966.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector2965) * _thickness) * _modelScale2966);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist2985 = length((_vPosition - _origin));\nreturn ((_dist2985 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3002 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3003 = ((clamp(_fresnel3002, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3003 / clamp((_lalpha3003 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3003, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3003) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3013 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3013).xyz;\n}\nfloat3 f_g99edc2ad720a4c61ab1a28da5fd57214_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3025 = _colors[0];\nfloat _depth3026 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3027 = {0};\n{ for(int _i3028 = {1}; (_i3028 < 4); (_i3028++))\n{\n(_p3027 = clamp(((_depth3026 - _steps[(_i3028 - 1)]) / (_steps[_i3028] - _steps[(_i3028 - 1)])), 0.0, 1.0));\n(_color3025 = lerp(_color3025, _colors[_i3028], _p3027));\n}\n}\nfloat _lalpha3029 = ((_alpha * _color3025.w) * _mask);\n(_calpha = lerp((_lalpha3029 / clamp((_lalpha3029 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3029, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3029) * (1.0 - float_ctor(_isMask))));\nreturn _color3025.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3044 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3045 = (_position + _transmissionRay3044);\nfloat4 _ndcPos3046 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3045, 1.0));\nfloat2 _refractionCoords3047 = (_ndcPos3046.xy / _ndcPos3046.w);\n(_refractionCoords3047 += 1.0);\n(_refractionCoords3047 /= 2.0);\nfloat4 _ndcPosUnrefracted3048 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3049 = (_ndcPosUnrefracted3048.xy / _ndcPosUnrefracted3048.w);\n(_unrefractedCoords3049 += 1.0);\n(_unrefractedCoords3049 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3047, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3049, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3062 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3062 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3062 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3063 = f_getIBLVolumeRefraction(_vWNormal, (-_v3062), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3064 = (_alpha * _mask);\n(_calpha = (_lalpha3064 / clamp((_lalpha3064 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3063;\n}\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input, bool isFrontFace : SV_IsFrontFace){\n    float rhw = 1.0 / input.gl_FragCoord.w;\n    gl_FragCoord.x = input.dx_Position.x - dx_FragCoordOffset.x;\n    gl_FragCoord.y = input.dx_Position.y - dx_FragCoordOffset.y;\n    gl_FragCoord.z = input.dx_Position.z;\n    gl_FragCoord.w = rhw;\n    gl_FrontFacing = isFrontFace;\n    _vViewPosition = input.v0.xyz;\n    _vWPosition = input.v1.xyz;\n    _vLightFront = input.v2.xyz;\n    _vIndirectFront = input.v3.xyz;\n    _vLightBack = input.v4.xyz;\n    _vIndirectBack = input.v5.xyz;\n    _vNormal = input.v6.xyz;\n    _vPosition = input.v7.xyz;\n    _vWNormal = input.v8.xyz;\n    _vWorldViewDir = input.v9.xyz;\n\nfloat _gd359c5c981634998b9e2592c17d6c0b8_calpha3066 = {0};\nfloat _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067 = {0};\nfloat _g4e59df6d89f2444db446421aa7681104_calpha3068 = {0};\nfloat sc09 = {0};\nif (gl_FrontFacing)\n{\n(sc09 = 1.0);\n}\nelse\n{\n(sc09 = -1.0);\n}\nfloat _faceDirection3069 = sc09;\nfloat3 _normal3070 = normalize(_vNormal);\n(_normal3070 = (_normal3070 * _faceDirection3069));\nfloat3 _viewdx3072 = ddx(_vViewPosition);\nfloat3 _viewdy3073 = ddy(_vViewPosition);\nfloat3 _faceNormal3074 = normalize(cross(_viewdx3072, _viewdy3073));\nbool _isFrontFacing3075 = (dot(_normal3070, _faceNormal3074) >= 0.0);\nfloat3 _diffuseColor3076 = f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3070, 1.0, _nodeU7, _gd359c5c981634998b9e2592c17d6c0b8_calpha3066), f_g99edc2ad720a4c61ab1a28da5fd57214_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067), _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _g4e59df6d89f2444db446421aa7681104_calpha3068), _g4e59df6d89f2444db446421aa7681104_calpha3068, _nodeU22);\n_ReflectedLight _reflectedLight3077 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 sc0a = {0, 0, 0};\nif (_isFrontFacing3075)\n{\n(sc0a = _vIndirectFront);\n}\nelse\n{\n(sc0a = _vIndirectBack);\n}\n(_reflectedLight3077._indirectDiffuse += sc0a);\n(_reflectedLight3077._indirectDiffuse *= f_BRDF_Lambert(_diffuseColor3076.xyz));\nfloat3 sc0b = {0, 0, 0};\nif (_isFrontFacing3075)\n{\n(sc0b = _vLightFront);\n}\nelse\n{\n(sc0b = _vLightBack);\n}\n(_reflectedLight3077._directDiffuse = sc0b);\n(_reflectedLight3077._directDiffuse *= (f_BRDF_Lambert(_diffuseColor3076.xyz) * f_getShadowMask()));\n(_reflectedLight3077._directDiffuse += (_nodeU26 * _nodeU27));\nfloat3 sc0c = {0, 0, 0};\nif ((_aoEnabled && _nodeU28))\n{\n(sc0c = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc0c = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3078 = sc0c;\nfloat3 _outgoingLight3079 = (_reflectedLight3077._directDiffuse + _reflectedLight3077._indirectDiffuse);\nif (!all(_outgoingLight3079 == _diffuseColor3076))\n{\nfloat _lightAccu3080 = clamp(length((_reflectedLight3077._directSpecular + _reflectedLight3077._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU23) * 1.0) * _lightAccu3080));\n(_outgoingLight3079 = f_spe_blend_int(_diffuseColor3076, _outgoingLight3079, (_nodeU23 * 1.0), _nodeU24));\n(_outgoingLight3079 *= _ao3078);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3079, (_accumAlpha * _nodeU25)));\n(out_pc_fragColor.w *= _nodeU29);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                            }
                        ]
                    },
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLProgram - ID: 6",
                        "id": 6,
                        "typeName": "WebGLProgram"
                    }
                }
            ],
            "commandEndTime": 1732773587682.4,
            "endTime": 1732773587683,
            "id": 26,
            "name": "useProgram",
            "stackTrace": [
                "Object.useProgram (https://unpkg.com/three@0.149.0/build/three.module.js:21720:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28554:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587682.4,
            "status": 0,
            "text": "useProgram: WebGLProgram - ID: 6"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 196",
                        "id": 196,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                {
                    "0": 0,
                    "1": 0,
                    "2": 0,
                    "3": 0,
                    "4": 0,
                    "5": 0,
                    "6": 0,
                    "7": 0,
                    "8": 0,
                    "9": 0,
                    "10": 0,
                    "11": 0,
                    "12": 0,
                    "13": 0,
                    "14": 0,
                    "15": 0,
                    "16": 0,
                    "17": 0,
                    "18": 0,
                    "19": 0,
                    "20": 0,
                    "21": 0,
                    "22": 0,
                    "23": 0,
                    "24": 0,
                    "25": 0,
                    "26": 0
                }
            ],
            "commandEndTime": 1732773587683.1,
            "endTime": 1732773587683.2,
            "id": 27,
            "name": "uniform3fv",
            "stackTrace": [
                "PureArrayUniform.setValueV3fArray [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17760:5)",
                "WebGLUniforms.upload (https://unpkg.com/three@0.149.0/build/three.module.js:18187:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28724:18)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773587683.1,
            "status": 0,
            "text": "uniform3fv: WebGLUniformLocation - ID: 196, [..(27)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 231",
                        "id": 231,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                {
                    "0": 0.008213827386498451,
                    "1": 0.3519526422023773,
                    "2": 0.5212568044662476,
                    "3": 1,
                    "4": 0,
                    "5": 0.1360582858324051,
                    "6": 0.18638122081756592,
                    "7": 1,
                    "8": 0,
                    "9": 0.11592911928892136,
                    "10": 0.18638122081756592,
                    "11": 1,
                    "12": 0.03988436982035637,
                    "13": 0.05705885961651802,
                    "14": 0.09528595209121704,
                    "15": 1
                }
            ],
            "commandEndTime": 1732773587683.2,
            "endTime": 1732773587683.3,
            "id": 28,
            "name": "uniform4fv",
            "stackTrace": [
                "PureArrayUniform.setValueV4fArray [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17768:5)",
                "WebGLUniforms.upload (https://unpkg.com/three@0.149.0/build/three.module.js:18187:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28724:18)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773587683.2,
            "status": 0,
            "text": "uniform4fv: WebGLUniformLocation - ID: 231, [..(16)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 232",
                        "id": 232,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                [
                    0,
                    0.2630236231752599,
                    0.5431194040374775,
                    0.9511203746788478
                ]
            ],
            "commandEndTime": 1732773587683.3,
            "endTime": 1732773587683.4,
            "id": 29,
            "name": "uniform1fv",
            "stackTrace": [
                "PureArrayUniform.setValueV1fArray [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17742:5)",
                "WebGLUniforms.upload (https://unpkg.com/three@0.149.0/build/three.module.js:18187:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28724:18)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773587683.3,
            "status": 0,
            "text": "uniform1fv: WebGLUniformLocation - ID: 232, [..(4)..]"
        },
        {
            "commandArguments": [
                3553,
                {
                    "__SPECTOR_Object_CustomData": {
                        "format": 6408,
                        "height": 870,
                        "internalFormat": 34842,
                        "isCompressed": false,
                        "length": 12145200,
                        "target": "TEXTURE_2D",
                        "type": 5131,
                        "width": 1745
                    },
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLTexture - ID: 2",
                        "id": 2,
                        "typeName": "WebGLTexture"
                    }
                }
            ],
            "commandEndTime": 1732773587683.4,
            "endTime": 1732773587683.4,
            "id": 30,
            "name": "bindTexture",
            "stackTrace": [
                "Object.bindTexture (https://unpkg.com/three@0.149.0/build/three.module.js:22096:7)",
                "WebGLTextures.setTexture2D (https://unpkg.com/three@0.149.0/build/three.module.js:22929:9)",
                "SingleUniform.setValueT1 [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17632:11)",
                "WebGLUniforms.upload (https://unpkg.com/three@0.149.0/build/three.module.js:18187:7)"
            ],
            "startTime": 1732773587683.4,
            "status": 0,
            "text": "bindTexture: TEXTURE_2D, WebGLTexture - ID: 2"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 6",
                        "id": 6,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773587683.4,
            "endTime": 1732773587683.4,
            "id": 31,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587683.4,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 6"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 268644,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 16",
                                "id": 16,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 268644,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 268644,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 17",
                                "id": 17,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 268644,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 1,
                        "name": "normal",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 2,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 179096,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 18",
                                "id": 18,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 179096,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 2,
                        "name": "uv",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 8,
                        "type": "FLOAT_VEC2",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "elementArray": {
                    "arrayBuffer": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 239976,
                            "target": "ELEMENT_ARRAY_BUFFER",
                            "usage": 35044
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLBuffer - ID: 19",
                            "id": 19,
                            "typeName": "WebGLBuffer"
                        }
                    }
                },
                "frameBuffer": null,
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 73183,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "NodeMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define LAMBERT 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS 4\n#define g99edc2ad720a4c61ab1a28da5fd57214_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define VERTEX_TEXTURES\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat neighbor_offset = 0.0001;\n\nuniform int frameIndex;\nuniform vec2 resolution;\nuniform mat4 previousModelViewMatrix;\nuniform mat4 previousProjectionMatrix;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifndef DOUBLE_SIDED\n   #define DOUBLE_SIDED\n#endif\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\n\n\n\n\n\nvoid main() {\n\n\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec3 displaced_position = position;\n\t\t\t\tvec3 displaced_normal = normal;\n\n\t\t\t\t#ifdef USE_LAYER_DISPLACE\n\t\t\t\t\tvec3 transformed;\n\t\t\t\t\tvec3 transformedNormal;\n\t\t\t\t#endif\n\t\t\t\t\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\nvec3 transformed = vec3( position );\n\t\t\t\t#endif\n\t\t\t\t\ntransformed = displaced_position;\ntransformedNormal = normalMatrix * displaced_normal;\n#ifndef FLAT_SHADED\n    vNormal = transformedNormal;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n\n\t\t\t\t\tvec3 diffuse = vec3( 1.0 );\n\t\t\t\t\tGeometricContext geometry;\n\t\t\t\t\tgeometry.position = mvPosition.xyz;\n\t\t\t\t\tgeometry.normal = normalize( transformedNormal );\n\t\t\t\t\tgeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\t\t\t\t\n\n\t\t\t\t\tGeometricContext backGeometry;\n\t\t\t\t\tbackGeometry.position = geometry.position;\n\t\t\t\t\tbackGeometry.normal = -geometry.normal;\n\t\t\t\t\tbackGeometry.viewDir = geometry.viewDir;\n\t\t\t\t\tvLightFront = vec3( 0.0 );\n\t\t\t\t\tvIndirectFront = vec3( 0.0 );\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\tvLightBack = vec3( 0.0 );\n\t\t\t\t\t\tvIndirectBack = vec3( 0.0 );\n\t\t\t\t\t#endif\n\t\t\t\t\tIncidentLight directLight;\n\t\t\t\t\tfloat dotNL;\n\t\t\t\t\tvec3 directLightColor_Diffuse;\n\t\t\t\t\tvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\t\t\t\t\tvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\t\t\t\t\t\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n\t\t\t\t\t#endif\n\t\t\t\t\t#if 0 > 0\n\t\t\t\t\t\t\n\t\t\t\t\t#endif\n\t\t\t\t\t#if 0 > 0\n\t\t\t\t\t\t\n\t\t\t\t\t#endif\n\t\t\t\t\t#if 1 > 0\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tgetDirectionalLightInfo( directionalLights[ 0 ], geometry, directLight );\n\t\t\t\t\t\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\t\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\t\t\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\n\t\t\t\t\t#endif\n\t\t\t\t\t#if 1 > 0\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ 0 ], backGeometry.normal );\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\n\t\t\t\t\t#endif\n\t\t\t\t\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\nvWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;\nvUv = uv;\nvPosition = transformed;\nvWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;\nvWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );\n\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_2;\n    float3 _normal;\n    float pad_3;\n    float3 _viewDir;\n    float pad_4;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_5;\n    float3 _normal;\n    float pad_6;\n    float3 _viewDir;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_8;\n    float3 _color;\n    float pad_9;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_10;\n    float3 _color;\n    float pad_11;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_12;\n    float3 _skyColor;\n    float pad_13;\n    float3 _groundColor;\n    float pad_14;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_15;\n    float3 _skyColor;\n    float pad_16;\n    float3 _groundColor;\n    float pad_17;\n};\n#pragma pack_matrix(column_major)\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\nuniform bool _isOrthographic : register(c20);\nuniform float3 _ambientLightColor : register(c21);\nuniform float3 _lightProbe[9] : register(c22);\nuniform _DirectionalLight _directionalLights[1] : register(c31);\nuniform _HemisphereLight _hemisphereLights[1] : register(c33);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vLightFront = {0, 0, 0};\nstatic  float3 _vIndirectFront = {0, 0, 0};\nstatic  float3 _vLightBack = {0, 0, 0};\nstatic  float3 _vIndirectBack = {0, 0, 0};\nstatic  float3 _vColor = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2794 = _normal.x;\nfloat _y2795 = _normal.y;\nfloat _z2796 = _normal.z;\nfloat3 _result2797 = (_shCoefficients[0] * 0.88622701);\n(_result2797 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2795));\n(_result2797 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2796));\n(_result2797 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2794));\n(_result2797 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2794) * _y2795));\n(_result2797 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2795) * _z2796));\n(_result2797 += (_shCoefficients[6] * (((0.74312502 * _z2796) * _z2796) - 0.24770799)));\n(_result2797 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2794) * _z2796));\n(_result2797 += ((_shCoefficients[8] * 0.42904299) * ((_x2794 * _x2794) - (_y2795 * _y2795))));\nreturn _result2797;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2801 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2802 = f_shGetIrradianceAt(_worldNormal2801, _lightProbe);\nreturn _irradiance2802;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2805 = _ambientLightColor;\nreturn _irradiance2805;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2827 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2828 = ((0.5 * _dotNL2827) + 0.5);\nfloat3 _irradiance2829 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2828);\nreturn _irradiance2829;\n}\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2837 = vec3_ctor(_normal);\nfloat3 _transformedNormal2838 = _objectNormal2837;\n(_transformedNormal2838 = mul(transpose(_normalMatrix), _transformedNormal2838));\nfloat3 _displaced_position2839 = _position;\nfloat3 _displaced_normal2840 = _normal;\n(_vNormal = normalize(_transformedNormal2838));\nfloat3 _transformed2841 = vec3_ctor(_position);\n(_transformed2841 = _displaced_position2839);\n(_transformedNormal2838 = mul(transpose(_normalMatrix), _displaced_normal2840));\n(_vNormal = _transformedNormal2838);\nfloat4 _mvPosition2842 = vec4_ctor(_transformed2841, 1.0);\n(_mvPosition2842 = mul(transpose(_modelViewMatrix), _mvPosition2842));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2842));\n(_vViewPosition = (-_mvPosition2842.xyz));\nfloat4 _worldPosition2843 = vec4_ctor(_transformed2841, 1.0);\n(_worldPosition2843 = mul(transpose(_modelMatrix), _worldPosition2843));\n_GeometricContext _geometry2845 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry2845._position = _mvPosition2842.xyz);\n(_geometry2845._normal = normalize(_transformedNormal2838));\nfloat3 sb22 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sb22 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sb22 = normalize((-_mvPosition2842.xyz)));\n}\n(_geometry2845._viewDir = sb22);\n_GeometricContext _backGeometry2846 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_backGeometry2846._position = _geometry2845._position);\n(_backGeometry2846._normal = (-_geometry2845._normal));\n(_backGeometry2846._viewDir = _geometry2845._viewDir);\n(_vLightFront = float3(0.0, 0.0, 0.0));\n(_vIndirectFront = float3(0.0, 0.0, 0.0));\n(_vLightBack = float3(0.0, 0.0, 0.0));\n(_vIndirectBack = float3(0.0, 0.0, 0.0));\n_IncidentLight _directLight2847 = {0, 0, 0, 0, 0, 0, 0};\nfloat _dotNL2848 = {0};\nfloat3 _directLightColor_Diffuse2849 = {0, 0, 0};\n(_vIndirectFront += f_getAmbientLightIrradiance(_ambientLightColor));\n(_vIndirectFront += f_getLightProbeIrradiance(_lightProbe, _geometry2845._normal));\n(_vIndirectBack += f_getAmbientLightIrradiance(_ambientLightColor));\n(_vIndirectBack += f_getLightProbeIrradiance(_lightProbe, _backGeometry2846._normal));\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLights[0], _geometry2845, _directLight2847);\n(_dotNL2848 = dot(_geometry2845._normal, _directLight2847._direction));\n(_directLightColor_Diffuse2849 = _directLight2847._color);\n(_vLightFront += (clamp(_dotNL2848, 0.0, 1.0) * _directLightColor_Diffuse2849));\n(_vLightBack += (clamp((-_dotNL2848), 0.0, 1.0) * _directLightColor_Diffuse2849));\n(_vIndirectFront += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry2845._normal));\n(_vIndirectBack += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _backGeometry2846._normal));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2841, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2841);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2838, _viewMatrix).xyz);\nfloat3 sb23 = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sb23 = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sb23 = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sb23);\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD10;\n    float4 gl_FragCoord : TEXCOORD11;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n    float3 v6 : TEXCOORD6;\n    float3 v7 : TEXCOORD7;\n    float3 v8 : TEXCOORD8;\n    float3 v9 : TEXCOORD9;\n};\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_2;\n    float3 _normal;\n    float pad_3;\n    float3 _viewDir;\n    float pad_4;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_5;\n    float3 _normal;\n    float pad_6;\n    float3 _viewDir;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_8;\n    float3 _color;\n    float pad_9;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_10;\n    float3 _color;\n    float pad_11;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_12;\n    float3 _skyColor;\n    float pad_13;\n    float3 _groundColor;\n    float pad_14;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_15;\n    float3 _skyColor;\n    float pad_16;\n    float3 _groundColor;\n    float pad_17;\n};\n#pragma pack_matrix(column_major)\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\nuniform bool _isOrthographic : register(c20);\nuniform float3 _ambientLightColor : register(c21);\nuniform float3 _lightProbe[9] : register(c22);\nuniform _DirectionalLight _directionalLights[1] : register(c31);\nuniform _HemisphereLight _hemisphereLights[1] : register(c33);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vLightFront = {0, 0, 0};\nstatic  float3 _vIndirectFront = {0, 0, 0};\nstatic  float3 _vLightBack = {0, 0, 0};\nstatic  float3 _vIndirectBack = {0, 0, 0};\nstatic  float3 _vColor = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2794 = _normal.x;\nfloat _y2795 = _normal.y;\nfloat _z2796 = _normal.z;\nfloat3 _result2797 = (_shCoefficients[0] * 0.88622701);\n(_result2797 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2795));\n(_result2797 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2796));\n(_result2797 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2794));\n(_result2797 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2794) * _y2795));\n(_result2797 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2795) * _z2796));\n(_result2797 += (_shCoefficients[6] * (((0.74312502 * _z2796) * _z2796) - 0.24770799)));\n(_result2797 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2794) * _z2796));\n(_result2797 += ((_shCoefficients[8] * 0.42904299) * ((_x2794 * _x2794) - (_y2795 * _y2795))));\nreturn _result2797;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2801 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2802 = f_shGetIrradianceAt(_worldNormal2801, _lightProbe);\nreturn _irradiance2802;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2805 = _ambientLightColor;\nreturn _irradiance2805;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2827 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2828 = ((0.5 * _dotNL2827) + 0.5);\nfloat3 _irradiance2829 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2828);\nreturn _irradiance2829;\n}\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _normal : TEXCOORD1;\n    float2 _uv : TEXCOORD2;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _normal = input._normal;\n    _uv = input._uv;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.gl_FragCoord = gl_Position;\n    output.v0 = _vViewPosition;\n    output.v1 = _vWPosition;\n    output.v2 = _vLightFront;\n    output.v3 = _vIndirectFront;\n    output.v4 = _vLightBack;\n    output.v5 = _vIndirectBack;\n    output.v6 = _vNormal;\n    output.v7 = _vPosition;\n    output.v8 = _vWNormal;\n    output.v9 = _vWorldViewDir;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2837 = vec3_ctor(_normal);\nfloat3 _transformedNormal2838 = _objectNormal2837;\n(_transformedNormal2838 = mul(transpose(_normalMatrix), _transformedNormal2838));\nfloat3 _displaced_position2839 = _position;\nfloat3 _displaced_normal2840 = _normal;\n(_vNormal = normalize(_transformedNormal2838));\nfloat3 _transformed2841 = vec3_ctor(_position);\n(_transformed2841 = _displaced_position2839);\n(_transformedNormal2838 = mul(transpose(_normalMatrix), _displaced_normal2840));\n(_vNormal = _transformedNormal2838);\nfloat4 _mvPosition2842 = vec4_ctor(_transformed2841, 1.0);\n(_mvPosition2842 = mul(transpose(_modelViewMatrix), _mvPosition2842));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2842));\n(_vViewPosition = (-_mvPosition2842.xyz));\nfloat4 _worldPosition2843 = vec4_ctor(_transformed2841, 1.0);\n(_worldPosition2843 = mul(transpose(_modelMatrix), _worldPosition2843));\n_GeometricContext _geometry2845 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry2845._position = _mvPosition2842.xyz);\n(_geometry2845._normal = normalize(_transformedNormal2838));\nfloat3 sb22 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sb22 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sb22 = normalize((-_mvPosition2842.xyz)));\n}\n(_geometry2845._viewDir = sb22);\n_GeometricContext _backGeometry2846 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_backGeometry2846._position = _geometry2845._position);\n(_backGeometry2846._normal = (-_geometry2845._normal));\n(_backGeometry2846._viewDir = _geometry2845._viewDir);\n(_vLightFront = float3(0.0, 0.0, 0.0));\n(_vIndirectFront = float3(0.0, 0.0, 0.0));\n(_vLightBack = float3(0.0, 0.0, 0.0));\n(_vIndirectBack = float3(0.0, 0.0, 0.0));\n_IncidentLight _directLight2847 = {0, 0, 0, 0, 0, 0, 0};\nfloat _dotNL2848 = {0};\nfloat3 _directLightColor_Diffuse2849 = {0, 0, 0};\n(_vIndirectFront += f_getAmbientLightIrradiance(_ambientLightColor));\n(_vIndirectFront += f_getLightProbeIrradiance(_lightProbe, _geometry2845._normal));\n(_vIndirectBack += f_getAmbientLightIrradiance(_ambientLightColor));\n(_vIndirectBack += f_getLightProbeIrradiance(_lightProbe, _backGeometry2846._normal));\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLights[0], _geometry2845, _directLight2847);\n(_dotNL2848 = dot(_geometry2845._normal, _directLight2847._direction));\n(_directLightColor_Diffuse2849 = _directLight2847._color);\n(_vLightFront += (clamp(_dotNL2848, 0.0, 1.0) * _directLightColor_Diffuse2849));\n(_vLightBack += (clamp((-_dotNL2848), 0.0, 1.0) * _directLightColor_Diffuse2849));\n(_vIndirectFront += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry2845._normal));\n(_vIndirectBack += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _backGeometry2846._normal));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2841, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2841);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2838, _viewMatrix).xyz);\nfloat3 sb23 = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sb23 = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sb23 = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sb23);\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "NodeMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define LAMBERT 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS 4\n#define g99edc2ad720a4c61ab1a28da5fd57214_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define DITHERING\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat accumAlpha = 0.0;\nvoid accumulateAlpha(float alpha) {\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * alpha;\n\t\t\t\t}\n\nlayout(location = 1) out vec4 gVelocity;\n\nuniform int frameIndex;\nuniform vec2 resolution;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nconst vec2 haltonSequence[16] = vec2[16](\nvec2( 0.000000,-0.333334),\nvec2(-0.500000, 0.333334),\nvec2( 0.500000,-0.777778),\nvec2(-0.750000,-0.111112),\nvec2( 0.250000, 0.555556),\nvec2(-0.250000,-0.555556),\nvec2( 0.750000, 0.111112),\nvec2(-0.875000, 0.777778),\nvec2(0.125000, -0.925926),\nvec2(-0.375000, -0.259260),\nvec2(0.625000, 0.407408),\nvec2(-0.625000, -0.703704),\nvec2(0.375000, -0.037038),\nvec2(-0.125000, 0.629630),\nvec2(0.875000, -0.481482),\nvec2(-0.937500, 0.185186));\n\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n  const float goldenAngle = 2.399963f; // radians\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n  float theta = float(sampleIndex) * goldenAngle + angle;\n  float sine = sin(theta);\n  float cosine = cos(theta);\n  return vec2(cosine, sine) * r;\n}\n\n// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso\nfloat getNoiseInterleavedGradient(vec2 screenPos) {\n    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);\n    return fract(magic.z * fract(dot(screenPos, magic.xy)));\n}\n\n\nuniform float penumbraSize[5];\nuniform sampler2D aoMap;\nuniform bool aoEnabled;\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifndef DOUBLE_SIDED\n   #define DOUBLE_SIDED\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\nfloat getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\tDirectionalLightShadow directionalLight;\n\t\n\t#endif\n\t#if 0 > 0\n\tSpotLightShadow spotLight;\n\t\n\t#endif\n\t#if 0 > 0\n\tPointLightShadow pointLight;\n\t\n\t#endif\n\t#endif\n\treturn shadow;\n}\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\nuniform float nodeU0;\nuniform float nodeU1;\nuniform float nodeU2;\nuniform vec2 nodeU3;\nuniform sampler2D nodeU4;\nuniform sampler2D nodeU5;\nuniform vec2 nodeU6;\nuniform float nodeU7;\nuniform float nodeU8;\nuniform float nodeU9;\nuniform vec3 nodeU10;\nuniform vec3 nodeU11;\nuniform bool nodeU12;\nuniform float nodeU13;\nuniform int nodeU14;\nuniform vec3 nodeU15;\nuniform float nodeU16;\nuniform float nodeU17;\nuniform float nodeU18;\nuniform float nodeU19;\nuniform bool nodeU20;\nuniform float nodeU21;\nuniform int nodeU22;\nuniform float nodeU23;\nuniform int nodeU24;\nuniform float nodeU25;\nuniform vec3 nodeU26;\nuniform float nodeU27;\nuniform bool nodeU28;\nuniform float nodeU29;\n\nuniform vec4 nodeUA0[4];\nuniform float nodeUA1[4];\n\n\n\nfloat w0( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n        }\n    \n        float w1( float a ) {\n            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n        }\n    \n        float w2( float a ){\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n        }\n    \n        float w3( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * a * a );\n        }\n    \n        // g0 and g1 are the two amplitude functions\n        float g0( float a ) {\n            return w0( a ) + w1( a );\n        }\n    \n        float g1( float a ) {\n            return w2( a ) + w3( a );\n        }\n    \n        // h0 and h1 are the two offset functions\n        float h0( float a ) {\n            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n        }\n    \n        float h1( float a ) {\n            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n        }\n    \n        vec4 bicubic( sampler2D tex, vec2 vUv, vec4 texelSize, float lod ) {\n            vUv = vUv * texelSize.zw + 0.5;\n    \n            vec2 iuv = floor( vUv );\n            vec2 fuv = fract( vUv );\n    \n            float g0x = g0( fuv.x );\n            float g1x = g1( fuv.x );\n            float h0x = h0( fuv.x );\n            float h1x = h1( fuv.x );\n            float h0y = h0( fuv.y );\n            float h1y = h1( fuv.y );\n    \n            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n    \n            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + \n                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n        }\n\n        vec4 textureBicubic( sampler2D sampler, vec2 vUv, float lod ) {\n            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n            vec2 fLodSizeInv = 1.0 / fLodSize;\n            vec2 cLodSizeInv = 1.0 / cLodSize;\n            vec4 fSample = bicubic( sampler, vUv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n            vec4 cSample = bicubic( sampler, vUv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n            return mix( fSample, cSample, fract( lod ) );\n        }\nfloat applyIorToRoughness( float roughness, float ior ) {\n\t\t\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\t\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t\t\t}\nvec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {\n                // Slightly modified version of this:\n                // https://www.shadertoy.com/view/ltScRG\n\n\t\t\t\t// Special case for blur == 0.0\n\t\t\t\tif (lod == 0.0) {\n\t\t\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\t\treturn texture2DLodEXT( sp, U, 0.0).rgb;\n\t\t\t\t\t#else\n\t\t\t\t\treturn textureLod( sp, U, 0.0).rgb;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec2 texelSize = vec2(1.0) / resolution;\n                vec2 halton = haltonSequence[frameIndex];\n                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n                float temporalAngle  = temporalOffset * PI2;\n\t\t\t\tvec3 res = vec3(0.0);\n                vec2 vUv = vec2(0.0);\n                vec2 offset = vec2(0.0);\n                vec2 vogelSample = vec2(0.0);\n                for (int i = 0; i < NUM_SAMPLES; i++) {\n                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;\n                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20\n                    vUv = U + offset;\n                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, vUv, lod));\n                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {\n                        vUv = unrefractedU;\n                        lod = lod > 4.0 ? lod : lod / 2.0;\n                    }\n                    res += textureLod(sp, vUv, lod).rgb;\n                }\n                return res / float(NUM_SAMPLES);\n            }\nvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\t        // Direction of refracted light.\n\t\t        vec3 refractionVector = refract( -v,  n, 1.0 / ior );\n\t\t        \n\t\t\t\t// Compute rotation-independant scaling of the model matrix.\n\t\t        vec3 modelScale;\n\t\t        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\t        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\t        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t        // The thickness is specified in local space\n\t\t        return normalize( refractionVector ) * thickness * modelScale;\n\t        }\nfloat vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vPosition.x - origin.x) + n.y*(vPosition.y - origin.y) + n.z*(vPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vWPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nvec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {\n\t\t\t\t\tfloat fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );\n\n\t\t\t\t\tfloat lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;\n\t\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\t\treturn color;\n\t\t\t\t}\nvec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {\n\t\t\t\t// Threejs exports do not pass a depth map to this shader, so we have to fallback to the \"Threejs method of blurring\" - see\n\t\t\t\t// also the code in convertTransmission.ts, which runs during export\n\t\t\t\t#ifdef IS_THREEJS_EXPORT\n\t\t\t\t\tfloat lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);\n\t\t\t\t\treturn textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;\n\t\t\t\t#else\n\t\t\t\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t\t\t\tfloat lod = applyIorToRoughness(roughness, ior);\n\t\t\t\t\treturn blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);\n\t\t\t\t#endif\n\t\t\t}\nvec3 g99edc2ad720a4c61ab1a28da5fd57214_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS], float steps[g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {\n               vec4 color = colors[0];\n               #ifdef g99edc2ad720a4c61ab1a28da5fd57214_IS_VECTOR\n                   #ifdef g99edc2ad720a4c61ab1a28da5fd57214_LINEAR\n                       #ifdef g99edc2ad720a4c61ab1a28da5fd57214_WORLDSPACE\n                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);\n                       #else\n                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);\n                       #endif\n                   #else\n                       #ifdef g99edc2ad720a4c61ab1a28da5fd57214_WORLDSPACE\n                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);\n                       #else\n                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);\n                       #endif\n                   #endif\n               #else\n                   float dist = length(vWPosition - cameraPosition);\n\t\t\t       float depth = ( dist - near ) / ( far - near );\n               #endif\n\n\n              float p;\n              #ifdef g99edc2ad720a4c61ab1a28da5fd57214_SMOOTH\n\t\t\t\tfor ( int i = 1; i < g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS; i++ ) {\n\t\t\t\t\t\tp = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );\n\t\t\t\t\t\tcolor = mix(color, colors[i], smoothstep(0.0, 1.0, p));\n\t\t\t\t\t}\n              #else\n                for ( int i = 1; i < g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS; i++ ) {\n                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);\n                   color = mix(color, colors[i], p);\n                 }\n              #endif\n\n               float lalpha = alpha * color.a * mask;\n               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\t\t\t   \n               return color.rgb;\n\t\t\t}\nvec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\n\t\t\t\tvec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );\n\t\t\t\tvec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;\n\t\t\t\tunrefractedCoords += 1.0;\n\t\t\t\tunrefractedCoords /= 2.0;\n\n\t\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\t\treturn getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );\n    \t\t}\nvec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {\n                vec3 v = vec3(0.);\n                if (isOrthographic) {\n                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n                } else {\n                    v = normalize(vWPosition - cameraPosition);\n                }\n                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );\n                \n\t\t\t\tfloat lalpha = alpha * mask;\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * alpha;\n\n\t\t\t\treturn transmission;\n            }\n\nvoid main() {\n\nfloat gd359c5c981634998b9e2592c17d6c0b8_calpha;\nfloat g99edc2ad720a4c61ab1a28da5fd57214_calpha;\nfloat g4e59df6d89f2444db446421aa7681104_calpha;\n\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n\n\t\t\t\t// NOTE: gl_FrontFacing alternative using face normal estimation.\n\t\t\t\tvec3 viewdx = dFdx(vViewPosition);\n\t\t\t\tvec3 viewdy = dFdy(vViewPosition);\n\t\t\t\tvec3 faceNormal = normalize(cross(viewdx, viewdy));\n\t\t\t\tbool isFrontFacing = (dot(normal, faceNormal) >= 0.0);\n\t\t\t\t\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\nvec3 diffuseColor = spe_blend(spe_blend(transmission(nodeU0,nodeU1,nodeU2,nodeU3,nodeU4,nodeU5,nodeU6,normal,1.0,nodeU7,gd359c5c981634998b9e2592c17d6c0b8_calpha),g99edc2ad720a4c61ab1a28da5fd57214_sdepth(nodeU8,nodeU9,nodeU10,nodeU11,nodeUA0,nodeUA1,nodeU12,1.0,nodeU13,g99edc2ad720a4c61ab1a28da5fd57214_calpha),( g99edc2ad720a4c61ab1a28da5fd57214_calpha ),nodeU14),fresnel(nodeU15,nodeU16,nodeU17,nodeU18,nodeU19,nodeU20,1.0,nodeU21,nodeU22,g4e59df6d89f2444db446421aa7681104_calpha),( g4e59df6d89f2444db446421aa7681104_calpha ),nodeU22);\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n#ifdef ALPHATEST\nif ( nodeU25 <= ALPHATEST ) discard;\n#endif\n#ifdef DOUBLE_SIDED\n\treflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;\n#else\n\treflectedLight.indirectDiffuse += vIndirectFront;\n#endif\n#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif\nreflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n#ifdef DOUBLE_SIDED\n\treflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;\n#else\n\treflectedLight.directDiffuse = vLightFront;\n#endif\nreflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\nreflectedLight.directDiffuse += nodeU26 * nodeU27;\nvec3 ao = aoEnabled && nodeU28 ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);\nvec3 outgoingLight = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) ;\n\n\t\t\t\tif (outgoingLight != diffuseColor) {\n\t\t\t\t\tfloat lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );\n\t\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * nodeU23 * 1.0 * lightAccu;\n\t\t\t\t\toutgoingLight = spe_blend( diffuseColor, outgoingLight, nodeU23 * 1.0, nodeU24 );\n\n\t\t\t\t\toutgoingLight *= ao;\n\t\t\t\t}\n\t\t\t\t\ngl_FragColor = vec4( outgoingLight, accumAlpha * nodeU25 );\ngl_FragColor.a *= nodeU29;\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_8;\n    float3 _color;\n    float pad_9;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_10;\n    float3 _color;\n    float pad_11;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_12;\n    float3 _skyColor;\n    float pad_13;\n    float3 _groundColor;\n    float pad_14;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_15;\n    float3 _skyColor;\n    float pad_16;\n    float3 _groundColor;\n    float pad_17;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform bool _aoEnabled : register(c7);\nuniform float4x4 _modelMatrix : register(c8);\nuniform float4x4 _projectionMatrix : register(c12);\nuniform float _nodeU0 : register(c16);\nuniform float _nodeU1 : register(c17);\nuniform float _nodeU2 : register(c18);\nuniform float2 _nodeU3 : register(c19);\nuniform float2 _nodeU6 : register(c20);\nuniform float _nodeU7 : register(c21);\nuniform float _nodeU8 : register(c22);\nuniform float _nodeU9 : register(c23);\nuniform float3 _nodeU10 : register(c24);\nuniform float3 _nodeU11 : register(c25);\nuniform bool _nodeU12 : register(c26);\nuniform float _nodeU13 : register(c27);\nuniform int _nodeU14 : register(c28);\nuniform float3 _nodeU15 : register(c29);\nuniform float _nodeU16 : register(c30);\nuniform float _nodeU17 : register(c31);\nuniform float _nodeU18 : register(c32);\nuniform float _nodeU19 : register(c33);\nuniform bool _nodeU20 : register(c34);\nuniform float _nodeU21 : register(c35);\nuniform int _nodeU22 : register(c36);\nuniform float _nodeU23 : register(c37);\nuniform int _nodeU24 : register(c38);\nuniform float _nodeU25 : register(c39);\nuniform float3 _nodeU26 : register(c40);\nuniform float _nodeU27 : register(c41);\nuniform bool _nodeU28 : register(c42);\nuniform float _nodeU29 : register(c43);\nuniform float4 _nodeUA0[4] : register(c44);\nuniform float _nodeUA1[4] : register(c48);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vLightFront = {0, 0, 0};\nstatic  float3 _vIndirectFront = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vLightBack = {0, 0, 0};\nstatic  float3 _vIndirectBack = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\nstatic bool gl_FrontFacing = false;\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\n#define GL_USES_FRONT_FACING\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\nstatic float _accumAlpha = {0.0};\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\n;\n;\nfloat f_getShadowMask()\n{\nfloat _shadow2852 = {1.0};\nreturn _shadow2852;\n}\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2855 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2856 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2856 = lerp((2.0 * _dither_shift_RGB2856), (-2.0 * _dither_shift_RGB2856), _grid_position2855));\nreturn (_color + _dither_shift_RGB2856);\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2916 = floor(_vUv);\nfloat2 _fuv2917 = frac(_vUv);\nfloat _g0x2918 = f_g0(_fuv2917.x);\nfloat _g1x2919 = f_g1(_fuv2917.x);\nfloat _h0x2920 = f_h0(_fuv2917.x);\nfloat _h1x2921 = f_h1(_fuv2917.x);\nfloat _h0y2922 = f_h0(_fuv2917.y);\nfloat _h1y2923 = f_h1(_fuv2917.y);\nfloat2 _p02924 = ((vec2_ctor((_iuv2916.x + _h0x2920), (_iuv2916.y + _h0y2922)) - 0.5) * _texelSize.xy);\nfloat2 _p12925 = ((vec2_ctor((_iuv2916.x + _h1x2921), (_iuv2916.y + _h0y2922)) - 0.5) * _texelSize.xy);\nfloat2 _p22926 = ((vec2_ctor((_iuv2916.x + _h0x2920), (_iuv2916.y + _h1y2923)) - 0.5) * _texelSize.xy);\nfloat2 _p32927 = ((vec2_ctor((_iuv2916.x + _h1x2921), (_iuv2916.y + _h1y2923)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2917.y) * ((_g0x2918 * gl_texture2DLod(_tex, _p02924, _lod)) + (_g1x2919 * gl_texture2DLod(_tex, _p12925, _lod)))) + (f_g1(_fuv2917.y) * ((_g0x2918 * gl_texture2DLod(_tex, _p22926, _lod)) + (_g1x2919 * gl_texture2DLod(_tex, _p32927, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize2932 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize2933 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv2934 = (1.0 / _fLodSize2932);\nfloat2 _cLodSizeInv2935 = (1.0 / _cLodSize2933);\nfloat4 _fSample2936 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv2934, _fLodSize2932), floor(_lod));\nfloat4 _cSample2937 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv2935, _cLodSize2933), ceil(_lod));\nreturn lerp(_fSample2936, _cSample2937, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector2965 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale2966 = {0, 0, 0};\n(_modelScale2966.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale2966.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale2966.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector2965) * _thickness) * _modelScale2966);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist2985 = length((_vPosition - _origin));\nreturn ((_dist2985 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3002 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3003 = ((clamp(_fresnel3002, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3003 / clamp((_lalpha3003 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3003, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3003) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3013 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3013).xyz;\n}\nfloat3 f_g99edc2ad720a4c61ab1a28da5fd57214_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3025 = _colors[0];\nfloat _depth3026 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3027 = {0};\n{ for(int _i3028 = {1}; (_i3028 < 4); (_i3028++))\n{\n(_p3027 = clamp(((_depth3026 - _steps[(_i3028 - 1)]) / (_steps[_i3028] - _steps[(_i3028 - 1)])), 0.0, 1.0));\n(_color3025 = lerp(_color3025, _colors[_i3028], _p3027));\n}\n}\nfloat _lalpha3029 = ((_alpha * _color3025.w) * _mask);\n(_calpha = lerp((_lalpha3029 / clamp((_lalpha3029 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3029, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3029) * (1.0 - float_ctor(_isMask))));\nreturn _color3025.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3044 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3045 = (_position + _transmissionRay3044);\nfloat4 _ndcPos3046 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3045, 1.0));\nfloat2 _refractionCoords3047 = (_ndcPos3046.xy / _ndcPos3046.w);\n(_refractionCoords3047 += 1.0);\n(_refractionCoords3047 /= 2.0);\nfloat4 _ndcPosUnrefracted3048 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3049 = (_ndcPosUnrefracted3048.xy / _ndcPosUnrefracted3048.w);\n(_unrefractedCoords3049 += 1.0);\n(_unrefractedCoords3049 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3047, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3049, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3062 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3062 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3062 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3063 = f_getIBLVolumeRefraction(_vWNormal, (-_v3062), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3064 = (_alpha * _mask);\n(_calpha = (_lalpha3064 / clamp((_lalpha3064 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3063;\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat _gd359c5c981634998b9e2592c17d6c0b8_calpha3066 = {0};\nfloat _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067 = {0};\nfloat _g4e59df6d89f2444db446421aa7681104_calpha3068 = {0};\nfloat sc09 = {0};\nif (gl_FrontFacing)\n{\n(sc09 = 1.0);\n}\nelse\n{\n(sc09 = -1.0);\n}\nfloat _faceDirection3069 = sc09;\nfloat3 _normal3070 = normalize(_vNormal);\n(_normal3070 = (_normal3070 * _faceDirection3069));\nfloat3 _viewdx3072 = ddx(_vViewPosition);\nfloat3 _viewdy3073 = ddy(_vViewPosition);\nfloat3 _faceNormal3074 = normalize(cross(_viewdx3072, _viewdy3073));\nbool _isFrontFacing3075 = (dot(_normal3070, _faceNormal3074) >= 0.0);\nfloat3 _diffuseColor3076 = f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3070, 1.0, _nodeU7, _gd359c5c981634998b9e2592c17d6c0b8_calpha3066), f_g99edc2ad720a4c61ab1a28da5fd57214_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067), _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _g4e59df6d89f2444db446421aa7681104_calpha3068), _g4e59df6d89f2444db446421aa7681104_calpha3068, _nodeU22);\n_ReflectedLight _reflectedLight3077 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 sc0a = {0, 0, 0};\nif (_isFrontFacing3075)\n{\n(sc0a = _vIndirectFront);\n}\nelse\n{\n(sc0a = _vIndirectBack);\n}\n(_reflectedLight3077._indirectDiffuse += sc0a);\n(_reflectedLight3077._indirectDiffuse *= f_BRDF_Lambert(_diffuseColor3076.xyz));\nfloat3 sc0b = {0, 0, 0};\nif (_isFrontFacing3075)\n{\n(sc0b = _vLightFront);\n}\nelse\n{\n(sc0b = _vLightBack);\n}\n(_reflectedLight3077._directDiffuse = sc0b);\n(_reflectedLight3077._directDiffuse *= (f_BRDF_Lambert(_diffuseColor3076.xyz) * f_getShadowMask()));\n(_reflectedLight3077._directDiffuse += (_nodeU26 * _nodeU27));\nfloat3 sc0c = {0, 0, 0};\nif ((_aoEnabled && _nodeU28))\n{\n(sc0c = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc0c = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3078 = sc0c;\nfloat3 _outgoingLight3079 = (_reflectedLight3077._directDiffuse + _reflectedLight3077._indirectDiffuse);\nif (!all(_outgoingLight3079 == _diffuseColor3076))\n{\nfloat _lightAccu3080 = clamp(length((_reflectedLight3077._directSpecular + _reflectedLight3077._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU23) * 1.0) * _lightAccu3080));\n(_outgoingLight3079 = f_spe_blend_int(_diffuseColor3076, _outgoingLight3079, (_nodeU23 * 1.0), _nodeU24));\n(_outgoingLight3079 *= _ao3078);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3079, (_accumAlpha * _nodeU25)));\n(out_pc_fragColor.w *= _nodeU29);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD10;\n    float4 gl_FragCoord : TEXCOORD11;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n    float3 v6 : TEXCOORD6;\n    float3 v7 : TEXCOORD7;\n    float3 v8 : TEXCOORD8;\n    float3 v9 : TEXCOORD9;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_8;\n    float3 _color;\n    float pad_9;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_10;\n    float3 _color;\n    float pad_11;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_12;\n    float3 _skyColor;\n    float pad_13;\n    float3 _groundColor;\n    float pad_14;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_15;\n    float3 _skyColor;\n    float pad_16;\n    float3 _groundColor;\n    float pad_17;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform bool _aoEnabled : register(c7);\nuniform float4x4 _modelMatrix : register(c8);\nuniform float4x4 _projectionMatrix : register(c12);\nuniform float _nodeU0 : register(c16);\nuniform float _nodeU1 : register(c17);\nuniform float _nodeU2 : register(c18);\nuniform float2 _nodeU3 : register(c19);\nuniform float2 _nodeU6 : register(c20);\nuniform float _nodeU7 : register(c21);\nuniform float _nodeU8 : register(c22);\nuniform float _nodeU9 : register(c23);\nuniform float3 _nodeU10 : register(c24);\nuniform float3 _nodeU11 : register(c25);\nuniform bool _nodeU12 : register(c26);\nuniform float _nodeU13 : register(c27);\nuniform int _nodeU14 : register(c28);\nuniform float3 _nodeU15 : register(c29);\nuniform float _nodeU16 : register(c30);\nuniform float _nodeU17 : register(c31);\nuniform float _nodeU18 : register(c32);\nuniform float _nodeU19 : register(c33);\nuniform bool _nodeU20 : register(c34);\nuniform float _nodeU21 : register(c35);\nuniform int _nodeU22 : register(c36);\nuniform float _nodeU23 : register(c37);\nuniform int _nodeU24 : register(c38);\nuniform float _nodeU25 : register(c39);\nuniform float3 _nodeU26 : register(c40);\nuniform float _nodeU27 : register(c41);\nuniform bool _nodeU28 : register(c42);\nuniform float _nodeU29 : register(c43);\nuniform float4 _nodeUA0[4] : register(c44);\nuniform float _nodeUA1[4] : register(c48);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vLightFront = {0, 0, 0};\nstatic  float3 _vIndirectFront = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vLightBack = {0, 0, 0};\nstatic  float3 _vIndirectBack = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\nstatic bool gl_FrontFacing = false;\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\n#define GL_USES_FRONT_FACING\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\nstatic float _accumAlpha = {0.0};\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\n;\n;\nfloat f_getShadowMask()\n{\nfloat _shadow2852 = {1.0};\nreturn _shadow2852;\n}\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2855 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2856 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2856 = lerp((2.0 * _dither_shift_RGB2856), (-2.0 * _dither_shift_RGB2856), _grid_position2855));\nreturn (_color + _dither_shift_RGB2856);\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2916 = floor(_vUv);\nfloat2 _fuv2917 = frac(_vUv);\nfloat _g0x2918 = f_g0(_fuv2917.x);\nfloat _g1x2919 = f_g1(_fuv2917.x);\nfloat _h0x2920 = f_h0(_fuv2917.x);\nfloat _h1x2921 = f_h1(_fuv2917.x);\nfloat _h0y2922 = f_h0(_fuv2917.y);\nfloat _h1y2923 = f_h1(_fuv2917.y);\nfloat2 _p02924 = ((vec2_ctor((_iuv2916.x + _h0x2920), (_iuv2916.y + _h0y2922)) - 0.5) * _texelSize.xy);\nfloat2 _p12925 = ((vec2_ctor((_iuv2916.x + _h1x2921), (_iuv2916.y + _h0y2922)) - 0.5) * _texelSize.xy);\nfloat2 _p22926 = ((vec2_ctor((_iuv2916.x + _h0x2920), (_iuv2916.y + _h1y2923)) - 0.5) * _texelSize.xy);\nfloat2 _p32927 = ((vec2_ctor((_iuv2916.x + _h1x2921), (_iuv2916.y + _h1y2923)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2917.y) * ((_g0x2918 * gl_texture2DLod(_tex, _p02924, _lod)) + (_g1x2919 * gl_texture2DLod(_tex, _p12925, _lod)))) + (f_g1(_fuv2917.y) * ((_g0x2918 * gl_texture2DLod(_tex, _p22926, _lod)) + (_g1x2919 * gl_texture2DLod(_tex, _p32927, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize2932 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize2933 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv2934 = (1.0 / _fLodSize2932);\nfloat2 _cLodSizeInv2935 = (1.0 / _cLodSize2933);\nfloat4 _fSample2936 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv2934, _fLodSize2932), floor(_lod));\nfloat4 _cSample2937 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv2935, _cLodSize2933), ceil(_lod));\nreturn lerp(_fSample2936, _cSample2937, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector2965 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale2966 = {0, 0, 0};\n(_modelScale2966.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale2966.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale2966.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector2965) * _thickness) * _modelScale2966);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist2985 = length((_vPosition - _origin));\nreturn ((_dist2985 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3002 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3003 = ((clamp(_fresnel3002, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3003 / clamp((_lalpha3003 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3003, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3003) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3013 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3013).xyz;\n}\nfloat3 f_g99edc2ad720a4c61ab1a28da5fd57214_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3025 = _colors[0];\nfloat _depth3026 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3027 = {0};\n{ for(int _i3028 = {1}; (_i3028 < 4); (_i3028++))\n{\n(_p3027 = clamp(((_depth3026 - _steps[(_i3028 - 1)]) / (_steps[_i3028] - _steps[(_i3028 - 1)])), 0.0, 1.0));\n(_color3025 = lerp(_color3025, _colors[_i3028], _p3027));\n}\n}\nfloat _lalpha3029 = ((_alpha * _color3025.w) * _mask);\n(_calpha = lerp((_lalpha3029 / clamp((_lalpha3029 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3029, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3029) * (1.0 - float_ctor(_isMask))));\nreturn _color3025.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3044 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3045 = (_position + _transmissionRay3044);\nfloat4 _ndcPos3046 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3045, 1.0));\nfloat2 _refractionCoords3047 = (_ndcPos3046.xy / _ndcPos3046.w);\n(_refractionCoords3047 += 1.0);\n(_refractionCoords3047 /= 2.0);\nfloat4 _ndcPosUnrefracted3048 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3049 = (_ndcPosUnrefracted3048.xy / _ndcPosUnrefracted3048.w);\n(_unrefractedCoords3049 += 1.0);\n(_unrefractedCoords3049 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3047, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3049, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3062 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3062 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3062 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3063 = f_getIBLVolumeRefraction(_vWNormal, (-_v3062), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3064 = (_alpha * _mask);\n(_calpha = (_lalpha3064 / clamp((_lalpha3064 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3063;\n}\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input, bool isFrontFace : SV_IsFrontFace){\n    float rhw = 1.0 / input.gl_FragCoord.w;\n    gl_FragCoord.x = input.dx_Position.x - dx_FragCoordOffset.x;\n    gl_FragCoord.y = input.dx_Position.y - dx_FragCoordOffset.y;\n    gl_FragCoord.z = input.dx_Position.z;\n    gl_FragCoord.w = rhw;\n    gl_FrontFacing = isFrontFace;\n    _vViewPosition = input.v0.xyz;\n    _vWPosition = input.v1.xyz;\n    _vLightFront = input.v2.xyz;\n    _vIndirectFront = input.v3.xyz;\n    _vLightBack = input.v4.xyz;\n    _vIndirectBack = input.v5.xyz;\n    _vNormal = input.v6.xyz;\n    _vPosition = input.v7.xyz;\n    _vWNormal = input.v8.xyz;\n    _vWorldViewDir = input.v9.xyz;\n\nfloat _gd359c5c981634998b9e2592c17d6c0b8_calpha3066 = {0};\nfloat _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067 = {0};\nfloat _g4e59df6d89f2444db446421aa7681104_calpha3068 = {0};\nfloat sc09 = {0};\nif (gl_FrontFacing)\n{\n(sc09 = 1.0);\n}\nelse\n{\n(sc09 = -1.0);\n}\nfloat _faceDirection3069 = sc09;\nfloat3 _normal3070 = normalize(_vNormal);\n(_normal3070 = (_normal3070 * _faceDirection3069));\nfloat3 _viewdx3072 = ddx(_vViewPosition);\nfloat3 _viewdy3073 = ddy(_vViewPosition);\nfloat3 _faceNormal3074 = normalize(cross(_viewdx3072, _viewdy3073));\nbool _isFrontFacing3075 = (dot(_normal3070, _faceNormal3074) >= 0.0);\nfloat3 _diffuseColor3076 = f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3070, 1.0, _nodeU7, _gd359c5c981634998b9e2592c17d6c0b8_calpha3066), f_g99edc2ad720a4c61ab1a28da5fd57214_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067), _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _g4e59df6d89f2444db446421aa7681104_calpha3068), _g4e59df6d89f2444db446421aa7681104_calpha3068, _nodeU22);\n_ReflectedLight _reflectedLight3077 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 sc0a = {0, 0, 0};\nif (_isFrontFacing3075)\n{\n(sc0a = _vIndirectFront);\n}\nelse\n{\n(sc0a = _vIndirectBack);\n}\n(_reflectedLight3077._indirectDiffuse += sc0a);\n(_reflectedLight3077._indirectDiffuse *= f_BRDF_Lambert(_diffuseColor3076.xyz));\nfloat3 sc0b = {0, 0, 0};\nif (_isFrontFacing3075)\n{\n(sc0b = _vLightFront);\n}\nelse\n{\n(sc0b = _vLightBack);\n}\n(_reflectedLight3077._directDiffuse = sc0b);\n(_reflectedLight3077._directDiffuse *= (f_BRDF_Lambert(_diffuseColor3076.xyz) * f_getShadowMask()));\n(_reflectedLight3077._directDiffuse += (_nodeU26 * _nodeU27));\nfloat3 sc0c = {0, 0, 0};\nif ((_aoEnabled && _nodeU28))\n{\n(sc0c = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc0c = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3078 = sc0c;\nfloat3 _outgoingLight3079 = (_reflectedLight3077._directDiffuse + _reflectedLight3077._indirectDiffuse);\nif (!all(_outgoingLight3079 == _diffuseColor3076))\n{\nfloat _lightAccu3080 = clamp(length((_reflectedLight3077._directSpecular + _reflectedLight3077._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU23) * 1.0) * _lightAccu3080));\n(_outgoingLight3079 = f_spe_blend_int(_diffuseColor3076, _outgoingLight3079, (_nodeU23 * 1.0), _nodeU24));\n(_outgoingLight3079 *= _ao3078);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3079, (_accumAlpha * _nodeU25)));\n(out_pc_fragColor.w *= _nodeU29);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 6",
                            "id": 6,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "NodeMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define LAMBERT 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS 4\n#define g99edc2ad720a4c61ab1a28da5fd57214_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define VERTEX_TEXTURES\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat neighbor_offset = 0.0001;\n\nuniform int frameIndex;\nuniform vec2 resolution;\nuniform mat4 previousModelViewMatrix;\nuniform mat4 previousProjectionMatrix;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifndef DOUBLE_SIDED\n   #define DOUBLE_SIDED\n#endif\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\n\n\n\n\n\nvoid main() {\n\n\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec3 displaced_position = position;\n\t\t\t\tvec3 displaced_normal = normal;\n\n\t\t\t\t#ifdef USE_LAYER_DISPLACE\n\t\t\t\t\tvec3 transformed;\n\t\t\t\t\tvec3 transformedNormal;\n\t\t\t\t#endif\n\t\t\t\t\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\nvec3 transformed = vec3( position );\n\t\t\t\t#endif\n\t\t\t\t\ntransformed = displaced_position;\ntransformedNormal = normalMatrix * displaced_normal;\n#ifndef FLAT_SHADED\n    vNormal = transformedNormal;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n\n\t\t\t\t\tvec3 diffuse = vec3( 1.0 );\n\t\t\t\t\tGeometricContext geometry;\n\t\t\t\t\tgeometry.position = mvPosition.xyz;\n\t\t\t\t\tgeometry.normal = normalize( transformedNormal );\n\t\t\t\t\tgeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\t\t\t\t\n\n\t\t\t\t\tGeometricContext backGeometry;\n\t\t\t\t\tbackGeometry.position = geometry.position;\n\t\t\t\t\tbackGeometry.normal = -geometry.normal;\n\t\t\t\t\tbackGeometry.viewDir = geometry.viewDir;\n\t\t\t\t\tvLightFront = vec3( 0.0 );\n\t\t\t\t\tvIndirectFront = vec3( 0.0 );\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\tvLightBack = vec3( 0.0 );\n\t\t\t\t\t\tvIndirectBack = vec3( 0.0 );\n\t\t\t\t\t#endif\n\t\t\t\t\tIncidentLight directLight;\n\t\t\t\t\tfloat dotNL;\n\t\t\t\t\tvec3 directLightColor_Diffuse;\n\t\t\t\t\tvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\t\t\t\t\tvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\t\t\t\t\t\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n\t\t\t\t\t#endif\n\t\t\t\t\t#if 0 > 0\n\t\t\t\t\t\t\n\t\t\t\t\t#endif\n\t\t\t\t\t#if 0 > 0\n\t\t\t\t\t\t\n\t\t\t\t\t#endif\n\t\t\t\t\t#if 1 > 0\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tgetDirectionalLightInfo( directionalLights[ 0 ], geometry, directLight );\n\t\t\t\t\t\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\t\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\t\t\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\n\t\t\t\t\t#endif\n\t\t\t\t\t#if 1 > 0\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ 0 ], backGeometry.normal );\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\n\t\t\t\t\t#endif\n\t\t\t\t\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\nvWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;\nvUv = uv;\nvPosition = transformed;\nvWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;\nvWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );\n\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_2;\n    float3 _normal;\n    float pad_3;\n    float3 _viewDir;\n    float pad_4;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_5;\n    float3 _normal;\n    float pad_6;\n    float3 _viewDir;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_8;\n    float3 _color;\n    float pad_9;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_10;\n    float3 _color;\n    float pad_11;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_12;\n    float3 _skyColor;\n    float pad_13;\n    float3 _groundColor;\n    float pad_14;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_15;\n    float3 _skyColor;\n    float pad_16;\n    float3 _groundColor;\n    float pad_17;\n};\n#pragma pack_matrix(column_major)\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\nuniform bool _isOrthographic : register(c20);\nuniform float3 _ambientLightColor : register(c21);\nuniform float3 _lightProbe[9] : register(c22);\nuniform _DirectionalLight _directionalLights[1] : register(c31);\nuniform _HemisphereLight _hemisphereLights[1] : register(c33);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vLightFront = {0, 0, 0};\nstatic  float3 _vIndirectFront = {0, 0, 0};\nstatic  float3 _vLightBack = {0, 0, 0};\nstatic  float3 _vIndirectBack = {0, 0, 0};\nstatic  float3 _vColor = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2794 = _normal.x;\nfloat _y2795 = _normal.y;\nfloat _z2796 = _normal.z;\nfloat3 _result2797 = (_shCoefficients[0] * 0.88622701);\n(_result2797 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2795));\n(_result2797 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2796));\n(_result2797 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2794));\n(_result2797 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2794) * _y2795));\n(_result2797 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2795) * _z2796));\n(_result2797 += (_shCoefficients[6] * (((0.74312502 * _z2796) * _z2796) - 0.24770799)));\n(_result2797 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2794) * _z2796));\n(_result2797 += ((_shCoefficients[8] * 0.42904299) * ((_x2794 * _x2794) - (_y2795 * _y2795))));\nreturn _result2797;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2801 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2802 = f_shGetIrradianceAt(_worldNormal2801, _lightProbe);\nreturn _irradiance2802;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2805 = _ambientLightColor;\nreturn _irradiance2805;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2827 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2828 = ((0.5 * _dotNL2827) + 0.5);\nfloat3 _irradiance2829 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2828);\nreturn _irradiance2829;\n}\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2837 = vec3_ctor(_normal);\nfloat3 _transformedNormal2838 = _objectNormal2837;\n(_transformedNormal2838 = mul(transpose(_normalMatrix), _transformedNormal2838));\nfloat3 _displaced_position2839 = _position;\nfloat3 _displaced_normal2840 = _normal;\n(_vNormal = normalize(_transformedNormal2838));\nfloat3 _transformed2841 = vec3_ctor(_position);\n(_transformed2841 = _displaced_position2839);\n(_transformedNormal2838 = mul(transpose(_normalMatrix), _displaced_normal2840));\n(_vNormal = _transformedNormal2838);\nfloat4 _mvPosition2842 = vec4_ctor(_transformed2841, 1.0);\n(_mvPosition2842 = mul(transpose(_modelViewMatrix), _mvPosition2842));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2842));\n(_vViewPosition = (-_mvPosition2842.xyz));\nfloat4 _worldPosition2843 = vec4_ctor(_transformed2841, 1.0);\n(_worldPosition2843 = mul(transpose(_modelMatrix), _worldPosition2843));\n_GeometricContext _geometry2845 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry2845._position = _mvPosition2842.xyz);\n(_geometry2845._normal = normalize(_transformedNormal2838));\nfloat3 sb22 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sb22 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sb22 = normalize((-_mvPosition2842.xyz)));\n}\n(_geometry2845._viewDir = sb22);\n_GeometricContext _backGeometry2846 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_backGeometry2846._position = _geometry2845._position);\n(_backGeometry2846._normal = (-_geometry2845._normal));\n(_backGeometry2846._viewDir = _geometry2845._viewDir);\n(_vLightFront = float3(0.0, 0.0, 0.0));\n(_vIndirectFront = float3(0.0, 0.0, 0.0));\n(_vLightBack = float3(0.0, 0.0, 0.0));\n(_vIndirectBack = float3(0.0, 0.0, 0.0));\n_IncidentLight _directLight2847 = {0, 0, 0, 0, 0, 0, 0};\nfloat _dotNL2848 = {0};\nfloat3 _directLightColor_Diffuse2849 = {0, 0, 0};\n(_vIndirectFront += f_getAmbientLightIrradiance(_ambientLightColor));\n(_vIndirectFront += f_getLightProbeIrradiance(_lightProbe, _geometry2845._normal));\n(_vIndirectBack += f_getAmbientLightIrradiance(_ambientLightColor));\n(_vIndirectBack += f_getLightProbeIrradiance(_lightProbe, _backGeometry2846._normal));\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLights[0], _geometry2845, _directLight2847);\n(_dotNL2848 = dot(_geometry2845._normal, _directLight2847._direction));\n(_directLightColor_Diffuse2849 = _directLight2847._color);\n(_vLightFront += (clamp(_dotNL2848, 0.0, 1.0) * _directLightColor_Diffuse2849));\n(_vLightBack += (clamp((-_dotNL2848), 0.0, 1.0) * _directLightColor_Diffuse2849));\n(_vIndirectFront += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry2845._normal));\n(_vIndirectBack += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _backGeometry2846._normal));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2841, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2841);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2838, _viewMatrix).xyz);\nfloat3 sb23 = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sb23 = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sb23 = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sb23);\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD10;\n    float4 gl_FragCoord : TEXCOORD11;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n    float3 v6 : TEXCOORD6;\n    float3 v7 : TEXCOORD7;\n    float3 v8 : TEXCOORD8;\n    float3 v9 : TEXCOORD9;\n};\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_2;\n    float3 _normal;\n    float pad_3;\n    float3 _viewDir;\n    float pad_4;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_5;\n    float3 _normal;\n    float pad_6;\n    float3 _viewDir;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_8;\n    float3 _color;\n    float pad_9;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_10;\n    float3 _color;\n    float pad_11;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_12;\n    float3 _skyColor;\n    float pad_13;\n    float3 _groundColor;\n    float pad_14;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_15;\n    float3 _skyColor;\n    float pad_16;\n    float3 _groundColor;\n    float pad_17;\n};\n#pragma pack_matrix(column_major)\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\nuniform bool _isOrthographic : register(c20);\nuniform float3 _ambientLightColor : register(c21);\nuniform float3 _lightProbe[9] : register(c22);\nuniform _DirectionalLight _directionalLights[1] : register(c31);\nuniform _HemisphereLight _hemisphereLights[1] : register(c33);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vLightFront = {0, 0, 0};\nstatic  float3 _vIndirectFront = {0, 0, 0};\nstatic  float3 _vLightBack = {0, 0, 0};\nstatic  float3 _vIndirectBack = {0, 0, 0};\nstatic  float3 _vColor = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2794 = _normal.x;\nfloat _y2795 = _normal.y;\nfloat _z2796 = _normal.z;\nfloat3 _result2797 = (_shCoefficients[0] * 0.88622701);\n(_result2797 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2795));\n(_result2797 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2796));\n(_result2797 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2794));\n(_result2797 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2794) * _y2795));\n(_result2797 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2795) * _z2796));\n(_result2797 += (_shCoefficients[6] * (((0.74312502 * _z2796) * _z2796) - 0.24770799)));\n(_result2797 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2794) * _z2796));\n(_result2797 += ((_shCoefficients[8] * 0.42904299) * ((_x2794 * _x2794) - (_y2795 * _y2795))));\nreturn _result2797;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2801 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2802 = f_shGetIrradianceAt(_worldNormal2801, _lightProbe);\nreturn _irradiance2802;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2805 = _ambientLightColor;\nreturn _irradiance2805;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2827 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2828 = ((0.5 * _dotNL2827) + 0.5);\nfloat3 _irradiance2829 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2828);\nreturn _irradiance2829;\n}\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _normal : TEXCOORD1;\n    float2 _uv : TEXCOORD2;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _normal = input._normal;\n    _uv = input._uv;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.gl_FragCoord = gl_Position;\n    output.v0 = _vViewPosition;\n    output.v1 = _vWPosition;\n    output.v2 = _vLightFront;\n    output.v3 = _vIndirectFront;\n    output.v4 = _vLightBack;\n    output.v5 = _vIndirectBack;\n    output.v6 = _vNormal;\n    output.v7 = _vPosition;\n    output.v8 = _vWNormal;\n    output.v9 = _vWorldViewDir;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2837 = vec3_ctor(_normal);\nfloat3 _transformedNormal2838 = _objectNormal2837;\n(_transformedNormal2838 = mul(transpose(_normalMatrix), _transformedNormal2838));\nfloat3 _displaced_position2839 = _position;\nfloat3 _displaced_normal2840 = _normal;\n(_vNormal = normalize(_transformedNormal2838));\nfloat3 _transformed2841 = vec3_ctor(_position);\n(_transformed2841 = _displaced_position2839);\n(_transformedNormal2838 = mul(transpose(_normalMatrix), _displaced_normal2840));\n(_vNormal = _transformedNormal2838);\nfloat4 _mvPosition2842 = vec4_ctor(_transformed2841, 1.0);\n(_mvPosition2842 = mul(transpose(_modelViewMatrix), _mvPosition2842));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2842));\n(_vViewPosition = (-_mvPosition2842.xyz));\nfloat4 _worldPosition2843 = vec4_ctor(_transformed2841, 1.0);\n(_worldPosition2843 = mul(transpose(_modelMatrix), _worldPosition2843));\n_GeometricContext _geometry2845 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry2845._position = _mvPosition2842.xyz);\n(_geometry2845._normal = normalize(_transformedNormal2838));\nfloat3 sb22 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sb22 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sb22 = normalize((-_mvPosition2842.xyz)));\n}\n(_geometry2845._viewDir = sb22);\n_GeometricContext _backGeometry2846 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_backGeometry2846._position = _geometry2845._position);\n(_backGeometry2846._normal = (-_geometry2845._normal));\n(_backGeometry2846._viewDir = _geometry2845._viewDir);\n(_vLightFront = float3(0.0, 0.0, 0.0));\n(_vIndirectFront = float3(0.0, 0.0, 0.0));\n(_vLightBack = float3(0.0, 0.0, 0.0));\n(_vIndirectBack = float3(0.0, 0.0, 0.0));\n_IncidentLight _directLight2847 = {0, 0, 0, 0, 0, 0, 0};\nfloat _dotNL2848 = {0};\nfloat3 _directLightColor_Diffuse2849 = {0, 0, 0};\n(_vIndirectFront += f_getAmbientLightIrradiance(_ambientLightColor));\n(_vIndirectFront += f_getLightProbeIrradiance(_lightProbe, _geometry2845._normal));\n(_vIndirectBack += f_getAmbientLightIrradiance(_ambientLightColor));\n(_vIndirectBack += f_getLightProbeIrradiance(_lightProbe, _backGeometry2846._normal));\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLights[0], _geometry2845, _directLight2847);\n(_dotNL2848 = dot(_geometry2845._normal, _directLight2847._direction));\n(_directLightColor_Diffuse2849 = _directLight2847._color);\n(_vLightFront += (clamp(_dotNL2848, 0.0, 1.0) * _directLightColor_Diffuse2849));\n(_vLightBack += (clamp((-_dotNL2848), 0.0, 1.0) * _directLightColor_Diffuse2849));\n(_vIndirectFront += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry2845._normal));\n(_vIndirectBack += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _backGeometry2846._normal));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2841, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2841);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2838, _viewMatrix).xyz);\nfloat3 sb23 = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sb23 = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sb23 = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sb23);\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "NodeMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define LAMBERT 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS 4\n#define g99edc2ad720a4c61ab1a28da5fd57214_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define DITHERING\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat accumAlpha = 0.0;\nvoid accumulateAlpha(float alpha) {\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * alpha;\n\t\t\t\t}\n\nlayout(location = 1) out vec4 gVelocity;\n\nuniform int frameIndex;\nuniform vec2 resolution;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nconst vec2 haltonSequence[16] = vec2[16](\nvec2( 0.000000,-0.333334),\nvec2(-0.500000, 0.333334),\nvec2( 0.500000,-0.777778),\nvec2(-0.750000,-0.111112),\nvec2( 0.250000, 0.555556),\nvec2(-0.250000,-0.555556),\nvec2( 0.750000, 0.111112),\nvec2(-0.875000, 0.777778),\nvec2(0.125000, -0.925926),\nvec2(-0.375000, -0.259260),\nvec2(0.625000, 0.407408),\nvec2(-0.625000, -0.703704),\nvec2(0.375000, -0.037038),\nvec2(-0.125000, 0.629630),\nvec2(0.875000, -0.481482),\nvec2(-0.937500, 0.185186));\n\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n  const float goldenAngle = 2.399963f; // radians\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n  float theta = float(sampleIndex) * goldenAngle + angle;\n  float sine = sin(theta);\n  float cosine = cos(theta);\n  return vec2(cosine, sine) * r;\n}\n\n// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso\nfloat getNoiseInterleavedGradient(vec2 screenPos) {\n    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);\n    return fract(magic.z * fract(dot(screenPos, magic.xy)));\n}\n\n\nuniform float penumbraSize[5];\nuniform sampler2D aoMap;\nuniform bool aoEnabled;\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifndef DOUBLE_SIDED\n   #define DOUBLE_SIDED\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\nfloat getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\tDirectionalLightShadow directionalLight;\n\t\n\t#endif\n\t#if 0 > 0\n\tSpotLightShadow spotLight;\n\t\n\t#endif\n\t#if 0 > 0\n\tPointLightShadow pointLight;\n\t\n\t#endif\n\t#endif\n\treturn shadow;\n}\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\nuniform float nodeU0;\nuniform float nodeU1;\nuniform float nodeU2;\nuniform vec2 nodeU3;\nuniform sampler2D nodeU4;\nuniform sampler2D nodeU5;\nuniform vec2 nodeU6;\nuniform float nodeU7;\nuniform float nodeU8;\nuniform float nodeU9;\nuniform vec3 nodeU10;\nuniform vec3 nodeU11;\nuniform bool nodeU12;\nuniform float nodeU13;\nuniform int nodeU14;\nuniform vec3 nodeU15;\nuniform float nodeU16;\nuniform float nodeU17;\nuniform float nodeU18;\nuniform float nodeU19;\nuniform bool nodeU20;\nuniform float nodeU21;\nuniform int nodeU22;\nuniform float nodeU23;\nuniform int nodeU24;\nuniform float nodeU25;\nuniform vec3 nodeU26;\nuniform float nodeU27;\nuniform bool nodeU28;\nuniform float nodeU29;\n\nuniform vec4 nodeUA0[4];\nuniform float nodeUA1[4];\n\n\n\nfloat w0( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n        }\n    \n        float w1( float a ) {\n            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n        }\n    \n        float w2( float a ){\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n        }\n    \n        float w3( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * a * a );\n        }\n    \n        // g0 and g1 are the two amplitude functions\n        float g0( float a ) {\n            return w0( a ) + w1( a );\n        }\n    \n        float g1( float a ) {\n            return w2( a ) + w3( a );\n        }\n    \n        // h0 and h1 are the two offset functions\n        float h0( float a ) {\n            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n        }\n    \n        float h1( float a ) {\n            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n        }\n    \n        vec4 bicubic( sampler2D tex, vec2 vUv, vec4 texelSize, float lod ) {\n            vUv = vUv * texelSize.zw + 0.5;\n    \n            vec2 iuv = floor( vUv );\n            vec2 fuv = fract( vUv );\n    \n            float g0x = g0( fuv.x );\n            float g1x = g1( fuv.x );\n            float h0x = h0( fuv.x );\n            float h1x = h1( fuv.x );\n            float h0y = h0( fuv.y );\n            float h1y = h1( fuv.y );\n    \n            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n    \n            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + \n                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n        }\n\n        vec4 textureBicubic( sampler2D sampler, vec2 vUv, float lod ) {\n            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n            vec2 fLodSizeInv = 1.0 / fLodSize;\n            vec2 cLodSizeInv = 1.0 / cLodSize;\n            vec4 fSample = bicubic( sampler, vUv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n            vec4 cSample = bicubic( sampler, vUv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n            return mix( fSample, cSample, fract( lod ) );\n        }\nfloat applyIorToRoughness( float roughness, float ior ) {\n\t\t\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\t\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t\t\t}\nvec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {\n                // Slightly modified version of this:\n                // https://www.shadertoy.com/view/ltScRG\n\n\t\t\t\t// Special case for blur == 0.0\n\t\t\t\tif (lod == 0.0) {\n\t\t\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\t\treturn texture2DLodEXT( sp, U, 0.0).rgb;\n\t\t\t\t\t#else\n\t\t\t\t\treturn textureLod( sp, U, 0.0).rgb;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec2 texelSize = vec2(1.0) / resolution;\n                vec2 halton = haltonSequence[frameIndex];\n                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n                float temporalAngle  = temporalOffset * PI2;\n\t\t\t\tvec3 res = vec3(0.0);\n                vec2 vUv = vec2(0.0);\n                vec2 offset = vec2(0.0);\n                vec2 vogelSample = vec2(0.0);\n                for (int i = 0; i < NUM_SAMPLES; i++) {\n                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;\n                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20\n                    vUv = U + offset;\n                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, vUv, lod));\n                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {\n                        vUv = unrefractedU;\n                        lod = lod > 4.0 ? lod : lod / 2.0;\n                    }\n                    res += textureLod(sp, vUv, lod).rgb;\n                }\n                return res / float(NUM_SAMPLES);\n            }\nvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\t        // Direction of refracted light.\n\t\t        vec3 refractionVector = refract( -v,  n, 1.0 / ior );\n\t\t        \n\t\t\t\t// Compute rotation-independant scaling of the model matrix.\n\t\t        vec3 modelScale;\n\t\t        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\t        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\t        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t        // The thickness is specified in local space\n\t\t        return normalize( refractionVector ) * thickness * modelScale;\n\t        }\nfloat vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vPosition.x - origin.x) + n.y*(vPosition.y - origin.y) + n.z*(vPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vWPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nvec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {\n\t\t\t\t\tfloat fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );\n\n\t\t\t\t\tfloat lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;\n\t\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\t\treturn color;\n\t\t\t\t}\nvec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {\n\t\t\t\t// Threejs exports do not pass a depth map to this shader, so we have to fallback to the \"Threejs method of blurring\" - see\n\t\t\t\t// also the code in convertTransmission.ts, which runs during export\n\t\t\t\t#ifdef IS_THREEJS_EXPORT\n\t\t\t\t\tfloat lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);\n\t\t\t\t\treturn textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;\n\t\t\t\t#else\n\t\t\t\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t\t\t\tfloat lod = applyIorToRoughness(roughness, ior);\n\t\t\t\t\treturn blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);\n\t\t\t\t#endif\n\t\t\t}\nvec3 g99edc2ad720a4c61ab1a28da5fd57214_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS], float steps[g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {\n               vec4 color = colors[0];\n               #ifdef g99edc2ad720a4c61ab1a28da5fd57214_IS_VECTOR\n                   #ifdef g99edc2ad720a4c61ab1a28da5fd57214_LINEAR\n                       #ifdef g99edc2ad720a4c61ab1a28da5fd57214_WORLDSPACE\n                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);\n                       #else\n                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);\n                       #endif\n                   #else\n                       #ifdef g99edc2ad720a4c61ab1a28da5fd57214_WORLDSPACE\n                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);\n                       #else\n                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);\n                       #endif\n                   #endif\n               #else\n                   float dist = length(vWPosition - cameraPosition);\n\t\t\t       float depth = ( dist - near ) / ( far - near );\n               #endif\n\n\n              float p;\n              #ifdef g99edc2ad720a4c61ab1a28da5fd57214_SMOOTH\n\t\t\t\tfor ( int i = 1; i < g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS; i++ ) {\n\t\t\t\t\t\tp = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );\n\t\t\t\t\t\tcolor = mix(color, colors[i], smoothstep(0.0, 1.0, p));\n\t\t\t\t\t}\n              #else\n                for ( int i = 1; i < g99edc2ad720a4c61ab1a28da5fd57214_MAX_COLORS; i++ ) {\n                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);\n                   color = mix(color, colors[i], p);\n                 }\n              #endif\n\n               float lalpha = alpha * color.a * mask;\n               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\t\t\t   \n               return color.rgb;\n\t\t\t}\nvec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\n\t\t\t\tvec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );\n\t\t\t\tvec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;\n\t\t\t\tunrefractedCoords += 1.0;\n\t\t\t\tunrefractedCoords /= 2.0;\n\n\t\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\t\treturn getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );\n    \t\t}\nvec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {\n                vec3 v = vec3(0.);\n                if (isOrthographic) {\n                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n                } else {\n                    v = normalize(vWPosition - cameraPosition);\n                }\n                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );\n                \n\t\t\t\tfloat lalpha = alpha * mask;\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * alpha;\n\n\t\t\t\treturn transmission;\n            }\n\nvoid main() {\n\nfloat gd359c5c981634998b9e2592c17d6c0b8_calpha;\nfloat g99edc2ad720a4c61ab1a28da5fd57214_calpha;\nfloat g4e59df6d89f2444db446421aa7681104_calpha;\n\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n\n\t\t\t\t// NOTE: gl_FrontFacing alternative using face normal estimation.\n\t\t\t\tvec3 viewdx = dFdx(vViewPosition);\n\t\t\t\tvec3 viewdy = dFdy(vViewPosition);\n\t\t\t\tvec3 faceNormal = normalize(cross(viewdx, viewdy));\n\t\t\t\tbool isFrontFacing = (dot(normal, faceNormal) >= 0.0);\n\t\t\t\t\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n\nvec3 diffuseColor = spe_blend(spe_blend(transmission(nodeU0,nodeU1,nodeU2,nodeU3,nodeU4,nodeU5,nodeU6,normal,1.0,nodeU7,gd359c5c981634998b9e2592c17d6c0b8_calpha),g99edc2ad720a4c61ab1a28da5fd57214_sdepth(nodeU8,nodeU9,nodeU10,nodeU11,nodeUA0,nodeUA1,nodeU12,1.0,nodeU13,g99edc2ad720a4c61ab1a28da5fd57214_calpha),( g99edc2ad720a4c61ab1a28da5fd57214_calpha ),nodeU14),fresnel(nodeU15,nodeU16,nodeU17,nodeU18,nodeU19,nodeU20,1.0,nodeU21,nodeU22,g4e59df6d89f2444db446421aa7681104_calpha),( g4e59df6d89f2444db446421aa7681104_calpha ),nodeU22);\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n#ifdef ALPHATEST\nif ( nodeU25 <= ALPHATEST ) discard;\n#endif\n#ifdef DOUBLE_SIDED\n\treflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;\n#else\n\treflectedLight.indirectDiffuse += vIndirectFront;\n#endif\n#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif\nreflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n#ifdef DOUBLE_SIDED\n\treflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;\n#else\n\treflectedLight.directDiffuse = vLightFront;\n#endif\nreflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\nreflectedLight.directDiffuse += nodeU26 * nodeU27;\nvec3 ao = aoEnabled && nodeU28 ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);\nvec3 outgoingLight = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) ;\n\n\t\t\t\tif (outgoingLight != diffuseColor) {\n\t\t\t\t\tfloat lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );\n\t\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * nodeU23 * 1.0 * lightAccu;\n\t\t\t\t\toutgoingLight = spe_blend( diffuseColor, outgoingLight, nodeU23 * 1.0, nodeU24 );\n\n\t\t\t\t\toutgoingLight *= ao;\n\t\t\t\t}\n\t\t\t\t\ngl_FragColor = vec4( outgoingLight, accumAlpha * nodeU25 );\ngl_FragColor.a *= nodeU29;\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_8;\n    float3 _color;\n    float pad_9;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_10;\n    float3 _color;\n    float pad_11;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_12;\n    float3 _skyColor;\n    float pad_13;\n    float3 _groundColor;\n    float pad_14;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_15;\n    float3 _skyColor;\n    float pad_16;\n    float3 _groundColor;\n    float pad_17;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform bool _aoEnabled : register(c7);\nuniform float4x4 _modelMatrix : register(c8);\nuniform float4x4 _projectionMatrix : register(c12);\nuniform float _nodeU0 : register(c16);\nuniform float _nodeU1 : register(c17);\nuniform float _nodeU2 : register(c18);\nuniform float2 _nodeU3 : register(c19);\nuniform float2 _nodeU6 : register(c20);\nuniform float _nodeU7 : register(c21);\nuniform float _nodeU8 : register(c22);\nuniform float _nodeU9 : register(c23);\nuniform float3 _nodeU10 : register(c24);\nuniform float3 _nodeU11 : register(c25);\nuniform bool _nodeU12 : register(c26);\nuniform float _nodeU13 : register(c27);\nuniform int _nodeU14 : register(c28);\nuniform float3 _nodeU15 : register(c29);\nuniform float _nodeU16 : register(c30);\nuniform float _nodeU17 : register(c31);\nuniform float _nodeU18 : register(c32);\nuniform float _nodeU19 : register(c33);\nuniform bool _nodeU20 : register(c34);\nuniform float _nodeU21 : register(c35);\nuniform int _nodeU22 : register(c36);\nuniform float _nodeU23 : register(c37);\nuniform int _nodeU24 : register(c38);\nuniform float _nodeU25 : register(c39);\nuniform float3 _nodeU26 : register(c40);\nuniform float _nodeU27 : register(c41);\nuniform bool _nodeU28 : register(c42);\nuniform float _nodeU29 : register(c43);\nuniform float4 _nodeUA0[4] : register(c44);\nuniform float _nodeUA1[4] : register(c48);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vLightFront = {0, 0, 0};\nstatic  float3 _vIndirectFront = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vLightBack = {0, 0, 0};\nstatic  float3 _vIndirectBack = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\nstatic bool gl_FrontFacing = false;\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\n#define GL_USES_FRONT_FACING\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\nstatic float _accumAlpha = {0.0};\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\n;\n;\nfloat f_getShadowMask()\n{\nfloat _shadow2852 = {1.0};\nreturn _shadow2852;\n}\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2855 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2856 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2856 = lerp((2.0 * _dither_shift_RGB2856), (-2.0 * _dither_shift_RGB2856), _grid_position2855));\nreturn (_color + _dither_shift_RGB2856);\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2916 = floor(_vUv);\nfloat2 _fuv2917 = frac(_vUv);\nfloat _g0x2918 = f_g0(_fuv2917.x);\nfloat _g1x2919 = f_g1(_fuv2917.x);\nfloat _h0x2920 = f_h0(_fuv2917.x);\nfloat _h1x2921 = f_h1(_fuv2917.x);\nfloat _h0y2922 = f_h0(_fuv2917.y);\nfloat _h1y2923 = f_h1(_fuv2917.y);\nfloat2 _p02924 = ((vec2_ctor((_iuv2916.x + _h0x2920), (_iuv2916.y + _h0y2922)) - 0.5) * _texelSize.xy);\nfloat2 _p12925 = ((vec2_ctor((_iuv2916.x + _h1x2921), (_iuv2916.y + _h0y2922)) - 0.5) * _texelSize.xy);\nfloat2 _p22926 = ((vec2_ctor((_iuv2916.x + _h0x2920), (_iuv2916.y + _h1y2923)) - 0.5) * _texelSize.xy);\nfloat2 _p32927 = ((vec2_ctor((_iuv2916.x + _h1x2921), (_iuv2916.y + _h1y2923)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2917.y) * ((_g0x2918 * gl_texture2DLod(_tex, _p02924, _lod)) + (_g1x2919 * gl_texture2DLod(_tex, _p12925, _lod)))) + (f_g1(_fuv2917.y) * ((_g0x2918 * gl_texture2DLod(_tex, _p22926, _lod)) + (_g1x2919 * gl_texture2DLod(_tex, _p32927, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize2932 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize2933 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv2934 = (1.0 / _fLodSize2932);\nfloat2 _cLodSizeInv2935 = (1.0 / _cLodSize2933);\nfloat4 _fSample2936 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv2934, _fLodSize2932), floor(_lod));\nfloat4 _cSample2937 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv2935, _cLodSize2933), ceil(_lod));\nreturn lerp(_fSample2936, _cSample2937, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector2965 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale2966 = {0, 0, 0};\n(_modelScale2966.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale2966.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale2966.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector2965) * _thickness) * _modelScale2966);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist2985 = length((_vPosition - _origin));\nreturn ((_dist2985 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3002 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3003 = ((clamp(_fresnel3002, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3003 / clamp((_lalpha3003 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3003, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3003) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3013 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3013).xyz;\n}\nfloat3 f_g99edc2ad720a4c61ab1a28da5fd57214_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3025 = _colors[0];\nfloat _depth3026 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3027 = {0};\n{ for(int _i3028 = {1}; (_i3028 < 4); (_i3028++))\n{\n(_p3027 = clamp(((_depth3026 - _steps[(_i3028 - 1)]) / (_steps[_i3028] - _steps[(_i3028 - 1)])), 0.0, 1.0));\n(_color3025 = lerp(_color3025, _colors[_i3028], _p3027));\n}\n}\nfloat _lalpha3029 = ((_alpha * _color3025.w) * _mask);\n(_calpha = lerp((_lalpha3029 / clamp((_lalpha3029 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3029, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3029) * (1.0 - float_ctor(_isMask))));\nreturn _color3025.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3044 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3045 = (_position + _transmissionRay3044);\nfloat4 _ndcPos3046 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3045, 1.0));\nfloat2 _refractionCoords3047 = (_ndcPos3046.xy / _ndcPos3046.w);\n(_refractionCoords3047 += 1.0);\n(_refractionCoords3047 /= 2.0);\nfloat4 _ndcPosUnrefracted3048 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3049 = (_ndcPosUnrefracted3048.xy / _ndcPosUnrefracted3048.w);\n(_unrefractedCoords3049 += 1.0);\n(_unrefractedCoords3049 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3047, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3049, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3062 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3062 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3062 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3063 = f_getIBLVolumeRefraction(_vWNormal, (-_v3062), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3064 = (_alpha * _mask);\n(_calpha = (_lalpha3064 / clamp((_lalpha3064 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3063;\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat _gd359c5c981634998b9e2592c17d6c0b8_calpha3066 = {0};\nfloat _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067 = {0};\nfloat _g4e59df6d89f2444db446421aa7681104_calpha3068 = {0};\nfloat sc09 = {0};\nif (gl_FrontFacing)\n{\n(sc09 = 1.0);\n}\nelse\n{\n(sc09 = -1.0);\n}\nfloat _faceDirection3069 = sc09;\nfloat3 _normal3070 = normalize(_vNormal);\n(_normal3070 = (_normal3070 * _faceDirection3069));\nfloat3 _viewdx3072 = ddx(_vViewPosition);\nfloat3 _viewdy3073 = ddy(_vViewPosition);\nfloat3 _faceNormal3074 = normalize(cross(_viewdx3072, _viewdy3073));\nbool _isFrontFacing3075 = (dot(_normal3070, _faceNormal3074) >= 0.0);\nfloat3 _diffuseColor3076 = f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3070, 1.0, _nodeU7, _gd359c5c981634998b9e2592c17d6c0b8_calpha3066), f_g99edc2ad720a4c61ab1a28da5fd57214_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067), _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _g4e59df6d89f2444db446421aa7681104_calpha3068), _g4e59df6d89f2444db446421aa7681104_calpha3068, _nodeU22);\n_ReflectedLight _reflectedLight3077 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 sc0a = {0, 0, 0};\nif (_isFrontFacing3075)\n{\n(sc0a = _vIndirectFront);\n}\nelse\n{\n(sc0a = _vIndirectBack);\n}\n(_reflectedLight3077._indirectDiffuse += sc0a);\n(_reflectedLight3077._indirectDiffuse *= f_BRDF_Lambert(_diffuseColor3076.xyz));\nfloat3 sc0b = {0, 0, 0};\nif (_isFrontFacing3075)\n{\n(sc0b = _vLightFront);\n}\nelse\n{\n(sc0b = _vLightBack);\n}\n(_reflectedLight3077._directDiffuse = sc0b);\n(_reflectedLight3077._directDiffuse *= (f_BRDF_Lambert(_diffuseColor3076.xyz) * f_getShadowMask()));\n(_reflectedLight3077._directDiffuse += (_nodeU26 * _nodeU27));\nfloat3 sc0c = {0, 0, 0};\nif ((_aoEnabled && _nodeU28))\n{\n(sc0c = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc0c = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3078 = sc0c;\nfloat3 _outgoingLight3079 = (_reflectedLight3077._directDiffuse + _reflectedLight3077._indirectDiffuse);\nif (!all(_outgoingLight3079 == _diffuseColor3076))\n{\nfloat _lightAccu3080 = clamp(length((_reflectedLight3077._directSpecular + _reflectedLight3077._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU23) * 1.0) * _lightAccu3080));\n(_outgoingLight3079 = f_spe_blend_int(_diffuseColor3076, _outgoingLight3079, (_nodeU23 * 1.0), _nodeU24));\n(_outgoingLight3079 *= _ao3078);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3079, (_accumAlpha * _nodeU25)));\n(out_pc_fragColor.w *= _nodeU29);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD10;\n    float4 gl_FragCoord : TEXCOORD11;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n    float3 v6 : TEXCOORD6;\n    float3 v7 : TEXCOORD7;\n    float3 v8 : TEXCOORD8;\n    float3 v9 : TEXCOORD9;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_0;\n    float3 _directSpecular;\n    float pad_1;\n    float3 _indirectDiffuse;\n    float pad_2;\n    float3 _indirectSpecular;\n    float pad_3;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_4;\n    float3 _directSpecular;\n    float pad_5;\n    float3 _indirectDiffuse;\n    float pad_6;\n    float3 _indirectSpecular;\n    float pad_7;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_8;\n    float3 _color;\n    float pad_9;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_10;\n    float3 _color;\n    float pad_11;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_12;\n    float3 _skyColor;\n    float pad_13;\n    float3 _groundColor;\n    float pad_14;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_15;\n    float3 _skyColor;\n    float pad_16;\n    float3 _groundColor;\n    float pad_17;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform bool _aoEnabled : register(c7);\nuniform float4x4 _modelMatrix : register(c8);\nuniform float4x4 _projectionMatrix : register(c12);\nuniform float _nodeU0 : register(c16);\nuniform float _nodeU1 : register(c17);\nuniform float _nodeU2 : register(c18);\nuniform float2 _nodeU3 : register(c19);\nuniform float2 _nodeU6 : register(c20);\nuniform float _nodeU7 : register(c21);\nuniform float _nodeU8 : register(c22);\nuniform float _nodeU9 : register(c23);\nuniform float3 _nodeU10 : register(c24);\nuniform float3 _nodeU11 : register(c25);\nuniform bool _nodeU12 : register(c26);\nuniform float _nodeU13 : register(c27);\nuniform int _nodeU14 : register(c28);\nuniform float3 _nodeU15 : register(c29);\nuniform float _nodeU16 : register(c30);\nuniform float _nodeU17 : register(c31);\nuniform float _nodeU18 : register(c32);\nuniform float _nodeU19 : register(c33);\nuniform bool _nodeU20 : register(c34);\nuniform float _nodeU21 : register(c35);\nuniform int _nodeU22 : register(c36);\nuniform float _nodeU23 : register(c37);\nuniform int _nodeU24 : register(c38);\nuniform float _nodeU25 : register(c39);\nuniform float3 _nodeU26 : register(c40);\nuniform float _nodeU27 : register(c41);\nuniform bool _nodeU28 : register(c42);\nuniform float _nodeU29 : register(c43);\nuniform float4 _nodeUA0[4] : register(c44);\nuniform float _nodeUA1[4] : register(c48);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vLightFront = {0, 0, 0};\nstatic  float3 _vIndirectFront = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vLightBack = {0, 0, 0};\nstatic  float3 _vIndirectBack = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\nstatic bool gl_FrontFacing = false;\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\n#define GL_USES_FRONT_FACING\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\nstatic float _accumAlpha = {0.0};\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\n;\n;\nfloat f_getShadowMask()\n{\nfloat _shadow2852 = {1.0};\nreturn _shadow2852;\n}\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2855 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2856 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2856 = lerp((2.0 * _dither_shift_RGB2856), (-2.0 * _dither_shift_RGB2856), _grid_position2855));\nreturn (_color + _dither_shift_RGB2856);\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2916 = floor(_vUv);\nfloat2 _fuv2917 = frac(_vUv);\nfloat _g0x2918 = f_g0(_fuv2917.x);\nfloat _g1x2919 = f_g1(_fuv2917.x);\nfloat _h0x2920 = f_h0(_fuv2917.x);\nfloat _h1x2921 = f_h1(_fuv2917.x);\nfloat _h0y2922 = f_h0(_fuv2917.y);\nfloat _h1y2923 = f_h1(_fuv2917.y);\nfloat2 _p02924 = ((vec2_ctor((_iuv2916.x + _h0x2920), (_iuv2916.y + _h0y2922)) - 0.5) * _texelSize.xy);\nfloat2 _p12925 = ((vec2_ctor((_iuv2916.x + _h1x2921), (_iuv2916.y + _h0y2922)) - 0.5) * _texelSize.xy);\nfloat2 _p22926 = ((vec2_ctor((_iuv2916.x + _h0x2920), (_iuv2916.y + _h1y2923)) - 0.5) * _texelSize.xy);\nfloat2 _p32927 = ((vec2_ctor((_iuv2916.x + _h1x2921), (_iuv2916.y + _h1y2923)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2917.y) * ((_g0x2918 * gl_texture2DLod(_tex, _p02924, _lod)) + (_g1x2919 * gl_texture2DLod(_tex, _p12925, _lod)))) + (f_g1(_fuv2917.y) * ((_g0x2918 * gl_texture2DLod(_tex, _p22926, _lod)) + (_g1x2919 * gl_texture2DLod(_tex, _p32927, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize2932 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize2933 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv2934 = (1.0 / _fLodSize2932);\nfloat2 _cLodSizeInv2935 = (1.0 / _cLodSize2933);\nfloat4 _fSample2936 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv2934, _fLodSize2932), floor(_lod));\nfloat4 _cSample2937 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv2935, _cLodSize2933), ceil(_lod));\nreturn lerp(_fSample2936, _cSample2937, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector2965 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale2966 = {0, 0, 0};\n(_modelScale2966.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale2966.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale2966.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector2965) * _thickness) * _modelScale2966);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist2985 = length((_vPosition - _origin));\nreturn ((_dist2985 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3002 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3003 = ((clamp(_fresnel3002, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3003 / clamp((_lalpha3003 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3003, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3003) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3013 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3013).xyz;\n}\nfloat3 f_g99edc2ad720a4c61ab1a28da5fd57214_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3025 = _colors[0];\nfloat _depth3026 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3027 = {0};\n{ for(int _i3028 = {1}; (_i3028 < 4); (_i3028++))\n{\n(_p3027 = clamp(((_depth3026 - _steps[(_i3028 - 1)]) / (_steps[_i3028] - _steps[(_i3028 - 1)])), 0.0, 1.0));\n(_color3025 = lerp(_color3025, _colors[_i3028], _p3027));\n}\n}\nfloat _lalpha3029 = ((_alpha * _color3025.w) * _mask);\n(_calpha = lerp((_lalpha3029 / clamp((_lalpha3029 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3029, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3029) * (1.0 - float_ctor(_isMask))));\nreturn _color3025.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3044 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3045 = (_position + _transmissionRay3044);\nfloat4 _ndcPos3046 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3045, 1.0));\nfloat2 _refractionCoords3047 = (_ndcPos3046.xy / _ndcPos3046.w);\n(_refractionCoords3047 += 1.0);\n(_refractionCoords3047 /= 2.0);\nfloat4 _ndcPosUnrefracted3048 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3049 = (_ndcPosUnrefracted3048.xy / _ndcPosUnrefracted3048.w);\n(_unrefractedCoords3049 += 1.0);\n(_unrefractedCoords3049 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3047, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3049, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3062 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3062 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3062 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3063 = f_getIBLVolumeRefraction(_vWNormal, (-_v3062), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3064 = (_alpha * _mask);\n(_calpha = (_lalpha3064 / clamp((_lalpha3064 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3063;\n}\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input, bool isFrontFace : SV_IsFrontFace){\n    float rhw = 1.0 / input.gl_FragCoord.w;\n    gl_FragCoord.x = input.dx_Position.x - dx_FragCoordOffset.x;\n    gl_FragCoord.y = input.dx_Position.y - dx_FragCoordOffset.y;\n    gl_FragCoord.z = input.dx_Position.z;\n    gl_FragCoord.w = rhw;\n    gl_FrontFacing = isFrontFace;\n    _vViewPosition = input.v0.xyz;\n    _vWPosition = input.v1.xyz;\n    _vLightFront = input.v2.xyz;\n    _vIndirectFront = input.v3.xyz;\n    _vLightBack = input.v4.xyz;\n    _vIndirectBack = input.v5.xyz;\n    _vNormal = input.v6.xyz;\n    _vPosition = input.v7.xyz;\n    _vWNormal = input.v8.xyz;\n    _vWorldViewDir = input.v9.xyz;\n\nfloat _gd359c5c981634998b9e2592c17d6c0b8_calpha3066 = {0};\nfloat _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067 = {0};\nfloat _g4e59df6d89f2444db446421aa7681104_calpha3068 = {0};\nfloat sc09 = {0};\nif (gl_FrontFacing)\n{\n(sc09 = 1.0);\n}\nelse\n{\n(sc09 = -1.0);\n}\nfloat _faceDirection3069 = sc09;\nfloat3 _normal3070 = normalize(_vNormal);\n(_normal3070 = (_normal3070 * _faceDirection3069));\nfloat3 _viewdx3072 = ddx(_vViewPosition);\nfloat3 _viewdy3073 = ddy(_vViewPosition);\nfloat3 _faceNormal3074 = normalize(cross(_viewdx3072, _viewdy3073));\nbool _isFrontFacing3075 = (dot(_normal3070, _faceNormal3074) >= 0.0);\nfloat3 _diffuseColor3076 = f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3070, 1.0, _nodeU7, _gd359c5c981634998b9e2592c17d6c0b8_calpha3066), f_g99edc2ad720a4c61ab1a28da5fd57214_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067), _g99edc2ad720a4c61ab1a28da5fd57214_calpha3067, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _g4e59df6d89f2444db446421aa7681104_calpha3068), _g4e59df6d89f2444db446421aa7681104_calpha3068, _nodeU22);\n_ReflectedLight _reflectedLight3077 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 sc0a = {0, 0, 0};\nif (_isFrontFacing3075)\n{\n(sc0a = _vIndirectFront);\n}\nelse\n{\n(sc0a = _vIndirectBack);\n}\n(_reflectedLight3077._indirectDiffuse += sc0a);\n(_reflectedLight3077._indirectDiffuse *= f_BRDF_Lambert(_diffuseColor3076.xyz));\nfloat3 sc0b = {0, 0, 0};\nif (_isFrontFacing3075)\n{\n(sc0b = _vLightFront);\n}\nelse\n{\n(sc0b = _vLightBack);\n}\n(_reflectedLight3077._directDiffuse = sc0b);\n(_reflectedLight3077._directDiffuse *= (f_BRDF_Lambert(_diffuseColor3076.xyz) * f_getShadowMask()));\n(_reflectedLight3077._directDiffuse += (_nodeU26 * _nodeU27));\nfloat3 sc0c = {0, 0, 0};\nif ((_aoEnabled && _nodeU28))\n{\n(sc0c = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc0c = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3078 = sc0c;\nfloat3 _outgoingLight3079 = (_reflectedLight3077._directDiffuse + _reflectedLight3077._indirectDiffuse);\nif (!all(_outgoingLight3079 == _diffuseColor3076))\n{\nfloat _lightAccu3080 = clamp(length((_reflectedLight3077._directSpecular + _reflectedLight3077._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU23) * 1.0) * _lightAccu3080));\n(_outgoingLight3079 = f_spe_blend_int(_diffuseColor3076, _outgoingLight3079, (_nodeU23 * 1.0), _nodeU24));\n(_outgoingLight3079 *= _ao3078);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3079, (_accumAlpha * _nodeU25)));\n(out_pc_fragColor.w *= _nodeU29);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 260",
                                "id": 260,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            -0.17481952905654907,
                            -6.099029064178467,
                            -0.5960183143615723,
                            0,
                            -5.993692398071289,
                            0.04598744958639145,
                            1.2874362468719482,
                            0,
                            -1.2763406038284302,
                            0.6194230318069458,
                            -5.9641618728637695,
                            0,
                            1958.1959228515625,
                            -1459.68603515625,
                            -2324.263916015625,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 261",
                                "id": 261,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            -0.17278172075748444,
                            -6.0916852951049805,
                            -0.6674374938011169,
                            0,
                            -5.998056888580322,
                            0.03126350790262222,
                            1.267395257949829,
                            0,
                            -1.2559516429901123,
                            0.6887299418449402,
                            -5.960888385772705,
                            0,
                            1966.127197265625,
                            -1432.659423828125,
                            -17335.462890625,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 262",
                                "id": 262,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0007603672565892339,
                            0,
                            0,
                            0,
                            0,
                            0.0015251043951138854,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 263",
                                "id": 263,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "viewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.999994158744812,
                            -0.00003970626858063042,
                            0.0034170825965702534,
                            0,
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598,
                            0,
                            -0.0034173133317381144,
                            -0.011619079858064651,
                            0.9999266862869263,
                            0,
                            -3.0878077872387166e-15,
                            0,
                            -15001.1005859375,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 264",
                                "id": 264,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "normalMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT3",
                        "value": [
                            -0.004597220104187727,
                            -0.16208207607269287,
                            -0.017758576199412346,
                            -0.15959088504314423,
                            0.0008318312466144562,
                            0.03372171148657799,
                            -0.0334172323346138,
                            0.01832510530948639,
                            -0.15860195457935333
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 265",
                                "id": 265,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "cameraPosition",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            51.2599983215332,
                            174.3000030517578,
                            15000
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 266",
                                "id": 266,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "isOrthographic",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": true
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 267",
                                "id": 267,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "resolution",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC2",
                        "value": [
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 268",
                                "id": 268,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "ambientLightColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0,
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 269",
                                "id": 269,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "lightProbe",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 9,
                        "type": "FLOAT_VEC3",
                        "values": [
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 270",
                                "id": 270,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "directionalLights[0].direction",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            -0.440809041261673,
                            0.8562363386154175,
                            -0.26934507489204407
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 271",
                                "id": 271,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "directionalLights[0].color",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            2.880840539932251,
                            2.880840539932251,
                            2.880840539932251
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 272",
                                "id": 272,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].direction",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 273",
                                "id": 273,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].skyColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            2.092608690261841,
                            2.092608690261841,
                            2.092608690261841
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 274",
                                "id": 274,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].groundColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1.2892849445343018,
                            1.2892849445343018,
                            1.2892849445343018
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 275",
                                "id": 275,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "aoEnabled",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": false
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 276",
                                "id": 276,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU0",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 5
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 277",
                                "id": 277,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU1",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1.5
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 278",
                                "id": 278,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU2",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 3
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 279",
                                "id": 279,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU3",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC2",
                        "value": [
                            1745,
                            870
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 280",
                                "id": 280,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU6",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC2",
                        "value": [
                            0.4985673427581787,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 281",
                                "id": 281,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU7",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 0.800000011920929
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 282",
                                "id": 282,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU8",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 27.86949920654297
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 283",
                                "id": 283,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU9",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 349.9481506347656
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 284",
                                "id": 284,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU10",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            -141.90664672851562,
                            107.9556884765625,
                            106.93609619140625
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 285",
                                "id": 285,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU11",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 286",
                                "id": 286,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU12",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": false
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 287",
                                "id": 287,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU13",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 288",
                                "id": 288,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU14",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "INT",
                        "value": 2
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 289",
                                "id": 289,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU15",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            1,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 290",
                                "id": 290,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU16",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 0.10000000149011612
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 291",
                                "id": 291,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU17",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 292",
                                "id": 292,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU18",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 2
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 293",
                                "id": 293,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU19",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 294",
                                "id": 294,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU20",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": false
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 295",
                                "id": 295,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU21",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 0.8999999761581421
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 296",
                                "id": 296,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU22",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "INT",
                        "value": 3
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 297",
                                "id": 297,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU23",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 0.699999988079071
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 298",
                                "id": 298,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU24",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "INT",
                        "value": 3
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 299",
                                "id": 299,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU25",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 300",
                                "id": 300,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU26",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0,
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 301",
                                "id": 301,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU27",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 302",
                                "id": 302,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU28",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": true
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 303",
                                "id": 303,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU29",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 304",
                                "id": 304,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeUA0",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 4,
                        "type": "FLOAT_VEC4",
                        "values": [
                            {
                                "value": [
                                    0.008213827386498451,
                                    0.3519526422023773,
                                    0.5212568044662476,
                                    1
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0.1360582858324051,
                                    0.18638122081756592,
                                    1
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0.11592911928892136,
                                    0.18638122081756592,
                                    1
                                ]
                            },
                            {
                                "value": [
                                    0.03988436982035637,
                                    0.05705885961651802,
                                    0.09528595209121704,
                                    1
                                ]
                            }
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 305",
                                "id": 305,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeUA1",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 4,
                        "type": "FLOAT",
                        "values": [
                            {
                                "value": 0
                            },
                            {
                                "value": 0.26302361488342285
                            },
                            {
                                "value": 0.5431194305419922
                            },
                            {
                                "value": 0.9511203765869141
                            }
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 306",
                                "id": 306,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "aoMap",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "texture": {
                            "anisotropy": 1,
                            "baseLevel": 0,
                            "compareFunc": "LEQUAL",
                            "compareMode": "NONE",
                            "format": "RGBA",
                            "height": 1,
                            "immutable": false,
                            "immutableLevels": 0,
                            "internalFormat": "RGBA",
                            "magFilter": "NEAREST",
                            "maxLevel": 1000,
                            "maxLod": 1000,
                            "minFilter": "NEAREST",
                            "minLod": -1000,
                            "textureType": "UNSIGNED_BYTE",
                            "visual": {
                                "TEXTURE_2D": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAABkhJREFUeF7t1AERAAAIAjHpX9ogPxswPHaOAIGswLLJBSdA4AyAJyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedwAOf2gEBwEDqbgAAAABJRU5ErkJggg=="
                            },
                            "width": 1,
                            "wrapR": "REPEAT",
                            "wrapS": "REPEAT",
                            "wrapT": "REPEAT"
                        },
                        "type": "SAMPLER_2D",
                        "value": 0
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 307",
                                "id": 307,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU4",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "texture": {
                            "anisotropy": 1,
                            "baseLevel": 0,
                            "compareFunc": "LEQUAL",
                            "compareMode": "NONE",
                            "format": "RGBA",
                            "height": 870,
                            "immutable": false,
                            "immutableLevels": 0,
                            "internalFormat": "RGBA16F",
                            "magFilter": "LINEAR",
                            "maxLevel": 1000,
                            "maxLod": 1000,
                            "minFilter": "LINEAR_MIPMAP_LINEAR",
                            "minLod": -1000,
                            "textureType": "HALF_FLOAT",
                            "visual": {
                                "TEXTURE_2D": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAABb1JREFUeF7t2M2rp2MYB/D7nO2UOgs1NkZJkvfMDKGE2GhMNClLLKyIQSOmTqeYTBhiZSFLpYnGZGNCysbMyHuSTubYmN35Dw7N4ixGk87cXc/vd1/3/VEWdJ7r+V6f6+nbmVnYdsml/xT/zEXgxQPPldcOvzmXd3spgXMCCwrAh0BgXAEFMOfbf3z0w/LwvkfnnMLrRxVQAKNe3t4E/BGgjW/gj99/KlddfUMbYaQYSsBvAEOd27IEzhdQAI18EWdWfytXXHlNI2nEGEVAAYxyaXsSuICAAmjoszh+7GjZs3dfQ4lE6V1AAfR+YfsR+B8BBdDY53Ho1ZXy0svLjaUSp1cBBdDrZe1FYAsCCmALSLP+kQf3PFA+Pf7ZrF/rfQMKKIABj25lApsCCqDRb+H6664tP//ya6PpxOpFQAH0ckl7EKgQUAAVaB4h0IuAAujlkvYgUCGgACrQPEKgFwEF0Msl7UGgQkABVKB5hEAvAgqgl0vag0CFgAKoQPMIgV4EFEAvl7QHgQoBBVCB5hECvQgogF4uaQ8CFQIKoALNIwR6EVAACS952fbt5e+zZxMmF7k1AQXQ2kXkITBDAQUwQ+zIV91/373l8xNfRI40a0ABBTDg0a1MYFNAAST+Fg68sL8cfv1I4g1En7eAApj3BbyfwBwFFMAc8SNe/cH775XHnngyYpQZAwoogAGPbmUC/g6go2/g9LfflJ233tnRRlaZlYDfAGYl7T0EGhRQAA0epSbSO2+/UZ5+5vmaRz0zsIACGPj4ViegADr6Bo598lHZ+9AjHW1klakFFMDUwuYTaFhAATR8nJpoO3ZcXtbW/qp51DMDCiiAAY9uZQKbAgqgw29h165byqlT33W4mZWiBRRAtKh5BBIJKIBEx7qYqDffdGP5/ocfL+YRPzuggAIY8OhWJuDvAAb4BhYXF8vGxsYAm1qxVsBvALVyniPQgYAC6OCIViBQK6AAauU8R6ADAQXQwRGtQKBWQAHUyiV7bmlpqayvrydLLe7UAgpgamHzCTQsoAAaPo5oBKYWUABTC5tPoGEBBdDwcaaItv/Zp8qRt96dYrSZCQUUQMKjiUwgSkABREkmmnPP3XeVL7/6OlFiUacSUABTyZpLIIGAAkhwpCki7t69s5w8eXqK0WYmElAAiY4lKoFoAQUQLZpo3srywbK88kqixKJGCyiAaNFE8+64/bby+NpqWf3zTCkL5fx/z+3x3/93of9u/efOZd5qxqCfPXRiW5qvQAGkOZWgBOIFFEC8qYkE0ggogDSnEpRAvIACiDc1kUAaAQWQ5lSCEogXUADxpiYSSCOgANKcSlAC8QIKIN7URAJpBBRAmlMJSiBeQAHEm5pIII2AAkhzKkEJxAsogHhTEwmkEVAAaU4lKIF4AQUQb2oigTQCCiDNqQQlEC+gAOJNTSSQRkABpDmVoATiBRRAvKmJBNIIKIA0pxKUQLyAAog3NZFAGgEFkOZUghKIF1AA8aYmEkgjoADSnEpQAvECCiDe1EQCaQQUQJpTCUogXkABxJuaSCCNgAJIcypBCcQLKIB4UxMJpBFQAGlOJSiBeAEFEG9qIoE0AgogzakEJRAvoADiTU0kkEZAAaQ5laAE4gUUQLypiQTSCCiANKcSlEC8gAKINzWRQBoBBZDmVIISiBdQAPGmJhJII6AA0pxKUALxAgog3tREAmkEFECaUwlKIF5AAcSbmkggjYACSHMqQQnECyiAeFMTCaQRUABpTiUogXgBBRBvaiKBNAIKIM2pBCUQL6AA4k1NJJBGQAGkOZWgBOIFFEC8qYkE0ggogDSnEpRAvIACiDc1kUAaAQWQ5lSCEogXUADxpiYSSCOgANKcSlAC8QIKIN7URAJpBBRAmlMJSiBeQAHEm5pIII2AAkhzKkEJxAsogHhTEwmkEVAAaU4lKIF4AQUQb2oigTQCCiDNqQQlEC/wLzkw5NMX6PehAAAAAElFTkSuQmCC"
                            },
                            "width": 1745,
                            "wrapR": "REPEAT",
                            "wrapS": "CLAMP_TO_EDGE",
                            "wrapT": "CLAMP_TO_EDGE"
                        },
                        "type": "SAMPLER_2D",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 308",
                                "id": 308,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU5",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "texture": {
                            "anisotropy": 1,
                            "baseLevel": 0,
                            "compareFunc": "LEQUAL",
                            "compareMode": "NONE",
                            "format": "RGBA",
                            "height": 1,
                            "immutable": false,
                            "immutableLevels": 0,
                            "internalFormat": "RGBA",
                            "magFilter": "NEAREST",
                            "maxLevel": 1000,
                            "maxLod": 1000,
                            "minFilter": "NEAREST",
                            "minLod": -1000,
                            "textureType": "UNSIGNED_BYTE",
                            "visual": {
                                "TEXTURE_2D": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAABkhJREFUeF7t1AERAAAIAjHpX9ogPxswPHaOAIGswLLJBSdA4AyAJyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedwAOf2gEBwEDqbgAAAABJRU5ErkJggg=="
                            },
                            "width": 1,
                            "wrapR": "REPEAT",
                            "wrapS": "REPEAT",
                            "wrapT": "REPEAT"
                        },
                        "type": "SAMPLER_2D",
                        "value": 2
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    300,
                    150
                ],
                "SCISSOR_TEST": false
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "8",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "Canvas COLOR_ATTACHMENT",
                        "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAABkBJREFUeF7t2E2oVWUUBuB1HAhRUE7CJkYQEf0KaaZRYVSTSESKaGhB5CDMQomKMugPpSyaNImGEYWI0chIolFpZH8SkZkSJUEpEWnpPSfMHAQR1+069+y19yNc7uR8a6/veTcvxzs46+xzR+HfRAQeXvdQPLfh+Yk820MJHBcYKAAvAoH+CiiACWe/+a3XY8Xtd014C4/vq4AC6Gvy7k3AfwHa8Q58/dWncdHFV7ZjGVv0SsA3gF7F7bIE/i2gAFryRuz9ZndccOElLdnGGn0RUAB9Sdo9CfyHgAJo0WuxdcubsWz5HS3ayCpdF1AAXU/Y/Qj8j4ACaNnr8cxT6+ORx9a3bCvrdFVAAXQ1WfciMA0BBTANpJn+yLLbbo2tb78z04/1vB4KKIAehu7KBE4KKICWvguXX3ZpfP7Fly3dzlpdEVAAXUnSPQg0EFAADdAcIdAVAQXQlSTdg0ADAQXQAM0RAl0RUABdSdI9CDQQUAAN0Bwh0BUBBdCVJN2DQAMBBdAAzRECXRFQAF1J0j0INBBQAA3QHCHQFQEF0JUk3YNAAwEF0ADNEQJdEVAABZM8b+7c+PHAgYKbW7ltAgqgbYnYh8AMCiiAGcTOfNTNN90Y2959L3OkWT0UUAA9DN2VCZwUUACF34V1a9fEho2bCt/A6pMWUACTTsDzCUxQQAFMED/j0a+9+kqsvOe+jFFm9FBAAfQwdFcm4G8AHXoHdnz4QSxcdF2HbuQqMyXgG8BMSXsOgRYKKIAWhtJkpZc2bYzVa9Y2OepMjwUUQI/Dd3UCCqBD78CWzW/E8hV3duhGrjJuAQUwbmHzCbRYQAG0OJwmq50/b17s27+/yVFneiigAHoYuisTOCmgADr4LixccFXs2PlxB2/mStkCCiBb1DwChQQUQKGwTmXV+fOviF27PjuVIz7bQwEF0MPQXZmAvwH04B2YNWtWDIfDHtzUFZsK+AbQVM45Ah0QUAAdCNEVCDQVUABN5Zwj0AEBBdCBEF2BQFMBBdBUrti5OXPOiYMHDxXb2rrjFlAA4xY2n0CLBRRAi8OxGoFxCyiAcQubT6DFAgqgxeGMY7UHH7g/Xnjx5XGMNrOggAIoGJqVCWQJKIAsyUJzli69IbZvf7/QxlYdl4ACGJesuQQKCCiAAiGNY8WrFy6Ij3bsHMdoMwsJKIBCYVmVQLaAAsgWLTRv/ROPxvonny60sVWzBRRAtmihedcuuSZW7tsTe/Z+FzH4Z/Hjv6fzc/zj0/ncqcyd7sxJfW6ad3l225ll3gIFUCYqixLIF1AA+aYmEigjoADKRGVRAvkCCiDf1EQCZQQUQJmoLEogX0AB5JuaSKCMgAIoE5VFCeQLKIB8UxMJlBFQAGWisiiBfAEFkG9qIoEyAgqgTFQWJZAvoADyTU0kUEZAAZSJyqIE8gUUQL6piQTKCCiAMlFZlEC+gALINzWRQBkBBVAmKosSyBdQAPmmJhIoI6AAykRlUQL5Agog39REAmUEFECZqCxKIF9AAeSbmkigjIACKBOVRQnkCyiAfFMTCZQRUABlorIogXwBBZBvaiKBMgIKoExUFiWQL6AA8k1NJFBGQAGUicqiBPIFFEC+qYkEyggogDJRWZRAvoACyDc1kUAZAQVQJiqLEsgXUAD5piYSKCOgAMpEZVEC+QIKIN/URAJlBBRAmagsSiBfQAHkm5pIoIyAAigTlUUJ5AsogHxTEwmUEVAAZaKyKIF8AQWQb2oigTICCqBMVBYlkC+gAPJNTSRQRkABlInKogTyBRRAvqmJBMoIKIAyUVmUQL6AAsg3NZFAGQEFUCYqixLIF1AA+aYmEigjoADKRGVRAvkCCiDf1EQCZQQUQJmoLEogX0AB5JuaSKCMgAIoE5VFCeQLKIB8UxMJlBFQAGWisiiBfAEFkG9qIoESAsPF94YCKBGVJQnkCAyvXx2j336O0R+/xmg4pQByWE0h0HaBQUwtujtGh77/e9FRjGIwDAXQ9tjsR+B0BYa3PB7DHz6JGA5jNPVnxGhWxCAihscUwOniOk+gzQJTS1bF8JdvY3D0cIymjkYMp078Pv5z9IgCaHN4diPQWGD2GXFs8aoY/bQ74vChiNEwBoPZMTp25MS3gKljMTr6e/wFJi0rkPRikDAAAAAASUVORK5CYII=",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": null
            },
            "commandArguments": [
                4,
                59994,
                5125,
                0
            ],
            "commandEndTime": 1732773587683.5,
            "endTime": 1732773587783.2,
            "id": 32,
            "name": "drawElements",
            "stackTrace": [
                "WebGLIndexedBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:16593:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773587683.4,
            "status": 0,
            "text": "drawElements: TRIANGLES, 59994 indices, UNSIGNED_INT, 0"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_CustomData": {
                        "length": 65448,
                        "programStatus": {
                            "LINK_STATUS": true,
                            "VALIDATE_STATUS": false
                        },
                        "shaders": [
                            {
                                "COMPILE_STATUS": true,
                                "name": "NodeMaterial",
                                "shaderType": "VERTEX_SHADER",
                                "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define PHONG 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define gdf5f123cb813444e943da398041aedd4_MAX_COLORS 4\n#define gdf5f123cb813444e943da398041aedd4_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define VERTEX_TEXTURES\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat neighbor_offset = 0.0001;\n\nuniform int frameIndex;\nuniform vec2 resolution;\nuniform mat4 previousModelViewMatrix;\nuniform mat4 previousProjectionMatrix;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\n\n\n\n\n\nvoid main() {\n\n\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t\t\t\t#endif\n\n\n\t\t\t\tvec3 displaced_position = position;\n\t\t\t\tvec3 displaced_normal = objectNormal;\n\n\t\t\t\t#ifdef USE_LAYER_DISPLACE\n\t\t\t\t\tvec3 transformed;\n\t\t\t\t\tvec3 transformedNormal;\n\t\t\t\t#endif\n\t\t\t\t\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\nvec3 transformed = vec3( position );\n\t\t\t\t#endif\n\t\t\t\t\ntransformed = displaced_position;\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\ntransformedNormal = normalMatrix * displaced_normal;\n#ifndef FLAT_SHADED\n    vNormal = transformedNormal;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\nvWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;\nvUv = uv;\nvPosition = transformed;\nvWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;\nvWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );\n\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2691 = vec3_ctor(_normal);\nfloat3 _transformedNormal2692 = _objectNormal2691;\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _transformedNormal2692));\nfloat3 _displaced_position2693 = _position;\nfloat3 _displaced_normal2694 = _objectNormal2691;\n(_vNormal = normalize(_transformedNormal2692));\nfloat3 _transformed2695 = vec3_ctor(_position);\n(_transformed2695 = _displaced_position2693);\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _displaced_normal2694));\n(_vNormal = _transformedNormal2692);\nfloat4 _mvPosition2696 = vec4_ctor(_transformed2695, 1.0);\n(_mvPosition2696 = mul(transpose(_modelViewMatrix), _mvPosition2696));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2696));\n(_vViewPosition = (-_mvPosition2696.xyz));\nfloat4 _worldPosition2697 = vec4_ctor(_transformed2695, 1.0);\n(_worldPosition2697 = mul(transpose(_modelMatrix), _worldPosition2697));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2695, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2695);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2692, _viewMatrix).xyz);\nfloat3 sa8a = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sa8a = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sa8a = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sa8a);\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD6;\n    float4 gl_FragCoord : TEXCOORD7;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n};\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _normal : TEXCOORD1;\n    float2 _uv : TEXCOORD2;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _normal = input._normal;\n    _uv = input._uv;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.gl_FragCoord = gl_Position;\n    output.v0 = _vViewPosition;\n    output.v1 = _vWPosition;\n    output.v2 = _vNormal;\n    output.v3 = _vPosition;\n    output.v4 = _vWNormal;\n    output.v5 = _vWorldViewDir;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2691 = vec3_ctor(_normal);\nfloat3 _transformedNormal2692 = _objectNormal2691;\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _transformedNormal2692));\nfloat3 _displaced_position2693 = _position;\nfloat3 _displaced_normal2694 = _objectNormal2691;\n(_vNormal = normalize(_transformedNormal2692));\nfloat3 _transformed2695 = vec3_ctor(_position);\n(_transformed2695 = _displaced_position2693);\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _displaced_normal2694));\n(_vNormal = _transformedNormal2692);\nfloat4 _mvPosition2696 = vec4_ctor(_transformed2695, 1.0);\n(_mvPosition2696 = mul(transpose(_modelViewMatrix), _mvPosition2696));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2696));\n(_vViewPosition = (-_mvPosition2696.xyz));\nfloat4 _worldPosition2697 = vec4_ctor(_transformed2695, 1.0);\n(_worldPosition2697 = mul(transpose(_modelMatrix), _worldPosition2697));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2695, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2695);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2692, _viewMatrix).xyz);\nfloat3 sa8a = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sa8a = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sa8a = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sa8a);\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                            },
                            {
                                "COMPILE_STATUS": true,
                                "name": "NodeMaterial",
                                "shaderType": "FRAGMENT_SHADER",
                                "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define PHONG 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define gdf5f123cb813444e943da398041aedd4_MAX_COLORS 4\n#define gdf5f123cb813444e943da398041aedd4_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define DITHERING\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat accumAlpha = 0.0;\nvoid accumulateAlpha(float alpha) {\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * alpha;\n\t\t\t\t}\n\nlayout(location = 1) out vec4 gVelocity;\n\nuniform int frameIndex;\nuniform vec2 resolution;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nconst vec2 haltonSequence[16] = vec2[16](\nvec2( 0.000000,-0.333334),\nvec2(-0.500000, 0.333334),\nvec2( 0.500000,-0.777778),\nvec2(-0.750000,-0.111112),\nvec2( 0.250000, 0.555556),\nvec2(-0.250000,-0.555556),\nvec2( 0.750000, 0.111112),\nvec2(-0.875000, 0.777778),\nvec2(0.125000, -0.925926),\nvec2(-0.375000, -0.259260),\nvec2(0.625000, 0.407408),\nvec2(-0.625000, -0.703704),\nvec2(0.375000, -0.037038),\nvec2(-0.125000, 0.629630),\nvec2(0.875000, -0.481482),\nvec2(-0.937500, 0.185186));\n\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n  const float goldenAngle = 2.399963f; // radians\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n  float theta = float(sampleIndex) * goldenAngle + angle;\n  float sine = sin(theta);\n  float cosine = cos(theta);\n  return vec2(cosine, sine) * r;\n}\n\n// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso\nfloat getNoiseInterleavedGradient(vec2 screenPos) {\n    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);\n    return fract(magic.z * fract(dot(screenPos, magic.xy)));\n}\n\n\nvarying vec3 vWPosition;\nuniform vec3 emissive;\nuniform float penumbraSize[5];\nuniform sampler2D aoMap;\nuniform bool aoEnabled;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\nvarying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\nuniform float nodeU0;\nuniform float nodeU1;\nuniform float nodeU2;\nuniform vec2 nodeU3;\nuniform sampler2D nodeU4;\nuniform sampler2D nodeU5;\nuniform vec2 nodeU6;\nuniform float nodeU7;\nuniform float nodeU8;\nuniform float nodeU9;\nuniform vec3 nodeU10;\nuniform vec3 nodeU11;\nuniform bool nodeU12;\nuniform float nodeU13;\nuniform int nodeU14;\nuniform vec3 nodeU15;\nuniform float nodeU16;\nuniform float nodeU17;\nuniform float nodeU18;\nuniform float nodeU19;\nuniform bool nodeU20;\nuniform float nodeU21;\nuniform int nodeU22;\nuniform vec3 nodeU23;\nuniform float nodeU24;\nuniform float nodeU25;\nuniform float nodeU26;\nuniform float nodeU27;\nuniform bool nodeU28;\nuniform float nodeU29;\nuniform int nodeU30;\nuniform vec3 nodeU31;\nuniform float nodeU32;\nuniform bool nodeU33;\nuniform float nodeU34;\nuniform int nodeU35;\nuniform float nodeU36;\nuniform float nodeU37;\n\nuniform vec4 nodeUA0[4];\nuniform float nodeUA1[4];\n\n\n\nfloat w0( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n        }\n    \n        float w1( float a ) {\n            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n        }\n    \n        float w2( float a ){\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n        }\n    \n        float w3( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * a * a );\n        }\n    \n        // g0 and g1 are the two amplitude functions\n        float g0( float a ) {\n            return w0( a ) + w1( a );\n        }\n    \n        float g1( float a ) {\n            return w2( a ) + w3( a );\n        }\n    \n        // h0 and h1 are the two offset functions\n        float h0( float a ) {\n            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n        }\n    \n        float h1( float a ) {\n            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n        }\n    \n        vec4 bicubic( sampler2D tex, vec2 vUv, vec4 texelSize, float lod ) {\n            vUv = vUv * texelSize.zw + 0.5;\n    \n            vec2 iuv = floor( vUv );\n            vec2 fuv = fract( vUv );\n    \n            float g0x = g0( fuv.x );\n            float g1x = g1( fuv.x );\n            float h0x = h0( fuv.x );\n            float h1x = h1( fuv.x );\n            float h0y = h0( fuv.y );\n            float h1y = h1( fuv.y );\n    \n            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n    \n            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + \n                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n        }\n\n        vec4 textureBicubic( sampler2D sampler, vec2 vUv, float lod ) {\n            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n            vec2 fLodSizeInv = 1.0 / fLodSize;\n            vec2 cLodSizeInv = 1.0 / cLodSize;\n            vec4 fSample = bicubic( sampler, vUv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n            vec4 cSample = bicubic( sampler, vUv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n            return mix( fSample, cSample, fract( lod ) );\n        }\nfloat applyIorToRoughness( float roughness, float ior ) {\n\t\t\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\t\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t\t\t}\nvec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {\n                // Slightly modified version of this:\n                // https://www.shadertoy.com/view/ltScRG\n\n\t\t\t\t// Special case for blur == 0.0\n\t\t\t\tif (lod == 0.0) {\n\t\t\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\t\treturn texture2DLodEXT( sp, U, 0.0).rgb;\n\t\t\t\t\t#else\n\t\t\t\t\treturn textureLod( sp, U, 0.0).rgb;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec2 texelSize = vec2(1.0) / resolution;\n                vec2 halton = haltonSequence[frameIndex];\n                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n                float temporalAngle  = temporalOffset * PI2;\n\t\t\t\tvec3 res = vec3(0.0);\n                vec2 vUv = vec2(0.0);\n                vec2 offset = vec2(0.0);\n                vec2 vogelSample = vec2(0.0);\n                for (int i = 0; i < NUM_SAMPLES; i++) {\n                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;\n                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20\n                    vUv = U + offset;\n                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, vUv, lod));\n                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {\n                        vUv = unrefractedU;\n                        lod = lod > 4.0 ? lod : lod / 2.0;\n                    }\n                    res += textureLod(sp, vUv, lod).rgb;\n                }\n                return res / float(NUM_SAMPLES);\n            }\nvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\t        // Direction of refracted light.\n\t\t        vec3 refractionVector = refract( -v,  n, 1.0 / ior );\n\t\t        \n\t\t\t\t// Compute rotation-independant scaling of the model matrix.\n\t\t        vec3 modelScale;\n\t\t        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\t        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\t        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t        // The thickness is specified in local space\n\t\t        return normalize( refractionVector ) * thickness * modelScale;\n\t        }\nfloat vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vPosition.x - origin.x) + n.y*(vPosition.y - origin.y) + n.z*(vPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vWPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nvec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {\n\t\t\t\t\tfloat fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );\n\n\t\t\t\t\tfloat lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;\n\t\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\t\treturn color;\n\t\t\t\t}\nvec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {\n\t\t\t\t// Threejs exports do not pass a depth map to this shader, so we have to fallback to the \"Threejs method of blurring\" - see\n\t\t\t\t// also the code in convertTransmission.ts, which runs during export\n\t\t\t\t#ifdef IS_THREEJS_EXPORT\n\t\t\t\t\tfloat lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);\n\t\t\t\t\treturn textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;\n\t\t\t\t#else\n\t\t\t\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t\t\t\tfloat lod = applyIorToRoughness(roughness, ior);\n\t\t\t\t\treturn blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);\n\t\t\t\t#endif\n\t\t\t}\nvec3 gdf5f123cb813444e943da398041aedd4_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[gdf5f123cb813444e943da398041aedd4_MAX_COLORS], float steps[gdf5f123cb813444e943da398041aedd4_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {\n               vec4 color = colors[0];\n               #ifdef gdf5f123cb813444e943da398041aedd4_IS_VECTOR\n                   #ifdef gdf5f123cb813444e943da398041aedd4_LINEAR\n                       #ifdef gdf5f123cb813444e943da398041aedd4_WORLDSPACE\n                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);\n                       #else\n                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);\n                       #endif\n                   #else\n                       #ifdef gdf5f123cb813444e943da398041aedd4_WORLDSPACE\n                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);\n                       #else\n                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);\n                       #endif\n                   #endif\n               #else\n                   float dist = length(vWPosition - cameraPosition);\n\t\t\t       float depth = ( dist - near ) / ( far - near );\n               #endif\n\n\n              float p;\n              #ifdef gdf5f123cb813444e943da398041aedd4_SMOOTH\n\t\t\t\tfor ( int i = 1; i < gdf5f123cb813444e943da398041aedd4_MAX_COLORS; i++ ) {\n\t\t\t\t\t\tp = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );\n\t\t\t\t\t\tcolor = mix(color, colors[i], smoothstep(0.0, 1.0, p));\n\t\t\t\t\t}\n              #else\n                for ( int i = 1; i < gdf5f123cb813444e943da398041aedd4_MAX_COLORS; i++ ) {\n                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);\n                   color = mix(color, colors[i], p);\n                 }\n              #endif\n\n               float lalpha = alpha * color.a * mask;\n               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\t\t\t   \n               return color.rgb;\n\t\t\t}\nvec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\n\t\t\t\tvec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );\n\t\t\t\tvec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;\n\t\t\t\tunrefractedCoords += 1.0;\n\t\t\t\tunrefractedCoords /= 2.0;\n\n\t\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\t\treturn getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );\n    \t\t}\nvec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {\n                vec3 v = vec3(0.);\n                if (isOrthographic) {\n                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n                } else {\n                    v = normalize(vWPosition - cameraPosition);\n                }\n                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );\n                \n\t\t\t\tfloat lalpha = alpha * mask;\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * alpha;\n\n\t\t\t\treturn transmission;\n            }\n\nvoid main() {\n\nfloat g627fa06779964ee1b363313f8e785399_calpha;\nfloat gdf5f123cb813444e943da398041aedd4_calpha;\nfloat g822634f76f5542c4b775088f847f4c89_calpha;\nfloat g7c720394782c4ec7b24545ea3f46a937_calpha;\n\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n\n\t\t\t\t// NOTE: gl_FrontFacing alternative using face normal estimation.\n\t\t\t\tvec3 viewdx = dFdx(vViewPosition);\n\t\t\t\tvec3 viewdy = dFdy(vViewPosition);\n\t\t\t\tvec3 faceNormal = normalize(cross(viewdx,viewdy));\n\t\t\t\tif (dot(normal, faceNormal) < 0.0) {\n\t\t\t\t\tnormal *= -1.0;\n\t\t\t\t}\n\t\t\t\t\n\tBlinnPhongMaterial material;\n\n\tvec3 diffuseColor = spe_blend(spe_blend(spe_blend(transmission(nodeU0,nodeU1,nodeU2,nodeU3,nodeU4,nodeU5,nodeU6,normal,1.0,nodeU7,g627fa06779964ee1b363313f8e785399_calpha),gdf5f123cb813444e943da398041aedd4_sdepth(nodeU8,nodeU9,nodeU10,nodeU11,nodeUA0,nodeUA1,nodeU12,1.0,nodeU13,gdf5f123cb813444e943da398041aedd4_calpha),( gdf5f123cb813444e943da398041aedd4_calpha ),nodeU14),fresnel(nodeU15,nodeU16,nodeU17,nodeU18,nodeU19,nodeU20,1.0,nodeU21,nodeU22,g822634f76f5542c4b775088f847f4c89_calpha),( g822634f76f5542c4b775088f847f4c89_calpha ),nodeU22),fresnel(nodeU23,nodeU24,nodeU25,nodeU26,nodeU27,nodeU28,1.0,nodeU29,nodeU30,g7c720394782c4ec7b24545ea3f46a937_calpha),( g7c720394782c4ec7b24545ea3f46a937_calpha ),nodeU30);\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\tvec3 specular = nodeU31;\n\n\tfloat shininess = max( 0.0001, nodeU32 );\n\tfloat specularStrength = 1.0;\n\n#ifdef ALPHATEST\nif ( nodeU36 <= ALPHATEST ) discard;\n#endif\nmaterial.diffuseColor = diffuseColor;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t\n#endif\n#if ( 1 > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t\n\t\tdirectionalLight = directionalLights[ 0 ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( 0 < 0 )\n\t\tdirectionalLightShadow = directionalLightShadows[ 0 ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( 0, directionalShadowMap[ 0 ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( 1 > 0 )\n\t\t\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\nvec3 ao = aoEnabled && nodeU33 ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);\nvec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t\t\t\tif (outgoingLight != diffuseColor) {\n\t\t\t\t\tfloat lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );\n\t\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * nodeU34 * 1.0 * lightAccu;\n\t\t\t\t\toutgoingLight = spe_blend( diffuseColor, outgoingLight, nodeU34 * 1.0, nodeU35 );\n\t\t\t\t\t\n\t\t\t\t\toutgoingLight *= ao;\n\t\t\t\t}\n\t\t\t\t\ngl_FragColor = vec4( outgoingLight, accumAlpha * nodeU36);\ngl_FragColor.a *= nodeU37;\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_26;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_27;\n    float pad_28;\n    float pad_29;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_30;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_31;\n    float pad_32;\n    float pad_33;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform float3 _emissive : register(c7);\nuniform bool _aoEnabled : register(c8);\nuniform float3 _ambientLightColor : register(c9);\nuniform float3 _lightProbe[9] : register(c10);\nuniform _DirectionalLight _directionalLights[1] : register(c19);\nuniform _HemisphereLight _hemisphereLights[1] : register(c21);\nuniform float4x4 _modelMatrix : register(c24);\nuniform float4x4 _projectionMatrix : register(c28);\nuniform float _nodeU0 : register(c32);\nuniform float _nodeU1 : register(c33);\nuniform float _nodeU2 : register(c34);\nuniform float2 _nodeU3 : register(c35);\nuniform float2 _nodeU6 : register(c36);\nuniform float _nodeU7 : register(c37);\nuniform float _nodeU8 : register(c38);\nuniform float _nodeU9 : register(c39);\nuniform float3 _nodeU10 : register(c40);\nuniform float3 _nodeU11 : register(c41);\nuniform bool _nodeU12 : register(c42);\nuniform float _nodeU13 : register(c43);\nuniform int _nodeU14 : register(c44);\nuniform float3 _nodeU15 : register(c45);\nuniform float _nodeU16 : register(c46);\nuniform float _nodeU17 : register(c47);\nuniform float _nodeU18 : register(c48);\nuniform float _nodeU19 : register(c49);\nuniform bool _nodeU20 : register(c50);\nuniform float _nodeU21 : register(c51);\nuniform int _nodeU22 : register(c52);\nuniform float3 _nodeU23 : register(c53);\nuniform float _nodeU24 : register(c54);\nuniform float _nodeU25 : register(c55);\nuniform float _nodeU26 : register(c56);\nuniform float _nodeU27 : register(c57);\nuniform bool _nodeU28 : register(c58);\nuniform float _nodeU29 : register(c59);\nuniform int _nodeU30 : register(c60);\nuniform float3 _nodeU31 : register(c61);\nuniform float _nodeU32 : register(c62);\nuniform bool _nodeU33 : register(c63);\nuniform float _nodeU34 : register(c64);\nuniform int _nodeU35 : register(c65);\nuniform float _nodeU36 : register(c66);\nuniform float _nodeU37 : register(c67);\nuniform float4 _nodeUA0[4] : register(c68);\nuniform float _nodeUA1[4] : register(c72);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nstatic float _accumAlpha = {0.0};\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2708 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2708)) + (_f90 * _fresnel2708));\n}\nfloat f_G_BlinnPhong_Implicit()\n{\nreturn 0.25;\n}\nfloat f_D_BlinnPhong(const float _shininess, const float _dotNH)\n{\nreturn ((0.31830987 * ((_shininess * 0.5) + 1.0)) * pow(_dotNH, _shininess));\n}\nfloat3 f_BRDF_BlinnPhong(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _specularColor, const float _shininess)\n{\nfloat3 _halfDir2795 = normalize((_lightDir + _viewDir));\nfloat _dotNH2796 = clamp(dot(_normal, _halfDir2795), 0.0, 1.0);\nfloat _dotVH2797 = clamp(dot(_viewDir, _halfDir2795), 0.0, 1.0);\nfloat3 _F2798 = f_F_Schlick(_specularColor, 1.0, _dotVH2797);\nfloat _G2799 = f_G_BlinnPhong_Implicit();\nfloat _D2800 = f_D_BlinnPhong(_shininess, _dotNH2796);\nreturn (_F2798 * (_G2799 * _D2800));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2807 = _normal.x;\nfloat _y2808 = _normal.y;\nfloat _z2809 = _normal.z;\nfloat3 _result2810 = (_shCoefficients[0] * 0.88622701);\n(_result2810 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2808));\n(_result2810 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2809));\n(_result2810 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2807));\n(_result2810 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2807) * _y2808));\n(_result2810 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2808) * _z2809));\n(_result2810 += (_shCoefficients[6] * (((0.74312502 * _z2809) * _z2809) - 0.24770799)));\n(_result2810 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2807) * _z2809));\n(_result2810 += ((_shCoefficients[8] * 0.42904299) * ((_x2807 * _x2807) - (_y2808 * _y2808))));\nreturn _result2810;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2814 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2815 = f_shGetIrradianceAt(_worldNormal2814, _lightProbe);\nreturn _irradiance2815;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2818 = _ambientLightColor;\nreturn _irradiance2818;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2840 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2841 = ((0.5 * _dotNL2840) + 0.5);\nfloat3 _irradiance2842 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2841);\nreturn _irradiance2842;\n}\n;\nvoid f_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2851 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2852 = (_dotNL2851 * _directLight._color);\n(_reflectedLight._directDiffuse += (_irradiance2852 * f_BRDF_Lambert(_material._diffuseColor)));\n(_reflectedLight._directSpecular += ((_irradiance2852 * f_BRDF_BlinnPhong(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularShininess)) * _material._specularStrength));\n}\nvoid f_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2864 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2865 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2865 = lerp((2.0 * _dither_shift_RGB2865), (-2.0 * _dither_shift_RGB2865), _grid_position2864));\nreturn (_color + _dither_shift_RGB2865);\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2933 = floor(_vUv);\nfloat2 _fuv2934 = frac(_vUv);\nfloat _g0x2935 = f_g0(_fuv2934.x);\nfloat _g1x2936 = f_g1(_fuv2934.x);\nfloat _h0x2937 = f_h0(_fuv2934.x);\nfloat _h1x2938 = f_h1(_fuv2934.x);\nfloat _h0y2939 = f_h0(_fuv2934.y);\nfloat _h1y2940 = f_h1(_fuv2934.y);\nfloat2 _p02941 = ((vec2_ctor((_iuv2933.x + _h0x2937), (_iuv2933.y + _h0y2939)) - 0.5) * _texelSize.xy);\nfloat2 _p12942 = ((vec2_ctor((_iuv2933.x + _h1x2938), (_iuv2933.y + _h0y2939)) - 0.5) * _texelSize.xy);\nfloat2 _p22943 = ((vec2_ctor((_iuv2933.x + _h0x2937), (_iuv2933.y + _h1y2940)) - 0.5) * _texelSize.xy);\nfloat2 _p32944 = ((vec2_ctor((_iuv2933.x + _h1x2938), (_iuv2933.y + _h1y2940)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2934.y) * ((_g0x2935 * gl_texture2DLod(_tex, _p02941, _lod)) + (_g1x2936 * gl_texture2DLod(_tex, _p12942, _lod)))) + (f_g1(_fuv2934.y) * ((_g0x2935 * gl_texture2DLod(_tex, _p22943, _lod)) + (_g1x2936 * gl_texture2DLod(_tex, _p32944, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize2949 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize2950 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv2951 = (1.0 / _fLodSize2949);\nfloat2 _cLodSizeInv2952 = (1.0 / _cLodSize2950);\nfloat4 _fSample2953 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv2951, _fLodSize2949), floor(_lod));\nfloat4 _cSample2954 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv2952, _cLodSize2950), ceil(_lod));\nreturn lerp(_fSample2953, _cSample2954, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector2982 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale2983 = {0, 0, 0};\n(_modelScale2983.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale2983.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale2983.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector2982) * _thickness) * _modelScale2983);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist3002 = length((_vPosition - _origin));\nreturn ((_dist3002 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3019 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3020 = ((clamp(_fresnel3019, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3020 / clamp((_lalpha3020 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3020, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3020) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3030 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3030).xyz;\n}\nfloat3 f_gdf5f123cb813444e943da398041aedd4_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3042 = _colors[0];\nfloat _depth3043 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3044 = {0};\n{ for(int _i3045 = {1}; (_i3045 < 4); (_i3045++))\n{\n(_p3044 = clamp(((_depth3043 - _steps[(_i3045 - 1)]) / (_steps[_i3045] - _steps[(_i3045 - 1)])), 0.0, 1.0));\n(_color3042 = lerp(_color3042, _colors[_i3045], _p3044));\n}\n}\nfloat _lalpha3046 = ((_alpha * _color3042.w) * _mask);\n(_calpha = lerp((_lalpha3046 / clamp((_lalpha3046 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3046, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3046) * (1.0 - float_ctor(_isMask))));\nreturn _color3042.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3061 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3062 = (_position + _transmissionRay3061);\nfloat4 _ndcPos3063 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3062, 1.0));\nfloat2 _refractionCoords3064 = (_ndcPos3063.xy / _ndcPos3063.w);\n(_refractionCoords3064 += 1.0);\n(_refractionCoords3064 /= 2.0);\nfloat4 _ndcPosUnrefracted3065 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3066 = (_ndcPosUnrefracted3065.xy / _ndcPosUnrefracted3065.w);\n(_unrefractedCoords3066 += 1.0);\n(_unrefractedCoords3066 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3064, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3066, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3079 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3079 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3079 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3080 = f_getIBLVolumeRefraction(_vWNormal, (-_v3079), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3081 = (_alpha * _mask);\n(_calpha = (_lalpha3081 / clamp((_lalpha3081 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3080;\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat _g627fa06779964ee1b363313f8e785399_calpha3083 = {0};\nfloat _gdf5f123cb813444e943da398041aedd4_calpha3084 = {0};\nfloat _g822634f76f5542c4b775088f847f4c89_calpha3085 = {0};\nfloat _g7c720394782c4ec7b24545ea3f46a937_calpha3086 = {0};\nfloat3 _normal3088 = normalize(_vNormal);\nfloat3 _viewdx3090 = ddx(_vViewPosition);\nfloat3 _viewdy3091 = ddy(_vViewPosition);\nfloat3 _faceNormal3092 = normalize(cross(_viewdx3090, _viewdy3091));\nif ((dot(_normal3088, _faceNormal3092) < 0.0))\n{\n(_normal3088 *= -1.0);\n}\n_BlinnPhongMaterial _material3093 = {0, 0, 0, 0, 0, 0, 0, 0};\nfloat3 _diffuseColor3094 = f_spe_blend_int(f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3088, 1.0, _nodeU7, _g627fa06779964ee1b363313f8e785399_calpha3083), f_gdf5f123cb813444e943da398041aedd4_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _gdf5f123cb813444e943da398041aedd4_calpha3084), _gdf5f123cb813444e943da398041aedd4_calpha3084, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _g822634f76f5542c4b775088f847f4c89_calpha3085), _g822634f76f5542c4b775088f847f4c89_calpha3085, _nodeU22), f_fresnel_int(_nodeU23, _nodeU24, _nodeU25, _nodeU26, _nodeU27, _nodeU28, 1.0, _nodeU29, _nodeU30, _g7c720394782c4ec7b24545ea3f46a937_calpha3086), _g7c720394782c4ec7b24545ea3f46a937_calpha3086, _nodeU30);\n_ReflectedLight _reflectedLight3095 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 _totalEmissiveRadiance3096 = _emissive;\nfloat3 _specular3097 = _nodeU31;\nfloat _shininess3098 = max(9.9999997e-05, _nodeU32);\nfloat _specularStrength3099 = {1.0};\n(_material3093._diffuseColor = _diffuseColor3094);\n(_material3093._specularColor = _specular3097);\n(_material3093._specularShininess = _shininess3098);\n(_material3093._specularStrength = _specularStrength3099);\n_GeometricContext _geometry3100 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry3100._position = (-_vViewPosition));\n(_geometry3100._normal = _normal3088);\nfloat3 sc24 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sc24 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sc24 = normalize(_vViewPosition));\n}\n(_geometry3100._viewDir = sc24);\n_IncidentLight _directLight3101 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight3102 = {0, 0, 0, 0, 0, 0};\n(_directionalLight3102 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight3102, _geometry3100, _directLight3101);\nf_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(_directLight3101, _geometry3100, _material3093, _reflectedLight3095);\nfloat3 _irradiance3104 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance3104 += f_getLightProbeIrradiance(_lightProbe, _geometry3100._normal));\n(_irradiance3104 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry3100._normal));\nf_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(_irradiance3104, _geometry3100, _material3093, _reflectedLight3095);\nfloat3 sc25 = {0, 0, 0};\nif ((_aoEnabled && _nodeU33))\n{\n(sc25 = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc25 = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3105 = sc25;\nfloat3 _outgoingLight3106 = ((((_reflectedLight3095._directDiffuse + _reflectedLight3095._indirectDiffuse) + _reflectedLight3095._directSpecular) + _reflectedLight3095._indirectSpecular) + _totalEmissiveRadiance3096);\nif (!all(_outgoingLight3106 == _diffuseColor3094))\n{\nfloat _lightAccu3107 = clamp(length((_reflectedLight3095._directSpecular + _reflectedLight3095._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU34) * 1.0) * _lightAccu3107));\n(_outgoingLight3106 = f_spe_blend_int(_diffuseColor3094, _outgoingLight3106, (_nodeU34 * 1.0), _nodeU35));\n(_outgoingLight3106 *= _ao3105);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3106, (_accumAlpha * _nodeU36)));\n(out_pc_fragColor.w *= _nodeU37);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD6;\n    float4 gl_FragCoord : TEXCOORD7;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_26;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_27;\n    float pad_28;\n    float pad_29;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_30;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_31;\n    float pad_32;\n    float pad_33;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform float3 _emissive : register(c7);\nuniform bool _aoEnabled : register(c8);\nuniform float3 _ambientLightColor : register(c9);\nuniform float3 _lightProbe[9] : register(c10);\nuniform _DirectionalLight _directionalLights[1] : register(c19);\nuniform _HemisphereLight _hemisphereLights[1] : register(c21);\nuniform float4x4 _modelMatrix : register(c24);\nuniform float4x4 _projectionMatrix : register(c28);\nuniform float _nodeU0 : register(c32);\nuniform float _nodeU1 : register(c33);\nuniform float _nodeU2 : register(c34);\nuniform float2 _nodeU3 : register(c35);\nuniform float2 _nodeU6 : register(c36);\nuniform float _nodeU7 : register(c37);\nuniform float _nodeU8 : register(c38);\nuniform float _nodeU9 : register(c39);\nuniform float3 _nodeU10 : register(c40);\nuniform float3 _nodeU11 : register(c41);\nuniform bool _nodeU12 : register(c42);\nuniform float _nodeU13 : register(c43);\nuniform int _nodeU14 : register(c44);\nuniform float3 _nodeU15 : register(c45);\nuniform float _nodeU16 : register(c46);\nuniform float _nodeU17 : register(c47);\nuniform float _nodeU18 : register(c48);\nuniform float _nodeU19 : register(c49);\nuniform bool _nodeU20 : register(c50);\nuniform float _nodeU21 : register(c51);\nuniform int _nodeU22 : register(c52);\nuniform float3 _nodeU23 : register(c53);\nuniform float _nodeU24 : register(c54);\nuniform float _nodeU25 : register(c55);\nuniform float _nodeU26 : register(c56);\nuniform float _nodeU27 : register(c57);\nuniform bool _nodeU28 : register(c58);\nuniform float _nodeU29 : register(c59);\nuniform int _nodeU30 : register(c60);\nuniform float3 _nodeU31 : register(c61);\nuniform float _nodeU32 : register(c62);\nuniform bool _nodeU33 : register(c63);\nuniform float _nodeU34 : register(c64);\nuniform int _nodeU35 : register(c65);\nuniform float _nodeU36 : register(c66);\nuniform float _nodeU37 : register(c67);\nuniform float4 _nodeUA0[4] : register(c68);\nuniform float _nodeUA1[4] : register(c72);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nstatic float _accumAlpha = {0.0};\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2708 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2708)) + (_f90 * _fresnel2708));\n}\nfloat f_G_BlinnPhong_Implicit()\n{\nreturn 0.25;\n}\nfloat f_D_BlinnPhong(const float _shininess, const float _dotNH)\n{\nreturn ((0.31830987 * ((_shininess * 0.5) + 1.0)) * pow(_dotNH, _shininess));\n}\nfloat3 f_BRDF_BlinnPhong(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _specularColor, const float _shininess)\n{\nfloat3 _halfDir2795 = normalize((_lightDir + _viewDir));\nfloat _dotNH2796 = clamp(dot(_normal, _halfDir2795), 0.0, 1.0);\nfloat _dotVH2797 = clamp(dot(_viewDir, _halfDir2795), 0.0, 1.0);\nfloat3 _F2798 = f_F_Schlick(_specularColor, 1.0, _dotVH2797);\nfloat _G2799 = f_G_BlinnPhong_Implicit();\nfloat _D2800 = f_D_BlinnPhong(_shininess, _dotNH2796);\nreturn (_F2798 * (_G2799 * _D2800));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2807 = _normal.x;\nfloat _y2808 = _normal.y;\nfloat _z2809 = _normal.z;\nfloat3 _result2810 = (_shCoefficients[0] * 0.88622701);\n(_result2810 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2808));\n(_result2810 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2809));\n(_result2810 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2807));\n(_result2810 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2807) * _y2808));\n(_result2810 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2808) * _z2809));\n(_result2810 += (_shCoefficients[6] * (((0.74312502 * _z2809) * _z2809) - 0.24770799)));\n(_result2810 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2807) * _z2809));\n(_result2810 += ((_shCoefficients[8] * 0.42904299) * ((_x2807 * _x2807) - (_y2808 * _y2808))));\nreturn _result2810;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2814 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2815 = f_shGetIrradianceAt(_worldNormal2814, _lightProbe);\nreturn _irradiance2815;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2818 = _ambientLightColor;\nreturn _irradiance2818;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2840 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2841 = ((0.5 * _dotNL2840) + 0.5);\nfloat3 _irradiance2842 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2841);\nreturn _irradiance2842;\n}\n;\nvoid f_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2851 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2852 = (_dotNL2851 * _directLight._color);\n(_reflectedLight._directDiffuse += (_irradiance2852 * f_BRDF_Lambert(_material._diffuseColor)));\n(_reflectedLight._directSpecular += ((_irradiance2852 * f_BRDF_BlinnPhong(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularShininess)) * _material._specularStrength));\n}\nvoid f_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2864 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2865 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2865 = lerp((2.0 * _dither_shift_RGB2865), (-2.0 * _dither_shift_RGB2865), _grid_position2864));\nreturn (_color + _dither_shift_RGB2865);\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2933 = floor(_vUv);\nfloat2 _fuv2934 = frac(_vUv);\nfloat _g0x2935 = f_g0(_fuv2934.x);\nfloat _g1x2936 = f_g1(_fuv2934.x);\nfloat _h0x2937 = f_h0(_fuv2934.x);\nfloat _h1x2938 = f_h1(_fuv2934.x);\nfloat _h0y2939 = f_h0(_fuv2934.y);\nfloat _h1y2940 = f_h1(_fuv2934.y);\nfloat2 _p02941 = ((vec2_ctor((_iuv2933.x + _h0x2937), (_iuv2933.y + _h0y2939)) - 0.5) * _texelSize.xy);\nfloat2 _p12942 = ((vec2_ctor((_iuv2933.x + _h1x2938), (_iuv2933.y + _h0y2939)) - 0.5) * _texelSize.xy);\nfloat2 _p22943 = ((vec2_ctor((_iuv2933.x + _h0x2937), (_iuv2933.y + _h1y2940)) - 0.5) * _texelSize.xy);\nfloat2 _p32944 = ((vec2_ctor((_iuv2933.x + _h1x2938), (_iuv2933.y + _h1y2940)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2934.y) * ((_g0x2935 * gl_texture2DLod(_tex, _p02941, _lod)) + (_g1x2936 * gl_texture2DLod(_tex, _p12942, _lod)))) + (f_g1(_fuv2934.y) * ((_g0x2935 * gl_texture2DLod(_tex, _p22943, _lod)) + (_g1x2936 * gl_texture2DLod(_tex, _p32944, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize2949 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize2950 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv2951 = (1.0 / _fLodSize2949);\nfloat2 _cLodSizeInv2952 = (1.0 / _cLodSize2950);\nfloat4 _fSample2953 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv2951, _fLodSize2949), floor(_lod));\nfloat4 _cSample2954 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv2952, _cLodSize2950), ceil(_lod));\nreturn lerp(_fSample2953, _cSample2954, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector2982 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale2983 = {0, 0, 0};\n(_modelScale2983.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale2983.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale2983.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector2982) * _thickness) * _modelScale2983);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist3002 = length((_vPosition - _origin));\nreturn ((_dist3002 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3019 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3020 = ((clamp(_fresnel3019, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3020 / clamp((_lalpha3020 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3020, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3020) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3030 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3030).xyz;\n}\nfloat3 f_gdf5f123cb813444e943da398041aedd4_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3042 = _colors[0];\nfloat _depth3043 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3044 = {0};\n{ for(int _i3045 = {1}; (_i3045 < 4); (_i3045++))\n{\n(_p3044 = clamp(((_depth3043 - _steps[(_i3045 - 1)]) / (_steps[_i3045] - _steps[(_i3045 - 1)])), 0.0, 1.0));\n(_color3042 = lerp(_color3042, _colors[_i3045], _p3044));\n}\n}\nfloat _lalpha3046 = ((_alpha * _color3042.w) * _mask);\n(_calpha = lerp((_lalpha3046 / clamp((_lalpha3046 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3046, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3046) * (1.0 - float_ctor(_isMask))));\nreturn _color3042.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3061 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3062 = (_position + _transmissionRay3061);\nfloat4 _ndcPos3063 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3062, 1.0));\nfloat2 _refractionCoords3064 = (_ndcPos3063.xy / _ndcPos3063.w);\n(_refractionCoords3064 += 1.0);\n(_refractionCoords3064 /= 2.0);\nfloat4 _ndcPosUnrefracted3065 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3066 = (_ndcPosUnrefracted3065.xy / _ndcPosUnrefracted3065.w);\n(_unrefractedCoords3066 += 1.0);\n(_unrefractedCoords3066 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3064, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3066, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3079 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3079 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3079 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3080 = f_getIBLVolumeRefraction(_vWNormal, (-_v3079), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3081 = (_alpha * _mask);\n(_calpha = (_lalpha3081 / clamp((_lalpha3081 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3080;\n}\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input){\n    float rhw = 1.0 / input.gl_FragCoord.w;\n    gl_FragCoord.x = input.dx_Position.x - dx_FragCoordOffset.x;\n    gl_FragCoord.y = input.dx_Position.y - dx_FragCoordOffset.y;\n    gl_FragCoord.z = input.dx_Position.z;\n    gl_FragCoord.w = rhw;\n    _vViewPosition = input.v0.xyz;\n    _vWPosition = input.v1.xyz;\n    _vNormal = input.v2.xyz;\n    _vPosition = input.v3.xyz;\n    _vWNormal = input.v4.xyz;\n    _vWorldViewDir = input.v5.xyz;\n\nfloat _g627fa06779964ee1b363313f8e785399_calpha3083 = {0};\nfloat _gdf5f123cb813444e943da398041aedd4_calpha3084 = {0};\nfloat _g822634f76f5542c4b775088f847f4c89_calpha3085 = {0};\nfloat _g7c720394782c4ec7b24545ea3f46a937_calpha3086 = {0};\nfloat3 _normal3088 = normalize(_vNormal);\nfloat3 _viewdx3090 = ddx(_vViewPosition);\nfloat3 _viewdy3091 = ddy(_vViewPosition);\nfloat3 _faceNormal3092 = normalize(cross(_viewdx3090, _viewdy3091));\nif ((dot(_normal3088, _faceNormal3092) < 0.0))\n{\n(_normal3088 *= -1.0);\n}\n_BlinnPhongMaterial _material3093 = {0, 0, 0, 0, 0, 0, 0, 0};\nfloat3 _diffuseColor3094 = f_spe_blend_int(f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3088, 1.0, _nodeU7, _g627fa06779964ee1b363313f8e785399_calpha3083), f_gdf5f123cb813444e943da398041aedd4_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _gdf5f123cb813444e943da398041aedd4_calpha3084), _gdf5f123cb813444e943da398041aedd4_calpha3084, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _g822634f76f5542c4b775088f847f4c89_calpha3085), _g822634f76f5542c4b775088f847f4c89_calpha3085, _nodeU22), f_fresnel_int(_nodeU23, _nodeU24, _nodeU25, _nodeU26, _nodeU27, _nodeU28, 1.0, _nodeU29, _nodeU30, _g7c720394782c4ec7b24545ea3f46a937_calpha3086), _g7c720394782c4ec7b24545ea3f46a937_calpha3086, _nodeU30);\n_ReflectedLight _reflectedLight3095 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 _totalEmissiveRadiance3096 = _emissive;\nfloat3 _specular3097 = _nodeU31;\nfloat _shininess3098 = max(9.9999997e-05, _nodeU32);\nfloat _specularStrength3099 = {1.0};\n(_material3093._diffuseColor = _diffuseColor3094);\n(_material3093._specularColor = _specular3097);\n(_material3093._specularShininess = _shininess3098);\n(_material3093._specularStrength = _specularStrength3099);\n_GeometricContext _geometry3100 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry3100._position = (-_vViewPosition));\n(_geometry3100._normal = _normal3088);\nfloat3 sc24 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sc24 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sc24 = normalize(_vViewPosition));\n}\n(_geometry3100._viewDir = sc24);\n_IncidentLight _directLight3101 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight3102 = {0, 0, 0, 0, 0, 0};\n(_directionalLight3102 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight3102, _geometry3100, _directLight3101);\nf_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(_directLight3101, _geometry3100, _material3093, _reflectedLight3095);\nfloat3 _irradiance3104 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance3104 += f_getLightProbeIrradiance(_lightProbe, _geometry3100._normal));\n(_irradiance3104 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry3100._normal));\nf_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(_irradiance3104, _geometry3100, _material3093, _reflectedLight3095);\nfloat3 sc25 = {0, 0, 0};\nif ((_aoEnabled && _nodeU33))\n{\n(sc25 = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc25 = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3105 = sc25;\nfloat3 _outgoingLight3106 = ((((_reflectedLight3095._directDiffuse + _reflectedLight3095._indirectDiffuse) + _reflectedLight3095._directSpecular) + _reflectedLight3095._indirectSpecular) + _totalEmissiveRadiance3096);\nif (!all(_outgoingLight3106 == _diffuseColor3094))\n{\nfloat _lightAccu3107 = clamp(length((_reflectedLight3095._directSpecular + _reflectedLight3095._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU34) * 1.0) * _lightAccu3107));\n(_outgoingLight3106 = f_spe_blend_int(_diffuseColor3094, _outgoingLight3106, (_nodeU34 * 1.0), _nodeU35));\n(_outgoingLight3106 *= _ao3105);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3106, (_accumAlpha * _nodeU36)));\n(out_pc_fragColor.w *= _nodeU37);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                            }
                        ]
                    },
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLProgram - ID: 5",
                        "id": 5,
                        "typeName": "WebGLProgram"
                    }
                }
            ],
            "commandEndTime": 1732773587783.2,
            "endTime": 1732773587783.8,
            "id": 33,
            "name": "useProgram",
            "stackTrace": [
                "Object.useProgram (https://unpkg.com/three@0.149.0/build/three.module.js:21720:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28554:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587783.2,
            "status": 0,
            "text": "useProgram: WebGLProgram - ID: 5"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 140",
                        "id": 140,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                {
                    "0": 0,
                    "1": 0,
                    "2": 0,
                    "3": 0,
                    "4": 0,
                    "5": 0,
                    "6": 0,
                    "7": 0,
                    "8": 0,
                    "9": 0,
                    "10": 0,
                    "11": 0,
                    "12": 0,
                    "13": 0,
                    "14": 0,
                    "15": 0,
                    "16": 0,
                    "17": 0,
                    "18": 0,
                    "19": 0,
                    "20": 0,
                    "21": 0,
                    "22": 0,
                    "23": 0,
                    "24": 0,
                    "25": 0,
                    "26": 0
                }
            ],
            "commandEndTime": 1732773587783.8,
            "endTime": 1732773587783.9,
            "id": 34,
            "name": "uniform3fv",
            "stackTrace": [
                "PureArrayUniform.setValueV3fArray [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17760:5)",
                "WebGLUniforms.upload (https://unpkg.com/three@0.149.0/build/three.module.js:18187:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28724:18)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773587783.8,
            "status": 0,
            "text": "uniform3fv: WebGLUniformLocation - ID: 140, [..(27)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 182",
                        "id": 182,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                {
                    "0": 0,
                    "1": 0.21835188567638397,
                    "2": 0.5038889646530151,
                    "3": 1,
                    "4": 0.09380099922418594,
                    "5": 0.17632801830768585,
                    "6": 0.34138205647468567,
                    "7": 1,
                    "8": 0.033324576914310455,
                    "9": 0.10843804478645325,
                    "10": 0.21563883125782013,
                    "11": 1,
                    "12": 0.03739052265882492,
                    "13": 0.05459984391927719,
                    "14": 0.10192546993494034,
                    "15": 1
                }
            ],
            "commandEndTime": 1732773587783.9,
            "endTime": 1732773587784,
            "id": 35,
            "name": "uniform4fv",
            "stackTrace": [
                "PureArrayUniform.setValueV4fArray [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17768:5)",
                "WebGLUniforms.upload (https://unpkg.com/three@0.149.0/build/three.module.js:18187:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28724:18)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773587783.9,
            "status": 0,
            "text": "uniform4fv: WebGLUniformLocation - ID: 182, [..(16)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 183",
                        "id": 183,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                [
                    0,
                    0.2630236231752599,
                    0.5813861864448849,
                    0.9511203746788479
                ]
            ],
            "commandEndTime": 1732773587784,
            "endTime": 1732773587784,
            "id": 36,
            "name": "uniform1fv",
            "stackTrace": [
                "PureArrayUniform.setValueV1fArray [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17742:5)",
                "WebGLUniforms.upload (https://unpkg.com/three@0.149.0/build/three.module.js:18187:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28724:18)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773587784,
            "status": 0,
            "text": "uniform1fv: WebGLUniformLocation - ID: 183, [..(4)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 5",
                        "id": 5,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773587784.1,
            "endTime": 1732773587784.1,
            "id": 37,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587784,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 5"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 268644,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 7",
                                "id": 7,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 268644,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 268644,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 8",
                                "id": 8,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 268644,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 1,
                        "name": "normal",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 2,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 179096,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 9",
                                "id": 9,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 179096,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 2,
                        "name": "uv",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 8,
                        "type": "FLOAT_VEC2",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "elementArray": {
                    "arrayBuffer": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 239976,
                            "target": "ELEMENT_ARRAY_BUFFER",
                            "usage": 35044
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLBuffer - ID: 14",
                            "id": 14,
                            "typeName": "WebGLBuffer"
                        }
                    }
                },
                "frameBuffer": null,
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 65448,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "NodeMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define PHONG 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define gdf5f123cb813444e943da398041aedd4_MAX_COLORS 4\n#define gdf5f123cb813444e943da398041aedd4_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define VERTEX_TEXTURES\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat neighbor_offset = 0.0001;\n\nuniform int frameIndex;\nuniform vec2 resolution;\nuniform mat4 previousModelViewMatrix;\nuniform mat4 previousProjectionMatrix;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\n\n\n\n\n\nvoid main() {\n\n\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t\t\t\t#endif\n\n\n\t\t\t\tvec3 displaced_position = position;\n\t\t\t\tvec3 displaced_normal = objectNormal;\n\n\t\t\t\t#ifdef USE_LAYER_DISPLACE\n\t\t\t\t\tvec3 transformed;\n\t\t\t\t\tvec3 transformedNormal;\n\t\t\t\t#endif\n\t\t\t\t\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\nvec3 transformed = vec3( position );\n\t\t\t\t#endif\n\t\t\t\t\ntransformed = displaced_position;\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\ntransformedNormal = normalMatrix * displaced_normal;\n#ifndef FLAT_SHADED\n    vNormal = transformedNormal;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\nvWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;\nvUv = uv;\nvPosition = transformed;\nvWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;\nvWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );\n\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2691 = vec3_ctor(_normal);\nfloat3 _transformedNormal2692 = _objectNormal2691;\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _transformedNormal2692));\nfloat3 _displaced_position2693 = _position;\nfloat3 _displaced_normal2694 = _objectNormal2691;\n(_vNormal = normalize(_transformedNormal2692));\nfloat3 _transformed2695 = vec3_ctor(_position);\n(_transformed2695 = _displaced_position2693);\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _displaced_normal2694));\n(_vNormal = _transformedNormal2692);\nfloat4 _mvPosition2696 = vec4_ctor(_transformed2695, 1.0);\n(_mvPosition2696 = mul(transpose(_modelViewMatrix), _mvPosition2696));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2696));\n(_vViewPosition = (-_mvPosition2696.xyz));\nfloat4 _worldPosition2697 = vec4_ctor(_transformed2695, 1.0);\n(_worldPosition2697 = mul(transpose(_modelMatrix), _worldPosition2697));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2695, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2695);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2692, _viewMatrix).xyz);\nfloat3 sa8a = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sa8a = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sa8a = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sa8a);\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD6;\n    float4 gl_FragCoord : TEXCOORD7;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n};\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _normal : TEXCOORD1;\n    float2 _uv : TEXCOORD2;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _normal = input._normal;\n    _uv = input._uv;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.gl_FragCoord = gl_Position;\n    output.v0 = _vViewPosition;\n    output.v1 = _vWPosition;\n    output.v2 = _vNormal;\n    output.v3 = _vPosition;\n    output.v4 = _vWNormal;\n    output.v5 = _vWorldViewDir;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2691 = vec3_ctor(_normal);\nfloat3 _transformedNormal2692 = _objectNormal2691;\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _transformedNormal2692));\nfloat3 _displaced_position2693 = _position;\nfloat3 _displaced_normal2694 = _objectNormal2691;\n(_vNormal = normalize(_transformedNormal2692));\nfloat3 _transformed2695 = vec3_ctor(_position);\n(_transformed2695 = _displaced_position2693);\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _displaced_normal2694));\n(_vNormal = _transformedNormal2692);\nfloat4 _mvPosition2696 = vec4_ctor(_transformed2695, 1.0);\n(_mvPosition2696 = mul(transpose(_modelViewMatrix), _mvPosition2696));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2696));\n(_vViewPosition = (-_mvPosition2696.xyz));\nfloat4 _worldPosition2697 = vec4_ctor(_transformed2695, 1.0);\n(_worldPosition2697 = mul(transpose(_modelMatrix), _worldPosition2697));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2695, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2695);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2692, _viewMatrix).xyz);\nfloat3 sa8a = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sa8a = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sa8a = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sa8a);\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "NodeMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define PHONG 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define gdf5f123cb813444e943da398041aedd4_MAX_COLORS 4\n#define gdf5f123cb813444e943da398041aedd4_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define DITHERING\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat accumAlpha = 0.0;\nvoid accumulateAlpha(float alpha) {\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * alpha;\n\t\t\t\t}\n\nlayout(location = 1) out vec4 gVelocity;\n\nuniform int frameIndex;\nuniform vec2 resolution;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nconst vec2 haltonSequence[16] = vec2[16](\nvec2( 0.000000,-0.333334),\nvec2(-0.500000, 0.333334),\nvec2( 0.500000,-0.777778),\nvec2(-0.750000,-0.111112),\nvec2( 0.250000, 0.555556),\nvec2(-0.250000,-0.555556),\nvec2( 0.750000, 0.111112),\nvec2(-0.875000, 0.777778),\nvec2(0.125000, -0.925926),\nvec2(-0.375000, -0.259260),\nvec2(0.625000, 0.407408),\nvec2(-0.625000, -0.703704),\nvec2(0.375000, -0.037038),\nvec2(-0.125000, 0.629630),\nvec2(0.875000, -0.481482),\nvec2(-0.937500, 0.185186));\n\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n  const float goldenAngle = 2.399963f; // radians\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n  float theta = float(sampleIndex) * goldenAngle + angle;\n  float sine = sin(theta);\n  float cosine = cos(theta);\n  return vec2(cosine, sine) * r;\n}\n\n// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso\nfloat getNoiseInterleavedGradient(vec2 screenPos) {\n    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);\n    return fract(magic.z * fract(dot(screenPos, magic.xy)));\n}\n\n\nvarying vec3 vWPosition;\nuniform vec3 emissive;\nuniform float penumbraSize[5];\nuniform sampler2D aoMap;\nuniform bool aoEnabled;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\nvarying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\nuniform float nodeU0;\nuniform float nodeU1;\nuniform float nodeU2;\nuniform vec2 nodeU3;\nuniform sampler2D nodeU4;\nuniform sampler2D nodeU5;\nuniform vec2 nodeU6;\nuniform float nodeU7;\nuniform float nodeU8;\nuniform float nodeU9;\nuniform vec3 nodeU10;\nuniform vec3 nodeU11;\nuniform bool nodeU12;\nuniform float nodeU13;\nuniform int nodeU14;\nuniform vec3 nodeU15;\nuniform float nodeU16;\nuniform float nodeU17;\nuniform float nodeU18;\nuniform float nodeU19;\nuniform bool nodeU20;\nuniform float nodeU21;\nuniform int nodeU22;\nuniform vec3 nodeU23;\nuniform float nodeU24;\nuniform float nodeU25;\nuniform float nodeU26;\nuniform float nodeU27;\nuniform bool nodeU28;\nuniform float nodeU29;\nuniform int nodeU30;\nuniform vec3 nodeU31;\nuniform float nodeU32;\nuniform bool nodeU33;\nuniform float nodeU34;\nuniform int nodeU35;\nuniform float nodeU36;\nuniform float nodeU37;\n\nuniform vec4 nodeUA0[4];\nuniform float nodeUA1[4];\n\n\n\nfloat w0( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n        }\n    \n        float w1( float a ) {\n            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n        }\n    \n        float w2( float a ){\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n        }\n    \n        float w3( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * a * a );\n        }\n    \n        // g0 and g1 are the two amplitude functions\n        float g0( float a ) {\n            return w0( a ) + w1( a );\n        }\n    \n        float g1( float a ) {\n            return w2( a ) + w3( a );\n        }\n    \n        // h0 and h1 are the two offset functions\n        float h0( float a ) {\n            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n        }\n    \n        float h1( float a ) {\n            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n        }\n    \n        vec4 bicubic( sampler2D tex, vec2 vUv, vec4 texelSize, float lod ) {\n            vUv = vUv * texelSize.zw + 0.5;\n    \n            vec2 iuv = floor( vUv );\n            vec2 fuv = fract( vUv );\n    \n            float g0x = g0( fuv.x );\n            float g1x = g1( fuv.x );\n            float h0x = h0( fuv.x );\n            float h1x = h1( fuv.x );\n            float h0y = h0( fuv.y );\n            float h1y = h1( fuv.y );\n    \n            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n    \n            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + \n                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n        }\n\n        vec4 textureBicubic( sampler2D sampler, vec2 vUv, float lod ) {\n            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n            vec2 fLodSizeInv = 1.0 / fLodSize;\n            vec2 cLodSizeInv = 1.0 / cLodSize;\n            vec4 fSample = bicubic( sampler, vUv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n            vec4 cSample = bicubic( sampler, vUv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n            return mix( fSample, cSample, fract( lod ) );\n        }\nfloat applyIorToRoughness( float roughness, float ior ) {\n\t\t\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\t\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t\t\t}\nvec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {\n                // Slightly modified version of this:\n                // https://www.shadertoy.com/view/ltScRG\n\n\t\t\t\t// Special case for blur == 0.0\n\t\t\t\tif (lod == 0.0) {\n\t\t\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\t\treturn texture2DLodEXT( sp, U, 0.0).rgb;\n\t\t\t\t\t#else\n\t\t\t\t\treturn textureLod( sp, U, 0.0).rgb;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec2 texelSize = vec2(1.0) / resolution;\n                vec2 halton = haltonSequence[frameIndex];\n                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n                float temporalAngle  = temporalOffset * PI2;\n\t\t\t\tvec3 res = vec3(0.0);\n                vec2 vUv = vec2(0.0);\n                vec2 offset = vec2(0.0);\n                vec2 vogelSample = vec2(0.0);\n                for (int i = 0; i < NUM_SAMPLES; i++) {\n                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;\n                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20\n                    vUv = U + offset;\n                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, vUv, lod));\n                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {\n                        vUv = unrefractedU;\n                        lod = lod > 4.0 ? lod : lod / 2.0;\n                    }\n                    res += textureLod(sp, vUv, lod).rgb;\n                }\n                return res / float(NUM_SAMPLES);\n            }\nvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\t        // Direction of refracted light.\n\t\t        vec3 refractionVector = refract( -v,  n, 1.0 / ior );\n\t\t        \n\t\t\t\t// Compute rotation-independant scaling of the model matrix.\n\t\t        vec3 modelScale;\n\t\t        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\t        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\t        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t        // The thickness is specified in local space\n\t\t        return normalize( refractionVector ) * thickness * modelScale;\n\t        }\nfloat vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vPosition.x - origin.x) + n.y*(vPosition.y - origin.y) + n.z*(vPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vWPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nvec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {\n\t\t\t\t\tfloat fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );\n\n\t\t\t\t\tfloat lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;\n\t\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\t\treturn color;\n\t\t\t\t}\nvec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {\n\t\t\t\t// Threejs exports do not pass a depth map to this shader, so we have to fallback to the \"Threejs method of blurring\" - see\n\t\t\t\t// also the code in convertTransmission.ts, which runs during export\n\t\t\t\t#ifdef IS_THREEJS_EXPORT\n\t\t\t\t\tfloat lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);\n\t\t\t\t\treturn textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;\n\t\t\t\t#else\n\t\t\t\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t\t\t\tfloat lod = applyIorToRoughness(roughness, ior);\n\t\t\t\t\treturn blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);\n\t\t\t\t#endif\n\t\t\t}\nvec3 gdf5f123cb813444e943da398041aedd4_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[gdf5f123cb813444e943da398041aedd4_MAX_COLORS], float steps[gdf5f123cb813444e943da398041aedd4_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {\n               vec4 color = colors[0];\n               #ifdef gdf5f123cb813444e943da398041aedd4_IS_VECTOR\n                   #ifdef gdf5f123cb813444e943da398041aedd4_LINEAR\n                       #ifdef gdf5f123cb813444e943da398041aedd4_WORLDSPACE\n                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);\n                       #else\n                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);\n                       #endif\n                   #else\n                       #ifdef gdf5f123cb813444e943da398041aedd4_WORLDSPACE\n                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);\n                       #else\n                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);\n                       #endif\n                   #endif\n               #else\n                   float dist = length(vWPosition - cameraPosition);\n\t\t\t       float depth = ( dist - near ) / ( far - near );\n               #endif\n\n\n              float p;\n              #ifdef gdf5f123cb813444e943da398041aedd4_SMOOTH\n\t\t\t\tfor ( int i = 1; i < gdf5f123cb813444e943da398041aedd4_MAX_COLORS; i++ ) {\n\t\t\t\t\t\tp = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );\n\t\t\t\t\t\tcolor = mix(color, colors[i], smoothstep(0.0, 1.0, p));\n\t\t\t\t\t}\n              #else\n                for ( int i = 1; i < gdf5f123cb813444e943da398041aedd4_MAX_COLORS; i++ ) {\n                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);\n                   color = mix(color, colors[i], p);\n                 }\n              #endif\n\n               float lalpha = alpha * color.a * mask;\n               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\t\t\t   \n               return color.rgb;\n\t\t\t}\nvec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\n\t\t\t\tvec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );\n\t\t\t\tvec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;\n\t\t\t\tunrefractedCoords += 1.0;\n\t\t\t\tunrefractedCoords /= 2.0;\n\n\t\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\t\treturn getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );\n    \t\t}\nvec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {\n                vec3 v = vec3(0.);\n                if (isOrthographic) {\n                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n                } else {\n                    v = normalize(vWPosition - cameraPosition);\n                }\n                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );\n                \n\t\t\t\tfloat lalpha = alpha * mask;\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * alpha;\n\n\t\t\t\treturn transmission;\n            }\n\nvoid main() {\n\nfloat g627fa06779964ee1b363313f8e785399_calpha;\nfloat gdf5f123cb813444e943da398041aedd4_calpha;\nfloat g822634f76f5542c4b775088f847f4c89_calpha;\nfloat g7c720394782c4ec7b24545ea3f46a937_calpha;\n\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n\n\t\t\t\t// NOTE: gl_FrontFacing alternative using face normal estimation.\n\t\t\t\tvec3 viewdx = dFdx(vViewPosition);\n\t\t\t\tvec3 viewdy = dFdy(vViewPosition);\n\t\t\t\tvec3 faceNormal = normalize(cross(viewdx,viewdy));\n\t\t\t\tif (dot(normal, faceNormal) < 0.0) {\n\t\t\t\t\tnormal *= -1.0;\n\t\t\t\t}\n\t\t\t\t\n\tBlinnPhongMaterial material;\n\n\tvec3 diffuseColor = spe_blend(spe_blend(spe_blend(transmission(nodeU0,nodeU1,nodeU2,nodeU3,nodeU4,nodeU5,nodeU6,normal,1.0,nodeU7,g627fa06779964ee1b363313f8e785399_calpha),gdf5f123cb813444e943da398041aedd4_sdepth(nodeU8,nodeU9,nodeU10,nodeU11,nodeUA0,nodeUA1,nodeU12,1.0,nodeU13,gdf5f123cb813444e943da398041aedd4_calpha),( gdf5f123cb813444e943da398041aedd4_calpha ),nodeU14),fresnel(nodeU15,nodeU16,nodeU17,nodeU18,nodeU19,nodeU20,1.0,nodeU21,nodeU22,g822634f76f5542c4b775088f847f4c89_calpha),( g822634f76f5542c4b775088f847f4c89_calpha ),nodeU22),fresnel(nodeU23,nodeU24,nodeU25,nodeU26,nodeU27,nodeU28,1.0,nodeU29,nodeU30,g7c720394782c4ec7b24545ea3f46a937_calpha),( g7c720394782c4ec7b24545ea3f46a937_calpha ),nodeU30);\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\tvec3 specular = nodeU31;\n\n\tfloat shininess = max( 0.0001, nodeU32 );\n\tfloat specularStrength = 1.0;\n\n#ifdef ALPHATEST\nif ( nodeU36 <= ALPHATEST ) discard;\n#endif\nmaterial.diffuseColor = diffuseColor;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t\n#endif\n#if ( 1 > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t\n\t\tdirectionalLight = directionalLights[ 0 ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( 0 < 0 )\n\t\tdirectionalLightShadow = directionalLightShadows[ 0 ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( 0, directionalShadowMap[ 0 ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( 1 > 0 )\n\t\t\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\nvec3 ao = aoEnabled && nodeU33 ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);\nvec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t\t\t\tif (outgoingLight != diffuseColor) {\n\t\t\t\t\tfloat lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );\n\t\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * nodeU34 * 1.0 * lightAccu;\n\t\t\t\t\toutgoingLight = spe_blend( diffuseColor, outgoingLight, nodeU34 * 1.0, nodeU35 );\n\t\t\t\t\t\n\t\t\t\t\toutgoingLight *= ao;\n\t\t\t\t}\n\t\t\t\t\ngl_FragColor = vec4( outgoingLight, accumAlpha * nodeU36);\ngl_FragColor.a *= nodeU37;\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_26;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_27;\n    float pad_28;\n    float pad_29;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_30;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_31;\n    float pad_32;\n    float pad_33;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform float3 _emissive : register(c7);\nuniform bool _aoEnabled : register(c8);\nuniform float3 _ambientLightColor : register(c9);\nuniform float3 _lightProbe[9] : register(c10);\nuniform _DirectionalLight _directionalLights[1] : register(c19);\nuniform _HemisphereLight _hemisphereLights[1] : register(c21);\nuniform float4x4 _modelMatrix : register(c24);\nuniform float4x4 _projectionMatrix : register(c28);\nuniform float _nodeU0 : register(c32);\nuniform float _nodeU1 : register(c33);\nuniform float _nodeU2 : register(c34);\nuniform float2 _nodeU3 : register(c35);\nuniform float2 _nodeU6 : register(c36);\nuniform float _nodeU7 : register(c37);\nuniform float _nodeU8 : register(c38);\nuniform float _nodeU9 : register(c39);\nuniform float3 _nodeU10 : register(c40);\nuniform float3 _nodeU11 : register(c41);\nuniform bool _nodeU12 : register(c42);\nuniform float _nodeU13 : register(c43);\nuniform int _nodeU14 : register(c44);\nuniform float3 _nodeU15 : register(c45);\nuniform float _nodeU16 : register(c46);\nuniform float _nodeU17 : register(c47);\nuniform float _nodeU18 : register(c48);\nuniform float _nodeU19 : register(c49);\nuniform bool _nodeU20 : register(c50);\nuniform float _nodeU21 : register(c51);\nuniform int _nodeU22 : register(c52);\nuniform float3 _nodeU23 : register(c53);\nuniform float _nodeU24 : register(c54);\nuniform float _nodeU25 : register(c55);\nuniform float _nodeU26 : register(c56);\nuniform float _nodeU27 : register(c57);\nuniform bool _nodeU28 : register(c58);\nuniform float _nodeU29 : register(c59);\nuniform int _nodeU30 : register(c60);\nuniform float3 _nodeU31 : register(c61);\nuniform float _nodeU32 : register(c62);\nuniform bool _nodeU33 : register(c63);\nuniform float _nodeU34 : register(c64);\nuniform int _nodeU35 : register(c65);\nuniform float _nodeU36 : register(c66);\nuniform float _nodeU37 : register(c67);\nuniform float4 _nodeUA0[4] : register(c68);\nuniform float _nodeUA1[4] : register(c72);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nstatic float _accumAlpha = {0.0};\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2708 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2708)) + (_f90 * _fresnel2708));\n}\nfloat f_G_BlinnPhong_Implicit()\n{\nreturn 0.25;\n}\nfloat f_D_BlinnPhong(const float _shininess, const float _dotNH)\n{\nreturn ((0.31830987 * ((_shininess * 0.5) + 1.0)) * pow(_dotNH, _shininess));\n}\nfloat3 f_BRDF_BlinnPhong(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _specularColor, const float _shininess)\n{\nfloat3 _halfDir2795 = normalize((_lightDir + _viewDir));\nfloat _dotNH2796 = clamp(dot(_normal, _halfDir2795), 0.0, 1.0);\nfloat _dotVH2797 = clamp(dot(_viewDir, _halfDir2795), 0.0, 1.0);\nfloat3 _F2798 = f_F_Schlick(_specularColor, 1.0, _dotVH2797);\nfloat _G2799 = f_G_BlinnPhong_Implicit();\nfloat _D2800 = f_D_BlinnPhong(_shininess, _dotNH2796);\nreturn (_F2798 * (_G2799 * _D2800));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2807 = _normal.x;\nfloat _y2808 = _normal.y;\nfloat _z2809 = _normal.z;\nfloat3 _result2810 = (_shCoefficients[0] * 0.88622701);\n(_result2810 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2808));\n(_result2810 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2809));\n(_result2810 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2807));\n(_result2810 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2807) * _y2808));\n(_result2810 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2808) * _z2809));\n(_result2810 += (_shCoefficients[6] * (((0.74312502 * _z2809) * _z2809) - 0.24770799)));\n(_result2810 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2807) * _z2809));\n(_result2810 += ((_shCoefficients[8] * 0.42904299) * ((_x2807 * _x2807) - (_y2808 * _y2808))));\nreturn _result2810;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2814 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2815 = f_shGetIrradianceAt(_worldNormal2814, _lightProbe);\nreturn _irradiance2815;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2818 = _ambientLightColor;\nreturn _irradiance2818;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2840 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2841 = ((0.5 * _dotNL2840) + 0.5);\nfloat3 _irradiance2842 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2841);\nreturn _irradiance2842;\n}\n;\nvoid f_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2851 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2852 = (_dotNL2851 * _directLight._color);\n(_reflectedLight._directDiffuse += (_irradiance2852 * f_BRDF_Lambert(_material._diffuseColor)));\n(_reflectedLight._directSpecular += ((_irradiance2852 * f_BRDF_BlinnPhong(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularShininess)) * _material._specularStrength));\n}\nvoid f_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2864 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2865 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2865 = lerp((2.0 * _dither_shift_RGB2865), (-2.0 * _dither_shift_RGB2865), _grid_position2864));\nreturn (_color + _dither_shift_RGB2865);\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2933 = floor(_vUv);\nfloat2 _fuv2934 = frac(_vUv);\nfloat _g0x2935 = f_g0(_fuv2934.x);\nfloat _g1x2936 = f_g1(_fuv2934.x);\nfloat _h0x2937 = f_h0(_fuv2934.x);\nfloat _h1x2938 = f_h1(_fuv2934.x);\nfloat _h0y2939 = f_h0(_fuv2934.y);\nfloat _h1y2940 = f_h1(_fuv2934.y);\nfloat2 _p02941 = ((vec2_ctor((_iuv2933.x + _h0x2937), (_iuv2933.y + _h0y2939)) - 0.5) * _texelSize.xy);\nfloat2 _p12942 = ((vec2_ctor((_iuv2933.x + _h1x2938), (_iuv2933.y + _h0y2939)) - 0.5) * _texelSize.xy);\nfloat2 _p22943 = ((vec2_ctor((_iuv2933.x + _h0x2937), (_iuv2933.y + _h1y2940)) - 0.5) * _texelSize.xy);\nfloat2 _p32944 = ((vec2_ctor((_iuv2933.x + _h1x2938), (_iuv2933.y + _h1y2940)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2934.y) * ((_g0x2935 * gl_texture2DLod(_tex, _p02941, _lod)) + (_g1x2936 * gl_texture2DLod(_tex, _p12942, _lod)))) + (f_g1(_fuv2934.y) * ((_g0x2935 * gl_texture2DLod(_tex, _p22943, _lod)) + (_g1x2936 * gl_texture2DLod(_tex, _p32944, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize2949 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize2950 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv2951 = (1.0 / _fLodSize2949);\nfloat2 _cLodSizeInv2952 = (1.0 / _cLodSize2950);\nfloat4 _fSample2953 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv2951, _fLodSize2949), floor(_lod));\nfloat4 _cSample2954 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv2952, _cLodSize2950), ceil(_lod));\nreturn lerp(_fSample2953, _cSample2954, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector2982 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale2983 = {0, 0, 0};\n(_modelScale2983.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale2983.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale2983.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector2982) * _thickness) * _modelScale2983);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist3002 = length((_vPosition - _origin));\nreturn ((_dist3002 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3019 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3020 = ((clamp(_fresnel3019, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3020 / clamp((_lalpha3020 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3020, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3020) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3030 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3030).xyz;\n}\nfloat3 f_gdf5f123cb813444e943da398041aedd4_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3042 = _colors[0];\nfloat _depth3043 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3044 = {0};\n{ for(int _i3045 = {1}; (_i3045 < 4); (_i3045++))\n{\n(_p3044 = clamp(((_depth3043 - _steps[(_i3045 - 1)]) / (_steps[_i3045] - _steps[(_i3045 - 1)])), 0.0, 1.0));\n(_color3042 = lerp(_color3042, _colors[_i3045], _p3044));\n}\n}\nfloat _lalpha3046 = ((_alpha * _color3042.w) * _mask);\n(_calpha = lerp((_lalpha3046 / clamp((_lalpha3046 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3046, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3046) * (1.0 - float_ctor(_isMask))));\nreturn _color3042.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3061 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3062 = (_position + _transmissionRay3061);\nfloat4 _ndcPos3063 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3062, 1.0));\nfloat2 _refractionCoords3064 = (_ndcPos3063.xy / _ndcPos3063.w);\n(_refractionCoords3064 += 1.0);\n(_refractionCoords3064 /= 2.0);\nfloat4 _ndcPosUnrefracted3065 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3066 = (_ndcPosUnrefracted3065.xy / _ndcPosUnrefracted3065.w);\n(_unrefractedCoords3066 += 1.0);\n(_unrefractedCoords3066 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3064, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3066, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3079 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3079 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3079 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3080 = f_getIBLVolumeRefraction(_vWNormal, (-_v3079), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3081 = (_alpha * _mask);\n(_calpha = (_lalpha3081 / clamp((_lalpha3081 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3080;\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat _g627fa06779964ee1b363313f8e785399_calpha3083 = {0};\nfloat _gdf5f123cb813444e943da398041aedd4_calpha3084 = {0};\nfloat _g822634f76f5542c4b775088f847f4c89_calpha3085 = {0};\nfloat _g7c720394782c4ec7b24545ea3f46a937_calpha3086 = {0};\nfloat3 _normal3088 = normalize(_vNormal);\nfloat3 _viewdx3090 = ddx(_vViewPosition);\nfloat3 _viewdy3091 = ddy(_vViewPosition);\nfloat3 _faceNormal3092 = normalize(cross(_viewdx3090, _viewdy3091));\nif ((dot(_normal3088, _faceNormal3092) < 0.0))\n{\n(_normal3088 *= -1.0);\n}\n_BlinnPhongMaterial _material3093 = {0, 0, 0, 0, 0, 0, 0, 0};\nfloat3 _diffuseColor3094 = f_spe_blend_int(f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3088, 1.0, _nodeU7, _g627fa06779964ee1b363313f8e785399_calpha3083), f_gdf5f123cb813444e943da398041aedd4_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _gdf5f123cb813444e943da398041aedd4_calpha3084), _gdf5f123cb813444e943da398041aedd4_calpha3084, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _g822634f76f5542c4b775088f847f4c89_calpha3085), _g822634f76f5542c4b775088f847f4c89_calpha3085, _nodeU22), f_fresnel_int(_nodeU23, _nodeU24, _nodeU25, _nodeU26, _nodeU27, _nodeU28, 1.0, _nodeU29, _nodeU30, _g7c720394782c4ec7b24545ea3f46a937_calpha3086), _g7c720394782c4ec7b24545ea3f46a937_calpha3086, _nodeU30);\n_ReflectedLight _reflectedLight3095 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 _totalEmissiveRadiance3096 = _emissive;\nfloat3 _specular3097 = _nodeU31;\nfloat _shininess3098 = max(9.9999997e-05, _nodeU32);\nfloat _specularStrength3099 = {1.0};\n(_material3093._diffuseColor = _diffuseColor3094);\n(_material3093._specularColor = _specular3097);\n(_material3093._specularShininess = _shininess3098);\n(_material3093._specularStrength = _specularStrength3099);\n_GeometricContext _geometry3100 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry3100._position = (-_vViewPosition));\n(_geometry3100._normal = _normal3088);\nfloat3 sc24 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sc24 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sc24 = normalize(_vViewPosition));\n}\n(_geometry3100._viewDir = sc24);\n_IncidentLight _directLight3101 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight3102 = {0, 0, 0, 0, 0, 0};\n(_directionalLight3102 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight3102, _geometry3100, _directLight3101);\nf_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(_directLight3101, _geometry3100, _material3093, _reflectedLight3095);\nfloat3 _irradiance3104 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance3104 += f_getLightProbeIrradiance(_lightProbe, _geometry3100._normal));\n(_irradiance3104 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry3100._normal));\nf_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(_irradiance3104, _geometry3100, _material3093, _reflectedLight3095);\nfloat3 sc25 = {0, 0, 0};\nif ((_aoEnabled && _nodeU33))\n{\n(sc25 = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc25 = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3105 = sc25;\nfloat3 _outgoingLight3106 = ((((_reflectedLight3095._directDiffuse + _reflectedLight3095._indirectDiffuse) + _reflectedLight3095._directSpecular) + _reflectedLight3095._indirectSpecular) + _totalEmissiveRadiance3096);\nif (!all(_outgoingLight3106 == _diffuseColor3094))\n{\nfloat _lightAccu3107 = clamp(length((_reflectedLight3095._directSpecular + _reflectedLight3095._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU34) * 1.0) * _lightAccu3107));\n(_outgoingLight3106 = f_spe_blend_int(_diffuseColor3094, _outgoingLight3106, (_nodeU34 * 1.0), _nodeU35));\n(_outgoingLight3106 *= _ao3105);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3106, (_accumAlpha * _nodeU36)));\n(out_pc_fragColor.w *= _nodeU37);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD6;\n    float4 gl_FragCoord : TEXCOORD7;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_26;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_27;\n    float pad_28;\n    float pad_29;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_30;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_31;\n    float pad_32;\n    float pad_33;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform float3 _emissive : register(c7);\nuniform bool _aoEnabled : register(c8);\nuniform float3 _ambientLightColor : register(c9);\nuniform float3 _lightProbe[9] : register(c10);\nuniform _DirectionalLight _directionalLights[1] : register(c19);\nuniform _HemisphereLight _hemisphereLights[1] : register(c21);\nuniform float4x4 _modelMatrix : register(c24);\nuniform float4x4 _projectionMatrix : register(c28);\nuniform float _nodeU0 : register(c32);\nuniform float _nodeU1 : register(c33);\nuniform float _nodeU2 : register(c34);\nuniform float2 _nodeU3 : register(c35);\nuniform float2 _nodeU6 : register(c36);\nuniform float _nodeU7 : register(c37);\nuniform float _nodeU8 : register(c38);\nuniform float _nodeU9 : register(c39);\nuniform float3 _nodeU10 : register(c40);\nuniform float3 _nodeU11 : register(c41);\nuniform bool _nodeU12 : register(c42);\nuniform float _nodeU13 : register(c43);\nuniform int _nodeU14 : register(c44);\nuniform float3 _nodeU15 : register(c45);\nuniform float _nodeU16 : register(c46);\nuniform float _nodeU17 : register(c47);\nuniform float _nodeU18 : register(c48);\nuniform float _nodeU19 : register(c49);\nuniform bool _nodeU20 : register(c50);\nuniform float _nodeU21 : register(c51);\nuniform int _nodeU22 : register(c52);\nuniform float3 _nodeU23 : register(c53);\nuniform float _nodeU24 : register(c54);\nuniform float _nodeU25 : register(c55);\nuniform float _nodeU26 : register(c56);\nuniform float _nodeU27 : register(c57);\nuniform bool _nodeU28 : register(c58);\nuniform float _nodeU29 : register(c59);\nuniform int _nodeU30 : register(c60);\nuniform float3 _nodeU31 : register(c61);\nuniform float _nodeU32 : register(c62);\nuniform bool _nodeU33 : register(c63);\nuniform float _nodeU34 : register(c64);\nuniform int _nodeU35 : register(c65);\nuniform float _nodeU36 : register(c66);\nuniform float _nodeU37 : register(c67);\nuniform float4 _nodeUA0[4] : register(c68);\nuniform float _nodeUA1[4] : register(c72);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nstatic float _accumAlpha = {0.0};\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2708 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2708)) + (_f90 * _fresnel2708));\n}\nfloat f_G_BlinnPhong_Implicit()\n{\nreturn 0.25;\n}\nfloat f_D_BlinnPhong(const float _shininess, const float _dotNH)\n{\nreturn ((0.31830987 * ((_shininess * 0.5) + 1.0)) * pow(_dotNH, _shininess));\n}\nfloat3 f_BRDF_BlinnPhong(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _specularColor, const float _shininess)\n{\nfloat3 _halfDir2795 = normalize((_lightDir + _viewDir));\nfloat _dotNH2796 = clamp(dot(_normal, _halfDir2795), 0.0, 1.0);\nfloat _dotVH2797 = clamp(dot(_viewDir, _halfDir2795), 0.0, 1.0);\nfloat3 _F2798 = f_F_Schlick(_specularColor, 1.0, _dotVH2797);\nfloat _G2799 = f_G_BlinnPhong_Implicit();\nfloat _D2800 = f_D_BlinnPhong(_shininess, _dotNH2796);\nreturn (_F2798 * (_G2799 * _D2800));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2807 = _normal.x;\nfloat _y2808 = _normal.y;\nfloat _z2809 = _normal.z;\nfloat3 _result2810 = (_shCoefficients[0] * 0.88622701);\n(_result2810 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2808));\n(_result2810 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2809));\n(_result2810 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2807));\n(_result2810 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2807) * _y2808));\n(_result2810 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2808) * _z2809));\n(_result2810 += (_shCoefficients[6] * (((0.74312502 * _z2809) * _z2809) - 0.24770799)));\n(_result2810 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2807) * _z2809));\n(_result2810 += ((_shCoefficients[8] * 0.42904299) * ((_x2807 * _x2807) - (_y2808 * _y2808))));\nreturn _result2810;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2814 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2815 = f_shGetIrradianceAt(_worldNormal2814, _lightProbe);\nreturn _irradiance2815;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2818 = _ambientLightColor;\nreturn _irradiance2818;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2840 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2841 = ((0.5 * _dotNL2840) + 0.5);\nfloat3 _irradiance2842 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2841);\nreturn _irradiance2842;\n}\n;\nvoid f_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2851 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2852 = (_dotNL2851 * _directLight._color);\n(_reflectedLight._directDiffuse += (_irradiance2852 * f_BRDF_Lambert(_material._diffuseColor)));\n(_reflectedLight._directSpecular += ((_irradiance2852 * f_BRDF_BlinnPhong(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularShininess)) * _material._specularStrength));\n}\nvoid f_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2864 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2865 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2865 = lerp((2.0 * _dither_shift_RGB2865), (-2.0 * _dither_shift_RGB2865), _grid_position2864));\nreturn (_color + _dither_shift_RGB2865);\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2933 = floor(_vUv);\nfloat2 _fuv2934 = frac(_vUv);\nfloat _g0x2935 = f_g0(_fuv2934.x);\nfloat _g1x2936 = f_g1(_fuv2934.x);\nfloat _h0x2937 = f_h0(_fuv2934.x);\nfloat _h1x2938 = f_h1(_fuv2934.x);\nfloat _h0y2939 = f_h0(_fuv2934.y);\nfloat _h1y2940 = f_h1(_fuv2934.y);\nfloat2 _p02941 = ((vec2_ctor((_iuv2933.x + _h0x2937), (_iuv2933.y + _h0y2939)) - 0.5) * _texelSize.xy);\nfloat2 _p12942 = ((vec2_ctor((_iuv2933.x + _h1x2938), (_iuv2933.y + _h0y2939)) - 0.5) * _texelSize.xy);\nfloat2 _p22943 = ((vec2_ctor((_iuv2933.x + _h0x2937), (_iuv2933.y + _h1y2940)) - 0.5) * _texelSize.xy);\nfloat2 _p32944 = ((vec2_ctor((_iuv2933.x + _h1x2938), (_iuv2933.y + _h1y2940)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2934.y) * ((_g0x2935 * gl_texture2DLod(_tex, _p02941, _lod)) + (_g1x2936 * gl_texture2DLod(_tex, _p12942, _lod)))) + (f_g1(_fuv2934.y) * ((_g0x2935 * gl_texture2DLod(_tex, _p22943, _lod)) + (_g1x2936 * gl_texture2DLod(_tex, _p32944, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize2949 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize2950 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv2951 = (1.0 / _fLodSize2949);\nfloat2 _cLodSizeInv2952 = (1.0 / _cLodSize2950);\nfloat4 _fSample2953 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv2951, _fLodSize2949), floor(_lod));\nfloat4 _cSample2954 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv2952, _cLodSize2950), ceil(_lod));\nreturn lerp(_fSample2953, _cSample2954, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector2982 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale2983 = {0, 0, 0};\n(_modelScale2983.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale2983.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale2983.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector2982) * _thickness) * _modelScale2983);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist3002 = length((_vPosition - _origin));\nreturn ((_dist3002 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3019 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3020 = ((clamp(_fresnel3019, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3020 / clamp((_lalpha3020 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3020, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3020) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3030 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3030).xyz;\n}\nfloat3 f_gdf5f123cb813444e943da398041aedd4_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3042 = _colors[0];\nfloat _depth3043 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3044 = {0};\n{ for(int _i3045 = {1}; (_i3045 < 4); (_i3045++))\n{\n(_p3044 = clamp(((_depth3043 - _steps[(_i3045 - 1)]) / (_steps[_i3045] - _steps[(_i3045 - 1)])), 0.0, 1.0));\n(_color3042 = lerp(_color3042, _colors[_i3045], _p3044));\n}\n}\nfloat _lalpha3046 = ((_alpha * _color3042.w) * _mask);\n(_calpha = lerp((_lalpha3046 / clamp((_lalpha3046 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3046, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3046) * (1.0 - float_ctor(_isMask))));\nreturn _color3042.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3061 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3062 = (_position + _transmissionRay3061);\nfloat4 _ndcPos3063 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3062, 1.0));\nfloat2 _refractionCoords3064 = (_ndcPos3063.xy / _ndcPos3063.w);\n(_refractionCoords3064 += 1.0);\n(_refractionCoords3064 /= 2.0);\nfloat4 _ndcPosUnrefracted3065 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3066 = (_ndcPosUnrefracted3065.xy / _ndcPosUnrefracted3065.w);\n(_unrefractedCoords3066 += 1.0);\n(_unrefractedCoords3066 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3064, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3066, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3079 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3079 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3079 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3080 = f_getIBLVolumeRefraction(_vWNormal, (-_v3079), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3081 = (_alpha * _mask);\n(_calpha = (_lalpha3081 / clamp((_lalpha3081 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3080;\n}\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input){\n    float rhw = 1.0 / input.gl_FragCoord.w;\n    gl_FragCoord.x = input.dx_Position.x - dx_FragCoordOffset.x;\n    gl_FragCoord.y = input.dx_Position.y - dx_FragCoordOffset.y;\n    gl_FragCoord.z = input.dx_Position.z;\n    gl_FragCoord.w = rhw;\n    _vViewPosition = input.v0.xyz;\n    _vWPosition = input.v1.xyz;\n    _vNormal = input.v2.xyz;\n    _vPosition = input.v3.xyz;\n    _vWNormal = input.v4.xyz;\n    _vWorldViewDir = input.v5.xyz;\n\nfloat _g627fa06779964ee1b363313f8e785399_calpha3083 = {0};\nfloat _gdf5f123cb813444e943da398041aedd4_calpha3084 = {0};\nfloat _g822634f76f5542c4b775088f847f4c89_calpha3085 = {0};\nfloat _g7c720394782c4ec7b24545ea3f46a937_calpha3086 = {0};\nfloat3 _normal3088 = normalize(_vNormal);\nfloat3 _viewdx3090 = ddx(_vViewPosition);\nfloat3 _viewdy3091 = ddy(_vViewPosition);\nfloat3 _faceNormal3092 = normalize(cross(_viewdx3090, _viewdy3091));\nif ((dot(_normal3088, _faceNormal3092) < 0.0))\n{\n(_normal3088 *= -1.0);\n}\n_BlinnPhongMaterial _material3093 = {0, 0, 0, 0, 0, 0, 0, 0};\nfloat3 _diffuseColor3094 = f_spe_blend_int(f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3088, 1.0, _nodeU7, _g627fa06779964ee1b363313f8e785399_calpha3083), f_gdf5f123cb813444e943da398041aedd4_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _gdf5f123cb813444e943da398041aedd4_calpha3084), _gdf5f123cb813444e943da398041aedd4_calpha3084, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _g822634f76f5542c4b775088f847f4c89_calpha3085), _g822634f76f5542c4b775088f847f4c89_calpha3085, _nodeU22), f_fresnel_int(_nodeU23, _nodeU24, _nodeU25, _nodeU26, _nodeU27, _nodeU28, 1.0, _nodeU29, _nodeU30, _g7c720394782c4ec7b24545ea3f46a937_calpha3086), _g7c720394782c4ec7b24545ea3f46a937_calpha3086, _nodeU30);\n_ReflectedLight _reflectedLight3095 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 _totalEmissiveRadiance3096 = _emissive;\nfloat3 _specular3097 = _nodeU31;\nfloat _shininess3098 = max(9.9999997e-05, _nodeU32);\nfloat _specularStrength3099 = {1.0};\n(_material3093._diffuseColor = _diffuseColor3094);\n(_material3093._specularColor = _specular3097);\n(_material3093._specularShininess = _shininess3098);\n(_material3093._specularStrength = _specularStrength3099);\n_GeometricContext _geometry3100 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry3100._position = (-_vViewPosition));\n(_geometry3100._normal = _normal3088);\nfloat3 sc24 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sc24 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sc24 = normalize(_vViewPosition));\n}\n(_geometry3100._viewDir = sc24);\n_IncidentLight _directLight3101 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight3102 = {0, 0, 0, 0, 0, 0};\n(_directionalLight3102 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight3102, _geometry3100, _directLight3101);\nf_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(_directLight3101, _geometry3100, _material3093, _reflectedLight3095);\nfloat3 _irradiance3104 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance3104 += f_getLightProbeIrradiance(_lightProbe, _geometry3100._normal));\n(_irradiance3104 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry3100._normal));\nf_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(_irradiance3104, _geometry3100, _material3093, _reflectedLight3095);\nfloat3 sc25 = {0, 0, 0};\nif ((_aoEnabled && _nodeU33))\n{\n(sc25 = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc25 = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3105 = sc25;\nfloat3 _outgoingLight3106 = ((((_reflectedLight3095._directDiffuse + _reflectedLight3095._indirectDiffuse) + _reflectedLight3095._directSpecular) + _reflectedLight3095._indirectSpecular) + _totalEmissiveRadiance3096);\nif (!all(_outgoingLight3106 == _diffuseColor3094))\n{\nfloat _lightAccu3107 = clamp(length((_reflectedLight3095._directSpecular + _reflectedLight3095._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU34) * 1.0) * _lightAccu3107));\n(_outgoingLight3106 = f_spe_blend_int(_diffuseColor3094, _outgoingLight3106, (_nodeU34 * 1.0), _nodeU35));\n(_outgoingLight3106 *= _ao3105);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3106, (_accumAlpha * _nodeU36)));\n(out_pc_fragColor.w *= _nodeU37);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 5",
                            "id": 5,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "NodeMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define PHONG 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define gdf5f123cb813444e943da398041aedd4_MAX_COLORS 4\n#define gdf5f123cb813444e943da398041aedd4_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define VERTEX_TEXTURES\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat neighbor_offset = 0.0001;\n\nuniform int frameIndex;\nuniform vec2 resolution;\nuniform mat4 previousModelViewMatrix;\nuniform mat4 previousProjectionMatrix;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\n\n\n\n\n\nvoid main() {\n\n\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n\n#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t\t\t\t#endif\n\n\n\t\t\t\tvec3 displaced_position = position;\n\t\t\t\tvec3 displaced_normal = objectNormal;\n\n\t\t\t\t#ifdef USE_LAYER_DISPLACE\n\t\t\t\t\tvec3 transformed;\n\t\t\t\t\tvec3 transformedNormal;\n\t\t\t\t#endif\n\t\t\t\t\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\nvec3 transformed = vec3( position );\n\t\t\t\t#endif\n\t\t\t\t\ntransformed = displaced_position;\n#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\ntransformedNormal = normalMatrix * displaced_normal;\n#ifndef FLAT_SHADED\n    vNormal = transformedNormal;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\nvWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;\nvUv = uv;\nvPosition = transformed;\nvWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;\nvWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );\n\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2691 = vec3_ctor(_normal);\nfloat3 _transformedNormal2692 = _objectNormal2691;\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _transformedNormal2692));\nfloat3 _displaced_position2693 = _position;\nfloat3 _displaced_normal2694 = _objectNormal2691;\n(_vNormal = normalize(_transformedNormal2692));\nfloat3 _transformed2695 = vec3_ctor(_position);\n(_transformed2695 = _displaced_position2693);\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _displaced_normal2694));\n(_vNormal = _transformedNormal2692);\nfloat4 _mvPosition2696 = vec4_ctor(_transformed2695, 1.0);\n(_mvPosition2696 = mul(transpose(_modelViewMatrix), _mvPosition2696));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2696));\n(_vViewPosition = (-_mvPosition2696.xyz));\nfloat4 _worldPosition2697 = vec4_ctor(_transformed2695, 1.0);\n(_worldPosition2697 = mul(transpose(_modelMatrix), _worldPosition2697));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2695, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2695);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2692, _viewMatrix).xyz);\nfloat3 sa8a = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sa8a = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sa8a = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sa8a);\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD6;\n    float4 gl_FragCoord : TEXCOORD7;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n};\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _normal : TEXCOORD1;\n    float2 _uv : TEXCOORD2;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _normal = input._normal;\n    _uv = input._uv;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.gl_FragCoord = gl_Position;\n    output.v0 = _vViewPosition;\n    output.v1 = _vWPosition;\n    output.v2 = _vNormal;\n    output.v3 = _vPosition;\n    output.v4 = _vWNormal;\n    output.v5 = _vWorldViewDir;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2691 = vec3_ctor(_normal);\nfloat3 _transformedNormal2692 = _objectNormal2691;\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _transformedNormal2692));\nfloat3 _displaced_position2693 = _position;\nfloat3 _displaced_normal2694 = _objectNormal2691;\n(_vNormal = normalize(_transformedNormal2692));\nfloat3 _transformed2695 = vec3_ctor(_position);\n(_transformed2695 = _displaced_position2693);\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _displaced_normal2694));\n(_vNormal = _transformedNormal2692);\nfloat4 _mvPosition2696 = vec4_ctor(_transformed2695, 1.0);\n(_mvPosition2696 = mul(transpose(_modelViewMatrix), _mvPosition2696));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2696));\n(_vViewPosition = (-_mvPosition2696.xyz));\nfloat4 _worldPosition2697 = vec4_ctor(_transformed2695, 1.0);\n(_worldPosition2697 = mul(transpose(_modelMatrix), _worldPosition2697));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2695, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2695);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2692, _viewMatrix).xyz);\nfloat3 sa8a = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sa8a = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sa8a = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sa8a);\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "NodeMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define PHONG 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define gdf5f123cb813444e943da398041aedd4_MAX_COLORS 4\n#define gdf5f123cb813444e943da398041aedd4_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define DITHERING\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat accumAlpha = 0.0;\nvoid accumulateAlpha(float alpha) {\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * alpha;\n\t\t\t\t}\n\nlayout(location = 1) out vec4 gVelocity;\n\nuniform int frameIndex;\nuniform vec2 resolution;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nconst vec2 haltonSequence[16] = vec2[16](\nvec2( 0.000000,-0.333334),\nvec2(-0.500000, 0.333334),\nvec2( 0.500000,-0.777778),\nvec2(-0.750000,-0.111112),\nvec2( 0.250000, 0.555556),\nvec2(-0.250000,-0.555556),\nvec2( 0.750000, 0.111112),\nvec2(-0.875000, 0.777778),\nvec2(0.125000, -0.925926),\nvec2(-0.375000, -0.259260),\nvec2(0.625000, 0.407408),\nvec2(-0.625000, -0.703704),\nvec2(0.375000, -0.037038),\nvec2(-0.125000, 0.629630),\nvec2(0.875000, -0.481482),\nvec2(-0.937500, 0.185186));\n\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n  const float goldenAngle = 2.399963f; // radians\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n  float theta = float(sampleIndex) * goldenAngle + angle;\n  float sine = sin(theta);\n  float cosine = cos(theta);\n  return vec2(cosine, sine) * r;\n}\n\n// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso\nfloat getNoiseInterleavedGradient(vec2 screenPos) {\n    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);\n    return fract(magic.z * fract(dot(screenPos, magic.xy)));\n}\n\n\nvarying vec3 vWPosition;\nuniform vec3 emissive;\nuniform float penumbraSize[5];\nuniform sampler2D aoMap;\nuniform bool aoEnabled;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\nvarying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\nuniform float nodeU0;\nuniform float nodeU1;\nuniform float nodeU2;\nuniform vec2 nodeU3;\nuniform sampler2D nodeU4;\nuniform sampler2D nodeU5;\nuniform vec2 nodeU6;\nuniform float nodeU7;\nuniform float nodeU8;\nuniform float nodeU9;\nuniform vec3 nodeU10;\nuniform vec3 nodeU11;\nuniform bool nodeU12;\nuniform float nodeU13;\nuniform int nodeU14;\nuniform vec3 nodeU15;\nuniform float nodeU16;\nuniform float nodeU17;\nuniform float nodeU18;\nuniform float nodeU19;\nuniform bool nodeU20;\nuniform float nodeU21;\nuniform int nodeU22;\nuniform vec3 nodeU23;\nuniform float nodeU24;\nuniform float nodeU25;\nuniform float nodeU26;\nuniform float nodeU27;\nuniform bool nodeU28;\nuniform float nodeU29;\nuniform int nodeU30;\nuniform vec3 nodeU31;\nuniform float nodeU32;\nuniform bool nodeU33;\nuniform float nodeU34;\nuniform int nodeU35;\nuniform float nodeU36;\nuniform float nodeU37;\n\nuniform vec4 nodeUA0[4];\nuniform float nodeUA1[4];\n\n\n\nfloat w0( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n        }\n    \n        float w1( float a ) {\n            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n        }\n    \n        float w2( float a ){\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n        }\n    \n        float w3( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * a * a );\n        }\n    \n        // g0 and g1 are the two amplitude functions\n        float g0( float a ) {\n            return w0( a ) + w1( a );\n        }\n    \n        float g1( float a ) {\n            return w2( a ) + w3( a );\n        }\n    \n        // h0 and h1 are the two offset functions\n        float h0( float a ) {\n            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n        }\n    \n        float h1( float a ) {\n            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n        }\n    \n        vec4 bicubic( sampler2D tex, vec2 vUv, vec4 texelSize, float lod ) {\n            vUv = vUv * texelSize.zw + 0.5;\n    \n            vec2 iuv = floor( vUv );\n            vec2 fuv = fract( vUv );\n    \n            float g0x = g0( fuv.x );\n            float g1x = g1( fuv.x );\n            float h0x = h0( fuv.x );\n            float h1x = h1( fuv.x );\n            float h0y = h0( fuv.y );\n            float h1y = h1( fuv.y );\n    \n            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n    \n            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + \n                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n        }\n\n        vec4 textureBicubic( sampler2D sampler, vec2 vUv, float lod ) {\n            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n            vec2 fLodSizeInv = 1.0 / fLodSize;\n            vec2 cLodSizeInv = 1.0 / cLodSize;\n            vec4 fSample = bicubic( sampler, vUv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n            vec4 cSample = bicubic( sampler, vUv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n            return mix( fSample, cSample, fract( lod ) );\n        }\nfloat applyIorToRoughness( float roughness, float ior ) {\n\t\t\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\t\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t\t\t}\nvec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {\n                // Slightly modified version of this:\n                // https://www.shadertoy.com/view/ltScRG\n\n\t\t\t\t// Special case for blur == 0.0\n\t\t\t\tif (lod == 0.0) {\n\t\t\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\t\treturn texture2DLodEXT( sp, U, 0.0).rgb;\n\t\t\t\t\t#else\n\t\t\t\t\treturn textureLod( sp, U, 0.0).rgb;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec2 texelSize = vec2(1.0) / resolution;\n                vec2 halton = haltonSequence[frameIndex];\n                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n                float temporalAngle  = temporalOffset * PI2;\n\t\t\t\tvec3 res = vec3(0.0);\n                vec2 vUv = vec2(0.0);\n                vec2 offset = vec2(0.0);\n                vec2 vogelSample = vec2(0.0);\n                for (int i = 0; i < NUM_SAMPLES; i++) {\n                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;\n                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20\n                    vUv = U + offset;\n                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, vUv, lod));\n                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {\n                        vUv = unrefractedU;\n                        lod = lod > 4.0 ? lod : lod / 2.0;\n                    }\n                    res += textureLod(sp, vUv, lod).rgb;\n                }\n                return res / float(NUM_SAMPLES);\n            }\nvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\t        // Direction of refracted light.\n\t\t        vec3 refractionVector = refract( -v,  n, 1.0 / ior );\n\t\t        \n\t\t\t\t// Compute rotation-independant scaling of the model matrix.\n\t\t        vec3 modelScale;\n\t\t        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\t        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\t        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t        // The thickness is specified in local space\n\t\t        return normalize( refractionVector ) * thickness * modelScale;\n\t        }\nfloat vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vPosition.x - origin.x) + n.y*(vPosition.y - origin.y) + n.z*(vPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vWPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nvec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {\n\t\t\t\t\tfloat fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );\n\n\t\t\t\t\tfloat lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;\n\t\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\t\treturn color;\n\t\t\t\t}\nvec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {\n\t\t\t\t// Threejs exports do not pass a depth map to this shader, so we have to fallback to the \"Threejs method of blurring\" - see\n\t\t\t\t// also the code in convertTransmission.ts, which runs during export\n\t\t\t\t#ifdef IS_THREEJS_EXPORT\n\t\t\t\t\tfloat lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);\n\t\t\t\t\treturn textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;\n\t\t\t\t#else\n\t\t\t\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t\t\t\tfloat lod = applyIorToRoughness(roughness, ior);\n\t\t\t\t\treturn blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);\n\t\t\t\t#endif\n\t\t\t}\nvec3 gdf5f123cb813444e943da398041aedd4_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[gdf5f123cb813444e943da398041aedd4_MAX_COLORS], float steps[gdf5f123cb813444e943da398041aedd4_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {\n               vec4 color = colors[0];\n               #ifdef gdf5f123cb813444e943da398041aedd4_IS_VECTOR\n                   #ifdef gdf5f123cb813444e943da398041aedd4_LINEAR\n                       #ifdef gdf5f123cb813444e943da398041aedd4_WORLDSPACE\n                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);\n                       #else\n                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);\n                       #endif\n                   #else\n                       #ifdef gdf5f123cb813444e943da398041aedd4_WORLDSPACE\n                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);\n                       #else\n                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);\n                       #endif\n                   #endif\n               #else\n                   float dist = length(vWPosition - cameraPosition);\n\t\t\t       float depth = ( dist - near ) / ( far - near );\n               #endif\n\n\n              float p;\n              #ifdef gdf5f123cb813444e943da398041aedd4_SMOOTH\n\t\t\t\tfor ( int i = 1; i < gdf5f123cb813444e943da398041aedd4_MAX_COLORS; i++ ) {\n\t\t\t\t\t\tp = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );\n\t\t\t\t\t\tcolor = mix(color, colors[i], smoothstep(0.0, 1.0, p));\n\t\t\t\t\t}\n              #else\n                for ( int i = 1; i < gdf5f123cb813444e943da398041aedd4_MAX_COLORS; i++ ) {\n                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);\n                   color = mix(color, colors[i], p);\n                 }\n              #endif\n\n               float lalpha = alpha * color.a * mask;\n               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\t\t\t   \n               return color.rgb;\n\t\t\t}\nvec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\n\t\t\t\tvec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );\n\t\t\t\tvec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;\n\t\t\t\tunrefractedCoords += 1.0;\n\t\t\t\tunrefractedCoords /= 2.0;\n\n\t\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\t\treturn getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );\n    \t\t}\nvec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {\n                vec3 v = vec3(0.);\n                if (isOrthographic) {\n                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n                } else {\n                    v = normalize(vWPosition - cameraPosition);\n                }\n                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );\n                \n\t\t\t\tfloat lalpha = alpha * mask;\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * alpha;\n\n\t\t\t\treturn transmission;\n            }\n\nvoid main() {\n\nfloat g627fa06779964ee1b363313f8e785399_calpha;\nfloat gdf5f123cb813444e943da398041aedd4_calpha;\nfloat g822634f76f5542c4b775088f847f4c89_calpha;\nfloat g7c720394782c4ec7b24545ea3f46a937_calpha;\n\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n\n\t\t\t\t// NOTE: gl_FrontFacing alternative using face normal estimation.\n\t\t\t\tvec3 viewdx = dFdx(vViewPosition);\n\t\t\t\tvec3 viewdy = dFdy(vViewPosition);\n\t\t\t\tvec3 faceNormal = normalize(cross(viewdx,viewdy));\n\t\t\t\tif (dot(normal, faceNormal) < 0.0) {\n\t\t\t\t\tnormal *= -1.0;\n\t\t\t\t}\n\t\t\t\t\n\tBlinnPhongMaterial material;\n\n\tvec3 diffuseColor = spe_blend(spe_blend(spe_blend(transmission(nodeU0,nodeU1,nodeU2,nodeU3,nodeU4,nodeU5,nodeU6,normal,1.0,nodeU7,g627fa06779964ee1b363313f8e785399_calpha),gdf5f123cb813444e943da398041aedd4_sdepth(nodeU8,nodeU9,nodeU10,nodeU11,nodeUA0,nodeUA1,nodeU12,1.0,nodeU13,gdf5f123cb813444e943da398041aedd4_calpha),( gdf5f123cb813444e943da398041aedd4_calpha ),nodeU14),fresnel(nodeU15,nodeU16,nodeU17,nodeU18,nodeU19,nodeU20,1.0,nodeU21,nodeU22,g822634f76f5542c4b775088f847f4c89_calpha),( g822634f76f5542c4b775088f847f4c89_calpha ),nodeU22),fresnel(nodeU23,nodeU24,nodeU25,nodeU26,nodeU27,nodeU28,1.0,nodeU29,nodeU30,g7c720394782c4ec7b24545ea3f46a937_calpha),( g7c720394782c4ec7b24545ea3f46a937_calpha ),nodeU30);\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\tvec3 specular = nodeU31;\n\n\tfloat shininess = max( 0.0001, nodeU32 );\n\tfloat specularStrength = 1.0;\n\n#ifdef ALPHATEST\nif ( nodeU36 <= ALPHATEST ) discard;\n#endif\nmaterial.diffuseColor = diffuseColor;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t\n#endif\n#if ( 1 > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t\n\t\tdirectionalLight = directionalLights[ 0 ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( 0 < 0 )\n\t\tdirectionalLightShadow = directionalLightShadows[ 0 ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( 0, directionalShadowMap[ 0 ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( 1 > 0 )\n\t\t\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\nvec3 ao = aoEnabled && nodeU33 ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);\nvec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t\t\t\tif (outgoingLight != diffuseColor) {\n\t\t\t\t\tfloat lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );\n\t\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * nodeU34 * 1.0 * lightAccu;\n\t\t\t\t\toutgoingLight = spe_blend( diffuseColor, outgoingLight, nodeU34 * 1.0, nodeU35 );\n\t\t\t\t\t\n\t\t\t\t\toutgoingLight *= ao;\n\t\t\t\t}\n\t\t\t\t\ngl_FragColor = vec4( outgoingLight, accumAlpha * nodeU36);\ngl_FragColor.a *= nodeU37;\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_26;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_27;\n    float pad_28;\n    float pad_29;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_30;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_31;\n    float pad_32;\n    float pad_33;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform float3 _emissive : register(c7);\nuniform bool _aoEnabled : register(c8);\nuniform float3 _ambientLightColor : register(c9);\nuniform float3 _lightProbe[9] : register(c10);\nuniform _DirectionalLight _directionalLights[1] : register(c19);\nuniform _HemisphereLight _hemisphereLights[1] : register(c21);\nuniform float4x4 _modelMatrix : register(c24);\nuniform float4x4 _projectionMatrix : register(c28);\nuniform float _nodeU0 : register(c32);\nuniform float _nodeU1 : register(c33);\nuniform float _nodeU2 : register(c34);\nuniform float2 _nodeU3 : register(c35);\nuniform float2 _nodeU6 : register(c36);\nuniform float _nodeU7 : register(c37);\nuniform float _nodeU8 : register(c38);\nuniform float _nodeU9 : register(c39);\nuniform float3 _nodeU10 : register(c40);\nuniform float3 _nodeU11 : register(c41);\nuniform bool _nodeU12 : register(c42);\nuniform float _nodeU13 : register(c43);\nuniform int _nodeU14 : register(c44);\nuniform float3 _nodeU15 : register(c45);\nuniform float _nodeU16 : register(c46);\nuniform float _nodeU17 : register(c47);\nuniform float _nodeU18 : register(c48);\nuniform float _nodeU19 : register(c49);\nuniform bool _nodeU20 : register(c50);\nuniform float _nodeU21 : register(c51);\nuniform int _nodeU22 : register(c52);\nuniform float3 _nodeU23 : register(c53);\nuniform float _nodeU24 : register(c54);\nuniform float _nodeU25 : register(c55);\nuniform float _nodeU26 : register(c56);\nuniform float _nodeU27 : register(c57);\nuniform bool _nodeU28 : register(c58);\nuniform float _nodeU29 : register(c59);\nuniform int _nodeU30 : register(c60);\nuniform float3 _nodeU31 : register(c61);\nuniform float _nodeU32 : register(c62);\nuniform bool _nodeU33 : register(c63);\nuniform float _nodeU34 : register(c64);\nuniform int _nodeU35 : register(c65);\nuniform float _nodeU36 : register(c66);\nuniform float _nodeU37 : register(c67);\nuniform float4 _nodeUA0[4] : register(c68);\nuniform float _nodeUA1[4] : register(c72);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nstatic float _accumAlpha = {0.0};\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2708 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2708)) + (_f90 * _fresnel2708));\n}\nfloat f_G_BlinnPhong_Implicit()\n{\nreturn 0.25;\n}\nfloat f_D_BlinnPhong(const float _shininess, const float _dotNH)\n{\nreturn ((0.31830987 * ((_shininess * 0.5) + 1.0)) * pow(_dotNH, _shininess));\n}\nfloat3 f_BRDF_BlinnPhong(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _specularColor, const float _shininess)\n{\nfloat3 _halfDir2795 = normalize((_lightDir + _viewDir));\nfloat _dotNH2796 = clamp(dot(_normal, _halfDir2795), 0.0, 1.0);\nfloat _dotVH2797 = clamp(dot(_viewDir, _halfDir2795), 0.0, 1.0);\nfloat3 _F2798 = f_F_Schlick(_specularColor, 1.0, _dotVH2797);\nfloat _G2799 = f_G_BlinnPhong_Implicit();\nfloat _D2800 = f_D_BlinnPhong(_shininess, _dotNH2796);\nreturn (_F2798 * (_G2799 * _D2800));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2807 = _normal.x;\nfloat _y2808 = _normal.y;\nfloat _z2809 = _normal.z;\nfloat3 _result2810 = (_shCoefficients[0] * 0.88622701);\n(_result2810 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2808));\n(_result2810 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2809));\n(_result2810 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2807));\n(_result2810 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2807) * _y2808));\n(_result2810 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2808) * _z2809));\n(_result2810 += (_shCoefficients[6] * (((0.74312502 * _z2809) * _z2809) - 0.24770799)));\n(_result2810 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2807) * _z2809));\n(_result2810 += ((_shCoefficients[8] * 0.42904299) * ((_x2807 * _x2807) - (_y2808 * _y2808))));\nreturn _result2810;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2814 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2815 = f_shGetIrradianceAt(_worldNormal2814, _lightProbe);\nreturn _irradiance2815;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2818 = _ambientLightColor;\nreturn _irradiance2818;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2840 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2841 = ((0.5 * _dotNL2840) + 0.5);\nfloat3 _irradiance2842 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2841);\nreturn _irradiance2842;\n}\n;\nvoid f_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2851 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2852 = (_dotNL2851 * _directLight._color);\n(_reflectedLight._directDiffuse += (_irradiance2852 * f_BRDF_Lambert(_material._diffuseColor)));\n(_reflectedLight._directSpecular += ((_irradiance2852 * f_BRDF_BlinnPhong(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularShininess)) * _material._specularStrength));\n}\nvoid f_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2864 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2865 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2865 = lerp((2.0 * _dither_shift_RGB2865), (-2.0 * _dither_shift_RGB2865), _grid_position2864));\nreturn (_color + _dither_shift_RGB2865);\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2933 = floor(_vUv);\nfloat2 _fuv2934 = frac(_vUv);\nfloat _g0x2935 = f_g0(_fuv2934.x);\nfloat _g1x2936 = f_g1(_fuv2934.x);\nfloat _h0x2937 = f_h0(_fuv2934.x);\nfloat _h1x2938 = f_h1(_fuv2934.x);\nfloat _h0y2939 = f_h0(_fuv2934.y);\nfloat _h1y2940 = f_h1(_fuv2934.y);\nfloat2 _p02941 = ((vec2_ctor((_iuv2933.x + _h0x2937), (_iuv2933.y + _h0y2939)) - 0.5) * _texelSize.xy);\nfloat2 _p12942 = ((vec2_ctor((_iuv2933.x + _h1x2938), (_iuv2933.y + _h0y2939)) - 0.5) * _texelSize.xy);\nfloat2 _p22943 = ((vec2_ctor((_iuv2933.x + _h0x2937), (_iuv2933.y + _h1y2940)) - 0.5) * _texelSize.xy);\nfloat2 _p32944 = ((vec2_ctor((_iuv2933.x + _h1x2938), (_iuv2933.y + _h1y2940)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2934.y) * ((_g0x2935 * gl_texture2DLod(_tex, _p02941, _lod)) + (_g1x2936 * gl_texture2DLod(_tex, _p12942, _lod)))) + (f_g1(_fuv2934.y) * ((_g0x2935 * gl_texture2DLod(_tex, _p22943, _lod)) + (_g1x2936 * gl_texture2DLod(_tex, _p32944, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize2949 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize2950 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv2951 = (1.0 / _fLodSize2949);\nfloat2 _cLodSizeInv2952 = (1.0 / _cLodSize2950);\nfloat4 _fSample2953 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv2951, _fLodSize2949), floor(_lod));\nfloat4 _cSample2954 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv2952, _cLodSize2950), ceil(_lod));\nreturn lerp(_fSample2953, _cSample2954, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector2982 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale2983 = {0, 0, 0};\n(_modelScale2983.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale2983.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale2983.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector2982) * _thickness) * _modelScale2983);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist3002 = length((_vPosition - _origin));\nreturn ((_dist3002 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3019 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3020 = ((clamp(_fresnel3019, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3020 / clamp((_lalpha3020 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3020, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3020) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3030 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3030).xyz;\n}\nfloat3 f_gdf5f123cb813444e943da398041aedd4_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3042 = _colors[0];\nfloat _depth3043 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3044 = {0};\n{ for(int _i3045 = {1}; (_i3045 < 4); (_i3045++))\n{\n(_p3044 = clamp(((_depth3043 - _steps[(_i3045 - 1)]) / (_steps[_i3045] - _steps[(_i3045 - 1)])), 0.0, 1.0));\n(_color3042 = lerp(_color3042, _colors[_i3045], _p3044));\n}\n}\nfloat _lalpha3046 = ((_alpha * _color3042.w) * _mask);\n(_calpha = lerp((_lalpha3046 / clamp((_lalpha3046 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3046, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3046) * (1.0 - float_ctor(_isMask))));\nreturn _color3042.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3061 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3062 = (_position + _transmissionRay3061);\nfloat4 _ndcPos3063 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3062, 1.0));\nfloat2 _refractionCoords3064 = (_ndcPos3063.xy / _ndcPos3063.w);\n(_refractionCoords3064 += 1.0);\n(_refractionCoords3064 /= 2.0);\nfloat4 _ndcPosUnrefracted3065 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3066 = (_ndcPosUnrefracted3065.xy / _ndcPosUnrefracted3065.w);\n(_unrefractedCoords3066 += 1.0);\n(_unrefractedCoords3066 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3064, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3066, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3079 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3079 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3079 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3080 = f_getIBLVolumeRefraction(_vWNormal, (-_v3079), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3081 = (_alpha * _mask);\n(_calpha = (_lalpha3081 / clamp((_lalpha3081 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3080;\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat _g627fa06779964ee1b363313f8e785399_calpha3083 = {0};\nfloat _gdf5f123cb813444e943da398041aedd4_calpha3084 = {0};\nfloat _g822634f76f5542c4b775088f847f4c89_calpha3085 = {0};\nfloat _g7c720394782c4ec7b24545ea3f46a937_calpha3086 = {0};\nfloat3 _normal3088 = normalize(_vNormal);\nfloat3 _viewdx3090 = ddx(_vViewPosition);\nfloat3 _viewdy3091 = ddy(_vViewPosition);\nfloat3 _faceNormal3092 = normalize(cross(_viewdx3090, _viewdy3091));\nif ((dot(_normal3088, _faceNormal3092) < 0.0))\n{\n(_normal3088 *= -1.0);\n}\n_BlinnPhongMaterial _material3093 = {0, 0, 0, 0, 0, 0, 0, 0};\nfloat3 _diffuseColor3094 = f_spe_blend_int(f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3088, 1.0, _nodeU7, _g627fa06779964ee1b363313f8e785399_calpha3083), f_gdf5f123cb813444e943da398041aedd4_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _gdf5f123cb813444e943da398041aedd4_calpha3084), _gdf5f123cb813444e943da398041aedd4_calpha3084, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _g822634f76f5542c4b775088f847f4c89_calpha3085), _g822634f76f5542c4b775088f847f4c89_calpha3085, _nodeU22), f_fresnel_int(_nodeU23, _nodeU24, _nodeU25, _nodeU26, _nodeU27, _nodeU28, 1.0, _nodeU29, _nodeU30, _g7c720394782c4ec7b24545ea3f46a937_calpha3086), _g7c720394782c4ec7b24545ea3f46a937_calpha3086, _nodeU30);\n_ReflectedLight _reflectedLight3095 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 _totalEmissiveRadiance3096 = _emissive;\nfloat3 _specular3097 = _nodeU31;\nfloat _shininess3098 = max(9.9999997e-05, _nodeU32);\nfloat _specularStrength3099 = {1.0};\n(_material3093._diffuseColor = _diffuseColor3094);\n(_material3093._specularColor = _specular3097);\n(_material3093._specularShininess = _shininess3098);\n(_material3093._specularStrength = _specularStrength3099);\n_GeometricContext _geometry3100 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry3100._position = (-_vViewPosition));\n(_geometry3100._normal = _normal3088);\nfloat3 sc24 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sc24 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sc24 = normalize(_vViewPosition));\n}\n(_geometry3100._viewDir = sc24);\n_IncidentLight _directLight3101 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight3102 = {0, 0, 0, 0, 0, 0};\n(_directionalLight3102 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight3102, _geometry3100, _directLight3101);\nf_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(_directLight3101, _geometry3100, _material3093, _reflectedLight3095);\nfloat3 _irradiance3104 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance3104 += f_getLightProbeIrradiance(_lightProbe, _geometry3100._normal));\n(_irradiance3104 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry3100._normal));\nf_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(_irradiance3104, _geometry3100, _material3093, _reflectedLight3095);\nfloat3 sc25 = {0, 0, 0};\nif ((_aoEnabled && _nodeU33))\n{\n(sc25 = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc25 = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3105 = sc25;\nfloat3 _outgoingLight3106 = ((((_reflectedLight3095._directDiffuse + _reflectedLight3095._indirectDiffuse) + _reflectedLight3095._directSpecular) + _reflectedLight3095._indirectSpecular) + _totalEmissiveRadiance3096);\nif (!all(_outgoingLight3106 == _diffuseColor3094))\n{\nfloat _lightAccu3107 = clamp(length((_reflectedLight3095._directSpecular + _reflectedLight3095._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU34) * 1.0) * _lightAccu3107));\n(_outgoingLight3106 = f_spe_blend_int(_diffuseColor3094, _outgoingLight3106, (_nodeU34 * 1.0), _nodeU35));\n(_outgoingLight3106 *= _ao3105);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3106, (_accumAlpha * _nodeU36)));\n(out_pc_fragColor.w *= _nodeU37);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD6;\n    float4 gl_FragCoord : TEXCOORD7;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_26;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_27;\n    float pad_28;\n    float pad_29;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__BlinnPhongMaterial\n{\n    float3 _diffuseColor;\n    float pad_30;\n    float3 _specularColor;\n    float _specularShininess;\n    float _specularStrength;\n    float pad_31;\n    float pad_32;\n    float pad_33;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform float3 _emissive : register(c7);\nuniform bool _aoEnabled : register(c8);\nuniform float3 _ambientLightColor : register(c9);\nuniform float3 _lightProbe[9] : register(c10);\nuniform _DirectionalLight _directionalLights[1] : register(c19);\nuniform _HemisphereLight _hemisphereLights[1] : register(c21);\nuniform float4x4 _modelMatrix : register(c24);\nuniform float4x4 _projectionMatrix : register(c28);\nuniform float _nodeU0 : register(c32);\nuniform float _nodeU1 : register(c33);\nuniform float _nodeU2 : register(c34);\nuniform float2 _nodeU3 : register(c35);\nuniform float2 _nodeU6 : register(c36);\nuniform float _nodeU7 : register(c37);\nuniform float _nodeU8 : register(c38);\nuniform float _nodeU9 : register(c39);\nuniform float3 _nodeU10 : register(c40);\nuniform float3 _nodeU11 : register(c41);\nuniform bool _nodeU12 : register(c42);\nuniform float _nodeU13 : register(c43);\nuniform int _nodeU14 : register(c44);\nuniform float3 _nodeU15 : register(c45);\nuniform float _nodeU16 : register(c46);\nuniform float _nodeU17 : register(c47);\nuniform float _nodeU18 : register(c48);\nuniform float _nodeU19 : register(c49);\nuniform bool _nodeU20 : register(c50);\nuniform float _nodeU21 : register(c51);\nuniform int _nodeU22 : register(c52);\nuniform float3 _nodeU23 : register(c53);\nuniform float _nodeU24 : register(c54);\nuniform float _nodeU25 : register(c55);\nuniform float _nodeU26 : register(c56);\nuniform float _nodeU27 : register(c57);\nuniform bool _nodeU28 : register(c58);\nuniform float _nodeU29 : register(c59);\nuniform int _nodeU30 : register(c60);\nuniform float3 _nodeU31 : register(c61);\nuniform float _nodeU32 : register(c62);\nuniform bool _nodeU33 : register(c63);\nuniform float _nodeU34 : register(c64);\nuniform int _nodeU35 : register(c65);\nuniform float _nodeU36 : register(c66);\nuniform float _nodeU37 : register(c67);\nuniform float4 _nodeUA0[4] : register(c68);\nuniform float _nodeUA1[4] : register(c72);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nstatic float _accumAlpha = {0.0};\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2708 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2708)) + (_f90 * _fresnel2708));\n}\nfloat f_G_BlinnPhong_Implicit()\n{\nreturn 0.25;\n}\nfloat f_D_BlinnPhong(const float _shininess, const float _dotNH)\n{\nreturn ((0.31830987 * ((_shininess * 0.5) + 1.0)) * pow(_dotNH, _shininess));\n}\nfloat3 f_BRDF_BlinnPhong(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _specularColor, const float _shininess)\n{\nfloat3 _halfDir2795 = normalize((_lightDir + _viewDir));\nfloat _dotNH2796 = clamp(dot(_normal, _halfDir2795), 0.0, 1.0);\nfloat _dotVH2797 = clamp(dot(_viewDir, _halfDir2795), 0.0, 1.0);\nfloat3 _F2798 = f_F_Schlick(_specularColor, 1.0, _dotVH2797);\nfloat _G2799 = f_G_BlinnPhong_Implicit();\nfloat _D2800 = f_D_BlinnPhong(_shininess, _dotNH2796);\nreturn (_F2798 * (_G2799 * _D2800));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2807 = _normal.x;\nfloat _y2808 = _normal.y;\nfloat _z2809 = _normal.z;\nfloat3 _result2810 = (_shCoefficients[0] * 0.88622701);\n(_result2810 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2808));\n(_result2810 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2809));\n(_result2810 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2807));\n(_result2810 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2807) * _y2808));\n(_result2810 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2808) * _z2809));\n(_result2810 += (_shCoefficients[6] * (((0.74312502 * _z2809) * _z2809) - 0.24770799)));\n(_result2810 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2807) * _z2809));\n(_result2810 += ((_shCoefficients[8] * 0.42904299) * ((_x2807 * _x2807) - (_y2808 * _y2808))));\nreturn _result2810;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2814 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2815 = f_shGetIrradianceAt(_worldNormal2814, _lightProbe);\nreturn _irradiance2815;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2818 = _ambientLightColor;\nreturn _irradiance2818;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2840 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2841 = ((0.5 * _dotNL2840) + 0.5);\nfloat3 _irradiance2842 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2841);\nreturn _irradiance2842;\n}\n;\nvoid f_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2851 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2852 = (_dotNL2851 * _directLight._color);\n(_reflectedLight._directDiffuse += (_irradiance2852 * f_BRDF_Lambert(_material._diffuseColor)));\n(_reflectedLight._directSpecular += ((_irradiance2852 * f_BRDF_BlinnPhong(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularShininess)) * _material._specularStrength));\n}\nvoid f_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _BlinnPhongMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2864 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2865 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2865 = lerp((2.0 * _dither_shift_RGB2865), (-2.0 * _dither_shift_RGB2865), _grid_position2864));\nreturn (_color + _dither_shift_RGB2865);\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2933 = floor(_vUv);\nfloat2 _fuv2934 = frac(_vUv);\nfloat _g0x2935 = f_g0(_fuv2934.x);\nfloat _g1x2936 = f_g1(_fuv2934.x);\nfloat _h0x2937 = f_h0(_fuv2934.x);\nfloat _h1x2938 = f_h1(_fuv2934.x);\nfloat _h0y2939 = f_h0(_fuv2934.y);\nfloat _h1y2940 = f_h1(_fuv2934.y);\nfloat2 _p02941 = ((vec2_ctor((_iuv2933.x + _h0x2937), (_iuv2933.y + _h0y2939)) - 0.5) * _texelSize.xy);\nfloat2 _p12942 = ((vec2_ctor((_iuv2933.x + _h1x2938), (_iuv2933.y + _h0y2939)) - 0.5) * _texelSize.xy);\nfloat2 _p22943 = ((vec2_ctor((_iuv2933.x + _h0x2937), (_iuv2933.y + _h1y2940)) - 0.5) * _texelSize.xy);\nfloat2 _p32944 = ((vec2_ctor((_iuv2933.x + _h1x2938), (_iuv2933.y + _h1y2940)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2934.y) * ((_g0x2935 * gl_texture2DLod(_tex, _p02941, _lod)) + (_g1x2936 * gl_texture2DLod(_tex, _p12942, _lod)))) + (f_g1(_fuv2934.y) * ((_g0x2935 * gl_texture2DLod(_tex, _p22943, _lod)) + (_g1x2936 * gl_texture2DLod(_tex, _p32944, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize2949 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize2950 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv2951 = (1.0 / _fLodSize2949);\nfloat2 _cLodSizeInv2952 = (1.0 / _cLodSize2950);\nfloat4 _fSample2953 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv2951, _fLodSize2949), floor(_lod));\nfloat4 _cSample2954 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv2952, _cLodSize2950), ceil(_lod));\nreturn lerp(_fSample2953, _cSample2954, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector2982 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale2983 = {0, 0, 0};\n(_modelScale2983.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale2983.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale2983.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector2982) * _thickness) * _modelScale2983);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist3002 = length((_vPosition - _origin));\nreturn ((_dist3002 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3019 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3020 = ((clamp(_fresnel3019, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3020 / clamp((_lalpha3020 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3020, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3020) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3030 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3030).xyz;\n}\nfloat3 f_gdf5f123cb813444e943da398041aedd4_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3042 = _colors[0];\nfloat _depth3043 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3044 = {0};\n{ for(int _i3045 = {1}; (_i3045 < 4); (_i3045++))\n{\n(_p3044 = clamp(((_depth3043 - _steps[(_i3045 - 1)]) / (_steps[_i3045] - _steps[(_i3045 - 1)])), 0.0, 1.0));\n(_color3042 = lerp(_color3042, _colors[_i3045], _p3044));\n}\n}\nfloat _lalpha3046 = ((_alpha * _color3042.w) * _mask);\n(_calpha = lerp((_lalpha3046 / clamp((_lalpha3046 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3046, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3046) * (1.0 - float_ctor(_isMask))));\nreturn _color3042.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3061 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3062 = (_position + _transmissionRay3061);\nfloat4 _ndcPos3063 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3062, 1.0));\nfloat2 _refractionCoords3064 = (_ndcPos3063.xy / _ndcPos3063.w);\n(_refractionCoords3064 += 1.0);\n(_refractionCoords3064 /= 2.0);\nfloat4 _ndcPosUnrefracted3065 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3066 = (_ndcPosUnrefracted3065.xy / _ndcPosUnrefracted3065.w);\n(_unrefractedCoords3066 += 1.0);\n(_unrefractedCoords3066 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3064, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3066, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3079 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3079 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3079 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3080 = f_getIBLVolumeRefraction(_vWNormal, (-_v3079), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3081 = (_alpha * _mask);\n(_calpha = (_lalpha3081 / clamp((_lalpha3081 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3080;\n}\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input){\n    float rhw = 1.0 / input.gl_FragCoord.w;\n    gl_FragCoord.x = input.dx_Position.x - dx_FragCoordOffset.x;\n    gl_FragCoord.y = input.dx_Position.y - dx_FragCoordOffset.y;\n    gl_FragCoord.z = input.dx_Position.z;\n    gl_FragCoord.w = rhw;\n    _vViewPosition = input.v0.xyz;\n    _vWPosition = input.v1.xyz;\n    _vNormal = input.v2.xyz;\n    _vPosition = input.v3.xyz;\n    _vWNormal = input.v4.xyz;\n    _vWorldViewDir = input.v5.xyz;\n\nfloat _g627fa06779964ee1b363313f8e785399_calpha3083 = {0};\nfloat _gdf5f123cb813444e943da398041aedd4_calpha3084 = {0};\nfloat _g822634f76f5542c4b775088f847f4c89_calpha3085 = {0};\nfloat _g7c720394782c4ec7b24545ea3f46a937_calpha3086 = {0};\nfloat3 _normal3088 = normalize(_vNormal);\nfloat3 _viewdx3090 = ddx(_vViewPosition);\nfloat3 _viewdy3091 = ddy(_vViewPosition);\nfloat3 _faceNormal3092 = normalize(cross(_viewdx3090, _viewdy3091));\nif ((dot(_normal3088, _faceNormal3092) < 0.0))\n{\n(_normal3088 *= -1.0);\n}\n_BlinnPhongMaterial _material3093 = {0, 0, 0, 0, 0, 0, 0, 0};\nfloat3 _diffuseColor3094 = f_spe_blend_int(f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3088, 1.0, _nodeU7, _g627fa06779964ee1b363313f8e785399_calpha3083), f_gdf5f123cb813444e943da398041aedd4_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _gdf5f123cb813444e943da398041aedd4_calpha3084), _gdf5f123cb813444e943da398041aedd4_calpha3084, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _g822634f76f5542c4b775088f847f4c89_calpha3085), _g822634f76f5542c4b775088f847f4c89_calpha3085, _nodeU22), f_fresnel_int(_nodeU23, _nodeU24, _nodeU25, _nodeU26, _nodeU27, _nodeU28, 1.0, _nodeU29, _nodeU30, _g7c720394782c4ec7b24545ea3f46a937_calpha3086), _g7c720394782c4ec7b24545ea3f46a937_calpha3086, _nodeU30);\n_ReflectedLight _reflectedLight3095 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat3 _totalEmissiveRadiance3096 = _emissive;\nfloat3 _specular3097 = _nodeU31;\nfloat _shininess3098 = max(9.9999997e-05, _nodeU32);\nfloat _specularStrength3099 = {1.0};\n(_material3093._diffuseColor = _diffuseColor3094);\n(_material3093._specularColor = _specular3097);\n(_material3093._specularShininess = _shininess3098);\n(_material3093._specularStrength = _specularStrength3099);\n_GeometricContext _geometry3100 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry3100._position = (-_vViewPosition));\n(_geometry3100._normal = _normal3088);\nfloat3 sc24 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sc24 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sc24 = normalize(_vViewPosition));\n}\n(_geometry3100._viewDir = sc24);\n_IncidentLight _directLight3101 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight3102 = {0, 0, 0, 0, 0, 0};\n(_directionalLight3102 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight3102, _geometry3100, _directLight3101);\nf_RE_Direct_BlinnPhong__IncidentLight__GeometricContext__BlinnPhongMaterial__ReflectedLight(_directLight3101, _geometry3100, _material3093, _reflectedLight3095);\nfloat3 _irradiance3104 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance3104 += f_getLightProbeIrradiance(_lightProbe, _geometry3100._normal));\n(_irradiance3104 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry3100._normal));\nf_RE_IndirectDiffuse_BlinnPhong__GeometricContext__BlinnPhongMaterial__ReflectedLight(_irradiance3104, _geometry3100, _material3093, _reflectedLight3095);\nfloat3 sc25 = {0, 0, 0};\nif ((_aoEnabled && _nodeU33))\n{\n(sc25 = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc25 = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3105 = sc25;\nfloat3 _outgoingLight3106 = ((((_reflectedLight3095._directDiffuse + _reflectedLight3095._indirectDiffuse) + _reflectedLight3095._directSpecular) + _reflectedLight3095._indirectSpecular) + _totalEmissiveRadiance3096);\nif (!all(_outgoingLight3106 == _diffuseColor3094))\n{\nfloat _lightAccu3107 = clamp(length((_reflectedLight3095._directSpecular + _reflectedLight3095._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU34) * 1.0) * _lightAccu3107));\n(_outgoingLight3106 = f_spe_blend_int(_diffuseColor3094, _outgoingLight3106, (_nodeU34 * 1.0), _nodeU35));\n(_outgoingLight3106 *= _ao3105);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3106, (_accumAlpha * _nodeU36)));\n(out_pc_fragColor.w *= _nodeU37);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 309",
                                "id": 309,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.5994671583175659,
                            -5.9073262214660645,
                            -1.525807499885559,
                            0,
                            -1.4231451749801636,
                            -1.6262495517730713,
                            5.73706579208374,
                            0,
                            -5.932895660400391,
                            -0.20678921043872833,
                            -1.5303401947021484,
                            0,
                            1395.1494140625,
                            710.5416259765625,
                            -550.0938110351562,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 310",
                                "id": 310,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.6046777963638306,
                            -5.889223098754883,
                            -1.5922852754592896,
                            0,
                            -1.4427422285079956,
                            -1.6927427053451538,
                            5.712886333465576,
                            0,
                            -5.927631378173828,
                            -0.18875853717327118,
                            -1.5529038906097412,
                            0,
                            1397.0211181640625,
                            716.829833984375,
                            -15538.130859375,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 311",
                                "id": 311,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0007603672565892339,
                            0,
                            0,
                            0,
                            0,
                            0.0015251043951138854,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 312",
                                "id": 312,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "viewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.999994158744812,
                            -0.00003970626858063042,
                            0.0034170825965702534,
                            0,
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598,
                            0,
                            -0.0034173133317381144,
                            -0.011619079858064651,
                            0.9999266862869263,
                            0,
                            -3.0878077872387166e-15,
                            0,
                            -15001.1005859375,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 313",
                                "id": 313,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "normalMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT3",
                        "value": [
                            0.01608872227370739,
                            -0.1566951423883438,
                            -0.042366091161966324,
                            -0.03838718309998512,
                            -0.04503897204995155,
                            0.15200333297252655,
                            -0.15771707892417908,
                            -0.005022317171096802,
                            -0.041318267583847046
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 314",
                                "id": 314,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "cameraPosition",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            51.2599983215332,
                            174.3000030517578,
                            15000
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 315",
                                "id": 315,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "isOrthographic",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": true
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 316",
                                "id": 316,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "resolution",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC2",
                        "value": [
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 317",
                                "id": 317,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "emissive",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0,
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 318",
                                "id": 318,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "aoEnabled",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": false
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 319",
                                "id": 319,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "ambientLightColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0,
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 320",
                                "id": 320,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "lightProbe",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 9,
                        "type": "FLOAT_VEC3",
                        "values": [
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 321",
                                "id": 321,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "directionalLights[0].direction",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            -0.440809041261673,
                            0.8562363386154175,
                            -0.26934507489204407
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 322",
                                "id": 322,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "directionalLights[0].color",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            2.880840539932251,
                            2.880840539932251,
                            2.880840539932251
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 323",
                                "id": 323,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].direction",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 324",
                                "id": 324,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].skyColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            2.092608690261841,
                            2.092608690261841,
                            2.092608690261841
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 325",
                                "id": 325,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].groundColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1.2892849445343018,
                            1.2892849445343018,
                            1.2892849445343018
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 326",
                                "id": 326,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU0",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 2
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 327",
                                "id": 327,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU1",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1.5
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 328",
                                "id": 328,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU2",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 4
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 329",
                                "id": 329,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU3",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC2",
                        "value": [
                            1745,
                            870
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 330",
                                "id": 330,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU6",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC2",
                        "value": [
                            0.4985673427581787,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 331",
                                "id": 331,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU7",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 332",
                                "id": 332,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU8",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 39.4227409362793
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 333",
                                "id": 333,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU9",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 159.49636840820312
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 334",
                                "id": 334,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU10",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            -61.58479690551758,
                            108.48526000976562,
                            89.03157043457031
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 335",
                                "id": 335,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU11",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 336",
                                "id": 336,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU12",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": false
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 337",
                                "id": 337,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU13",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 338",
                                "id": 338,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU14",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "INT",
                        "value": 2
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 339",
                                "id": 339,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU15",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            1,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 340",
                                "id": 340,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU16",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 0.10000000149011612
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 341",
                                "id": 341,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU17",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 342",
                                "id": 342,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU18",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 2
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 343",
                                "id": 343,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU19",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 344",
                                "id": 344,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU20",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": false
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 345",
                                "id": 345,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU21",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 346",
                                "id": 346,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU22",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "INT",
                        "value": 3
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 347",
                                "id": 347,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU23",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            1,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 348",
                                "id": 348,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU24",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 0.10000000149011612
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 349",
                                "id": 349,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU25",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 350",
                                "id": 350,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU26",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 2
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 351",
                                "id": 351,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU27",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 352",
                                "id": 352,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU28",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": false
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 353",
                                "id": 353,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU29",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 354",
                                "id": 354,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU30",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "INT",
                        "value": 3
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 355",
                                "id": 355,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU31",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0.20000000298023224,
                            0.20000000298023224,
                            0.20000000298023224
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 356",
                                "id": 356,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU32",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 5
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 357",
                                "id": 357,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU33",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": true
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 358",
                                "id": 358,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU34",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 0.699999988079071
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 359",
                                "id": 359,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU35",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "INT",
                        "value": 3
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 360",
                                "id": 360,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU36",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 361",
                                "id": 361,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU37",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 362",
                                "id": 362,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeUA0",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 4,
                        "type": "FLOAT_VEC4",
                        "values": [
                            {
                                "value": [
                                    0,
                                    0.21835188567638397,
                                    0.5038889646530151,
                                    1
                                ]
                            },
                            {
                                "value": [
                                    0.09380099922418594,
                                    0.17632801830768585,
                                    0.34138205647468567,
                                    1
                                ]
                            },
                            {
                                "value": [
                                    0.033324576914310455,
                                    0.10843804478645325,
                                    0.21563883125782013,
                                    1
                                ]
                            },
                            {
                                "value": [
                                    0.03739052265882492,
                                    0.05459984391927719,
                                    0.10192546993494034,
                                    1
                                ]
                            }
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 363",
                                "id": 363,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeUA1",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 4,
                        "type": "FLOAT",
                        "values": [
                            {
                                "value": 0
                            },
                            {
                                "value": 0.26302361488342285
                            },
                            {
                                "value": 0.5813862085342407
                            },
                            {
                                "value": 0.9511203765869141
                            }
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 364",
                                "id": 364,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "aoMap",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "texture": {
                            "anisotropy": 1,
                            "baseLevel": 0,
                            "compareFunc": "LEQUAL",
                            "compareMode": "NONE",
                            "format": "RGBA",
                            "height": 1,
                            "immutable": false,
                            "immutableLevels": 0,
                            "internalFormat": "RGBA",
                            "magFilter": "NEAREST",
                            "maxLevel": 1000,
                            "maxLod": 1000,
                            "minFilter": "NEAREST",
                            "minLod": -1000,
                            "textureType": "UNSIGNED_BYTE",
                            "visual": {
                                "TEXTURE_2D": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAABkhJREFUeF7t1AERAAAIAjHpX9ogPxswPHaOAIGswLLJBSdA4AyAJyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedwAOf2gEBwEDqbgAAAABJRU5ErkJggg=="
                            },
                            "width": 1,
                            "wrapR": "REPEAT",
                            "wrapS": "REPEAT",
                            "wrapT": "REPEAT"
                        },
                        "type": "SAMPLER_2D",
                        "value": 0
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 365",
                                "id": 365,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU4",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "texture": {
                            "anisotropy": 1,
                            "baseLevel": 0,
                            "compareFunc": "LEQUAL",
                            "compareMode": "NONE",
                            "format": "RGBA",
                            "height": 870,
                            "immutable": false,
                            "immutableLevels": 0,
                            "internalFormat": "RGBA16F",
                            "magFilter": "LINEAR",
                            "maxLevel": 1000,
                            "maxLod": 1000,
                            "minFilter": "LINEAR_MIPMAP_LINEAR",
                            "minLod": -1000,
                            "textureType": "HALF_FLOAT",
                            "visual": {
                                "TEXTURE_2D": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAABb1JREFUeF7t2M2rp2MYB/D7nO2UOgs1NkZJkvfMDKGE2GhMNClLLKyIQSOmTqeYTBhiZSFLpYnGZGNCysbMyHuSTubYmN35Dw7N4ixGk87cXc/vd1/3/VEWdJ7r+V6f6+nbmVnYdsml/xT/zEXgxQPPldcOvzmXd3spgXMCCwrAh0BgXAEFMOfbf3z0w/LwvkfnnMLrRxVQAKNe3t4E/BGgjW/gj99/KlddfUMbYaQYSsBvAEOd27IEzhdQAI18EWdWfytXXHlNI2nEGEVAAYxyaXsSuICAAmjoszh+7GjZs3dfQ4lE6V1AAfR+YfsR+B8BBdDY53Ho1ZXy0svLjaUSp1cBBdDrZe1FYAsCCmALSLP+kQf3PFA+Pf7ZrF/rfQMKKIABj25lApsCCqDRb+H6664tP//ya6PpxOpFQAH0ckl7EKgQUAAVaB4h0IuAAujlkvYgUCGgACrQPEKgFwEF0Msl7UGgQkABVKB5hEAvAgqgl0vag0CFgAKoQPMIgV4EFEAvl7QHgQoBBVCB5hECvQgogF4uaQ8CFQIKoALNIwR6EVAACS952fbt5e+zZxMmF7k1AQXQ2kXkITBDAQUwQ+zIV91/373l8xNfRI40a0ABBTDg0a1MYFNAAST+Fg68sL8cfv1I4g1En7eAApj3BbyfwBwFFMAc8SNe/cH775XHnngyYpQZAwoogAGPbmUC/g6go2/g9LfflJ233tnRRlaZlYDfAGYl7T0EGhRQAA0epSbSO2+/UZ5+5vmaRz0zsIACGPj4ViegADr6Bo598lHZ+9AjHW1klakFFMDUwuYTaFhAATR8nJpoO3ZcXtbW/qp51DMDCiiAAY9uZQKbAgqgw29h165byqlT33W4mZWiBRRAtKh5BBIJKIBEx7qYqDffdGP5/ocfL+YRPzuggAIY8OhWJuDvAAb4BhYXF8vGxsYAm1qxVsBvALVyniPQgYAC6OCIViBQK6AAauU8R6ADAQXQwRGtQKBWQAHUyiV7bmlpqayvrydLLe7UAgpgamHzCTQsoAAaPo5oBKYWUABTC5tPoGEBBdDwcaaItv/Zp8qRt96dYrSZCQUUQMKjiUwgSkABREkmmnPP3XeVL7/6OlFiUacSUABTyZpLIIGAAkhwpCki7t69s5w8eXqK0WYmElAAiY4lKoFoAQUQLZpo3srywbK88kqixKJGCyiAaNFE8+64/bby+NpqWf3zTCkL5fx/z+3x3/93of9u/efOZd5qxqCfPXRiW5qvQAGkOZWgBOIFFEC8qYkE0ggogDSnEpRAvIACiDc1kUAaAQWQ5lSCEogXUADxpiYSSCOgANKcSlAC8QIKIN7URAJpBBRAmlMJSiBeQAHEm5pIII2AAkhzKkEJxAsogHhTEwmkEVAAaU4lKIF4AQUQb2oigTQCCiDNqQQlEC+gAOJNTSSQRkABpDmVoATiBRRAvKmJBNIIKIA0pxKUQLyAAog3NZFAGgEFkOZUghKIF1AA8aYmEkgjoADSnEpQAvECCiDe1EQCaQQUQJpTCUogXkABxJuaSCCNgAJIcypBCcQLKIB4UxMJpBFQAGlOJSiBeAEFEG9qIoE0AgogzakEJRAvoADiTU0kkEZAAaQ5laAE4gUUQLypiQTSCCiANKcSlEC8gAKINzWRQBoBBZDmVIISiBdQAPGmJhJII6AA0pxKUALxAgog3tREAmkEFECaUwlKIF5AAcSbmkggjYACSHMqQQnECyiAeFMTCaQRUABpTiUogXgBBRBvaiKBNAIKIM2pBCUQL6AA4k1NJJBGQAGkOZWgBOIFFEC8qYkE0ggogDSnEpRAvIACiDc1kUAaAQWQ5lSCEogXUADxpiYSSCOgANKcSlAC8QIKIN7URAJpBBRAmlMJSiBeQAHEm5pIII2AAkhzKkEJxAsogHhTEwmkEVAAaU4lKIF4AQUQb2oigTQCCiDNqQQlEC/wLzkw5NMX6PehAAAAAElFTkSuQmCC"
                            },
                            "width": 1745,
                            "wrapR": "REPEAT",
                            "wrapS": "CLAMP_TO_EDGE",
                            "wrapT": "CLAMP_TO_EDGE"
                        },
                        "type": "SAMPLER_2D",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 366",
                                "id": 366,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU5",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "texture": {
                            "anisotropy": 1,
                            "baseLevel": 0,
                            "compareFunc": "LEQUAL",
                            "compareMode": "NONE",
                            "format": "RGBA",
                            "height": 1,
                            "immutable": false,
                            "immutableLevels": 0,
                            "internalFormat": "RGBA",
                            "magFilter": "NEAREST",
                            "maxLevel": 1000,
                            "maxLod": 1000,
                            "minFilter": "NEAREST",
                            "minLod": -1000,
                            "textureType": "UNSIGNED_BYTE",
                            "visual": {
                                "TEXTURE_2D": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAABkhJREFUeF7t1AERAAAIAjHpX9ogPxswPHaOAIGswLLJBSdA4AyAJyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedwAOf2gEBwEDqbgAAAABJRU5ErkJggg=="
                            },
                            "width": 1,
                            "wrapR": "REPEAT",
                            "wrapS": "REPEAT",
                            "wrapT": "REPEAT"
                        },
                        "type": "SAMPLER_2D",
                        "value": 2
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    300,
                    150
                ],
                "SCISSOR_TEST": false
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "8",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "Canvas COLOR_ATTACHMENT",
                        "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAAGINJREFUeF7tXQtwXcV5/s65L8mSLNkSMg8j8/AQG2KecUhIaEMmTR8ZHiUhbYZOO4QpKX0RWiBMSoPDEDeDmyaZ0pnMZGgyzXTIgzDUnXQ8EAppIRQw7zc2tnFtbGTLkq6k+z7ndPb/d/fsvXYJZq60utIvxlzdq3PP7vl299////7HBr39wwnkxwsCN9/01/j6Hd/w0rY0+t4QKHzhcZS3/Bvi+iEESQxA/VNLKEaQqNfI/h7Q5+p9hCBRrw2+JlDvYwT03lzP90roHrwkE/UeCYJY/Z/bUf/Rn6ntBIl6TRIkgXo1vwPZ/CCi2iSSuMp/5y/x9XQPfh+IAHhvE0G+tXgRWPbTHRj74p1Ao4iEFjcLAPMvsMIg0UJCL/QgAtSCD5SwYCFghQEtUmfBB2p9amGQ8OfpQlYLnQUEXWP/7izuMIcw34OoOgHEkXNtKkzUPUQAeJ7H995zNy7/zOc890KaPxoEBr90Kxp9l2Hiu3cjqY3SojY7Oy9a1gaUIGANQAkAZ7HTwlUaQLr78wJXC119xyx+3vN5kRsho3ZxLQxo10+1AL46FQJhrhdJVEUc11LtQDSAoxlquVYQODICK777OqY270D5pUcQl3ZqlVybAVrFJ0GgFjktdhYGRhA0CQm9+5sdn80AZQ5oYeCo/VaVt7u/XvRkNaSaAtsJAYJsF5K4hiSqI1HahzUx2JQQDWAezPDXX30Op605ax70RLpwNAh0nfc95NeeguKDdwFxhRcXLX6XC4jSxW+FgNYSjE3v7PJWEyBugJkAq/prQRFY9b9l0TtmhLYRSACQZhFVkSQNLQD0fYUDOJrhlmsFgcMR6D77O1jy0RGM/eSf0x2eTADmBKya76j7KWnIC7HJvm8h9UiWaPPAEIMpN+DwAKQRaJPBmhPc3yBTIG0grk9rgpFJRjJThAScH9N65/aXcfLq0+dHZ6QXR4XAwKX3YOrpBxFX9/Jur+17ZY8zIajVf83EW9KQ2HvN+Lt2vmMSWA7A2Pda1WdHQcrqp9c5BCECte4BZOglJo+AyzGIADiqgZaLBYEjIXDuj1/F3vv34MDmbyNQarbe7VMOwBCC6lWTeFa1V0IiIGKPBEbT4k8JPVcQ2MXv3MMQhewONFqD2uYDBEGG1H/mALTngDSAWDSA+TSlN9/3E1xy2RXzqUvSl3eBwPv+7FH0fWgIz9xwIxCXtBfAmACawSfXX+qP50Vq/P6ure8SecbN535Ph+0kQGx9/y1cgMMbBEFIGoBSAZKoxq5K614UDeBdDK9cIgi8MwIjn70Zvad8Btv/9U5ElV20y7MZoOIAdABOk3svDcRJA3/SIJ9UEzDeABMcZAhBV2CkLkLjHtSRQsYRgCDTxWFFUQVBnLoahQOYhzN74+0b8OVbNszDnkmX3gmBkct/jLHnn0F14hEWAI69b6L3XB+9YektCehE56Vknl6sxA9owo/Wfnp/d9GnZKLSNvjOyvYP833sSVAxAVHFIQJFA5BZLQi0BYH1//Imxp/Ygd0//IqODvx/Fqzr8qNVqkN7Tahuq0vQEQw28s8RAqw3pBqFcRm65kYQZGnRh/kBxI0iUK9y6LC4Adsy9m2/ySUXfwqb//1nbb+v3HD2EDj245/G+//4dmy97acojf4Hs/uacbdqvmX6W7mA5kVMOzdF+Km4AifQx0bxue4+tv+t1tBkcqR5BUowBGGONAJDBqpAI3EDzt6ckDsvMgTW/uX/YM+WzaiMPcQx/7zcmpJx3KAeWtwmKcfx4fNOfyQ7v/VefE2zq1ALHvN9o2UgJGFCu36QA2LlFWiIAJivc3Td+8/ACy++NF+7J/06AgJDF25CJliFye13I6rsdRJwQBqBscvNorVqurPYU05A2/CUCdiSFGRVfq0JmNBh53OXY6BFzw5I62ZU2oASAqIByFQWBNqEQO+aGzG4/mIk5Unse3ijdrs5fn+9qTcTf+ZDvo6FAqv1OkTIkn4mR8DmDLQs+DTVN70nP5oWPlYb0J8FGREAbRp7uY0ggPN/sAfF18Zx4MHnMLXzbkQqU1Cp2nYHNyp7mu1n7HdXlW+9niP+XOa/OaffeBk4Hdn1EpjSAswlWLNCCwR1qWgAMnEFgTYhkB9ajZEr78HkU9sw/eZmNMrbETdUkpAO7mGmzhb8OJL9zma60QJY/SetQEf4WXvfRAy69+TEAUsK2kXfZH6kGoF4Ado08HIbQcAgMPxbW5DJZFB89X4cd+nnsOv7X9CZeCkjb/zzrUFAliNoqgrk1gPQQUU2otAhC1u0DDcYiKlIwyNoblJrAaIByNwVBNqIQGHVlVh97QYUX38F088dRGNmN0pvb6acfBuvr+1y3otb1Ha9izf59rVany7i1tBgZ3E7QUit2ga919qAeWQRAG0cfLmVIFAYuRJrb7gZL2+8GcOfuAXZpXnsu28j6jPbLB/Q6g3QhnuLu1Bj6cTtGwHgCoJmm5/JPrPfW06gRTugayhLUDgAmbGCQFsR6DrpD4EgjwBdiGujOPbiL6F+YApvP3QDkkaZg3Acuz0l8Iy976rrvNRNBqHN9Gup6mPVfVLrA8sXNJsBRmvQ4QDKKFDagNQDaOv4y80EARROugph9hjE1f3oWXkxulcdj5nXt6G441tIFCloSncRu5+Schw9qDnCVtJPmwuHZxQ2R/sx8WfIQJM5mL5PcwS0cBEBIDNWEGgvAl2nXoPa2FYUBi9CJj+IbN/JyC8fRvGVH6I2/hjX6DNFPm0EIAuCVKVX69i471psfhvlZ0hA9hww2ac/a3L7mXsf7goUDaC9Yy93EwRwzKe2YOyXf4ts/xpk8seia2gdprbdhcGPfRljD29EVDuERGXlUWrukQg8E+GXCgUrMCyB6CxmR1BYPkETh8YDYLkBLRjMexEAMmEFgTYjcMade7H9G7egXnwNYbYXKz+7Cbu+//sUjjuw7g7MvPkD1KdfQRJpTsAp9smHfBhTwKjuDi+gFzZrC80lxE3eAVUCa6oPyDxCSg+mZoMIgDYPvtxOEFAIdK+5nlyAXI8vg9r4Vrvj5/vPRJgbRK34FGkCSVynwzsOiwZ0yT6t4BPJ59T+d338TYteF/2kZa+TgJrcgtpkEAHQgfP1uGOPxb79+zuw54uny0tO34D69MtoFLchyHQjqrwNxGbXTpDtOwW53rNRm3wMA+tvw6FHr6MMwoSy9PjAEHPsl+UGrPeAK/qy+WC0AMfOd7kEfcIQCQcnIpC8gFIVePFMSHnSuUWgcPLVCMJ+VA5sQRAWENWKCNTituQcEHYvpxJd6gw/WvxJjKVrb8XMrn8CGhXEkariy59TodFEO++d7EBr82vmnxd6s1DQhYdTvsG4FqUgyNxOina29huf+Dge+Pl/tvOWcq82IlBY/aeoTz5PwT+xKsbZmOG8AHP+n2orzFBuPlXsVddoMi9AFtklw4gbqsAoENdn2Ewwu73WBJpYf+s/dBON2NY3sQFsPpjPWGMQE6CNgy63EgQMAkO/+xTGHr4GYX4IQW4A9fGn2d63broAQahKdamy3SHiRjmt2U+fkfEOZPJQJb3ixjRxCPzDr67N3/S7EwvIiUTaPLCJSCZiUCIBO3rG3nTj9bhj0zc7+hkWdOcHzqJdPT94ISr7f0b2PTP1egGrfPwgSws0QMgCwp4HqHfoIIsgk+PYAaUFOIlCJrZfvXL1YV1ERGsIfOjI4RmIdL2uJCQawIKegfJwPhHoP/9HmHzlNhQGL0B5/wOcEGQWpOECwgBhkAfCkP6kTu8JokgTdkoypJoCn+zDZwamVIJx6fFC55LkRhSYC11B4Cx+ORzU5/RoT9vfu+s7uOrqP2nPzeQu7Udg6enIDZyD+qGnEdXHHbVdq+W8nGmhh5kuNhEi4wngUl5Qh3sEITP/sT7lV2cJuAKFhULzicJHig60n0kyUPvHW+4oCDQhoATA0tNRn3oNUflAUzEQrbPbzDz1PpPt4fr9+iRfpgKUGAiBbJ7IQj7hx83vJ+rffpbG+2uFg04lMuZBygcob4GYAAtgvj75+H9j/fkXLoAnWYCPkO1B2H8G2e716T3anacXoVmz9rETfZJvjCTmY8aJHzAuvkwBYaZAXgFyEWoJYjk+Y/OTGcBlQPlXThAysQDW2yAmwAKccPJI8w6BzPLzkelZhfLof7ENb9l4t6vadmf6H4F6bc3qU5+HWYTZHjSqhxCoisFm9Rt1gniAtCKACRg6LCdAnxokGsC8my7vrUPf/uYmXHf9je/ty/KtWUUgO/QR4txrU284p/Nqtd1E6ZBSkMb+24IdVrs3fIAmBZMYsaky5HyXxYfe+W1sAN+3NVRY4gBmddjl5oIAI3Dcp+/Fvi03Ia5P2QKhrRF7qk4/B/ukQsDN4FNBPIYs1EECnD+gIgWtKdAa6OOQgsaMcMKJRQAssBl6370/wmWX/94Ce6qF8ThJ14lI4qqO80936XSRB+zvb9RYhW8q7MEYsEdACwITUERxAyat2JxElLr6WDY4RUPcMwLEC7AwJpc8xfxHIOhbg0Zl1N3gtaqe7viZbLdOBlJuwNSdZ60E8ghmkeikIlM4NHXrmdOHtIDRuoH1AJj4AKdYiHAA83/uHFUPV42M4M3dKg1VfuYbAnF2eVrlR+3nJnFHE3dQkYFqgavEH0Xw6fqBxgtAWkBGhQ/zAZ/mJCETEkCHfTrEoVrvLvnXrFWwsBABMN9mifRnwSIQ5ZYTB5D65FOb3Zj+iv2nc/tU8I86UEQTfXyWQEARgypgSOUOmKPA0my/5iAgsvFNeLB1BxrzgLUEEQALcLqt/8B5eHLrUwvwyTr7kbID56A6tbMliEfb9/o0ILtggxBhbgllEKocgtQMCJDvW4na9F4iAc0hIwYZFQmYsv3GFNCL3a0SpL8gAqCz55T0vsMQSPLDVBnYMPe2+1Ssw/H9G65PZQyq0GBa2EwC5ntPQL00ynkDatM3Nr1j29sAIEP6seHA3kVbHCQQDaDD5s+77u7ZZ5+JZ599/l1fLxfOHQJJbpBqBLgBO2Tfm6LARnUnjV+5B9ndZ/bzMJMl+580A7vJp6W/+TxB7UloTRtW30jJAREAczfs0pIgwAgsP/NrGHtpExcCafH7u+/Z6xdyHQATFqyYgDCLrr4RlCdVYFF6kCi7CZkg5LgBfdiITRNmzoELhPCrmAALeFaGYYjYFpFYwA/agY9WGDwXpfHXqOeuzW6Kfmn1gP8eZBAnKkiIYwFUPoDSDBr16cPdhaaQiHIjunUAtarAgoF/5GSgDpw40uWFgUC29xQE2S7Up/chiqrNtrnziEpbD4NQpw8Ylh/I5noRqbLiZB6oz9OjxaytYLkBs+LTwqDkC5CjwRbGZJKn6EwEuofOQ3lyJy1ik+LL1YHUT+jUANQfKr89JQkBmVwP5QJQfQASAq3qvk7/1Ts+VwdS2oY5NIBNBDEBOnPuSK8XAAJ9J/wmelf8Dva98FXE9XJzrQA35JcUf626h6H+nUOHqdCoEiBO5KBV8W0cQApWU+6RkgVyNuACmEnyCB2LQK7vZHT1rUVx/y90zUDnUWjjz9j8AfIMhlldTFQpCSHlDlDEoIoA1CcMuWAY0q/pM3M+gAiAjp03R93xZcsGMD4+cdTfky/MPgIDJ16KqQOPo1451MLSczUgExVIuzeVDsvrkGFTYFSFDcdIVC1Byg7UEYC6mAh9zaQVtzyOaACzP77SgiDwjgiceNZGTB64H8VRVTewnPr2jb6uwoOtX5/NgTDbRZ4AFU9Abr8gw9xfEvE5BMQe8gnDKfNvCog4JoGYADI7BQH/CAyuugLV0g5MHXyRdvL0h5g//qc1AMMHhLkuhEEWkYos1EKAzhpIIjQaFceT6BQEcTlASQf2P/DSA0HAINA7eBZKk7vQaJQsqWdUd1MLQBUHDXQJcRUkpPIFaMHXpjlKQJGEmQIRg0ow2OpALvtnvAHiBVh8k++vvvgX+Idv/ePie/AOeeKu/tWoTO/Xx4iltf1U96kyMCkD6kARLhWu+IBMpoCoXkKjUSZTIczm2UMQ1RE3VPFQVTCEXYBN7kDRADpkVkg3FxUC3QNr0KhOoVY+gFgH+RgAzDkByv5Xu72KBzD2f70yzgVFyEGg/p5hLUARhDo/wNYgDziEWEjARTW1+GEvuujX8dBDv1iET945j7xs5W+jXjmImYnX09x/k8RD6oAKFGLbvmfgVDYBggT18jiZD0ZDUKZATEeSsRZAX6VfdPVhIQE7Z1JITxcXAoXeEXQvXY04KqF44Dm9kFmVj1V6sAPHitV/gMl9P6dPlDlA3gGdTKQ8C+bEIDcRiMSACIDFNanM035w/QfwxJNbF+fDd9hT9w6dg0Lf6Zh8637Ua0XOIKTAH/UgXE9MHTLaP3wuKlO79alCShDM6GzDGHFDnSbknhfAhwmJAOiwySDdXZwIZLuPQ+/ydZjc/xhiFf+vK/8YvV6Re2GYR++y1ShN/S/yhQFUK2PkDVDFRuuVSXs0uSECRQNYnHPJPvWGW/8GG776tUWOQuc8fs/gOmRyw5g6uFVXD1bxAkYT4P19ybJTESCHauktZHM9qFcmOEqQ0oMTxBQ2bIqLSDJQ54z+LPT0Ixd8CFe9+Qbe2LkrPaDSlKL6Va+GR/pV1xlDdSFc9y6f5e8e6JmF0eJbdi9di0LfShQPPKVdfLq4mK7937VkBbJd/Sj0nIri6C/JS1AtqXLkfDZAEithkAoOMQFmbajkxoLA7CGQ7x1BoecELioShBw3oJSBMMCS3pWoTL+FXPcQYhVUpIKC6iUyAVgbYAFAYcJCAs7eIMmdBYHZQiDXtcK69UJ1ohAtclUgpIGewfdhZmI7crmlVHYsm+9HjYqI1ukfxQXo7EERALM1QnJfQWCWERg57++x5/nbifxTqcFqYavAHxUYNHD8xzCx9yF09R2P6swoFRKJlGswqhEPoGIByJUoGsAsj5LcXhCYRQTC3HKqCqSi/jJ0joCuDxCGyGaXII4jZLNd6O5fjcnRJ/nvFC3IrkQRALM4OHJrQWAuEFABQwHlBCxFttCPcnE7InVyUBzp2gEZ5LsGUZnZR/kBSgsgLkA0gLkYHmlDEJh9BMLcALL5PhR6VqDQcxqRf1MHn0AUVRCGWXT3r0JUK6E8vdcKAFVuXDSA2R8baUEQmDMEglw/qfhDKy+htODS5AuoTO9G3/A5qM28hcrUHiYCyR0oAmDOBkYaEgTmGoFjTv486tVdKPSsRbX0GqLaJErFneQyNESgaABzPSrSniAwhwisOO3PMTl6P3oHzkOj9jZmxl8l25/yBJQ3QLwAczga0pQg4AGB4VP+CMWDj2LZCZehPPUSpkafILchVRcUAeBhRKRJQWCOEegeWItMrhs9Ax9EZfpFFEefBVRlIREAczwS0pwg4AOBIETf8HpE1SK6B9ahOr0NtcqYCAAfYyFtCgI+EBg86QqUJl6gCsPdvadh+tAzIgB8DIS0KQj4QkCFCJcm36C8gWUnfFIEgK+BkHYFAR8InHjO1zGx9x6UJ3eTJiAcgI9RkDYFAY8IHLP6akwffIQKiIoA8DgQ0rQg4AWBICT1f+rg0yIAvAyANCoIeEag75iPIsxIUVDPwyDNCwL+EFgysE40AH/wS8uCgH8EhAPwPwbSA0HAGwIiALxBLw0LAv4REAHgfwykB4KANwREAHiDXhoWBPwjIALA/xhIDwQBbwiIAPAGvTQsCPhHQASA/zGQHggC3hAQAeANemlYEPCPgAgA/2MgPRAEvCEgAsAb9NKwIOAfAREA/sdAeiAIeENABIA36KVhQcA/AiIA/I+B9EAQ8IaACABv0EvDgoB/BEQA+B8D6YEg4A0BEQDeoJeGBQH/CIgA8D8G0gNBwBsCIgC8QS8NCwL+ERAB4H8MpAeCgDcERAB4g14aFgT8IyACwP8YSA8EAW8IiADwBr00LAj4R0AEgP8xkB4IAt4QEAHgDXppWBDwj4AIAP9jID0QBLwhIALAG/TSsCDgHwERAP7HQHogCHhDQASAN+ilYUHAPwIiAPyPgfRAEPCGgAgAb9BLw4KAfwREAPgfA+mBIOANAREA3qCXhgUB/wiIAPA/BtIDQcAbAiIAvEEvDQsC/hEQAeB/DKQHgoA3BEQAeINeGhYE/CMgAsD/GEgPBAFvCIgA8Aa9NCwI+EUg/vA1EAHgdwykdUFgThGIf+06JNNjSKpFJHEkAmBO0ZfGBAFvCASIzv88kok91IMECYIYIgC8jYc0LAjMEQLxJ7+C+K1ngDhGEtWAJAQCAHFDBMAcjYE0Iwh4QSC64FrEh3YgqJeRRHUgjvhV/atXRAB4GRVpVBCYbQTy3Wh8+Fokoy8D5QkgiREEeSSNCmsBUQNJvYT/A3odhESbeer6AAAAAElFTkSuQmCC",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": null
            },
            "commandArguments": [
                4,
                59994,
                5125,
                0
            ],
            "commandEndTime": 1732773587784.1,
            "endTime": 1732773587878.2,
            "id": 38,
            "name": "drawElements",
            "stackTrace": [
                "WebGLIndexedBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:16593:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773587784.1,
            "status": 0,
            "text": "drawElements: TRIANGLES, 59994 indices, UNSIGNED_INT, 0"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_CustomData": {
                        "length": 70896,
                        "programStatus": {
                            "LINK_STATUS": true,
                            "VALIDATE_STATUS": false
                        },
                        "shaders": [
                            {
                                "COMPILE_STATUS": true,
                                "name": "NodeMaterial",
                                "shaderType": "VERTEX_SHADER",
                                "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define STANDARD 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS 4\n#define gb60bf13d71894171a2af79dd1d344da3_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define VERTEX_TEXTURES\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat neighbor_offset = 0.0001;\n\nuniform int frameIndex;\nuniform vec2 resolution;\nuniform mat4 previousModelViewMatrix;\nuniform mat4 previousProjectionMatrix;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\n\n\n\n\n\nvoid main() {\n\n\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n\n\t\t\t\t#if !defined( USE_LAYER_DISPLACE )\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec3 displaced_position = position;\n\t\t\t\tvec3 displaced_normal = normal;\n\n\t\t\t\t#if defined( USE_LAYER_DISPLACE )\n\t\t\t\t\tvec3 transformed;\n\t\t\t\t\tvec3 transformedNormal;\n\t\t\t\t#endif\n\t\t\t\t\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\n\t\t\t\t#if !defined( USE_LAYER_DISPLACE )\nvec3 transformed = vec3( position );\n\t\t\t\t#endif /* !USE_LAYER_DISPLACE */\n\t\t\t\t\ntransformed = displaced_position;\ntransformedNormal = normalMatrix * displaced_normal;\n#ifndef FLAT_SHADED\n    vNormal = transformedNormal;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\nvWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;\nvUv = uv;\nvPosition = transformed;\nvWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;\nvWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );\n\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2691 = vec3_ctor(_normal);\nfloat3 _transformedNormal2692 = _objectNormal2691;\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _transformedNormal2692));\nfloat3 _displaced_position2693 = _position;\nfloat3 _displaced_normal2694 = _normal;\n(_vNormal = normalize(_transformedNormal2692));\nfloat3 _transformed2695 = vec3_ctor(_position);\n(_transformed2695 = _displaced_position2693);\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _displaced_normal2694));\n(_vNormal = _transformedNormal2692);\nfloat4 _mvPosition2696 = vec4_ctor(_transformed2695, 1.0);\n(_mvPosition2696 = mul(transpose(_modelViewMatrix), _mvPosition2696));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2696));\n(_vViewPosition = (-_mvPosition2696.xyz));\nfloat4 _worldPosition2697 = vec4_ctor(_transformed2695, 1.0);\n(_worldPosition2697 = mul(transpose(_modelMatrix), _worldPosition2697));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2695, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2695);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2692, _viewMatrix).xyz);\nfloat3 sa8a = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sa8a = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sa8a = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sa8a);\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD6;\n    float4 gl_FragCoord : TEXCOORD7;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n};\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _normal : TEXCOORD1;\n    float2 _uv : TEXCOORD2;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _normal = input._normal;\n    _uv = input._uv;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.gl_FragCoord = gl_Position;\n    output.v0 = _vViewPosition;\n    output.v1 = _vWPosition;\n    output.v2 = _vNormal;\n    output.v3 = _vPosition;\n    output.v4 = _vWNormal;\n    output.v5 = _vWorldViewDir;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2691 = vec3_ctor(_normal);\nfloat3 _transformedNormal2692 = _objectNormal2691;\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _transformedNormal2692));\nfloat3 _displaced_position2693 = _position;\nfloat3 _displaced_normal2694 = _normal;\n(_vNormal = normalize(_transformedNormal2692));\nfloat3 _transformed2695 = vec3_ctor(_position);\n(_transformed2695 = _displaced_position2693);\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _displaced_normal2694));\n(_vNormal = _transformedNormal2692);\nfloat4 _mvPosition2696 = vec4_ctor(_transformed2695, 1.0);\n(_mvPosition2696 = mul(transpose(_modelViewMatrix), _mvPosition2696));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2696));\n(_vViewPosition = (-_mvPosition2696.xyz));\nfloat4 _worldPosition2697 = vec4_ctor(_transformed2695, 1.0);\n(_worldPosition2697 = mul(transpose(_modelMatrix), _worldPosition2697));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2695, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2695);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2692, _viewMatrix).xyz);\nfloat3 sa8a = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sa8a = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sa8a = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sa8a);\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                            },
                            {
                                "COMPILE_STATUS": true,
                                "name": "NodeMaterial",
                                "shaderType": "FRAGMENT_SHADER",
                                "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define STANDARD 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS 4\n#define gb60bf13d71894171a2af79dd1d344da3_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define DITHERING\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat accumAlpha = 0.0;\nvoid accumulateAlpha(float alpha) {\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * alpha;\n\t\t\t\t}\n\nlayout(location = 1) out vec4 gVelocity;\n\nuniform int frameIndex;\nuniform vec2 resolution;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nconst vec2 haltonSequence[16] = vec2[16](\nvec2( 0.000000,-0.333334),\nvec2(-0.500000, 0.333334),\nvec2( 0.500000,-0.777778),\nvec2(-0.750000,-0.111112),\nvec2( 0.250000, 0.555556),\nvec2(-0.250000,-0.555556),\nvec2( 0.750000, 0.111112),\nvec2(-0.875000, 0.777778),\nvec2(0.125000, -0.925926),\nvec2(-0.375000, -0.259260),\nvec2(0.625000, 0.407408),\nvec2(-0.625000, -0.703704),\nvec2(0.375000, -0.037038),\nvec2(-0.125000, 0.629630),\nvec2(0.875000, -0.481482),\nvec2(-0.937500, 0.185186));\n\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n  const float goldenAngle = 2.399963f; // radians\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n  float theta = float(sampleIndex) * goldenAngle + angle;\n  float sine = sin(theta);\n  float cosine = cos(theta);\n  return vec2(cosine, sine) * r;\n}\n\n// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso\nfloat getNoiseInterleavedGradient(vec2 screenPos) {\n    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);\n    return fract(magic.z * fract(dot(screenPos, magic.xy)));\n}\n\n\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\nuniform float penumbraSize[5];\nuniform sampler2D aoMap;\nuniform bool aoEnabled;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\nstruct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if 0 > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\nuniform float nodeU0;\nuniform float nodeU1;\nuniform float nodeU2;\nuniform vec2 nodeU3;\nuniform sampler2D nodeU4;\nuniform sampler2D nodeU5;\nuniform vec2 nodeU6;\nuniform float nodeU7;\nuniform float nodeU8;\nuniform float nodeU9;\nuniform vec3 nodeU10;\nuniform vec3 nodeU11;\nuniform bool nodeU12;\nuniform float nodeU13;\nuniform int nodeU14;\nuniform vec3 nodeU15;\nuniform float nodeU16;\nuniform float nodeU17;\nuniform float nodeU18;\nuniform float nodeU19;\nuniform bool nodeU20;\nuniform float nodeU21;\nuniform int nodeU22;\nuniform vec3 nodeU23;\nuniform float nodeU24;\nuniform float nodeU25;\nuniform float nodeU26;\nuniform float nodeU27;\nuniform bool nodeU28;\nuniform float nodeU29;\nuniform int nodeU30;\nuniform float nodeU31;\nuniform float nodeU32;\nuniform bool nodeU33;\nuniform float nodeU34;\nuniform int nodeU35;\nuniform float nodeU36;\nuniform float nodeU37;\nuniform float nodeU38;\n\nuniform vec4 nodeUA0[4];\nuniform float nodeUA1[4];\n\n\n\nfloat w0( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n        }\n    \n        float w1( float a ) {\n            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n        }\n    \n        float w2( float a ){\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n        }\n    \n        float w3( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * a * a );\n        }\n    \n        // g0 and g1 are the two amplitude functions\n        float g0( float a ) {\n            return w0( a ) + w1( a );\n        }\n    \n        float g1( float a ) {\n            return w2( a ) + w3( a );\n        }\n    \n        // h0 and h1 are the two offset functions\n        float h0( float a ) {\n            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n        }\n    \n        float h1( float a ) {\n            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n        }\n    \n        vec4 bicubic( sampler2D tex, vec2 vUv, vec4 texelSize, float lod ) {\n            vUv = vUv * texelSize.zw + 0.5;\n    \n            vec2 iuv = floor( vUv );\n            vec2 fuv = fract( vUv );\n    \n            float g0x = g0( fuv.x );\n            float g1x = g1( fuv.x );\n            float h0x = h0( fuv.x );\n            float h1x = h1( fuv.x );\n            float h0y = h0( fuv.y );\n            float h1y = h1( fuv.y );\n    \n            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n    \n            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + \n                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n        }\n\n        vec4 textureBicubic( sampler2D sampler, vec2 vUv, float lod ) {\n            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n            vec2 fLodSizeInv = 1.0 / fLodSize;\n            vec2 cLodSizeInv = 1.0 / cLodSize;\n            vec4 fSample = bicubic( sampler, vUv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n            vec4 cSample = bicubic( sampler, vUv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n            return mix( fSample, cSample, fract( lod ) );\n        }\nfloat applyIorToRoughness( float roughness, float ior ) {\n\t\t\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\t\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t\t\t}\nvec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {\n                // Slightly modified version of this:\n                // https://www.shadertoy.com/view/ltScRG\n\n\t\t\t\t// Special case for blur == 0.0\n\t\t\t\tif (lod == 0.0) {\n\t\t\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\t\treturn texture2DLodEXT( sp, U, 0.0).rgb;\n\t\t\t\t\t#else\n\t\t\t\t\treturn textureLod( sp, U, 0.0).rgb;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec2 texelSize = vec2(1.0) / resolution;\n                vec2 halton = haltonSequence[frameIndex];\n                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n                float temporalAngle  = temporalOffset * PI2;\n\t\t\t\tvec3 res = vec3(0.0);\n                vec2 vUv = vec2(0.0);\n                vec2 offset = vec2(0.0);\n                vec2 vogelSample = vec2(0.0);\n                for (int i = 0; i < NUM_SAMPLES; i++) {\n                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;\n                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20\n                    vUv = U + offset;\n                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, vUv, lod));\n                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {\n                        vUv = unrefractedU;\n                        lod = lod > 4.0 ? lod : lod / 2.0;\n                    }\n                    res += textureLod(sp, vUv, lod).rgb;\n                }\n                return res / float(NUM_SAMPLES);\n            }\nvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\t        // Direction of refracted light.\n\t\t        vec3 refractionVector = refract( -v,  n, 1.0 / ior );\n\t\t        \n\t\t\t\t// Compute rotation-independant scaling of the model matrix.\n\t\t        vec3 modelScale;\n\t\t        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\t        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\t        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t        // The thickness is specified in local space\n\t\t        return normalize( refractionVector ) * thickness * modelScale;\n\t        }\nfloat vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vPosition.x - origin.x) + n.y*(vPosition.y - origin.y) + n.z*(vPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vWPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nvec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {\n\t\t\t\t\tfloat fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );\n\n\t\t\t\t\tfloat lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;\n\t\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\t\treturn color;\n\t\t\t\t}\nvec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {\n\t\t\t\t// Threejs exports do not pass a depth map to this shader, so we have to fallback to the \"Threejs method of blurring\" - see\n\t\t\t\t// also the code in convertTransmission.ts, which runs during export\n\t\t\t\t#ifdef IS_THREEJS_EXPORT\n\t\t\t\t\tfloat lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);\n\t\t\t\t\treturn textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;\n\t\t\t\t#else\n\t\t\t\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t\t\t\tfloat lod = applyIorToRoughness(roughness, ior);\n\t\t\t\t\treturn blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);\n\t\t\t\t#endif\n\t\t\t}\nvec3 gb60bf13d71894171a2af79dd1d344da3_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS], float steps[gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {\n               vec4 color = colors[0];\n               #ifdef gb60bf13d71894171a2af79dd1d344da3_IS_VECTOR\n                   #ifdef gb60bf13d71894171a2af79dd1d344da3_LINEAR\n                       #ifdef gb60bf13d71894171a2af79dd1d344da3_WORLDSPACE\n                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);\n                       #else\n                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);\n                       #endif\n                   #else\n                       #ifdef gb60bf13d71894171a2af79dd1d344da3_WORLDSPACE\n                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);\n                       #else\n                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);\n                       #endif\n                   #endif\n               #else\n                   float dist = length(vWPosition - cameraPosition);\n\t\t\t       float depth = ( dist - near ) / ( far - near );\n               #endif\n\n\n              float p;\n              #ifdef gb60bf13d71894171a2af79dd1d344da3_SMOOTH\n\t\t\t\tfor ( int i = 1; i < gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS; i++ ) {\n\t\t\t\t\t\tp = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );\n\t\t\t\t\t\tcolor = mix(color, colors[i], smoothstep(0.0, 1.0, p));\n\t\t\t\t\t}\n              #else\n                for ( int i = 1; i < gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS; i++ ) {\n                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);\n                   color = mix(color, colors[i], p);\n                 }\n              #endif\n\n               float lalpha = alpha * color.a * mask;\n               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\t\t\t   \n               return color.rgb;\n\t\t\t}\nvec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\n\t\t\t\tvec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );\n\t\t\t\tvec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;\n\t\t\t\tunrefractedCoords += 1.0;\n\t\t\t\tunrefractedCoords /= 2.0;\n\n\t\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\t\treturn getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );\n    \t\t}\nvec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {\n                vec3 v = vec3(0.);\n                if (isOrthographic) {\n                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n                } else {\n                    v = normalize(vWPosition - cameraPosition);\n                }\n                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );\n                \n\t\t\t\tfloat lalpha = alpha * mask;\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * alpha;\n\n\t\t\t\treturn transmission;\n            }\n\nvoid main() {\n\nfloat g5bfaadd2eca34fa3b71f09ed96a7f085_calpha;\nfloat gb60bf13d71894171a2af79dd1d344da3_calpha;\nfloat gee38695320d24f1c8e9eb0283839cba8_calpha;\nfloat g354ff6fd46474004b7bb3125dc58a54f_calpha;\n\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n\n\t\t\t\t// NOTE: gl_FrontFacing alternative using face normal estimation.\n\t\t\t\tvec3 viewdx = dFdx(vViewPosition);\n\t\t\t\tvec3 viewdy = dFdy(vViewPosition);\n\t\t\t\tvec3 faceNormal = normalize(cross(viewdx,viewdy));\n\t\t\t\tif (dot(normal, faceNormal) < 0.0) {\n\t\t\t\t\tnormal *= -1.0;\n\t\t\t\t}\n\t\t\t\t\n\tPhysicalMaterial material;\n\tmaterial.diffuseColor = vec3( 1.0 );\n\n\tvec3 diffuseColor = spe_blend(spe_blend(spe_blend(transmission(nodeU0,nodeU1,nodeU2,nodeU3,nodeU4,nodeU5,nodeU6,normal,1.0,nodeU7,g5bfaadd2eca34fa3b71f09ed96a7f085_calpha),gb60bf13d71894171a2af79dd1d344da3_sdepth(nodeU8,nodeU9,nodeU10,nodeU11,nodeUA0,nodeUA1,nodeU12,1.0,nodeU13,gb60bf13d71894171a2af79dd1d344da3_calpha),( gb60bf13d71894171a2af79dd1d344da3_calpha ),nodeU14),fresnel(nodeU15,nodeU16,nodeU17,nodeU18,nodeU19,nodeU20,1.0,nodeU21,nodeU22,gee38695320d24f1c8e9eb0283839cba8_calpha),( gee38695320d24f1c8e9eb0283839cba8_calpha ),nodeU22),fresnel(nodeU23,nodeU24,nodeU25,nodeU26,nodeU27,nodeU28,1.0,nodeU29,nodeU30,g354ff6fd46474004b7bb3125dc58a54f_calpha),( g354ff6fd46474004b7bb3125dc58a54f_calpha ),nodeU30);\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\tfloat metalnessFactor = nodeU32;\n\n\tfloat roughnessFactor = nodeU31;\n\n#ifdef ALPHATEST\n\tif ( nodeU36 <= ALPHATEST ) discard;\n#endif\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );\nmaterial.roughness = max( roughnessFactor, 0.0525 );\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\nmaterial.roughness = clamp( roughnessFactor, 0.04, 1.0 );\n\nmaterial.specularColor = mix( vec3( 0.16 * pow2( nodeU37 ) ), diffuseColor, metalnessFactor );\n\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t\n#endif\n#if ( 1 > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t\n\t\tdirectionalLight = directionalLights[ 0 ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( 0 < 0 )\n\t\tdirectionalLightShadow = directionalLightShadows[ 0 ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( 0, directionalShadowMap[ 0 ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( 1 > 0 )\n\t\t\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\nvec3 ao = aoEnabled && nodeU33 ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);\nvec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n\t\t\t\tif (outgoingLight != diffuseColor) {\n\t\t\t\t\tfloat lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );\n\t\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * nodeU34 * 1.0 * lightAccu;\n\t\t\t\t\toutgoingLight = spe_blend( diffuseColor, outgoingLight, nodeU34 * 1.0, nodeU35 );\n\t\t\t\t\t\n\t\t\t\t\toutgoingLight *= ao;\n\t\t\t\t}\n\t\t\t\t\ngl_FragColor = vec4( outgoingLight, accumAlpha * nodeU36 );\ngl_FragColor.a *= nodeU38;\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n\n}",
                                "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n    float pad_26;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n    float pad_27;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0)\n{\n    return float3(x0, x0, x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform bool _aoEnabled : register(c7);\nuniform float3 _ambientLightColor : register(c8);\nuniform float3 _lightProbe[9] : register(c9);\nuniform _DirectionalLight _directionalLights[1] : register(c18);\nuniform _HemisphereLight _hemisphereLights[1] : register(c20);\nuniform float4x4 _modelMatrix : register(c23);\nuniform float4x4 _projectionMatrix : register(c27);\nuniform float _nodeU0 : register(c31);\nuniform float _nodeU1 : register(c32);\nuniform float _nodeU2 : register(c33);\nuniform float2 _nodeU3 : register(c34);\nuniform float2 _nodeU6 : register(c35);\nuniform float _nodeU7 : register(c36);\nuniform float _nodeU8 : register(c37);\nuniform float _nodeU9 : register(c38);\nuniform float3 _nodeU10 : register(c39);\nuniform float3 _nodeU11 : register(c40);\nuniform bool _nodeU12 : register(c41);\nuniform float _nodeU13 : register(c42);\nuniform int _nodeU14 : register(c43);\nuniform float3 _nodeU15 : register(c44);\nuniform float _nodeU16 : register(c45);\nuniform float _nodeU17 : register(c46);\nuniform float _nodeU18 : register(c47);\nuniform float _nodeU19 : register(c48);\nuniform bool _nodeU20 : register(c49);\nuniform float _nodeU21 : register(c50);\nuniform int _nodeU22 : register(c51);\nuniform float3 _nodeU23 : register(c52);\nuniform float _nodeU24 : register(c53);\nuniform float _nodeU25 : register(c54);\nuniform float _nodeU26 : register(c55);\nuniform float _nodeU27 : register(c56);\nuniform bool _nodeU28 : register(c57);\nuniform float _nodeU29 : register(c58);\nuniform int _nodeU30 : register(c59);\nuniform float _nodeU31 : register(c60);\nuniform float _nodeU32 : register(c61);\nuniform bool _nodeU33 : register(c62);\nuniform float _nodeU34 : register(c63);\nuniform int _nodeU35 : register(c64);\nuniform float _nodeU36 : register(c65);\nuniform float _nodeU37 : register(c66);\nuniform float _nodeU38 : register(c67);\nuniform float4 _nodeUA0[4] : register(c68);\nuniform float _nodeUA1[4] : register(c72);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_pow2(const float _x)\n{\nreturn (_x * _x);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nstatic float _accumAlpha = {0.0};\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2704 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2705 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2705 = lerp((2.0 * _dither_shift_RGB2705), (-2.0 * _dither_shift_RGB2705), _grid_position2704));\nreturn (_color + _dither_shift_RGB2705);\n}\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2712 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2712)) + (_f90 * _fresnel2712));\n}\nfloat f_V_GGX_SmithCorrelated(const float _alpha, const float _dotNL, const float _dotNV)\n{\nfloat _a22729 = f_pow2(_alpha);\nfloat _gv2730 = (_dotNL * sqrt((_a22729 + ((1.0 - _a22729) * f_pow2(_dotNV)))));\nfloat _gl2731 = (_dotNV * sqrt((_a22729 + ((1.0 - _a22729) * f_pow2(_dotNL)))));\nreturn (0.5 / max((_gv2730 + _gl2731), 1e-06));\n}\nfloat f_D_GGX(const float _alpha, const float _dotNH)\n{\nfloat _a22735 = f_pow2(_alpha);\nfloat _denom2736 = ((f_pow2(_dotNH) * (_a22735 - 1.0)) + 1.0);\nreturn ((0.31830987 * _a22735) / f_pow2(_denom2736));\n}\nfloat3 f_BRDF_GGX(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _f0, const float _f90, const float _roughness)\n{\nfloat _alpha2744 = f_pow2(_roughness);\nfloat3 _halfDir2745 = normalize((_lightDir + _viewDir));\nfloat _dotNL2746 = clamp(dot(_normal, _lightDir), 0.0, 1.0);\nfloat _dotNV2747 = clamp(dot(_normal, _viewDir), 0.0, 1.0);\nfloat _dotNH2748 = clamp(dot(_normal, _halfDir2745), 0.0, 1.0);\nfloat _dotVH2749 = clamp(dot(_viewDir, _halfDir2745), 0.0, 1.0);\nfloat3 _F2750 = f_F_Schlick(_f0, _f90, _dotVH2749);\nfloat _V2751 = f_V_GGX_SmithCorrelated(_alpha2744, _dotNL2746, _dotNV2747);\nfloat _D2752 = f_D_GGX(_alpha2744, _dotNH2748);\nreturn (_F2750 * (_V2751 * _D2752));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2811 = _normal.x;\nfloat _y2812 = _normal.y;\nfloat _z2813 = _normal.z;\nfloat3 _result2814 = (_shCoefficients[0] * 0.88622701);\n(_result2814 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2812));\n(_result2814 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2813));\n(_result2814 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2811));\n(_result2814 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2811) * _y2812));\n(_result2814 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2812) * _z2813));\n(_result2814 += (_shCoefficients[6] * (((0.74312502 * _z2813) * _z2813) - 0.24770799)));\n(_result2814 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2811) * _z2813));\n(_result2814 += ((_shCoefficients[8] * 0.42904299) * ((_x2811 * _x2811) - (_y2812 * _y2812))));\nreturn _result2814;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2818 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2819 = f_shGetIrradianceAt(_worldNormal2818, _lightProbe);\nreturn _irradiance2819;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2822 = _ambientLightColor;\nreturn _irradiance2822;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2844 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2845 = ((0.5 * _dotNL2844) + 0.5);\nfloat3 _irradiance2846 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2845);\nreturn _irradiance2846;\n}\n;\nfloat2 f_DFGApprox(const float3 _normal, const float3 _viewDir, const float _roughness)\n{\nfloat _dotNV2864 = clamp(dot(_normal, _viewDir), 0.0, 1.0);\nfloat4 _r2867 = ((_roughness * float4(-1.0, -0.0275, -0.57200003, 0.022)) + float4(1.0, 0.0425, 1.04, -0.039999999));\nfloat _a0042868 = ((min((_r2867.x * _r2867.x), exp2((-9.2799997 * _dotNV2864))) * _r2867.x) + _r2867.y);\nfloat2 _fab2869 = ((float2(-1.04, 1.04) * _a0042868) + _r2867.zw);\nreturn _fab2869;\n}\nvoid f_computeMultiscattering(const float3 _normal, const float3 _viewDir, const float3 _specularColor, const float _specularF90, const float _roughness, inout float3 _singleScatter, inout float3 _multiScatter)\n{\nfloat2 _fab2885 = f_DFGApprox(_normal, _viewDir, _roughness);\nfloat3 _Fr2886 = _specularColor;\nfloat3 _FssEss2887 = ((_Fr2886 * _fab2885.x) + (_specularF90 * _fab2885.y));\nfloat _Ess2888 = (_fab2885.x + _fab2885.y);\nfloat _Ems2889 = (1.0 - _Ess2888);\nfloat3 _Favg2890 = (_Fr2886 + ((1.0 - _Fr2886) * 0.047619));\nfloat3 _Fms2891 = ((_FssEss2887 * _Favg2890) / (1.0 - (_Ems2889 * _Favg2890)));\n(_singleScatter += _FssEss2887);\n(_multiScatter += (_Fms2891 * _Ems2889));\n}\nvoid f_RE_Direct_Physical__IncidentLight__GeometricContext__PhysicalMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2897 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2898 = (_dotNL2897 * _directLight._color);\n(_reflectedLight._directSpecular += (_irradiance2898 * f_BRDF_GGX(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularF90, _material._roughness)));\n(_reflectedLight._directDiffuse += (_irradiance2898 * f_BRDF_Lambert(_material._diffuseColor)));\n}\nvoid f_RE_IndirectDiffuse_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\nvoid f_RE_IndirectSpecular_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(const float3 _radiance, const float3 _irradiance, const float3 _clearcoatRadiance, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat3 _singleScattering2911 = {0.0, 0.0, 0.0};\nfloat3 _multiScattering2912 = {0.0, 0.0, 0.0};\nfloat3 _cosineWeightedIrradiance2913 = (_irradiance * 0.31830987);\nf_computeMultiscattering(_geometry._normal, _geometry._viewDir, _material._specularColor, _material._specularF90, _material._roughness, _singleScattering2911, _multiScattering2912);\nfloat3 _totalScattering2914 = (_singleScattering2911 + _multiScattering2912);\nfloat3 _diffuse2915 = (_material._diffuseColor * (1.0 - max(max(_totalScattering2914.x, _totalScattering2914.y), _totalScattering2914.z)));\n(_reflectedLight._indirectSpecular += (_radiance * _singleScattering2911));\n(_reflectedLight._indirectSpecular += (_multiScattering2912 * _cosineWeightedIrradiance2913));\n(_reflectedLight._indirectDiffuse += (_diffuse2915 * _cosineWeightedIrradiance2913));\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2992 = floor(_vUv);\nfloat2 _fuv2993 = frac(_vUv);\nfloat _g0x2994 = f_g0(_fuv2993.x);\nfloat _g1x2995 = f_g1(_fuv2993.x);\nfloat _h0x2996 = f_h0(_fuv2993.x);\nfloat _h1x2997 = f_h1(_fuv2993.x);\nfloat _h0y2998 = f_h0(_fuv2993.y);\nfloat _h1y2999 = f_h1(_fuv2993.y);\nfloat2 _p03000 = ((vec2_ctor((_iuv2992.x + _h0x2996), (_iuv2992.y + _h0y2998)) - 0.5) * _texelSize.xy);\nfloat2 _p13001 = ((vec2_ctor((_iuv2992.x + _h1x2997), (_iuv2992.y + _h0y2998)) - 0.5) * _texelSize.xy);\nfloat2 _p23002 = ((vec2_ctor((_iuv2992.x + _h0x2996), (_iuv2992.y + _h1y2999)) - 0.5) * _texelSize.xy);\nfloat2 _p33003 = ((vec2_ctor((_iuv2992.x + _h1x2997), (_iuv2992.y + _h1y2999)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2993.y) * ((_g0x2994 * gl_texture2DLod(_tex, _p03000, _lod)) + (_g1x2995 * gl_texture2DLod(_tex, _p13001, _lod)))) + (f_g1(_fuv2993.y) * ((_g0x2994 * gl_texture2DLod(_tex, _p23002, _lod)) + (_g1x2995 * gl_texture2DLod(_tex, _p33003, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize3008 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize3009 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv3010 = (1.0 / _fLodSize3008);\nfloat2 _cLodSizeInv3011 = (1.0 / _cLodSize3009);\nfloat4 _fSample3012 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv3010, _fLodSize3008), floor(_lod));\nfloat4 _cSample3013 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv3011, _cLodSize3009), ceil(_lod));\nreturn lerp(_fSample3012, _cSample3013, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector3041 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale3042 = {0, 0, 0};\n(_modelScale3042.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale3042.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale3042.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector3041) * _thickness) * _modelScale3042);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist3061 = length((_vPosition - _origin));\nreturn ((_dist3061 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3078 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3079 = ((clamp(_fresnel3078, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3079 / clamp((_lalpha3079 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3079, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3079) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3089 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3089).xyz;\n}\nfloat3 f_gb60bf13d71894171a2af79dd1d344da3_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3101 = _colors[0];\nfloat _depth3102 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3103 = {0};\n{ for(int _i3104 = {1}; (_i3104 < 4); (_i3104++))\n{\n(_p3103 = clamp(((_depth3102 - _steps[(_i3104 - 1)]) / (_steps[_i3104] - _steps[(_i3104 - 1)])), 0.0, 1.0));\n(_color3101 = lerp(_color3101, _colors[_i3104], _p3103));\n}\n}\nfloat _lalpha3105 = ((_alpha * _color3101.w) * _mask);\n(_calpha = lerp((_lalpha3105 / clamp((_lalpha3105 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3105, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3105) * (1.0 - float_ctor(_isMask))));\nreturn _color3101.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3120 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3121 = (_position + _transmissionRay3120);\nfloat4 _ndcPos3122 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3121, 1.0));\nfloat2 _refractionCoords3123 = (_ndcPos3122.xy / _ndcPos3122.w);\n(_refractionCoords3123 += 1.0);\n(_refractionCoords3123 /= 2.0);\nfloat4 _ndcPosUnrefracted3124 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3125 = (_ndcPosUnrefracted3124.xy / _ndcPosUnrefracted3124.w);\n(_unrefractedCoords3125 += 1.0);\n(_unrefractedCoords3125 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3123, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3125, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3138 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3138 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3138 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3139 = f_getIBLVolumeRefraction(_vWNormal, (-_v3138), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3140 = (_alpha * _mask);\n(_calpha = (_lalpha3140 / clamp((_lalpha3140 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3139;\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat _g5bfaadd2eca34fa3b71f09ed96a7f085_calpha3142 = {0};\nfloat _gb60bf13d71894171a2af79dd1d344da3_calpha3143 = {0};\nfloat _gee38695320d24f1c8e9eb0283839cba8_calpha3144 = {0};\nfloat _g354ff6fd46474004b7bb3125dc58a54f_calpha3145 = {0};\nfloat3 _normal3147 = normalize(_vNormal);\nfloat3 _geometryNormal3148 = _normal3147;\nfloat3 _viewdx3149 = ddx(_vViewPosition);\nfloat3 _viewdy3150 = ddy(_vViewPosition);\nfloat3 _faceNormal3151 = normalize(cross(_viewdx3149, _viewdy3150));\nif ((dot(_normal3147, _faceNormal3151) < 0.0))\n{\n(_normal3147 *= -1.0);\n}\n_PhysicalMaterial _material3152 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_material3152._diffuseColor = float3(1.0, 1.0, 1.0));\nfloat3 _diffuseColor3153 = f_spe_blend_int(f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3147, 1.0, _nodeU7, _g5bfaadd2eca34fa3b71f09ed96a7f085_calpha3142), f_gb60bf13d71894171a2af79dd1d344da3_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _gb60bf13d71894171a2af79dd1d344da3_calpha3143), _gb60bf13d71894171a2af79dd1d344da3_calpha3143, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _gee38695320d24f1c8e9eb0283839cba8_calpha3144), _gee38695320d24f1c8e9eb0283839cba8_calpha3144, _nodeU22), f_fresnel_int(_nodeU23, _nodeU24, _nodeU25, _nodeU26, _nodeU27, _nodeU28, 1.0, _nodeU29, _nodeU30, _g354ff6fd46474004b7bb3125dc58a54f_calpha3145), _g354ff6fd46474004b7bb3125dc58a54f_calpha3145, _nodeU30);\n_ReflectedLight _reflectedLight3154 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat _metalnessFactor3155 = _nodeU32;\nfloat _roughnessFactor3156 = _nodeU31;\nfloat3 _dxy3157 = max(abs(ddx(_geometryNormal3148)), abs(ddy(_geometryNormal3148)));\nfloat _geometryRoughness3158 = max(max(_dxy3157.x, _dxy3157.y), _dxy3157.z);\n(_material3152._diffuseColor = (_diffuseColor3153 * (1.0 - _metalnessFactor3155)));\n(_material3152._roughness = max(_roughnessFactor3156, 0.052499998));\n(_material3152._roughness += _geometryRoughness3158);\n(_material3152._roughness = min(_material3152._roughness, 1.0));\n(_material3152._roughness = clamp(_roughnessFactor3156, 0.039999999, 1.0));\n(_material3152._specularColor = lerp(vec3_ctor((0.16 * f_pow2(_nodeU37))), _diffuseColor3153, _metalnessFactor3155));\n_GeometricContext _geometry3159 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry3159._position = (-_vViewPosition));\n(_geometry3159._normal = _normal3147);\nfloat3 sc61 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sc61 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sc61 = normalize(_vViewPosition));\n}\n(_geometry3159._viewDir = sc61);\n_IncidentLight _directLight3160 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight3161 = {0, 0, 0, 0, 0, 0};\n(_directionalLight3161 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight3161, _geometry3159, _directLight3160);\nf_RE_Direct_Physical__IncidentLight__GeometricContext__PhysicalMaterial__ReflectedLight(_directLight3160, _geometry3159, _material3152, _reflectedLight3154);\nfloat3 _iblIrradiance3162 = {0.0, 0.0, 0.0};\nfloat3 _irradiance3163 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance3163 += f_getLightProbeIrradiance(_lightProbe, _geometry3159._normal));\n(_irradiance3163 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry3159._normal));\nfloat3 _radiance3164 = {0.0, 0.0, 0.0};\nfloat3 _clearcoatRadiance3165 = {0.0, 0.0, 0.0};\nf_RE_IndirectDiffuse_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(_irradiance3163, _geometry3159, _material3152, _reflectedLight3154);\nf_RE_IndirectSpecular_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(_radiance3164, _iblIrradiance3162, _clearcoatRadiance3165, _geometry3159, _material3152, _reflectedLight3154);\nfloat3 sc62 = {0, 0, 0};\nif ((_aoEnabled && _nodeU33))\n{\n(sc62 = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc62 = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3166 = sc62;\nfloat3 _outgoingLight3167 = (((_reflectedLight3154._directDiffuse + _reflectedLight3154._indirectDiffuse) + _reflectedLight3154._directSpecular) + _reflectedLight3154._indirectSpecular);\nif (!all(_outgoingLight3167 == _diffuseColor3153))\n{\nfloat _lightAccu3168 = clamp(length((_reflectedLight3154._directSpecular + _reflectedLight3154._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU34) * 1.0) * _lightAccu3168));\n(_outgoingLight3167 = f_spe_blend_int(_diffuseColor3153, _outgoingLight3167, (_nodeU34 * 1.0), _nodeU35));\n(_outgoingLight3167 *= _ao3166);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3167, (_accumAlpha * _nodeU36)));\n(out_pc_fragColor.w *= _nodeU38);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD6;\n    float4 gl_FragCoord : TEXCOORD7;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n    float pad_26;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n    float pad_27;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0)\n{\n    return float3(x0, x0, x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform bool _aoEnabled : register(c7);\nuniform float3 _ambientLightColor : register(c8);\nuniform float3 _lightProbe[9] : register(c9);\nuniform _DirectionalLight _directionalLights[1] : register(c18);\nuniform _HemisphereLight _hemisphereLights[1] : register(c20);\nuniform float4x4 _modelMatrix : register(c23);\nuniform float4x4 _projectionMatrix : register(c27);\nuniform float _nodeU0 : register(c31);\nuniform float _nodeU1 : register(c32);\nuniform float _nodeU2 : register(c33);\nuniform float2 _nodeU3 : register(c34);\nuniform float2 _nodeU6 : register(c35);\nuniform float _nodeU7 : register(c36);\nuniform float _nodeU8 : register(c37);\nuniform float _nodeU9 : register(c38);\nuniform float3 _nodeU10 : register(c39);\nuniform float3 _nodeU11 : register(c40);\nuniform bool _nodeU12 : register(c41);\nuniform float _nodeU13 : register(c42);\nuniform int _nodeU14 : register(c43);\nuniform float3 _nodeU15 : register(c44);\nuniform float _nodeU16 : register(c45);\nuniform float _nodeU17 : register(c46);\nuniform float _nodeU18 : register(c47);\nuniform float _nodeU19 : register(c48);\nuniform bool _nodeU20 : register(c49);\nuniform float _nodeU21 : register(c50);\nuniform int _nodeU22 : register(c51);\nuniform float3 _nodeU23 : register(c52);\nuniform float _nodeU24 : register(c53);\nuniform float _nodeU25 : register(c54);\nuniform float _nodeU26 : register(c55);\nuniform float _nodeU27 : register(c56);\nuniform bool _nodeU28 : register(c57);\nuniform float _nodeU29 : register(c58);\nuniform int _nodeU30 : register(c59);\nuniform float _nodeU31 : register(c60);\nuniform float _nodeU32 : register(c61);\nuniform bool _nodeU33 : register(c62);\nuniform float _nodeU34 : register(c63);\nuniform int _nodeU35 : register(c64);\nuniform float _nodeU36 : register(c65);\nuniform float _nodeU37 : register(c66);\nuniform float _nodeU38 : register(c67);\nuniform float4 _nodeUA0[4] : register(c68);\nuniform float _nodeUA1[4] : register(c72);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_pow2(const float _x)\n{\nreturn (_x * _x);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nstatic float _accumAlpha = {0.0};\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2704 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2705 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2705 = lerp((2.0 * _dither_shift_RGB2705), (-2.0 * _dither_shift_RGB2705), _grid_position2704));\nreturn (_color + _dither_shift_RGB2705);\n}\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2712 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2712)) + (_f90 * _fresnel2712));\n}\nfloat f_V_GGX_SmithCorrelated(const float _alpha, const float _dotNL, const float _dotNV)\n{\nfloat _a22729 = f_pow2(_alpha);\nfloat _gv2730 = (_dotNL * sqrt((_a22729 + ((1.0 - _a22729) * f_pow2(_dotNV)))));\nfloat _gl2731 = (_dotNV * sqrt((_a22729 + ((1.0 - _a22729) * f_pow2(_dotNL)))));\nreturn (0.5 / max((_gv2730 + _gl2731), 1e-06));\n}\nfloat f_D_GGX(const float _alpha, const float _dotNH)\n{\nfloat _a22735 = f_pow2(_alpha);\nfloat _denom2736 = ((f_pow2(_dotNH) * (_a22735 - 1.0)) + 1.0);\nreturn ((0.31830987 * _a22735) / f_pow2(_denom2736));\n}\nfloat3 f_BRDF_GGX(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _f0, const float _f90, const float _roughness)\n{\nfloat _alpha2744 = f_pow2(_roughness);\nfloat3 _halfDir2745 = normalize((_lightDir + _viewDir));\nfloat _dotNL2746 = clamp(dot(_normal, _lightDir), 0.0, 1.0);\nfloat _dotNV2747 = clamp(dot(_normal, _viewDir), 0.0, 1.0);\nfloat _dotNH2748 = clamp(dot(_normal, _halfDir2745), 0.0, 1.0);\nfloat _dotVH2749 = clamp(dot(_viewDir, _halfDir2745), 0.0, 1.0);\nfloat3 _F2750 = f_F_Schlick(_f0, _f90, _dotVH2749);\nfloat _V2751 = f_V_GGX_SmithCorrelated(_alpha2744, _dotNL2746, _dotNV2747);\nfloat _D2752 = f_D_GGX(_alpha2744, _dotNH2748);\nreturn (_F2750 * (_V2751 * _D2752));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2811 = _normal.x;\nfloat _y2812 = _normal.y;\nfloat _z2813 = _normal.z;\nfloat3 _result2814 = (_shCoefficients[0] * 0.88622701);\n(_result2814 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2812));\n(_result2814 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2813));\n(_result2814 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2811));\n(_result2814 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2811) * _y2812));\n(_result2814 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2812) * _z2813));\n(_result2814 += (_shCoefficients[6] * (((0.74312502 * _z2813) * _z2813) - 0.24770799)));\n(_result2814 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2811) * _z2813));\n(_result2814 += ((_shCoefficients[8] * 0.42904299) * ((_x2811 * _x2811) - (_y2812 * _y2812))));\nreturn _result2814;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2818 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2819 = f_shGetIrradianceAt(_worldNormal2818, _lightProbe);\nreturn _irradiance2819;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2822 = _ambientLightColor;\nreturn _irradiance2822;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2844 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2845 = ((0.5 * _dotNL2844) + 0.5);\nfloat3 _irradiance2846 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2845);\nreturn _irradiance2846;\n}\n;\nfloat2 f_DFGApprox(const float3 _normal, const float3 _viewDir, const float _roughness)\n{\nfloat _dotNV2864 = clamp(dot(_normal, _viewDir), 0.0, 1.0);\nfloat4 _r2867 = ((_roughness * float4(-1.0, -0.0275, -0.57200003, 0.022)) + float4(1.0, 0.0425, 1.04, -0.039999999));\nfloat _a0042868 = ((min((_r2867.x * _r2867.x), exp2((-9.2799997 * _dotNV2864))) * _r2867.x) + _r2867.y);\nfloat2 _fab2869 = ((float2(-1.04, 1.04) * _a0042868) + _r2867.zw);\nreturn _fab2869;\n}\nvoid f_computeMultiscattering(const float3 _normal, const float3 _viewDir, const float3 _specularColor, const float _specularF90, const float _roughness, inout float3 _singleScatter, inout float3 _multiScatter)\n{\nfloat2 _fab2885 = f_DFGApprox(_normal, _viewDir, _roughness);\nfloat3 _Fr2886 = _specularColor;\nfloat3 _FssEss2887 = ((_Fr2886 * _fab2885.x) + (_specularF90 * _fab2885.y));\nfloat _Ess2888 = (_fab2885.x + _fab2885.y);\nfloat _Ems2889 = (1.0 - _Ess2888);\nfloat3 _Favg2890 = (_Fr2886 + ((1.0 - _Fr2886) * 0.047619));\nfloat3 _Fms2891 = ((_FssEss2887 * _Favg2890) / (1.0 - (_Ems2889 * _Favg2890)));\n(_singleScatter += _FssEss2887);\n(_multiScatter += (_Fms2891 * _Ems2889));\n}\nvoid f_RE_Direct_Physical__IncidentLight__GeometricContext__PhysicalMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2897 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2898 = (_dotNL2897 * _directLight._color);\n(_reflectedLight._directSpecular += (_irradiance2898 * f_BRDF_GGX(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularF90, _material._roughness)));\n(_reflectedLight._directDiffuse += (_irradiance2898 * f_BRDF_Lambert(_material._diffuseColor)));\n}\nvoid f_RE_IndirectDiffuse_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\nvoid f_RE_IndirectSpecular_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(const float3 _radiance, const float3 _irradiance, const float3 _clearcoatRadiance, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat3 _singleScattering2911 = {0.0, 0.0, 0.0};\nfloat3 _multiScattering2912 = {0.0, 0.0, 0.0};\nfloat3 _cosineWeightedIrradiance2913 = (_irradiance * 0.31830987);\nf_computeMultiscattering(_geometry._normal, _geometry._viewDir, _material._specularColor, _material._specularF90, _material._roughness, _singleScattering2911, _multiScattering2912);\nfloat3 _totalScattering2914 = (_singleScattering2911 + _multiScattering2912);\nfloat3 _diffuse2915 = (_material._diffuseColor * (1.0 - max(max(_totalScattering2914.x, _totalScattering2914.y), _totalScattering2914.z)));\n(_reflectedLight._indirectSpecular += (_radiance * _singleScattering2911));\n(_reflectedLight._indirectSpecular += (_multiScattering2912 * _cosineWeightedIrradiance2913));\n(_reflectedLight._indirectDiffuse += (_diffuse2915 * _cosineWeightedIrradiance2913));\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2992 = floor(_vUv);\nfloat2 _fuv2993 = frac(_vUv);\nfloat _g0x2994 = f_g0(_fuv2993.x);\nfloat _g1x2995 = f_g1(_fuv2993.x);\nfloat _h0x2996 = f_h0(_fuv2993.x);\nfloat _h1x2997 = f_h1(_fuv2993.x);\nfloat _h0y2998 = f_h0(_fuv2993.y);\nfloat _h1y2999 = f_h1(_fuv2993.y);\nfloat2 _p03000 = ((vec2_ctor((_iuv2992.x + _h0x2996), (_iuv2992.y + _h0y2998)) - 0.5) * _texelSize.xy);\nfloat2 _p13001 = ((vec2_ctor((_iuv2992.x + _h1x2997), (_iuv2992.y + _h0y2998)) - 0.5) * _texelSize.xy);\nfloat2 _p23002 = ((vec2_ctor((_iuv2992.x + _h0x2996), (_iuv2992.y + _h1y2999)) - 0.5) * _texelSize.xy);\nfloat2 _p33003 = ((vec2_ctor((_iuv2992.x + _h1x2997), (_iuv2992.y + _h1y2999)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2993.y) * ((_g0x2994 * gl_texture2DLod(_tex, _p03000, _lod)) + (_g1x2995 * gl_texture2DLod(_tex, _p13001, _lod)))) + (f_g1(_fuv2993.y) * ((_g0x2994 * gl_texture2DLod(_tex, _p23002, _lod)) + (_g1x2995 * gl_texture2DLod(_tex, _p33003, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize3008 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize3009 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv3010 = (1.0 / _fLodSize3008);\nfloat2 _cLodSizeInv3011 = (1.0 / _cLodSize3009);\nfloat4 _fSample3012 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv3010, _fLodSize3008), floor(_lod));\nfloat4 _cSample3013 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv3011, _cLodSize3009), ceil(_lod));\nreturn lerp(_fSample3012, _cSample3013, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector3041 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale3042 = {0, 0, 0};\n(_modelScale3042.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale3042.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale3042.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector3041) * _thickness) * _modelScale3042);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist3061 = length((_vPosition - _origin));\nreturn ((_dist3061 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3078 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3079 = ((clamp(_fresnel3078, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3079 / clamp((_lalpha3079 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3079, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3079) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3089 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3089).xyz;\n}\nfloat3 f_gb60bf13d71894171a2af79dd1d344da3_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3101 = _colors[0];\nfloat _depth3102 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3103 = {0};\n{ for(int _i3104 = {1}; (_i3104 < 4); (_i3104++))\n{\n(_p3103 = clamp(((_depth3102 - _steps[(_i3104 - 1)]) / (_steps[_i3104] - _steps[(_i3104 - 1)])), 0.0, 1.0));\n(_color3101 = lerp(_color3101, _colors[_i3104], _p3103));\n}\n}\nfloat _lalpha3105 = ((_alpha * _color3101.w) * _mask);\n(_calpha = lerp((_lalpha3105 / clamp((_lalpha3105 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3105, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3105) * (1.0 - float_ctor(_isMask))));\nreturn _color3101.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3120 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3121 = (_position + _transmissionRay3120);\nfloat4 _ndcPos3122 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3121, 1.0));\nfloat2 _refractionCoords3123 = (_ndcPos3122.xy / _ndcPos3122.w);\n(_refractionCoords3123 += 1.0);\n(_refractionCoords3123 /= 2.0);\nfloat4 _ndcPosUnrefracted3124 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3125 = (_ndcPosUnrefracted3124.xy / _ndcPosUnrefracted3124.w);\n(_unrefractedCoords3125 += 1.0);\n(_unrefractedCoords3125 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3123, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3125, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3138 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3138 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3138 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3139 = f_getIBLVolumeRefraction(_vWNormal, (-_v3138), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3140 = (_alpha * _mask);\n(_calpha = (_lalpha3140 / clamp((_lalpha3140 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3139;\n}\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input){\n    float rhw = 1.0 / input.gl_FragCoord.w;\n    gl_FragCoord.x = input.dx_Position.x - dx_FragCoordOffset.x;\n    gl_FragCoord.y = input.dx_Position.y - dx_FragCoordOffset.y;\n    gl_FragCoord.z = input.dx_Position.z;\n    gl_FragCoord.w = rhw;\n    _vViewPosition = input.v0.xyz;\n    _vWPosition = input.v1.xyz;\n    _vNormal = input.v2.xyz;\n    _vPosition = input.v3.xyz;\n    _vWNormal = input.v4.xyz;\n    _vWorldViewDir = input.v5.xyz;\n\nfloat _g5bfaadd2eca34fa3b71f09ed96a7f085_calpha3142 = {0};\nfloat _gb60bf13d71894171a2af79dd1d344da3_calpha3143 = {0};\nfloat _gee38695320d24f1c8e9eb0283839cba8_calpha3144 = {0};\nfloat _g354ff6fd46474004b7bb3125dc58a54f_calpha3145 = {0};\nfloat3 _normal3147 = normalize(_vNormal);\nfloat3 _geometryNormal3148 = _normal3147;\nfloat3 _viewdx3149 = ddx(_vViewPosition);\nfloat3 _viewdy3150 = ddy(_vViewPosition);\nfloat3 _faceNormal3151 = normalize(cross(_viewdx3149, _viewdy3150));\nif ((dot(_normal3147, _faceNormal3151) < 0.0))\n{\n(_normal3147 *= -1.0);\n}\n_PhysicalMaterial _material3152 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_material3152._diffuseColor = float3(1.0, 1.0, 1.0));\nfloat3 _diffuseColor3153 = f_spe_blend_int(f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3147, 1.0, _nodeU7, _g5bfaadd2eca34fa3b71f09ed96a7f085_calpha3142), f_gb60bf13d71894171a2af79dd1d344da3_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _gb60bf13d71894171a2af79dd1d344da3_calpha3143), _gb60bf13d71894171a2af79dd1d344da3_calpha3143, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _gee38695320d24f1c8e9eb0283839cba8_calpha3144), _gee38695320d24f1c8e9eb0283839cba8_calpha3144, _nodeU22), f_fresnel_int(_nodeU23, _nodeU24, _nodeU25, _nodeU26, _nodeU27, _nodeU28, 1.0, _nodeU29, _nodeU30, _g354ff6fd46474004b7bb3125dc58a54f_calpha3145), _g354ff6fd46474004b7bb3125dc58a54f_calpha3145, _nodeU30);\n_ReflectedLight _reflectedLight3154 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat _metalnessFactor3155 = _nodeU32;\nfloat _roughnessFactor3156 = _nodeU31;\nfloat3 _dxy3157 = max(abs(ddx(_geometryNormal3148)), abs(ddy(_geometryNormal3148)));\nfloat _geometryRoughness3158 = max(max(_dxy3157.x, _dxy3157.y), _dxy3157.z);\n(_material3152._diffuseColor = (_diffuseColor3153 * (1.0 - _metalnessFactor3155)));\n(_material3152._roughness = max(_roughnessFactor3156, 0.052499998));\n(_material3152._roughness += _geometryRoughness3158);\n(_material3152._roughness = min(_material3152._roughness, 1.0));\n(_material3152._roughness = clamp(_roughnessFactor3156, 0.039999999, 1.0));\n(_material3152._specularColor = lerp(vec3_ctor((0.16 * f_pow2(_nodeU37))), _diffuseColor3153, _metalnessFactor3155));\n_GeometricContext _geometry3159 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry3159._position = (-_vViewPosition));\n(_geometry3159._normal = _normal3147);\nfloat3 sc61 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sc61 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sc61 = normalize(_vViewPosition));\n}\n(_geometry3159._viewDir = sc61);\n_IncidentLight _directLight3160 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight3161 = {0, 0, 0, 0, 0, 0};\n(_directionalLight3161 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight3161, _geometry3159, _directLight3160);\nf_RE_Direct_Physical__IncidentLight__GeometricContext__PhysicalMaterial__ReflectedLight(_directLight3160, _geometry3159, _material3152, _reflectedLight3154);\nfloat3 _iblIrradiance3162 = {0.0, 0.0, 0.0};\nfloat3 _irradiance3163 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance3163 += f_getLightProbeIrradiance(_lightProbe, _geometry3159._normal));\n(_irradiance3163 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry3159._normal));\nfloat3 _radiance3164 = {0.0, 0.0, 0.0};\nfloat3 _clearcoatRadiance3165 = {0.0, 0.0, 0.0};\nf_RE_IndirectDiffuse_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(_irradiance3163, _geometry3159, _material3152, _reflectedLight3154);\nf_RE_IndirectSpecular_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(_radiance3164, _iblIrradiance3162, _clearcoatRadiance3165, _geometry3159, _material3152, _reflectedLight3154);\nfloat3 sc62 = {0, 0, 0};\nif ((_aoEnabled && _nodeU33))\n{\n(sc62 = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc62 = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3166 = sc62;\nfloat3 _outgoingLight3167 = (((_reflectedLight3154._directDiffuse + _reflectedLight3154._indirectDiffuse) + _reflectedLight3154._directSpecular) + _reflectedLight3154._indirectSpecular);\nif (!all(_outgoingLight3167 == _diffuseColor3153))\n{\nfloat _lightAccu3168 = clamp(length((_reflectedLight3154._directSpecular + _reflectedLight3154._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU34) * 1.0) * _lightAccu3168));\n(_outgoingLight3167 = f_spe_blend_int(_diffuseColor3153, _outgoingLight3167, (_nodeU34 * 1.0), _nodeU35));\n(_outgoingLight3167 *= _ao3166);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3167, (_accumAlpha * _nodeU36)));\n(out_pc_fragColor.w *= _nodeU38);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                            }
                        ]
                    },
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLProgram - ID: 4",
                        "id": 4,
                        "typeName": "WebGLProgram"
                    }
                }
            ],
            "commandEndTime": 1732773587878.2,
            "endTime": 1732773587879.2,
            "id": 39,
            "name": "useProgram",
            "stackTrace": [
                "Object.useProgram (https://unpkg.com/three@0.149.0/build/three.module.js:21720:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28554:14)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587878.2,
            "status": 0,
            "text": "useProgram: WebGLProgram - ID: 4"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 81",
                        "id": 81,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                {
                    "0": 0,
                    "1": 0,
                    "2": 0,
                    "3": 0,
                    "4": 0,
                    "5": 0,
                    "6": 0,
                    "7": 0,
                    "8": 0,
                    "9": 0,
                    "10": 0,
                    "11": 0,
                    "12": 0,
                    "13": 0,
                    "14": 0,
                    "15": 0,
                    "16": 0,
                    "17": 0,
                    "18": 0,
                    "19": 0,
                    "20": 0,
                    "21": 0,
                    "22": 0,
                    "23": 0,
                    "24": 0,
                    "25": 0,
                    "26": 0
                }
            ],
            "commandEndTime": 1732773587879.2,
            "endTime": 1732773587879.3,
            "id": 40,
            "name": "uniform3fv",
            "stackTrace": [
                "PureArrayUniform.setValueV3fArray [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17760:5)",
                "WebGLUniforms.upload (https://unpkg.com/three@0.149.0/build/three.module.js:18187:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28724:18)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773587879.2,
            "status": 0,
            "text": "uniform3fv: WebGLUniformLocation - ID: 81, [..(27)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 124",
                        "id": 124,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                {
                    "0": 0.008213827386498451,
                    "1": 0.23190057277679443,
                    "2": 0.5212568044662476,
                    "3": 1,
                    "4": 0,
                    "5": 0.10698281973600388,
                    "6": 0.18638122081756592,
                    "7": 1,
                    "8": 0,
                    "9": 0.10698281973600388,
                    "10": 0.18638122081756592,
                    "11": 1,
                    "12": 0.024416930973529816,
                    "13": 0.03410720452666283,
                    "14": 0.06075546145439148,
                    "15": 1
                }
            ],
            "commandEndTime": 1732773587879.5,
            "endTime": 1732773587879.6,
            "id": 41,
            "name": "uniform4fv",
            "stackTrace": [
                "PureArrayUniform.setValueV4fArray [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17768:5)",
                "WebGLUniforms.upload (https://unpkg.com/three@0.149.0/build/three.module.js:18187:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28724:18)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773587879.5,
            "status": 0,
            "text": "uniform4fv: WebGLUniformLocation - ID: 124, [..(16)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLUniformLocation - ID: 125",
                        "id": 125,
                        "typeName": "WebGLUniformLocation"
                    }
                },
                [
                    0,
                    0.2630236231752599,
                    0.5431194040374775,
                    0.9511203746788478
                ]
            ],
            "commandEndTime": 1732773587879.6,
            "endTime": 1732773587879.7,
            "id": 42,
            "name": "uniform1fv",
            "stackTrace": [
                "PureArrayUniform.setValueV1fArray [as setValue] (https://unpkg.com/three@0.149.0/build/three.module.js:17742:5)",
                "WebGLUniforms.upload (https://unpkg.com/three@0.149.0/build/three.module.js:18187:7)",
                "setProgram (https://unpkg.com/three@0.149.0/build/three.module.js:28724:18)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27641:19)"
            ],
            "startTime": 1732773587879.6,
            "status": 0,
            "text": "uniform1fv: WebGLUniformLocation - ID: 125, [..(4)..]"
        },
        {
            "commandArguments": [
                {
                    "__SPECTOR_Object_TAG": {
                        "displayText": "WebGLVertexArrayObject - ID: 4",
                        "id": 4,
                        "typeName": "WebGLVertexArrayObject"
                    }
                }
            ],
            "commandEndTime": 1732773587879.7,
            "endTime": 1732773587879.8,
            "id": 43,
            "name": "bindVertexArray",
            "stackTrace": [
                "bindVertexArrayObject (https://unpkg.com/three@0.149.0/build/three.module.js:14176:42)",
                "Object.setup (https://unpkg.com/three@0.149.0/build/three.module.js:14118:5)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27690:17)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)"
            ],
            "startTime": 1732773587879.7,
            "status": 0,
            "text": "bindVertexArray: WebGLVertexArrayObject - ID: 4"
        },
        {
            "BlendState": {
                "BLEND": false,
                "BLEND_COLOR": [
                    0,
                    0,
                    0,
                    0
                ],
                "BLEND_DST_ALPHA": "ZERO",
                "BLEND_DST_RGB": "ZERO",
                "BLEND_EQUATION_ALPHA": "FUNC_ADD",
                "BLEND_EQUATION_RGB": "FUNC_ADD",
                "BLEND_SRC_ALPHA": "ONE",
                "BLEND_SRC_RGB": "ONE"
            },
            "ColorState": {
                "COLOR_WRITEMASK": [
                    true,
                    true,
                    true,
                    true
                ]
            },
            "CoverageState": {
                "SAMPLE_ALPHA_TO_COVERAGE": false,
                "SAMPLE_COVERAGE": false,
                "SAMPLE_COVERAGE_INVERT": false,
                "SAMPLE_COVERAGE_VALUE": 1
            },
            "CullState": {
                "CULL_FACE": true,
                "CULL_FACE_MODE": "BACK"
            },
            "DepthState": {
                "DEPTH_FUNC": "LEQUAL",
                "DEPTH_RANGE": [
                    0,
                    1
                ],
                "DEPTH_TEST": true,
                "DEPTH_WRITEMASK": true
            },
            "DrawCall": {
                "attributes": [
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 268644,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 10",
                                "id": 10,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 268644,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 0,
                        "name": "position",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 3,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 268644,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 11",
                                "id": 11,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 268644,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 1,
                        "name": "normal",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 12,
                        "type": "FLOAT_VEC3",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arraySize": 2,
                        "arrayType": "FLOAT",
                        "bufferBinding": {
                            "__SPECTOR_Object_CustomData": {
                                "length": 179096,
                                "target": "ARRAY_BUFFER",
                                "usage": 35044
                            },
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLBuffer - ID: 12",
                                "id": 12,
                                "typeName": "WebGLBuffer"
                            }
                        },
                        "bufferLength": 179096,
                        "bufferUsage": "STATIC_DRAW",
                        "divisor": 0,
                        "enabled": true,
                        "integer": false,
                        "location": 2,
                        "name": "uv",
                        "normalized": false,
                        "offsetPointer": 0,
                        "size": 1,
                        "stride": 8,
                        "type": "FLOAT_VEC2",
                        "vertexAttrib": [
                            0,
                            0,
                            0,
                            1
                        ]
                    }
                ],
                "elementArray": {
                    "arrayBuffer": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 239976,
                            "target": "ELEMENT_ARRAY_BUFFER",
                            "usage": 35044
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLBuffer - ID: 15",
                            "id": 15,
                            "typeName": "WebGLBuffer"
                        }
                    }
                },
                "frameBuffer": null,
                "programStatus": {
                    "LINK_STATUS": true,
                    "RECOMPILABLE": false,
                    "VALIDATE_STATUS": false,
                    "program": {
                        "__SPECTOR_Object_CustomData": {
                            "length": 70896,
                            "programStatus": {
                                "LINK_STATUS": true,
                                "VALIDATE_STATUS": false
                            },
                            "shaders": [
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "NodeMaterial",
                                    "shaderType": "VERTEX_SHADER",
                                    "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define STANDARD 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS 4\n#define gb60bf13d71894171a2af79dd1d344da3_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define VERTEX_TEXTURES\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat neighbor_offset = 0.0001;\n\nuniform int frameIndex;\nuniform vec2 resolution;\nuniform mat4 previousModelViewMatrix;\nuniform mat4 previousProjectionMatrix;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\n\n\n\n\n\nvoid main() {\n\n\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n\n\t\t\t\t#if !defined( USE_LAYER_DISPLACE )\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec3 displaced_position = position;\n\t\t\t\tvec3 displaced_normal = normal;\n\n\t\t\t\t#if defined( USE_LAYER_DISPLACE )\n\t\t\t\t\tvec3 transformed;\n\t\t\t\t\tvec3 transformedNormal;\n\t\t\t\t#endif\n\t\t\t\t\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\n\t\t\t\t#if !defined( USE_LAYER_DISPLACE )\nvec3 transformed = vec3( position );\n\t\t\t\t#endif /* !USE_LAYER_DISPLACE */\n\t\t\t\t\ntransformed = displaced_position;\ntransformedNormal = normalMatrix * displaced_normal;\n#ifndef FLAT_SHADED\n    vNormal = transformedNormal;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\nvWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;\nvUv = uv;\nvPosition = transformed;\nvWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;\nvWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );\n\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2691 = vec3_ctor(_normal);\nfloat3 _transformedNormal2692 = _objectNormal2691;\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _transformedNormal2692));\nfloat3 _displaced_position2693 = _position;\nfloat3 _displaced_normal2694 = _normal;\n(_vNormal = normalize(_transformedNormal2692));\nfloat3 _transformed2695 = vec3_ctor(_position);\n(_transformed2695 = _displaced_position2693);\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _displaced_normal2694));\n(_vNormal = _transformedNormal2692);\nfloat4 _mvPosition2696 = vec4_ctor(_transformed2695, 1.0);\n(_mvPosition2696 = mul(transpose(_modelViewMatrix), _mvPosition2696));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2696));\n(_vViewPosition = (-_mvPosition2696.xyz));\nfloat4 _worldPosition2697 = vec4_ctor(_transformed2695, 1.0);\n(_worldPosition2697 = mul(transpose(_modelMatrix), _worldPosition2697));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2695, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2695);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2692, _viewMatrix).xyz);\nfloat3 sa8a = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sa8a = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sa8a = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sa8a);\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD6;\n    float4 gl_FragCoord : TEXCOORD7;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n};\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _normal : TEXCOORD1;\n    float2 _uv : TEXCOORD2;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _normal = input._normal;\n    _uv = input._uv;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.gl_FragCoord = gl_Position;\n    output.v0 = _vViewPosition;\n    output.v1 = _vWPosition;\n    output.v2 = _vNormal;\n    output.v3 = _vPosition;\n    output.v4 = _vWNormal;\n    output.v5 = _vWorldViewDir;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2691 = vec3_ctor(_normal);\nfloat3 _transformedNormal2692 = _objectNormal2691;\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _transformedNormal2692));\nfloat3 _displaced_position2693 = _position;\nfloat3 _displaced_normal2694 = _normal;\n(_vNormal = normalize(_transformedNormal2692));\nfloat3 _transformed2695 = vec3_ctor(_position);\n(_transformed2695 = _displaced_position2693);\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _displaced_normal2694));\n(_vNormal = _transformedNormal2692);\nfloat4 _mvPosition2696 = vec4_ctor(_transformed2695, 1.0);\n(_mvPosition2696 = mul(transpose(_modelViewMatrix), _mvPosition2696));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2696));\n(_vViewPosition = (-_mvPosition2696.xyz));\nfloat4 _worldPosition2697 = vec4_ctor(_transformed2695, 1.0);\n(_worldPosition2697 = mul(transpose(_modelMatrix), _worldPosition2697));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2695, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2695);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2692, _viewMatrix).xyz);\nfloat3 sa8a = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sa8a = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sa8a = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sa8a);\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                                },
                                {
                                    "COMPILE_STATUS": true,
                                    "name": "NodeMaterial",
                                    "shaderType": "FRAGMENT_SHADER",
                                    "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define STANDARD 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS 4\n#define gb60bf13d71894171a2af79dd1d344da3_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define DITHERING\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat accumAlpha = 0.0;\nvoid accumulateAlpha(float alpha) {\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * alpha;\n\t\t\t\t}\n\nlayout(location = 1) out vec4 gVelocity;\n\nuniform int frameIndex;\nuniform vec2 resolution;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nconst vec2 haltonSequence[16] = vec2[16](\nvec2( 0.000000,-0.333334),\nvec2(-0.500000, 0.333334),\nvec2( 0.500000,-0.777778),\nvec2(-0.750000,-0.111112),\nvec2( 0.250000, 0.555556),\nvec2(-0.250000,-0.555556),\nvec2( 0.750000, 0.111112),\nvec2(-0.875000, 0.777778),\nvec2(0.125000, -0.925926),\nvec2(-0.375000, -0.259260),\nvec2(0.625000, 0.407408),\nvec2(-0.625000, -0.703704),\nvec2(0.375000, -0.037038),\nvec2(-0.125000, 0.629630),\nvec2(0.875000, -0.481482),\nvec2(-0.937500, 0.185186));\n\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n  const float goldenAngle = 2.399963f; // radians\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n  float theta = float(sampleIndex) * goldenAngle + angle;\n  float sine = sin(theta);\n  float cosine = cos(theta);\n  return vec2(cosine, sine) * r;\n}\n\n// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso\nfloat getNoiseInterleavedGradient(vec2 screenPos) {\n    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);\n    return fract(magic.z * fract(dot(screenPos, magic.xy)));\n}\n\n\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\nuniform float penumbraSize[5];\nuniform sampler2D aoMap;\nuniform bool aoEnabled;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\nstruct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if 0 > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\nuniform float nodeU0;\nuniform float nodeU1;\nuniform float nodeU2;\nuniform vec2 nodeU3;\nuniform sampler2D nodeU4;\nuniform sampler2D nodeU5;\nuniform vec2 nodeU6;\nuniform float nodeU7;\nuniform float nodeU8;\nuniform float nodeU9;\nuniform vec3 nodeU10;\nuniform vec3 nodeU11;\nuniform bool nodeU12;\nuniform float nodeU13;\nuniform int nodeU14;\nuniform vec3 nodeU15;\nuniform float nodeU16;\nuniform float nodeU17;\nuniform float nodeU18;\nuniform float nodeU19;\nuniform bool nodeU20;\nuniform float nodeU21;\nuniform int nodeU22;\nuniform vec3 nodeU23;\nuniform float nodeU24;\nuniform float nodeU25;\nuniform float nodeU26;\nuniform float nodeU27;\nuniform bool nodeU28;\nuniform float nodeU29;\nuniform int nodeU30;\nuniform float nodeU31;\nuniform float nodeU32;\nuniform bool nodeU33;\nuniform float nodeU34;\nuniform int nodeU35;\nuniform float nodeU36;\nuniform float nodeU37;\nuniform float nodeU38;\n\nuniform vec4 nodeUA0[4];\nuniform float nodeUA1[4];\n\n\n\nfloat w0( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n        }\n    \n        float w1( float a ) {\n            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n        }\n    \n        float w2( float a ){\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n        }\n    \n        float w3( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * a * a );\n        }\n    \n        // g0 and g1 are the two amplitude functions\n        float g0( float a ) {\n            return w0( a ) + w1( a );\n        }\n    \n        float g1( float a ) {\n            return w2( a ) + w3( a );\n        }\n    \n        // h0 and h1 are the two offset functions\n        float h0( float a ) {\n            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n        }\n    \n        float h1( float a ) {\n            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n        }\n    \n        vec4 bicubic( sampler2D tex, vec2 vUv, vec4 texelSize, float lod ) {\n            vUv = vUv * texelSize.zw + 0.5;\n    \n            vec2 iuv = floor( vUv );\n            vec2 fuv = fract( vUv );\n    \n            float g0x = g0( fuv.x );\n            float g1x = g1( fuv.x );\n            float h0x = h0( fuv.x );\n            float h1x = h1( fuv.x );\n            float h0y = h0( fuv.y );\n            float h1y = h1( fuv.y );\n    \n            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n    \n            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + \n                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n        }\n\n        vec4 textureBicubic( sampler2D sampler, vec2 vUv, float lod ) {\n            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n            vec2 fLodSizeInv = 1.0 / fLodSize;\n            vec2 cLodSizeInv = 1.0 / cLodSize;\n            vec4 fSample = bicubic( sampler, vUv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n            vec4 cSample = bicubic( sampler, vUv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n            return mix( fSample, cSample, fract( lod ) );\n        }\nfloat applyIorToRoughness( float roughness, float ior ) {\n\t\t\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\t\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t\t\t}\nvec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {\n                // Slightly modified version of this:\n                // https://www.shadertoy.com/view/ltScRG\n\n\t\t\t\t// Special case for blur == 0.0\n\t\t\t\tif (lod == 0.0) {\n\t\t\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\t\treturn texture2DLodEXT( sp, U, 0.0).rgb;\n\t\t\t\t\t#else\n\t\t\t\t\treturn textureLod( sp, U, 0.0).rgb;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec2 texelSize = vec2(1.0) / resolution;\n                vec2 halton = haltonSequence[frameIndex];\n                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n                float temporalAngle  = temporalOffset * PI2;\n\t\t\t\tvec3 res = vec3(0.0);\n                vec2 vUv = vec2(0.0);\n                vec2 offset = vec2(0.0);\n                vec2 vogelSample = vec2(0.0);\n                for (int i = 0; i < NUM_SAMPLES; i++) {\n                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;\n                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20\n                    vUv = U + offset;\n                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, vUv, lod));\n                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {\n                        vUv = unrefractedU;\n                        lod = lod > 4.0 ? lod : lod / 2.0;\n                    }\n                    res += textureLod(sp, vUv, lod).rgb;\n                }\n                return res / float(NUM_SAMPLES);\n            }\nvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\t        // Direction of refracted light.\n\t\t        vec3 refractionVector = refract( -v,  n, 1.0 / ior );\n\t\t        \n\t\t\t\t// Compute rotation-independant scaling of the model matrix.\n\t\t        vec3 modelScale;\n\t\t        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\t        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\t        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t        // The thickness is specified in local space\n\t\t        return normalize( refractionVector ) * thickness * modelScale;\n\t        }\nfloat vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vPosition.x - origin.x) + n.y*(vPosition.y - origin.y) + n.z*(vPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vWPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nvec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {\n\t\t\t\t\tfloat fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );\n\n\t\t\t\t\tfloat lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;\n\t\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\t\treturn color;\n\t\t\t\t}\nvec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {\n\t\t\t\t// Threejs exports do not pass a depth map to this shader, so we have to fallback to the \"Threejs method of blurring\" - see\n\t\t\t\t// also the code in convertTransmission.ts, which runs during export\n\t\t\t\t#ifdef IS_THREEJS_EXPORT\n\t\t\t\t\tfloat lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);\n\t\t\t\t\treturn textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;\n\t\t\t\t#else\n\t\t\t\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t\t\t\tfloat lod = applyIorToRoughness(roughness, ior);\n\t\t\t\t\treturn blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);\n\t\t\t\t#endif\n\t\t\t}\nvec3 gb60bf13d71894171a2af79dd1d344da3_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS], float steps[gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {\n               vec4 color = colors[0];\n               #ifdef gb60bf13d71894171a2af79dd1d344da3_IS_VECTOR\n                   #ifdef gb60bf13d71894171a2af79dd1d344da3_LINEAR\n                       #ifdef gb60bf13d71894171a2af79dd1d344da3_WORLDSPACE\n                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);\n                       #else\n                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);\n                       #endif\n                   #else\n                       #ifdef gb60bf13d71894171a2af79dd1d344da3_WORLDSPACE\n                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);\n                       #else\n                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);\n                       #endif\n                   #endif\n               #else\n                   float dist = length(vWPosition - cameraPosition);\n\t\t\t       float depth = ( dist - near ) / ( far - near );\n               #endif\n\n\n              float p;\n              #ifdef gb60bf13d71894171a2af79dd1d344da3_SMOOTH\n\t\t\t\tfor ( int i = 1; i < gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS; i++ ) {\n\t\t\t\t\t\tp = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );\n\t\t\t\t\t\tcolor = mix(color, colors[i], smoothstep(0.0, 1.0, p));\n\t\t\t\t\t}\n              #else\n                for ( int i = 1; i < gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS; i++ ) {\n                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);\n                   color = mix(color, colors[i], p);\n                 }\n              #endif\n\n               float lalpha = alpha * color.a * mask;\n               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\t\t\t   \n               return color.rgb;\n\t\t\t}\nvec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\n\t\t\t\tvec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );\n\t\t\t\tvec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;\n\t\t\t\tunrefractedCoords += 1.0;\n\t\t\t\tunrefractedCoords /= 2.0;\n\n\t\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\t\treturn getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );\n    \t\t}\nvec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {\n                vec3 v = vec3(0.);\n                if (isOrthographic) {\n                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n                } else {\n                    v = normalize(vWPosition - cameraPosition);\n                }\n                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );\n                \n\t\t\t\tfloat lalpha = alpha * mask;\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * alpha;\n\n\t\t\t\treturn transmission;\n            }\n\nvoid main() {\n\nfloat g5bfaadd2eca34fa3b71f09ed96a7f085_calpha;\nfloat gb60bf13d71894171a2af79dd1d344da3_calpha;\nfloat gee38695320d24f1c8e9eb0283839cba8_calpha;\nfloat g354ff6fd46474004b7bb3125dc58a54f_calpha;\n\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n\n\t\t\t\t// NOTE: gl_FrontFacing alternative using face normal estimation.\n\t\t\t\tvec3 viewdx = dFdx(vViewPosition);\n\t\t\t\tvec3 viewdy = dFdy(vViewPosition);\n\t\t\t\tvec3 faceNormal = normalize(cross(viewdx,viewdy));\n\t\t\t\tif (dot(normal, faceNormal) < 0.0) {\n\t\t\t\t\tnormal *= -1.0;\n\t\t\t\t}\n\t\t\t\t\n\tPhysicalMaterial material;\n\tmaterial.diffuseColor = vec3( 1.0 );\n\n\tvec3 diffuseColor = spe_blend(spe_blend(spe_blend(transmission(nodeU0,nodeU1,nodeU2,nodeU3,nodeU4,nodeU5,nodeU6,normal,1.0,nodeU7,g5bfaadd2eca34fa3b71f09ed96a7f085_calpha),gb60bf13d71894171a2af79dd1d344da3_sdepth(nodeU8,nodeU9,nodeU10,nodeU11,nodeUA0,nodeUA1,nodeU12,1.0,nodeU13,gb60bf13d71894171a2af79dd1d344da3_calpha),( gb60bf13d71894171a2af79dd1d344da3_calpha ),nodeU14),fresnel(nodeU15,nodeU16,nodeU17,nodeU18,nodeU19,nodeU20,1.0,nodeU21,nodeU22,gee38695320d24f1c8e9eb0283839cba8_calpha),( gee38695320d24f1c8e9eb0283839cba8_calpha ),nodeU22),fresnel(nodeU23,nodeU24,nodeU25,nodeU26,nodeU27,nodeU28,1.0,nodeU29,nodeU30,g354ff6fd46474004b7bb3125dc58a54f_calpha),( g354ff6fd46474004b7bb3125dc58a54f_calpha ),nodeU30);\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\tfloat metalnessFactor = nodeU32;\n\n\tfloat roughnessFactor = nodeU31;\n\n#ifdef ALPHATEST\n\tif ( nodeU36 <= ALPHATEST ) discard;\n#endif\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );\nmaterial.roughness = max( roughnessFactor, 0.0525 );\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\nmaterial.roughness = clamp( roughnessFactor, 0.04, 1.0 );\n\nmaterial.specularColor = mix( vec3( 0.16 * pow2( nodeU37 ) ), diffuseColor, metalnessFactor );\n\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t\n#endif\n#if ( 1 > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t\n\t\tdirectionalLight = directionalLights[ 0 ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( 0 < 0 )\n\t\tdirectionalLightShadow = directionalLightShadows[ 0 ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( 0, directionalShadowMap[ 0 ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( 1 > 0 )\n\t\t\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\nvec3 ao = aoEnabled && nodeU33 ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);\nvec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n\t\t\t\tif (outgoingLight != diffuseColor) {\n\t\t\t\t\tfloat lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );\n\t\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * nodeU34 * 1.0 * lightAccu;\n\t\t\t\t\toutgoingLight = spe_blend( diffuseColor, outgoingLight, nodeU34 * 1.0, nodeU35 );\n\t\t\t\t\t\n\t\t\t\t\toutgoingLight *= ao;\n\t\t\t\t}\n\t\t\t\t\ngl_FragColor = vec4( outgoingLight, accumAlpha * nodeU36 );\ngl_FragColor.a *= nodeU38;\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n\n}",
                                    "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n    float pad_26;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n    float pad_27;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0)\n{\n    return float3(x0, x0, x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform bool _aoEnabled : register(c7);\nuniform float3 _ambientLightColor : register(c8);\nuniform float3 _lightProbe[9] : register(c9);\nuniform _DirectionalLight _directionalLights[1] : register(c18);\nuniform _HemisphereLight _hemisphereLights[1] : register(c20);\nuniform float4x4 _modelMatrix : register(c23);\nuniform float4x4 _projectionMatrix : register(c27);\nuniform float _nodeU0 : register(c31);\nuniform float _nodeU1 : register(c32);\nuniform float _nodeU2 : register(c33);\nuniform float2 _nodeU3 : register(c34);\nuniform float2 _nodeU6 : register(c35);\nuniform float _nodeU7 : register(c36);\nuniform float _nodeU8 : register(c37);\nuniform float _nodeU9 : register(c38);\nuniform float3 _nodeU10 : register(c39);\nuniform float3 _nodeU11 : register(c40);\nuniform bool _nodeU12 : register(c41);\nuniform float _nodeU13 : register(c42);\nuniform int _nodeU14 : register(c43);\nuniform float3 _nodeU15 : register(c44);\nuniform float _nodeU16 : register(c45);\nuniform float _nodeU17 : register(c46);\nuniform float _nodeU18 : register(c47);\nuniform float _nodeU19 : register(c48);\nuniform bool _nodeU20 : register(c49);\nuniform float _nodeU21 : register(c50);\nuniform int _nodeU22 : register(c51);\nuniform float3 _nodeU23 : register(c52);\nuniform float _nodeU24 : register(c53);\nuniform float _nodeU25 : register(c54);\nuniform float _nodeU26 : register(c55);\nuniform float _nodeU27 : register(c56);\nuniform bool _nodeU28 : register(c57);\nuniform float _nodeU29 : register(c58);\nuniform int _nodeU30 : register(c59);\nuniform float _nodeU31 : register(c60);\nuniform float _nodeU32 : register(c61);\nuniform bool _nodeU33 : register(c62);\nuniform float _nodeU34 : register(c63);\nuniform int _nodeU35 : register(c64);\nuniform float _nodeU36 : register(c65);\nuniform float _nodeU37 : register(c66);\nuniform float _nodeU38 : register(c67);\nuniform float4 _nodeUA0[4] : register(c68);\nuniform float _nodeUA1[4] : register(c72);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_pow2(const float _x)\n{\nreturn (_x * _x);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nstatic float _accumAlpha = {0.0};\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2704 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2705 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2705 = lerp((2.0 * _dither_shift_RGB2705), (-2.0 * _dither_shift_RGB2705), _grid_position2704));\nreturn (_color + _dither_shift_RGB2705);\n}\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2712 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2712)) + (_f90 * _fresnel2712));\n}\nfloat f_V_GGX_SmithCorrelated(const float _alpha, const float _dotNL, const float _dotNV)\n{\nfloat _a22729 = f_pow2(_alpha);\nfloat _gv2730 = (_dotNL * sqrt((_a22729 + ((1.0 - _a22729) * f_pow2(_dotNV)))));\nfloat _gl2731 = (_dotNV * sqrt((_a22729 + ((1.0 - _a22729) * f_pow2(_dotNL)))));\nreturn (0.5 / max((_gv2730 + _gl2731), 1e-06));\n}\nfloat f_D_GGX(const float _alpha, const float _dotNH)\n{\nfloat _a22735 = f_pow2(_alpha);\nfloat _denom2736 = ((f_pow2(_dotNH) * (_a22735 - 1.0)) + 1.0);\nreturn ((0.31830987 * _a22735) / f_pow2(_denom2736));\n}\nfloat3 f_BRDF_GGX(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _f0, const float _f90, const float _roughness)\n{\nfloat _alpha2744 = f_pow2(_roughness);\nfloat3 _halfDir2745 = normalize((_lightDir + _viewDir));\nfloat _dotNL2746 = clamp(dot(_normal, _lightDir), 0.0, 1.0);\nfloat _dotNV2747 = clamp(dot(_normal, _viewDir), 0.0, 1.0);\nfloat _dotNH2748 = clamp(dot(_normal, _halfDir2745), 0.0, 1.0);\nfloat _dotVH2749 = clamp(dot(_viewDir, _halfDir2745), 0.0, 1.0);\nfloat3 _F2750 = f_F_Schlick(_f0, _f90, _dotVH2749);\nfloat _V2751 = f_V_GGX_SmithCorrelated(_alpha2744, _dotNL2746, _dotNV2747);\nfloat _D2752 = f_D_GGX(_alpha2744, _dotNH2748);\nreturn (_F2750 * (_V2751 * _D2752));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2811 = _normal.x;\nfloat _y2812 = _normal.y;\nfloat _z2813 = _normal.z;\nfloat3 _result2814 = (_shCoefficients[0] * 0.88622701);\n(_result2814 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2812));\n(_result2814 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2813));\n(_result2814 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2811));\n(_result2814 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2811) * _y2812));\n(_result2814 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2812) * _z2813));\n(_result2814 += (_shCoefficients[6] * (((0.74312502 * _z2813) * _z2813) - 0.24770799)));\n(_result2814 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2811) * _z2813));\n(_result2814 += ((_shCoefficients[8] * 0.42904299) * ((_x2811 * _x2811) - (_y2812 * _y2812))));\nreturn _result2814;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2818 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2819 = f_shGetIrradianceAt(_worldNormal2818, _lightProbe);\nreturn _irradiance2819;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2822 = _ambientLightColor;\nreturn _irradiance2822;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2844 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2845 = ((0.5 * _dotNL2844) + 0.5);\nfloat3 _irradiance2846 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2845);\nreturn _irradiance2846;\n}\n;\nfloat2 f_DFGApprox(const float3 _normal, const float3 _viewDir, const float _roughness)\n{\nfloat _dotNV2864 = clamp(dot(_normal, _viewDir), 0.0, 1.0);\nfloat4 _r2867 = ((_roughness * float4(-1.0, -0.0275, -0.57200003, 0.022)) + float4(1.0, 0.0425, 1.04, -0.039999999));\nfloat _a0042868 = ((min((_r2867.x * _r2867.x), exp2((-9.2799997 * _dotNV2864))) * _r2867.x) + _r2867.y);\nfloat2 _fab2869 = ((float2(-1.04, 1.04) * _a0042868) + _r2867.zw);\nreturn _fab2869;\n}\nvoid f_computeMultiscattering(const float3 _normal, const float3 _viewDir, const float3 _specularColor, const float _specularF90, const float _roughness, inout float3 _singleScatter, inout float3 _multiScatter)\n{\nfloat2 _fab2885 = f_DFGApprox(_normal, _viewDir, _roughness);\nfloat3 _Fr2886 = _specularColor;\nfloat3 _FssEss2887 = ((_Fr2886 * _fab2885.x) + (_specularF90 * _fab2885.y));\nfloat _Ess2888 = (_fab2885.x + _fab2885.y);\nfloat _Ems2889 = (1.0 - _Ess2888);\nfloat3 _Favg2890 = (_Fr2886 + ((1.0 - _Fr2886) * 0.047619));\nfloat3 _Fms2891 = ((_FssEss2887 * _Favg2890) / (1.0 - (_Ems2889 * _Favg2890)));\n(_singleScatter += _FssEss2887);\n(_multiScatter += (_Fms2891 * _Ems2889));\n}\nvoid f_RE_Direct_Physical__IncidentLight__GeometricContext__PhysicalMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2897 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2898 = (_dotNL2897 * _directLight._color);\n(_reflectedLight._directSpecular += (_irradiance2898 * f_BRDF_GGX(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularF90, _material._roughness)));\n(_reflectedLight._directDiffuse += (_irradiance2898 * f_BRDF_Lambert(_material._diffuseColor)));\n}\nvoid f_RE_IndirectDiffuse_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\nvoid f_RE_IndirectSpecular_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(const float3 _radiance, const float3 _irradiance, const float3 _clearcoatRadiance, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat3 _singleScattering2911 = {0.0, 0.0, 0.0};\nfloat3 _multiScattering2912 = {0.0, 0.0, 0.0};\nfloat3 _cosineWeightedIrradiance2913 = (_irradiance * 0.31830987);\nf_computeMultiscattering(_geometry._normal, _geometry._viewDir, _material._specularColor, _material._specularF90, _material._roughness, _singleScattering2911, _multiScattering2912);\nfloat3 _totalScattering2914 = (_singleScattering2911 + _multiScattering2912);\nfloat3 _diffuse2915 = (_material._diffuseColor * (1.0 - max(max(_totalScattering2914.x, _totalScattering2914.y), _totalScattering2914.z)));\n(_reflectedLight._indirectSpecular += (_radiance * _singleScattering2911));\n(_reflectedLight._indirectSpecular += (_multiScattering2912 * _cosineWeightedIrradiance2913));\n(_reflectedLight._indirectDiffuse += (_diffuse2915 * _cosineWeightedIrradiance2913));\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2992 = floor(_vUv);\nfloat2 _fuv2993 = frac(_vUv);\nfloat _g0x2994 = f_g0(_fuv2993.x);\nfloat _g1x2995 = f_g1(_fuv2993.x);\nfloat _h0x2996 = f_h0(_fuv2993.x);\nfloat _h1x2997 = f_h1(_fuv2993.x);\nfloat _h0y2998 = f_h0(_fuv2993.y);\nfloat _h1y2999 = f_h1(_fuv2993.y);\nfloat2 _p03000 = ((vec2_ctor((_iuv2992.x + _h0x2996), (_iuv2992.y + _h0y2998)) - 0.5) * _texelSize.xy);\nfloat2 _p13001 = ((vec2_ctor((_iuv2992.x + _h1x2997), (_iuv2992.y + _h0y2998)) - 0.5) * _texelSize.xy);\nfloat2 _p23002 = ((vec2_ctor((_iuv2992.x + _h0x2996), (_iuv2992.y + _h1y2999)) - 0.5) * _texelSize.xy);\nfloat2 _p33003 = ((vec2_ctor((_iuv2992.x + _h1x2997), (_iuv2992.y + _h1y2999)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2993.y) * ((_g0x2994 * gl_texture2DLod(_tex, _p03000, _lod)) + (_g1x2995 * gl_texture2DLod(_tex, _p13001, _lod)))) + (f_g1(_fuv2993.y) * ((_g0x2994 * gl_texture2DLod(_tex, _p23002, _lod)) + (_g1x2995 * gl_texture2DLod(_tex, _p33003, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize3008 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize3009 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv3010 = (1.0 / _fLodSize3008);\nfloat2 _cLodSizeInv3011 = (1.0 / _cLodSize3009);\nfloat4 _fSample3012 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv3010, _fLodSize3008), floor(_lod));\nfloat4 _cSample3013 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv3011, _cLodSize3009), ceil(_lod));\nreturn lerp(_fSample3012, _cSample3013, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector3041 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale3042 = {0, 0, 0};\n(_modelScale3042.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale3042.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale3042.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector3041) * _thickness) * _modelScale3042);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist3061 = length((_vPosition - _origin));\nreturn ((_dist3061 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3078 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3079 = ((clamp(_fresnel3078, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3079 / clamp((_lalpha3079 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3079, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3079) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3089 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3089).xyz;\n}\nfloat3 f_gb60bf13d71894171a2af79dd1d344da3_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3101 = _colors[0];\nfloat _depth3102 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3103 = {0};\n{ for(int _i3104 = {1}; (_i3104 < 4); (_i3104++))\n{\n(_p3103 = clamp(((_depth3102 - _steps[(_i3104 - 1)]) / (_steps[_i3104] - _steps[(_i3104 - 1)])), 0.0, 1.0));\n(_color3101 = lerp(_color3101, _colors[_i3104], _p3103));\n}\n}\nfloat _lalpha3105 = ((_alpha * _color3101.w) * _mask);\n(_calpha = lerp((_lalpha3105 / clamp((_lalpha3105 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3105, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3105) * (1.0 - float_ctor(_isMask))));\nreturn _color3101.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3120 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3121 = (_position + _transmissionRay3120);\nfloat4 _ndcPos3122 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3121, 1.0));\nfloat2 _refractionCoords3123 = (_ndcPos3122.xy / _ndcPos3122.w);\n(_refractionCoords3123 += 1.0);\n(_refractionCoords3123 /= 2.0);\nfloat4 _ndcPosUnrefracted3124 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3125 = (_ndcPosUnrefracted3124.xy / _ndcPosUnrefracted3124.w);\n(_unrefractedCoords3125 += 1.0);\n(_unrefractedCoords3125 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3123, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3125, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3138 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3138 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3138 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3139 = f_getIBLVolumeRefraction(_vWNormal, (-_v3138), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3140 = (_alpha * _mask);\n(_calpha = (_lalpha3140 / clamp((_lalpha3140 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3139;\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat _g5bfaadd2eca34fa3b71f09ed96a7f085_calpha3142 = {0};\nfloat _gb60bf13d71894171a2af79dd1d344da3_calpha3143 = {0};\nfloat _gee38695320d24f1c8e9eb0283839cba8_calpha3144 = {0};\nfloat _g354ff6fd46474004b7bb3125dc58a54f_calpha3145 = {0};\nfloat3 _normal3147 = normalize(_vNormal);\nfloat3 _geometryNormal3148 = _normal3147;\nfloat3 _viewdx3149 = ddx(_vViewPosition);\nfloat3 _viewdy3150 = ddy(_vViewPosition);\nfloat3 _faceNormal3151 = normalize(cross(_viewdx3149, _viewdy3150));\nif ((dot(_normal3147, _faceNormal3151) < 0.0))\n{\n(_normal3147 *= -1.0);\n}\n_PhysicalMaterial _material3152 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_material3152._diffuseColor = float3(1.0, 1.0, 1.0));\nfloat3 _diffuseColor3153 = f_spe_blend_int(f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3147, 1.0, _nodeU7, _g5bfaadd2eca34fa3b71f09ed96a7f085_calpha3142), f_gb60bf13d71894171a2af79dd1d344da3_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _gb60bf13d71894171a2af79dd1d344da3_calpha3143), _gb60bf13d71894171a2af79dd1d344da3_calpha3143, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _gee38695320d24f1c8e9eb0283839cba8_calpha3144), _gee38695320d24f1c8e9eb0283839cba8_calpha3144, _nodeU22), f_fresnel_int(_nodeU23, _nodeU24, _nodeU25, _nodeU26, _nodeU27, _nodeU28, 1.0, _nodeU29, _nodeU30, _g354ff6fd46474004b7bb3125dc58a54f_calpha3145), _g354ff6fd46474004b7bb3125dc58a54f_calpha3145, _nodeU30);\n_ReflectedLight _reflectedLight3154 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat _metalnessFactor3155 = _nodeU32;\nfloat _roughnessFactor3156 = _nodeU31;\nfloat3 _dxy3157 = max(abs(ddx(_geometryNormal3148)), abs(ddy(_geometryNormal3148)));\nfloat _geometryRoughness3158 = max(max(_dxy3157.x, _dxy3157.y), _dxy3157.z);\n(_material3152._diffuseColor = (_diffuseColor3153 * (1.0 - _metalnessFactor3155)));\n(_material3152._roughness = max(_roughnessFactor3156, 0.052499998));\n(_material3152._roughness += _geometryRoughness3158);\n(_material3152._roughness = min(_material3152._roughness, 1.0));\n(_material3152._roughness = clamp(_roughnessFactor3156, 0.039999999, 1.0));\n(_material3152._specularColor = lerp(vec3_ctor((0.16 * f_pow2(_nodeU37))), _diffuseColor3153, _metalnessFactor3155));\n_GeometricContext _geometry3159 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry3159._position = (-_vViewPosition));\n(_geometry3159._normal = _normal3147);\nfloat3 sc61 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sc61 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sc61 = normalize(_vViewPosition));\n}\n(_geometry3159._viewDir = sc61);\n_IncidentLight _directLight3160 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight3161 = {0, 0, 0, 0, 0, 0};\n(_directionalLight3161 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight3161, _geometry3159, _directLight3160);\nf_RE_Direct_Physical__IncidentLight__GeometricContext__PhysicalMaterial__ReflectedLight(_directLight3160, _geometry3159, _material3152, _reflectedLight3154);\nfloat3 _iblIrradiance3162 = {0.0, 0.0, 0.0};\nfloat3 _irradiance3163 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance3163 += f_getLightProbeIrradiance(_lightProbe, _geometry3159._normal));\n(_irradiance3163 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry3159._normal));\nfloat3 _radiance3164 = {0.0, 0.0, 0.0};\nfloat3 _clearcoatRadiance3165 = {0.0, 0.0, 0.0};\nf_RE_IndirectDiffuse_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(_irradiance3163, _geometry3159, _material3152, _reflectedLight3154);\nf_RE_IndirectSpecular_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(_radiance3164, _iblIrradiance3162, _clearcoatRadiance3165, _geometry3159, _material3152, _reflectedLight3154);\nfloat3 sc62 = {0, 0, 0};\nif ((_aoEnabled && _nodeU33))\n{\n(sc62 = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc62 = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3166 = sc62;\nfloat3 _outgoingLight3167 = (((_reflectedLight3154._directDiffuse + _reflectedLight3154._indirectDiffuse) + _reflectedLight3154._directSpecular) + _reflectedLight3154._indirectSpecular);\nif (!all(_outgoingLight3167 == _diffuseColor3153))\n{\nfloat _lightAccu3168 = clamp(length((_reflectedLight3154._directSpecular + _reflectedLight3154._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU34) * 1.0) * _lightAccu3168));\n(_outgoingLight3167 = f_spe_blend_int(_diffuseColor3153, _outgoingLight3167, (_nodeU34 * 1.0), _nodeU35));\n(_outgoingLight3167 *= _ao3166);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3167, (_accumAlpha * _nodeU36)));\n(out_pc_fragColor.w *= _nodeU38);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD6;\n    float4 gl_FragCoord : TEXCOORD7;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n    float pad_26;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n    float pad_27;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0)\n{\n    return float3(x0, x0, x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform bool _aoEnabled : register(c7);\nuniform float3 _ambientLightColor : register(c8);\nuniform float3 _lightProbe[9] : register(c9);\nuniform _DirectionalLight _directionalLights[1] : register(c18);\nuniform _HemisphereLight _hemisphereLights[1] : register(c20);\nuniform float4x4 _modelMatrix : register(c23);\nuniform float4x4 _projectionMatrix : register(c27);\nuniform float _nodeU0 : register(c31);\nuniform float _nodeU1 : register(c32);\nuniform float _nodeU2 : register(c33);\nuniform float2 _nodeU3 : register(c34);\nuniform float2 _nodeU6 : register(c35);\nuniform float _nodeU7 : register(c36);\nuniform float _nodeU8 : register(c37);\nuniform float _nodeU9 : register(c38);\nuniform float3 _nodeU10 : register(c39);\nuniform float3 _nodeU11 : register(c40);\nuniform bool _nodeU12 : register(c41);\nuniform float _nodeU13 : register(c42);\nuniform int _nodeU14 : register(c43);\nuniform float3 _nodeU15 : register(c44);\nuniform float _nodeU16 : register(c45);\nuniform float _nodeU17 : register(c46);\nuniform float _nodeU18 : register(c47);\nuniform float _nodeU19 : register(c48);\nuniform bool _nodeU20 : register(c49);\nuniform float _nodeU21 : register(c50);\nuniform int _nodeU22 : register(c51);\nuniform float3 _nodeU23 : register(c52);\nuniform float _nodeU24 : register(c53);\nuniform float _nodeU25 : register(c54);\nuniform float _nodeU26 : register(c55);\nuniform float _nodeU27 : register(c56);\nuniform bool _nodeU28 : register(c57);\nuniform float _nodeU29 : register(c58);\nuniform int _nodeU30 : register(c59);\nuniform float _nodeU31 : register(c60);\nuniform float _nodeU32 : register(c61);\nuniform bool _nodeU33 : register(c62);\nuniform float _nodeU34 : register(c63);\nuniform int _nodeU35 : register(c64);\nuniform float _nodeU36 : register(c65);\nuniform float _nodeU37 : register(c66);\nuniform float _nodeU38 : register(c67);\nuniform float4 _nodeUA0[4] : register(c68);\nuniform float _nodeUA1[4] : register(c72);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_pow2(const float _x)\n{\nreturn (_x * _x);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nstatic float _accumAlpha = {0.0};\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2704 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2705 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2705 = lerp((2.0 * _dither_shift_RGB2705), (-2.0 * _dither_shift_RGB2705), _grid_position2704));\nreturn (_color + _dither_shift_RGB2705);\n}\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2712 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2712)) + (_f90 * _fresnel2712));\n}\nfloat f_V_GGX_SmithCorrelated(const float _alpha, const float _dotNL, const float _dotNV)\n{\nfloat _a22729 = f_pow2(_alpha);\nfloat _gv2730 = (_dotNL * sqrt((_a22729 + ((1.0 - _a22729) * f_pow2(_dotNV)))));\nfloat _gl2731 = (_dotNV * sqrt((_a22729 + ((1.0 - _a22729) * f_pow2(_dotNL)))));\nreturn (0.5 / max((_gv2730 + _gl2731), 1e-06));\n}\nfloat f_D_GGX(const float _alpha, const float _dotNH)\n{\nfloat _a22735 = f_pow2(_alpha);\nfloat _denom2736 = ((f_pow2(_dotNH) * (_a22735 - 1.0)) + 1.0);\nreturn ((0.31830987 * _a22735) / f_pow2(_denom2736));\n}\nfloat3 f_BRDF_GGX(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _f0, const float _f90, const float _roughness)\n{\nfloat _alpha2744 = f_pow2(_roughness);\nfloat3 _halfDir2745 = normalize((_lightDir + _viewDir));\nfloat _dotNL2746 = clamp(dot(_normal, _lightDir), 0.0, 1.0);\nfloat _dotNV2747 = clamp(dot(_normal, _viewDir), 0.0, 1.0);\nfloat _dotNH2748 = clamp(dot(_normal, _halfDir2745), 0.0, 1.0);\nfloat _dotVH2749 = clamp(dot(_viewDir, _halfDir2745), 0.0, 1.0);\nfloat3 _F2750 = f_F_Schlick(_f0, _f90, _dotVH2749);\nfloat _V2751 = f_V_GGX_SmithCorrelated(_alpha2744, _dotNL2746, _dotNV2747);\nfloat _D2752 = f_D_GGX(_alpha2744, _dotNH2748);\nreturn (_F2750 * (_V2751 * _D2752));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2811 = _normal.x;\nfloat _y2812 = _normal.y;\nfloat _z2813 = _normal.z;\nfloat3 _result2814 = (_shCoefficients[0] * 0.88622701);\n(_result2814 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2812));\n(_result2814 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2813));\n(_result2814 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2811));\n(_result2814 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2811) * _y2812));\n(_result2814 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2812) * _z2813));\n(_result2814 += (_shCoefficients[6] * (((0.74312502 * _z2813) * _z2813) - 0.24770799)));\n(_result2814 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2811) * _z2813));\n(_result2814 += ((_shCoefficients[8] * 0.42904299) * ((_x2811 * _x2811) - (_y2812 * _y2812))));\nreturn _result2814;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2818 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2819 = f_shGetIrradianceAt(_worldNormal2818, _lightProbe);\nreturn _irradiance2819;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2822 = _ambientLightColor;\nreturn _irradiance2822;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2844 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2845 = ((0.5 * _dotNL2844) + 0.5);\nfloat3 _irradiance2846 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2845);\nreturn _irradiance2846;\n}\n;\nfloat2 f_DFGApprox(const float3 _normal, const float3 _viewDir, const float _roughness)\n{\nfloat _dotNV2864 = clamp(dot(_normal, _viewDir), 0.0, 1.0);\nfloat4 _r2867 = ((_roughness * float4(-1.0, -0.0275, -0.57200003, 0.022)) + float4(1.0, 0.0425, 1.04, -0.039999999));\nfloat _a0042868 = ((min((_r2867.x * _r2867.x), exp2((-9.2799997 * _dotNV2864))) * _r2867.x) + _r2867.y);\nfloat2 _fab2869 = ((float2(-1.04, 1.04) * _a0042868) + _r2867.zw);\nreturn _fab2869;\n}\nvoid f_computeMultiscattering(const float3 _normal, const float3 _viewDir, const float3 _specularColor, const float _specularF90, const float _roughness, inout float3 _singleScatter, inout float3 _multiScatter)\n{\nfloat2 _fab2885 = f_DFGApprox(_normal, _viewDir, _roughness);\nfloat3 _Fr2886 = _specularColor;\nfloat3 _FssEss2887 = ((_Fr2886 * _fab2885.x) + (_specularF90 * _fab2885.y));\nfloat _Ess2888 = (_fab2885.x + _fab2885.y);\nfloat _Ems2889 = (1.0 - _Ess2888);\nfloat3 _Favg2890 = (_Fr2886 + ((1.0 - _Fr2886) * 0.047619));\nfloat3 _Fms2891 = ((_FssEss2887 * _Favg2890) / (1.0 - (_Ems2889 * _Favg2890)));\n(_singleScatter += _FssEss2887);\n(_multiScatter += (_Fms2891 * _Ems2889));\n}\nvoid f_RE_Direct_Physical__IncidentLight__GeometricContext__PhysicalMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2897 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2898 = (_dotNL2897 * _directLight._color);\n(_reflectedLight._directSpecular += (_irradiance2898 * f_BRDF_GGX(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularF90, _material._roughness)));\n(_reflectedLight._directDiffuse += (_irradiance2898 * f_BRDF_Lambert(_material._diffuseColor)));\n}\nvoid f_RE_IndirectDiffuse_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\nvoid f_RE_IndirectSpecular_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(const float3 _radiance, const float3 _irradiance, const float3 _clearcoatRadiance, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat3 _singleScattering2911 = {0.0, 0.0, 0.0};\nfloat3 _multiScattering2912 = {0.0, 0.0, 0.0};\nfloat3 _cosineWeightedIrradiance2913 = (_irradiance * 0.31830987);\nf_computeMultiscattering(_geometry._normal, _geometry._viewDir, _material._specularColor, _material._specularF90, _material._roughness, _singleScattering2911, _multiScattering2912);\nfloat3 _totalScattering2914 = (_singleScattering2911 + _multiScattering2912);\nfloat3 _diffuse2915 = (_material._diffuseColor * (1.0 - max(max(_totalScattering2914.x, _totalScattering2914.y), _totalScattering2914.z)));\n(_reflectedLight._indirectSpecular += (_radiance * _singleScattering2911));\n(_reflectedLight._indirectSpecular += (_multiScattering2912 * _cosineWeightedIrradiance2913));\n(_reflectedLight._indirectDiffuse += (_diffuse2915 * _cosineWeightedIrradiance2913));\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2992 = floor(_vUv);\nfloat2 _fuv2993 = frac(_vUv);\nfloat _g0x2994 = f_g0(_fuv2993.x);\nfloat _g1x2995 = f_g1(_fuv2993.x);\nfloat _h0x2996 = f_h0(_fuv2993.x);\nfloat _h1x2997 = f_h1(_fuv2993.x);\nfloat _h0y2998 = f_h0(_fuv2993.y);\nfloat _h1y2999 = f_h1(_fuv2993.y);\nfloat2 _p03000 = ((vec2_ctor((_iuv2992.x + _h0x2996), (_iuv2992.y + _h0y2998)) - 0.5) * _texelSize.xy);\nfloat2 _p13001 = ((vec2_ctor((_iuv2992.x + _h1x2997), (_iuv2992.y + _h0y2998)) - 0.5) * _texelSize.xy);\nfloat2 _p23002 = ((vec2_ctor((_iuv2992.x + _h0x2996), (_iuv2992.y + _h1y2999)) - 0.5) * _texelSize.xy);\nfloat2 _p33003 = ((vec2_ctor((_iuv2992.x + _h1x2997), (_iuv2992.y + _h1y2999)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2993.y) * ((_g0x2994 * gl_texture2DLod(_tex, _p03000, _lod)) + (_g1x2995 * gl_texture2DLod(_tex, _p13001, _lod)))) + (f_g1(_fuv2993.y) * ((_g0x2994 * gl_texture2DLod(_tex, _p23002, _lod)) + (_g1x2995 * gl_texture2DLod(_tex, _p33003, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize3008 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize3009 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv3010 = (1.0 / _fLodSize3008);\nfloat2 _cLodSizeInv3011 = (1.0 / _cLodSize3009);\nfloat4 _fSample3012 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv3010, _fLodSize3008), floor(_lod));\nfloat4 _cSample3013 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv3011, _cLodSize3009), ceil(_lod));\nreturn lerp(_fSample3012, _cSample3013, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector3041 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale3042 = {0, 0, 0};\n(_modelScale3042.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale3042.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale3042.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector3041) * _thickness) * _modelScale3042);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist3061 = length((_vPosition - _origin));\nreturn ((_dist3061 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3078 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3079 = ((clamp(_fresnel3078, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3079 / clamp((_lalpha3079 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3079, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3079) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3089 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3089).xyz;\n}\nfloat3 f_gb60bf13d71894171a2af79dd1d344da3_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3101 = _colors[0];\nfloat _depth3102 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3103 = {0};\n{ for(int _i3104 = {1}; (_i3104 < 4); (_i3104++))\n{\n(_p3103 = clamp(((_depth3102 - _steps[(_i3104 - 1)]) / (_steps[_i3104] - _steps[(_i3104 - 1)])), 0.0, 1.0));\n(_color3101 = lerp(_color3101, _colors[_i3104], _p3103));\n}\n}\nfloat _lalpha3105 = ((_alpha * _color3101.w) * _mask);\n(_calpha = lerp((_lalpha3105 / clamp((_lalpha3105 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3105, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3105) * (1.0 - float_ctor(_isMask))));\nreturn _color3101.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3120 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3121 = (_position + _transmissionRay3120);\nfloat4 _ndcPos3122 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3121, 1.0));\nfloat2 _refractionCoords3123 = (_ndcPos3122.xy / _ndcPos3122.w);\n(_refractionCoords3123 += 1.0);\n(_refractionCoords3123 /= 2.0);\nfloat4 _ndcPosUnrefracted3124 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3125 = (_ndcPosUnrefracted3124.xy / _ndcPosUnrefracted3124.w);\n(_unrefractedCoords3125 += 1.0);\n(_unrefractedCoords3125 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3123, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3125, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3138 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3138 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3138 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3139 = f_getIBLVolumeRefraction(_vWNormal, (-_v3138), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3140 = (_alpha * _mask);\n(_calpha = (_lalpha3140 / clamp((_lalpha3140 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3139;\n}\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input){\n    float rhw = 1.0 / input.gl_FragCoord.w;\n    gl_FragCoord.x = input.dx_Position.x - dx_FragCoordOffset.x;\n    gl_FragCoord.y = input.dx_Position.y - dx_FragCoordOffset.y;\n    gl_FragCoord.z = input.dx_Position.z;\n    gl_FragCoord.w = rhw;\n    _vViewPosition = input.v0.xyz;\n    _vWPosition = input.v1.xyz;\n    _vNormal = input.v2.xyz;\n    _vPosition = input.v3.xyz;\n    _vWNormal = input.v4.xyz;\n    _vWorldViewDir = input.v5.xyz;\n\nfloat _g5bfaadd2eca34fa3b71f09ed96a7f085_calpha3142 = {0};\nfloat _gb60bf13d71894171a2af79dd1d344da3_calpha3143 = {0};\nfloat _gee38695320d24f1c8e9eb0283839cba8_calpha3144 = {0};\nfloat _g354ff6fd46474004b7bb3125dc58a54f_calpha3145 = {0};\nfloat3 _normal3147 = normalize(_vNormal);\nfloat3 _geometryNormal3148 = _normal3147;\nfloat3 _viewdx3149 = ddx(_vViewPosition);\nfloat3 _viewdy3150 = ddy(_vViewPosition);\nfloat3 _faceNormal3151 = normalize(cross(_viewdx3149, _viewdy3150));\nif ((dot(_normal3147, _faceNormal3151) < 0.0))\n{\n(_normal3147 *= -1.0);\n}\n_PhysicalMaterial _material3152 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_material3152._diffuseColor = float3(1.0, 1.0, 1.0));\nfloat3 _diffuseColor3153 = f_spe_blend_int(f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3147, 1.0, _nodeU7, _g5bfaadd2eca34fa3b71f09ed96a7f085_calpha3142), f_gb60bf13d71894171a2af79dd1d344da3_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _gb60bf13d71894171a2af79dd1d344da3_calpha3143), _gb60bf13d71894171a2af79dd1d344da3_calpha3143, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _gee38695320d24f1c8e9eb0283839cba8_calpha3144), _gee38695320d24f1c8e9eb0283839cba8_calpha3144, _nodeU22), f_fresnel_int(_nodeU23, _nodeU24, _nodeU25, _nodeU26, _nodeU27, _nodeU28, 1.0, _nodeU29, _nodeU30, _g354ff6fd46474004b7bb3125dc58a54f_calpha3145), _g354ff6fd46474004b7bb3125dc58a54f_calpha3145, _nodeU30);\n_ReflectedLight _reflectedLight3154 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat _metalnessFactor3155 = _nodeU32;\nfloat _roughnessFactor3156 = _nodeU31;\nfloat3 _dxy3157 = max(abs(ddx(_geometryNormal3148)), abs(ddy(_geometryNormal3148)));\nfloat _geometryRoughness3158 = max(max(_dxy3157.x, _dxy3157.y), _dxy3157.z);\n(_material3152._diffuseColor = (_diffuseColor3153 * (1.0 - _metalnessFactor3155)));\n(_material3152._roughness = max(_roughnessFactor3156, 0.052499998));\n(_material3152._roughness += _geometryRoughness3158);\n(_material3152._roughness = min(_material3152._roughness, 1.0));\n(_material3152._roughness = clamp(_roughnessFactor3156, 0.039999999, 1.0));\n(_material3152._specularColor = lerp(vec3_ctor((0.16 * f_pow2(_nodeU37))), _diffuseColor3153, _metalnessFactor3155));\n_GeometricContext _geometry3159 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry3159._position = (-_vViewPosition));\n(_geometry3159._normal = _normal3147);\nfloat3 sc61 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sc61 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sc61 = normalize(_vViewPosition));\n}\n(_geometry3159._viewDir = sc61);\n_IncidentLight _directLight3160 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight3161 = {0, 0, 0, 0, 0, 0};\n(_directionalLight3161 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight3161, _geometry3159, _directLight3160);\nf_RE_Direct_Physical__IncidentLight__GeometricContext__PhysicalMaterial__ReflectedLight(_directLight3160, _geometry3159, _material3152, _reflectedLight3154);\nfloat3 _iblIrradiance3162 = {0.0, 0.0, 0.0};\nfloat3 _irradiance3163 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance3163 += f_getLightProbeIrradiance(_lightProbe, _geometry3159._normal));\n(_irradiance3163 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry3159._normal));\nfloat3 _radiance3164 = {0.0, 0.0, 0.0};\nfloat3 _clearcoatRadiance3165 = {0.0, 0.0, 0.0};\nf_RE_IndirectDiffuse_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(_irradiance3163, _geometry3159, _material3152, _reflectedLight3154);\nf_RE_IndirectSpecular_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(_radiance3164, _iblIrradiance3162, _clearcoatRadiance3165, _geometry3159, _material3152, _reflectedLight3154);\nfloat3 sc62 = {0, 0, 0};\nif ((_aoEnabled && _nodeU33))\n{\n(sc62 = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc62 = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3166 = sc62;\nfloat3 _outgoingLight3167 = (((_reflectedLight3154._directDiffuse + _reflectedLight3154._indirectDiffuse) + _reflectedLight3154._directSpecular) + _reflectedLight3154._indirectSpecular);\nif (!all(_outgoingLight3167 == _diffuseColor3153))\n{\nfloat _lightAccu3168 = clamp(length((_reflectedLight3154._directSpecular + _reflectedLight3154._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU34) * 1.0) * _lightAccu3168));\n(_outgoingLight3167 = f_spe_blend_int(_diffuseColor3153, _outgoingLight3167, (_nodeU34 * 1.0), _nodeU35));\n(_outgoingLight3167 *= _ao3166);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3167, (_accumAlpha * _nodeU36)));\n(out_pc_fragColor.w *= _nodeU38);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                                }
                            ]
                        },
                        "__SPECTOR_Object_TAG": {
                            "displayText": "WebGLProgram - ID: 4",
                            "id": 4,
                            "typeName": "WebGLProgram"
                        }
                    }
                },
                "shaders": [
                    {
                        "COMPILE_STATUS": true,
                        "name": "NodeMaterial",
                        "shaderType": "VERTEX_SHADER",
                        "source": "#version 300 es\nprecision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define STANDARD 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS 4\n#define gb60bf13d71894171a2af79dd1d344da3_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define VERTEX_TEXTURES\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tattribute vec3 instanceColor;\n#endif\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_TANGENT\n\tattribute vec4 tangent;\n#endif\n#if defined( USE_COLOR_ALPHA )\n\tattribute vec4 color;\n#elif defined( USE_COLOR )\n\tattribute vec3 color;\n#endif\n#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat neighbor_offset = 0.0001;\n\nuniform int frameIndex;\nuniform vec2 resolution;\nuniform mat4 previousModelViewMatrix;\nuniform mat4 previousProjectionMatrix;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\n#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#if 0 > 0\n  uniform mat4 spotLightMatrix[ 0 ];\n  varying vec4 vSpotLightCoord[ 0 ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if 0 > 0\n\t\tuniform mat4 directionalShadowMatrix[ 0 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 0 ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform mat4 pointShadowMatrix[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ 0 ];\n\t#endif\n#endif\n#if 0 > 0\n\tvarying vec3 vClipPosition;\n#endif\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\n\n\n\n\n\nvoid main() {\n\n\nvec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif\n\n\t\t\t\t#if !defined( USE_LAYER_DISPLACE )\nvec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec3 displaced_position = position;\n\t\t\t\tvec3 displaced_normal = normal;\n\n\t\t\t\t#if defined( USE_LAYER_DISPLACE )\n\t\t\t\t\tvec3 transformed;\n\t\t\t\t\tvec3 transformedNormal;\n\t\t\t\t#endif\n\t\t\t\t\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\n\t\t\t\t#if !defined( USE_LAYER_DISPLACE )\nvec3 transformed = vec3( position );\n\t\t\t\t#endif /* !USE_LAYER_DISPLACE */\n\t\t\t\t\ntransformed = displaced_position;\ntransformedNormal = normalMatrix * displaced_normal;\n#ifndef FLAT_SHADED\n    vNormal = transformedNormal;\n#endif\nvec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif\n#if 0 > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif\n\tvViewPosition = - mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || 0 > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif\n#if ( defined( USE_SHADOWMAP ) && ( 0 > 0 || 0 > 0 ) ) || ( 0 > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if 0 > 0\n\t\t\n\t#endif\n\t#if 0 > 0\n\t\t\n\t#endif\n#endif\n#if 0 > 0\n\t\n#endif\nvWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;\nvUv = uv;\nvPosition = transformed;\nvWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;\nvWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );\n\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\n@@ VERTEX ATTRIBUTES @@\n\n@@ VERTEX OUTPUT @@\n\nVS_OUTPUT main(VS_INPUT input){\n@@ MAIN PROLOGUE @@\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2691 = vec3_ctor(_normal);\nfloat3 _transformedNormal2692 = _objectNormal2691;\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _transformedNormal2692));\nfloat3 _displaced_position2693 = _position;\nfloat3 _displaced_normal2694 = _normal;\n(_vNormal = normalize(_transformedNormal2692));\nfloat3 _transformed2695 = vec3_ctor(_position);\n(_transformed2695 = _displaced_position2693);\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _displaced_normal2694));\n(_vNormal = _transformedNormal2692);\nfloat4 _mvPosition2696 = vec4_ctor(_transformed2695, 1.0);\n(_mvPosition2696 = mul(transpose(_modelViewMatrix), _mvPosition2696));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2696));\n(_vViewPosition = (-_mvPosition2696.xyz));\nfloat4 _worldPosition2697 = vec4_ctor(_transformed2695, 1.0);\n(_worldPosition2697 = mul(transpose(_modelMatrix), _worldPosition2697));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2695, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2695);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2692, _viewMatrix).xyz);\nfloat3 sa8a = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sa8a = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sa8a = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sa8a);\nreturn generateOutput(input);\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct VS_OUTPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD6;\n    float4 gl_FragCoord : TEXCOORD7;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n};\n#pragma warning( disable: 3556 3571 )\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\n// Uniforms\n\nuniform float4x4 _modelMatrix : register(c0);\nuniform float4x4 _modelViewMatrix : register(c4);\nuniform float4x4 _projectionMatrix : register(c8);\nuniform float4x4 _viewMatrix : register(c12);\nuniform float3x3 _normalMatrix : register(c16);\nuniform float3 _cameraPosition : register(c19);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Attributes\nstatic float3 _position = {0, 0, 0};\nstatic float3 _normal = {0, 0, 0};\nstatic float2 _uv = {0, 0};\n\nstatic float4 gl_Position = float4(0, 0, 0, 0);\n\n// Varyings\nstatic  float4 _vCurrentPosition = {0, 0, 0, 0};\nstatic  float4 _vPreviousPosition = {0, 0, 0, 0};\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float2 _vUv = {0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewAdjust : packoffset(c1);\n    float2 dx_ViewCoords : packoffset(c2);\n    float2 dx_ViewScale  : packoffset(c3);\n    float clipControlOrigin : packoffset(c3.z);\n    float clipControlZeroToOne : packoffset(c3.w);\n};\n\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nbool f_isPerspectiveMatrix(in float4x4 _m)\n{\nreturn (_m[2][3] == -1.0);\n}\nstruct VS_INPUT\n{\n    float3 _position : TEXCOORD0;\n    float3 _normal : TEXCOORD1;\n    float2 _uv : TEXCOORD2;\n};\n\nvoid initAttributes(VS_INPUT input)\n{\n    _position = input._position;\n    _normal = input._normal;\n    _uv = input._uv;\n}\n\n\nVS_OUTPUT generateOutput(VS_INPUT input)\n{\n    VS_OUTPUT output;\n    output.gl_Position = gl_Position;\n    output.dx_Position.x = gl_Position.x;\n    output.dx_Position.y = clipControlOrigin * gl_Position.y;\n    if (clipControlZeroToOne)\n    {\n        output.dx_Position.z = gl_Position.z;\n    } else {\n        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n    }\n    output.dx_Position.w = gl_Position.w;\n    output.gl_FragCoord = gl_Position;\n    output.v0 = _vViewPosition;\n    output.v1 = _vWPosition;\n    output.v2 = _vNormal;\n    output.v3 = _vPosition;\n    output.v4 = _vWNormal;\n    output.v5 = _vWorldViewDir;\n\n    return output;\n}\n\nVS_OUTPUT main(VS_INPUT input){\n    initAttributes(input);\n\n(gl_Position = float4(0.0, 0.0, 0.0, 0.0));\nfloat3 _objectNormal2691 = vec3_ctor(_normal);\nfloat3 _transformedNormal2692 = _objectNormal2691;\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _transformedNormal2692));\nfloat3 _displaced_position2693 = _position;\nfloat3 _displaced_normal2694 = _normal;\n(_vNormal = normalize(_transformedNormal2692));\nfloat3 _transformed2695 = vec3_ctor(_position);\n(_transformed2695 = _displaced_position2693);\n(_transformedNormal2692 = mul(transpose(_normalMatrix), _displaced_normal2694));\n(_vNormal = _transformedNormal2692);\nfloat4 _mvPosition2696 = vec4_ctor(_transformed2695, 1.0);\n(_mvPosition2696 = mul(transpose(_modelViewMatrix), _mvPosition2696));\n(gl_Position = mul(transpose(_projectionMatrix), _mvPosition2696));\n(_vViewPosition = (-_mvPosition2696.xyz));\nfloat4 _worldPosition2697 = vec4_ctor(_transformed2695, 1.0);\n(_worldPosition2697 = mul(transpose(_modelMatrix), _worldPosition2697));\n(_vWPosition = mul(transpose(_modelMatrix), vec4_ctor(_transformed2695, 1.0)).xyz);\n(_vUv = _uv);\n(_vPosition = _transformed2695);\n(_vWNormal = f_inverseTransformDirection(_transformedNormal2692, _viewMatrix).xyz);\nfloat3 sa8a = {0, 0, 0};\nif (f_isPerspectiveMatrix(_projectionMatrix))\n{\n(sa8a = (mul(transpose(_modelMatrix), vec4_ctor(_position, 1.0)).xyz - _cameraPosition));\n}\nelse\n{\n(sa8a = vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2])));\n}\n(_vWorldViewDir = sa8a);\nreturn generateOutput(input);\n}\n\n// COMPILER INPUT HLSL END\n\n// VERTEX SHADER END\n\u0000"
                    },
                    {
                        "COMPILE_STATUS": true,
                        "name": "NodeMaterial",
                        "shaderType": "FRAGMENT_SHADER",
                        "source": "#version 300 es\n#define varying in\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\nprecision highp float;\nprecision highp int;\n#define HIGH_PRECISION\n#define SHADER_NAME NodeMaterial\n#define STANDARD 1\n#define NUM_SAMPLES 6\n#define BLUR_SLOD 4\n#define gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS 4\n#define gb60bf13d71894171a2af79dd1d344da3_IS_VECTOR 1\n#define IS_THREEJS_EXPORT true\n#define USE_TRANSMISSION\n#define USE_COLOR\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n#define DITHERING\n#define OPAQUE\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\n\n#ifdef TEXTURE_LOD_EXT\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n#else\n\t#define texCube(a, b) textureCube(a, b)\n\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\t#define tex2D(a, b) texture2D(a, b)\n\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n#endif\n\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nfloat accumAlpha = 0.0;\nvoid accumulateAlpha(float alpha) {\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * alpha;\n\t\t\t\t}\n\nlayout(location = 1) out vec4 gVelocity;\n\nuniform int frameIndex;\nuniform vec2 resolution;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nconst vec2 haltonSequence[16] = vec2[16](\nvec2( 0.000000,-0.333334),\nvec2(-0.500000, 0.333334),\nvec2( 0.500000,-0.777778),\nvec2(-0.750000,-0.111112),\nvec2( 0.250000, 0.555556),\nvec2(-0.250000,-0.555556),\nvec2( 0.750000, 0.111112),\nvec2(-0.875000, 0.777778),\nvec2(0.125000, -0.925926),\nvec2(-0.375000, -0.259260),\nvec2(0.625000, 0.407408),\nvec2(-0.625000, -0.703704),\nvec2(0.375000, -0.037038),\nvec2(-0.125000, 0.629630),\nvec2(0.875000, -0.481482),\nvec2(-0.937500, 0.185186));\n\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n  const float goldenAngle = 2.399963f; // radians\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n  float theta = float(sampleIndex) * goldenAngle + angle;\n  float sine = sin(theta);\n  float cosine = cos(theta);\n  return vec2(cosine, sine) * r;\n}\n\n// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso\nfloat getNoiseInterleavedGradient(vec2 screenPos) {\n    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);\n    return fract(magic.z * fract(dot(screenPos, magic.xy)));\n}\n\n\nvarying vec3 vViewPosition;\nvarying vec3 vWPosition;\nuniform float penumbraSize[5];\nuniform sampler2D aoMap;\nuniform bool aoEnabled;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif\nstruct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if 0 > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = 8;\nconst int gShadowSamples = 8;\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if 0 > 0\n\n        uniform sampler2D directionalShadowMap[ 0 ];\n        varying vec4 vDirectionalShadowCoord[ 0 ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D spotShadowMap[ 0 ];\n        varying vec4 vSpotLightCoord[ 0 ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ 0 ];\n\n    #endif\n\n    #if 0 > 0\n\n        uniform sampler2D pointShadowMap[ 0 ];\n        varying vec4 vPointShadowCoord[ 0 ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ 0 ];\n\n    #endif\n\n    /*\n    #if 0 > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nvarying vec3 vWNormal;\nvarying vec3 vWorldViewDir;\n\n\nuniform float nodeU0;\nuniform float nodeU1;\nuniform float nodeU2;\nuniform vec2 nodeU3;\nuniform sampler2D nodeU4;\nuniform sampler2D nodeU5;\nuniform vec2 nodeU6;\nuniform float nodeU7;\nuniform float nodeU8;\nuniform float nodeU9;\nuniform vec3 nodeU10;\nuniform vec3 nodeU11;\nuniform bool nodeU12;\nuniform float nodeU13;\nuniform int nodeU14;\nuniform vec3 nodeU15;\nuniform float nodeU16;\nuniform float nodeU17;\nuniform float nodeU18;\nuniform float nodeU19;\nuniform bool nodeU20;\nuniform float nodeU21;\nuniform int nodeU22;\nuniform vec3 nodeU23;\nuniform float nodeU24;\nuniform float nodeU25;\nuniform float nodeU26;\nuniform float nodeU27;\nuniform bool nodeU28;\nuniform float nodeU29;\nuniform int nodeU30;\nuniform float nodeU31;\nuniform float nodeU32;\nuniform bool nodeU33;\nuniform float nodeU34;\nuniform int nodeU35;\nuniform float nodeU36;\nuniform float nodeU37;\nuniform float nodeU38;\n\nuniform vec4 nodeUA0[4];\nuniform float nodeUA1[4];\n\n\n\nfloat w0( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n        }\n    \n        float w1( float a ) {\n            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n        }\n    \n        float w2( float a ){\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n        }\n    \n        float w3( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * a * a );\n        }\n    \n        // g0 and g1 are the two amplitude functions\n        float g0( float a ) {\n            return w0( a ) + w1( a );\n        }\n    \n        float g1( float a ) {\n            return w2( a ) + w3( a );\n        }\n    \n        // h0 and h1 are the two offset functions\n        float h0( float a ) {\n            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n        }\n    \n        float h1( float a ) {\n            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n        }\n    \n        vec4 bicubic( sampler2D tex, vec2 vUv, vec4 texelSize, float lod ) {\n            vUv = vUv * texelSize.zw + 0.5;\n    \n            vec2 iuv = floor( vUv );\n            vec2 fuv = fract( vUv );\n    \n            float g0x = g0( fuv.x );\n            float g1x = g1( fuv.x );\n            float h0x = h0( fuv.x );\n            float h1x = h1( fuv.x );\n            float h0y = h0( fuv.y );\n            float h1y = h1( fuv.y );\n    \n            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n    \n            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + \n                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n        }\n\n        vec4 textureBicubic( sampler2D sampler, vec2 vUv, float lod ) {\n            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n            vec2 fLodSizeInv = 1.0 / fLodSize;\n            vec2 cLodSizeInv = 1.0 / cLodSize;\n            vec4 fSample = bicubic( sampler, vUv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n            vec4 cSample = bicubic( sampler, vUv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n            return mix( fSample, cSample, fract( lod ) );\n        }\nfloat applyIorToRoughness( float roughness, float ior ) {\n\t\t\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\t\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t\t\t}\nvec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {\n                // Slightly modified version of this:\n                // https://www.shadertoy.com/view/ltScRG\n\n\t\t\t\t// Special case for blur == 0.0\n\t\t\t\tif (lod == 0.0) {\n\t\t\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\t\treturn texture2DLodEXT( sp, U, 0.0).rgb;\n\t\t\t\t\t#else\n\t\t\t\t\treturn textureLod( sp, U, 0.0).rgb;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec2 texelSize = vec2(1.0) / resolution;\n                vec2 halton = haltonSequence[frameIndex];\n                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n                float temporalAngle  = temporalOffset * PI2;\n\t\t\t\tvec3 res = vec3(0.0);\n                vec2 vUv = vec2(0.0);\n                vec2 offset = vec2(0.0);\n                vec2 vogelSample = vec2(0.0);\n                for (int i = 0; i < NUM_SAMPLES; i++) {\n                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;\n                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20\n                    vUv = U + offset;\n                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, vUv, lod));\n                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {\n                        vUv = unrefractedU;\n                        lod = lod > 4.0 ? lod : lod / 2.0;\n                    }\n                    res += textureLod(sp, vUv, lod).rgb;\n                }\n                return res / float(NUM_SAMPLES);\n            }\nvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\t        // Direction of refracted light.\n\t\t        vec3 refractionVector = refract( -v,  n, 1.0 / ior );\n\t\t        \n\t\t\t\t// Compute rotation-independant scaling of the model matrix.\n\t\t        vec3 modelScale;\n\t\t        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\t        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\t        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t        // The thickness is specified in local space\n\t\t        return normalize( refractionVector ) * thickness * modelScale;\n\t        }\nfloat vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vPosition.x - origin.x) + n.y*(vPosition.y - origin.y) + n.z*(vPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nfloat vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vWPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }\nvec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {\n\t\t\t\t\tfloat fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );\n\n\t\t\t\t\tfloat lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;\n\t\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\t\treturn color;\n\t\t\t\t}\nvec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {\n\t\t\t\t// Threejs exports do not pass a depth map to this shader, so we have to fallback to the \"Threejs method of blurring\" - see\n\t\t\t\t// also the code in convertTransmission.ts, which runs during export\n\t\t\t\t#ifdef IS_THREEJS_EXPORT\n\t\t\t\t\tfloat lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);\n\t\t\t\t\treturn textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;\n\t\t\t\t#else\n\t\t\t\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t\t\t\tfloat lod = applyIorToRoughness(roughness, ior);\n\t\t\t\t\treturn blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);\n\t\t\t\t#endif\n\t\t\t}\nvec3 gb60bf13d71894171a2af79dd1d344da3_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS], float steps[gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {\n               vec4 color = colors[0];\n               #ifdef gb60bf13d71894171a2af79dd1d344da3_IS_VECTOR\n                   #ifdef gb60bf13d71894171a2af79dd1d344da3_LINEAR\n                       #ifdef gb60bf13d71894171a2af79dd1d344da3_WORLDSPACE\n                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);\n                       #else\n                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);\n                       #endif\n                   #else\n                       #ifdef gb60bf13d71894171a2af79dd1d344da3_WORLDSPACE\n                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);\n                       #else\n                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);\n                       #endif\n                   #endif\n               #else\n                   float dist = length(vWPosition - cameraPosition);\n\t\t\t       float depth = ( dist - near ) / ( far - near );\n               #endif\n\n\n              float p;\n              #ifdef gb60bf13d71894171a2af79dd1d344da3_SMOOTH\n\t\t\t\tfor ( int i = 1; i < gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS; i++ ) {\n\t\t\t\t\t\tp = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );\n\t\t\t\t\t\tcolor = mix(color, colors[i], smoothstep(0.0, 1.0, p));\n\t\t\t\t\t}\n              #else\n                for ( int i = 1; i < gb60bf13d71894171a2af79dd1d344da3_MAX_COLORS; i++ ) {\n                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);\n                   color = mix(color, colors[i], p);\n                 }\n              #endif\n\n               float lalpha = alpha * color.a * mask;\n               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\t\t\t   \n               return color.rgb;\n\t\t\t}\nvec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\n\t\t\t\tvec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );\n\t\t\t\tvec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;\n\t\t\t\tunrefractedCoords += 1.0;\n\t\t\t\tunrefractedCoords /= 2.0;\n\n\t\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\t\treturn getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );\n    \t\t}\nvec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {\n                vec3 v = vec3(0.);\n                if (isOrthographic) {\n                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n                } else {\n                    v = normalize(vWPosition - cameraPosition);\n                }\n                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );\n                \n\t\t\t\tfloat lalpha = alpha * mask;\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * alpha;\n\n\t\t\t\treturn transmission;\n            }\n\nvoid main() {\n\nfloat g5bfaadd2eca34fa3b71f09ed96a7f085_calpha;\nfloat gb60bf13d71894171a2af79dd1d344da3_calpha;\nfloat gee38695320d24f1c8e9eb0283839cba8_calpha;\nfloat g354ff6fd46474004b7bb3125dc58a54f_calpha;\n\n#if 0 > 0\n\tvec4 plane;\n\t\n\t#if 0 < 0\n\t\tbool clipped = true;\n\t\t\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;\n\n\t\t\t\t// NOTE: gl_FrontFacing alternative using face normal estimation.\n\t\t\t\tvec3 viewdx = dFdx(vViewPosition);\n\t\t\t\tvec3 viewdy = dFdy(vViewPosition);\n\t\t\t\tvec3 faceNormal = normalize(cross(viewdx,viewdy));\n\t\t\t\tif (dot(normal, faceNormal) < 0.0) {\n\t\t\t\t\tnormal *= -1.0;\n\t\t\t\t}\n\t\t\t\t\n\tPhysicalMaterial material;\n\tmaterial.diffuseColor = vec3( 1.0 );\n\n\tvec3 diffuseColor = spe_blend(spe_blend(spe_blend(transmission(nodeU0,nodeU1,nodeU2,nodeU3,nodeU4,nodeU5,nodeU6,normal,1.0,nodeU7,g5bfaadd2eca34fa3b71f09ed96a7f085_calpha),gb60bf13d71894171a2af79dd1d344da3_sdepth(nodeU8,nodeU9,nodeU10,nodeU11,nodeUA0,nodeUA1,nodeU12,1.0,nodeU13,gb60bf13d71894171a2af79dd1d344da3_calpha),( gb60bf13d71894171a2af79dd1d344da3_calpha ),nodeU14),fresnel(nodeU15,nodeU16,nodeU17,nodeU18,nodeU19,nodeU20,1.0,nodeU21,nodeU22,gee38695320d24f1c8e9eb0283839cba8_calpha),( gee38695320d24f1c8e9eb0283839cba8_calpha ),nodeU22),fresnel(nodeU23,nodeU24,nodeU25,nodeU26,nodeU27,nodeU28,1.0,nodeU29,nodeU30,g354ff6fd46474004b7bb3125dc58a54f_calpha),( g354ff6fd46474004b7bb3125dc58a54f_calpha ),nodeU30);\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\tfloat metalnessFactor = nodeU32;\n\n\tfloat roughnessFactor = nodeU31;\n\n#ifdef ALPHATEST\n\tif ( nodeU36 <= ALPHATEST ) discard;\n#endif\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );\nmaterial.roughness = max( roughnessFactor, 0.0525 );\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\nmaterial.roughness = clamp( roughnessFactor, 0.04, 1.0 );\n\nmaterial.specularColor = mix( vec3( 0.16 * pow2( nodeU37 ) ), diffuseColor, metalnessFactor );\n\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t\n#endif\n#if ( 1 > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && 0 > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t\n\t\tdirectionalLight = directionalLights[ 0 ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( 0 < 0 )\n\t\tdirectionalLightShadow = directionalLightShadows[ 0 ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( 0, directionalShadowMap[ 0 ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t\n#endif\n#if ( 0 > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( 1 > 0 )\n\t\t\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry.normal );\n\t\t\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\nvec3 ao = aoEnabled && nodeU33 ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);\nvec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n\t\t\t\tif (outgoingLight != diffuseColor) {\n\t\t\t\t\tfloat lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );\n\t\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * nodeU34 * 1.0 * lightAccu;\n\t\t\t\t\toutgoingLight = spe_blend( diffuseColor, outgoingLight, nodeU34 * 1.0, nodeU35 );\n\t\t\t\t\t\n\t\t\t\t\toutgoingLight *= ao;\n\t\t\t\t}\n\t\t\t\t\ngl_FragColor = vec4( outgoingLight, accumAlpha * nodeU36 );\ngl_FragColor.a *= nodeU38;\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n\n}",
                        "translatedSource": "// INITIAL HLSL BEGIN\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n    float pad_26;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n    float pad_27;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0)\n{\n    return float3(x0, x0, x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform bool _aoEnabled : register(c7);\nuniform float3 _ambientLightColor : register(c8);\nuniform float3 _lightProbe[9] : register(c9);\nuniform _DirectionalLight _directionalLights[1] : register(c18);\nuniform _HemisphereLight _hemisphereLights[1] : register(c20);\nuniform float4x4 _modelMatrix : register(c23);\nuniform float4x4 _projectionMatrix : register(c27);\nuniform float _nodeU0 : register(c31);\nuniform float _nodeU1 : register(c32);\nuniform float _nodeU2 : register(c33);\nuniform float2 _nodeU3 : register(c34);\nuniform float2 _nodeU6 : register(c35);\nuniform float _nodeU7 : register(c36);\nuniform float _nodeU8 : register(c37);\nuniform float _nodeU9 : register(c38);\nuniform float3 _nodeU10 : register(c39);\nuniform float3 _nodeU11 : register(c40);\nuniform bool _nodeU12 : register(c41);\nuniform float _nodeU13 : register(c42);\nuniform int _nodeU14 : register(c43);\nuniform float3 _nodeU15 : register(c44);\nuniform float _nodeU16 : register(c45);\nuniform float _nodeU17 : register(c46);\nuniform float _nodeU18 : register(c47);\nuniform float _nodeU19 : register(c48);\nuniform bool _nodeU20 : register(c49);\nuniform float _nodeU21 : register(c50);\nuniform int _nodeU22 : register(c51);\nuniform float3 _nodeU23 : register(c52);\nuniform float _nodeU24 : register(c53);\nuniform float _nodeU25 : register(c54);\nuniform float _nodeU26 : register(c55);\nuniform float _nodeU27 : register(c56);\nuniform bool _nodeU28 : register(c57);\nuniform float _nodeU29 : register(c58);\nuniform int _nodeU30 : register(c59);\nuniform float _nodeU31 : register(c60);\nuniform float _nodeU32 : register(c61);\nuniform bool _nodeU33 : register(c62);\nuniform float _nodeU34 : register(c63);\nuniform int _nodeU35 : register(c64);\nuniform float _nodeU36 : register(c65);\nuniform float _nodeU37 : register(c66);\nuniform float _nodeU38 : register(c67);\nuniform float4 _nodeUA0[4] : register(c68);\nuniform float _nodeUA1[4] : register(c72);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_pow2(const float _x)\n{\nreturn (_x * _x);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nstatic float _accumAlpha = {0.0};\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2704 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2705 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2705 = lerp((2.0 * _dither_shift_RGB2705), (-2.0 * _dither_shift_RGB2705), _grid_position2704));\nreturn (_color + _dither_shift_RGB2705);\n}\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2712 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2712)) + (_f90 * _fresnel2712));\n}\nfloat f_V_GGX_SmithCorrelated(const float _alpha, const float _dotNL, const float _dotNV)\n{\nfloat _a22729 = f_pow2(_alpha);\nfloat _gv2730 = (_dotNL * sqrt((_a22729 + ((1.0 - _a22729) * f_pow2(_dotNV)))));\nfloat _gl2731 = (_dotNV * sqrt((_a22729 + ((1.0 - _a22729) * f_pow2(_dotNL)))));\nreturn (0.5 / max((_gv2730 + _gl2731), 1e-06));\n}\nfloat f_D_GGX(const float _alpha, const float _dotNH)\n{\nfloat _a22735 = f_pow2(_alpha);\nfloat _denom2736 = ((f_pow2(_dotNH) * (_a22735 - 1.0)) + 1.0);\nreturn ((0.31830987 * _a22735) / f_pow2(_denom2736));\n}\nfloat3 f_BRDF_GGX(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _f0, const float _f90, const float _roughness)\n{\nfloat _alpha2744 = f_pow2(_roughness);\nfloat3 _halfDir2745 = normalize((_lightDir + _viewDir));\nfloat _dotNL2746 = clamp(dot(_normal, _lightDir), 0.0, 1.0);\nfloat _dotNV2747 = clamp(dot(_normal, _viewDir), 0.0, 1.0);\nfloat _dotNH2748 = clamp(dot(_normal, _halfDir2745), 0.0, 1.0);\nfloat _dotVH2749 = clamp(dot(_viewDir, _halfDir2745), 0.0, 1.0);\nfloat3 _F2750 = f_F_Schlick(_f0, _f90, _dotVH2749);\nfloat _V2751 = f_V_GGX_SmithCorrelated(_alpha2744, _dotNL2746, _dotNV2747);\nfloat _D2752 = f_D_GGX(_alpha2744, _dotNH2748);\nreturn (_F2750 * (_V2751 * _D2752));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2811 = _normal.x;\nfloat _y2812 = _normal.y;\nfloat _z2813 = _normal.z;\nfloat3 _result2814 = (_shCoefficients[0] * 0.88622701);\n(_result2814 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2812));\n(_result2814 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2813));\n(_result2814 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2811));\n(_result2814 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2811) * _y2812));\n(_result2814 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2812) * _z2813));\n(_result2814 += (_shCoefficients[6] * (((0.74312502 * _z2813) * _z2813) - 0.24770799)));\n(_result2814 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2811) * _z2813));\n(_result2814 += ((_shCoefficients[8] * 0.42904299) * ((_x2811 * _x2811) - (_y2812 * _y2812))));\nreturn _result2814;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2818 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2819 = f_shGetIrradianceAt(_worldNormal2818, _lightProbe);\nreturn _irradiance2819;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2822 = _ambientLightColor;\nreturn _irradiance2822;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2844 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2845 = ((0.5 * _dotNL2844) + 0.5);\nfloat3 _irradiance2846 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2845);\nreturn _irradiance2846;\n}\n;\nfloat2 f_DFGApprox(const float3 _normal, const float3 _viewDir, const float _roughness)\n{\nfloat _dotNV2864 = clamp(dot(_normal, _viewDir), 0.0, 1.0);\nfloat4 _r2867 = ((_roughness * float4(-1.0, -0.0275, -0.57200003, 0.022)) + float4(1.0, 0.0425, 1.04, -0.039999999));\nfloat _a0042868 = ((min((_r2867.x * _r2867.x), exp2((-9.2799997 * _dotNV2864))) * _r2867.x) + _r2867.y);\nfloat2 _fab2869 = ((float2(-1.04, 1.04) * _a0042868) + _r2867.zw);\nreturn _fab2869;\n}\nvoid f_computeMultiscattering(const float3 _normal, const float3 _viewDir, const float3 _specularColor, const float _specularF90, const float _roughness, inout float3 _singleScatter, inout float3 _multiScatter)\n{\nfloat2 _fab2885 = f_DFGApprox(_normal, _viewDir, _roughness);\nfloat3 _Fr2886 = _specularColor;\nfloat3 _FssEss2887 = ((_Fr2886 * _fab2885.x) + (_specularF90 * _fab2885.y));\nfloat _Ess2888 = (_fab2885.x + _fab2885.y);\nfloat _Ems2889 = (1.0 - _Ess2888);\nfloat3 _Favg2890 = (_Fr2886 + ((1.0 - _Fr2886) * 0.047619));\nfloat3 _Fms2891 = ((_FssEss2887 * _Favg2890) / (1.0 - (_Ems2889 * _Favg2890)));\n(_singleScatter += _FssEss2887);\n(_multiScatter += (_Fms2891 * _Ems2889));\n}\nvoid f_RE_Direct_Physical__IncidentLight__GeometricContext__PhysicalMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2897 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2898 = (_dotNL2897 * _directLight._color);\n(_reflectedLight._directSpecular += (_irradiance2898 * f_BRDF_GGX(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularF90, _material._roughness)));\n(_reflectedLight._directDiffuse += (_irradiance2898 * f_BRDF_Lambert(_material._diffuseColor)));\n}\nvoid f_RE_IndirectDiffuse_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\nvoid f_RE_IndirectSpecular_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(const float3 _radiance, const float3 _irradiance, const float3 _clearcoatRadiance, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat3 _singleScattering2911 = {0.0, 0.0, 0.0};\nfloat3 _multiScattering2912 = {0.0, 0.0, 0.0};\nfloat3 _cosineWeightedIrradiance2913 = (_irradiance * 0.31830987);\nf_computeMultiscattering(_geometry._normal, _geometry._viewDir, _material._specularColor, _material._specularF90, _material._roughness, _singleScattering2911, _multiScattering2912);\nfloat3 _totalScattering2914 = (_singleScattering2911 + _multiScattering2912);\nfloat3 _diffuse2915 = (_material._diffuseColor * (1.0 - max(max(_totalScattering2914.x, _totalScattering2914.y), _totalScattering2914.z)));\n(_reflectedLight._indirectSpecular += (_radiance * _singleScattering2911));\n(_reflectedLight._indirectSpecular += (_multiScattering2912 * _cosineWeightedIrradiance2913));\n(_reflectedLight._indirectDiffuse += (_diffuse2915 * _cosineWeightedIrradiance2913));\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2992 = floor(_vUv);\nfloat2 _fuv2993 = frac(_vUv);\nfloat _g0x2994 = f_g0(_fuv2993.x);\nfloat _g1x2995 = f_g1(_fuv2993.x);\nfloat _h0x2996 = f_h0(_fuv2993.x);\nfloat _h1x2997 = f_h1(_fuv2993.x);\nfloat _h0y2998 = f_h0(_fuv2993.y);\nfloat _h1y2999 = f_h1(_fuv2993.y);\nfloat2 _p03000 = ((vec2_ctor((_iuv2992.x + _h0x2996), (_iuv2992.y + _h0y2998)) - 0.5) * _texelSize.xy);\nfloat2 _p13001 = ((vec2_ctor((_iuv2992.x + _h1x2997), (_iuv2992.y + _h0y2998)) - 0.5) * _texelSize.xy);\nfloat2 _p23002 = ((vec2_ctor((_iuv2992.x + _h0x2996), (_iuv2992.y + _h1y2999)) - 0.5) * _texelSize.xy);\nfloat2 _p33003 = ((vec2_ctor((_iuv2992.x + _h1x2997), (_iuv2992.y + _h1y2999)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2993.y) * ((_g0x2994 * gl_texture2DLod(_tex, _p03000, _lod)) + (_g1x2995 * gl_texture2DLod(_tex, _p13001, _lod)))) + (f_g1(_fuv2993.y) * ((_g0x2994 * gl_texture2DLod(_tex, _p23002, _lod)) + (_g1x2995 * gl_texture2DLod(_tex, _p33003, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize3008 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize3009 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv3010 = (1.0 / _fLodSize3008);\nfloat2 _cLodSizeInv3011 = (1.0 / _cLodSize3009);\nfloat4 _fSample3012 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv3010, _fLodSize3008), floor(_lod));\nfloat4 _cSample3013 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv3011, _cLodSize3009), ceil(_lod));\nreturn lerp(_fSample3012, _cSample3013, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector3041 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale3042 = {0, 0, 0};\n(_modelScale3042.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale3042.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale3042.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector3041) * _thickness) * _modelScale3042);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist3061 = length((_vPosition - _origin));\nreturn ((_dist3061 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3078 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3079 = ((clamp(_fresnel3078, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3079 / clamp((_lalpha3079 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3079, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3079) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3089 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3089).xyz;\n}\nfloat3 f_gb60bf13d71894171a2af79dd1d344da3_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3101 = _colors[0];\nfloat _depth3102 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3103 = {0};\n{ for(int _i3104 = {1}; (_i3104 < 4); (_i3104++))\n{\n(_p3103 = clamp(((_depth3102 - _steps[(_i3104 - 1)]) / (_steps[_i3104] - _steps[(_i3104 - 1)])), 0.0, 1.0));\n(_color3101 = lerp(_color3101, _colors[_i3104], _p3103));\n}\n}\nfloat _lalpha3105 = ((_alpha * _color3101.w) * _mask);\n(_calpha = lerp((_lalpha3105 / clamp((_lalpha3105 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3105, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3105) * (1.0 - float_ctor(_isMask))));\nreturn _color3101.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3120 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3121 = (_position + _transmissionRay3120);\nfloat4 _ndcPos3122 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3121, 1.0));\nfloat2 _refractionCoords3123 = (_ndcPos3122.xy / _ndcPos3122.w);\n(_refractionCoords3123 += 1.0);\n(_refractionCoords3123 /= 2.0);\nfloat4 _ndcPosUnrefracted3124 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3125 = (_ndcPosUnrefracted3124.xy / _ndcPosUnrefracted3124.w);\n(_unrefractedCoords3125 += 1.0);\n(_unrefractedCoords3125 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3123, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3125, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3138 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3138 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3138 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3139 = f_getIBLVolumeRefraction(_vWNormal, (-_v3138), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3140 = (_alpha * _mask);\n(_calpha = (_lalpha3140 / clamp((_lalpha3140 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3139;\n}\n@@ PIXEL OUTPUT @@\n\nPS_OUTPUT main(@@ PIXEL MAIN PARAMETERS @@){\n@@ MAIN PROLOGUE @@\nfloat _g5bfaadd2eca34fa3b71f09ed96a7f085_calpha3142 = {0};\nfloat _gb60bf13d71894171a2af79dd1d344da3_calpha3143 = {0};\nfloat _gee38695320d24f1c8e9eb0283839cba8_calpha3144 = {0};\nfloat _g354ff6fd46474004b7bb3125dc58a54f_calpha3145 = {0};\nfloat3 _normal3147 = normalize(_vNormal);\nfloat3 _geometryNormal3148 = _normal3147;\nfloat3 _viewdx3149 = ddx(_vViewPosition);\nfloat3 _viewdy3150 = ddy(_vViewPosition);\nfloat3 _faceNormal3151 = normalize(cross(_viewdx3149, _viewdy3150));\nif ((dot(_normal3147, _faceNormal3151) < 0.0))\n{\n(_normal3147 *= -1.0);\n}\n_PhysicalMaterial _material3152 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_material3152._diffuseColor = float3(1.0, 1.0, 1.0));\nfloat3 _diffuseColor3153 = f_spe_blend_int(f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3147, 1.0, _nodeU7, _g5bfaadd2eca34fa3b71f09ed96a7f085_calpha3142), f_gb60bf13d71894171a2af79dd1d344da3_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _gb60bf13d71894171a2af79dd1d344da3_calpha3143), _gb60bf13d71894171a2af79dd1d344da3_calpha3143, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _gee38695320d24f1c8e9eb0283839cba8_calpha3144), _gee38695320d24f1c8e9eb0283839cba8_calpha3144, _nodeU22), f_fresnel_int(_nodeU23, _nodeU24, _nodeU25, _nodeU26, _nodeU27, _nodeU28, 1.0, _nodeU29, _nodeU30, _g354ff6fd46474004b7bb3125dc58a54f_calpha3145), _g354ff6fd46474004b7bb3125dc58a54f_calpha3145, _nodeU30);\n_ReflectedLight _reflectedLight3154 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat _metalnessFactor3155 = _nodeU32;\nfloat _roughnessFactor3156 = _nodeU31;\nfloat3 _dxy3157 = max(abs(ddx(_geometryNormal3148)), abs(ddy(_geometryNormal3148)));\nfloat _geometryRoughness3158 = max(max(_dxy3157.x, _dxy3157.y), _dxy3157.z);\n(_material3152._diffuseColor = (_diffuseColor3153 * (1.0 - _metalnessFactor3155)));\n(_material3152._roughness = max(_roughnessFactor3156, 0.052499998));\n(_material3152._roughness += _geometryRoughness3158);\n(_material3152._roughness = min(_material3152._roughness, 1.0));\n(_material3152._roughness = clamp(_roughnessFactor3156, 0.039999999, 1.0));\n(_material3152._specularColor = lerp(vec3_ctor((0.16 * f_pow2(_nodeU37))), _diffuseColor3153, _metalnessFactor3155));\n_GeometricContext _geometry3159 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry3159._position = (-_vViewPosition));\n(_geometry3159._normal = _normal3147);\nfloat3 sc61 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sc61 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sc61 = normalize(_vViewPosition));\n}\n(_geometry3159._viewDir = sc61);\n_IncidentLight _directLight3160 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight3161 = {0, 0, 0, 0, 0, 0};\n(_directionalLight3161 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight3161, _geometry3159, _directLight3160);\nf_RE_Direct_Physical__IncidentLight__GeometricContext__PhysicalMaterial__ReflectedLight(_directLight3160, _geometry3159, _material3152, _reflectedLight3154);\nfloat3 _iblIrradiance3162 = {0.0, 0.0, 0.0};\nfloat3 _irradiance3163 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance3163 += f_getLightProbeIrradiance(_lightProbe, _geometry3159._normal));\n(_irradiance3163 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry3159._normal));\nfloat3 _radiance3164 = {0.0, 0.0, 0.0};\nfloat3 _clearcoatRadiance3165 = {0.0, 0.0, 0.0};\nf_RE_IndirectDiffuse_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(_irradiance3163, _geometry3159, _material3152, _reflectedLight3154);\nf_RE_IndirectSpecular_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(_radiance3164, _iblIrradiance3162, _clearcoatRadiance3165, _geometry3159, _material3152, _reflectedLight3154);\nfloat3 sc62 = {0, 0, 0};\nif ((_aoEnabled && _nodeU33))\n{\n(sc62 = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc62 = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3166 = sc62;\nfloat3 _outgoingLight3167 = (((_reflectedLight3154._directDiffuse + _reflectedLight3154._indirectDiffuse) + _reflectedLight3154._directSpecular) + _reflectedLight3154._indirectSpecular);\nif (!all(_outgoingLight3167 == _diffuseColor3153))\n{\nfloat _lightAccu3168 = clamp(length((_reflectedLight3154._directSpecular + _reflectedLight3154._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU34) * 1.0) * _lightAccu3168));\n(_outgoingLight3167 = f_spe_blend_int(_diffuseColor3153, _outgoingLight3167, (_nodeU34 * 1.0), _nodeU35));\n(_outgoingLight3167 *= _ao3166);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3167, (_accumAlpha * _nodeU36)));\n(out_pc_fragColor.w *= _nodeU38);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// INITIAL HLSL END\n\n\n// COMPILER INPUT HLSL BEGIN\n\nstruct PS_INPUT\n{\n    float4 dx_Position : SV_Position;\n    float4 gl_Position : TEXCOORD6;\n    float4 gl_FragCoord : TEXCOORD7;\n    float3 v0 : TEXCOORD0;\n    float3 v1 : TEXCOORD1;\n    float3 v2 : TEXCOORD2;\n    float3 v3 : TEXCOORD3;\n    float3 v4 : TEXCOORD4;\n    float3 v5 : TEXCOORD5;\n};\n\n#pragma warning( disable: 3556 3571 )\nstruct _IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__IncidentLight\n{\n    float3 _color;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__IncidentLight\n{\n    float3 _color;\n    float pad_0;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__IncidentLight\n{\n    float3 _color;\n    float pad_1;\n    float3 _direction;\n    bool _visible;\n};\n#pragma pack_matrix(column_major)\nstruct _ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__ReflectedLight\n{\n    float3 _directDiffuse;\n    float3 _directSpecular;\n    float3 _indirectDiffuse;\n    float3 _indirectSpecular;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_2;\n    float3 _directSpecular;\n    float pad_3;\n    float3 _indirectDiffuse;\n    float pad_4;\n    float3 _indirectSpecular;\n    float pad_5;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__ReflectedLight\n{\n    float3 _directDiffuse;\n    float pad_6;\n    float3 _directSpecular;\n    float pad_7;\n    float3 _indirectDiffuse;\n    float pad_8;\n    float3 _indirectSpecular;\n    float pad_9;\n};\n#pragma pack_matrix(column_major)\nstruct _GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__GeometricContext\n{\n    float3 _position;\n    float3 _normal;\n    float3 _viewDir;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__GeometricContext\n{\n    float3 _position;\n    float pad_10;\n    float3 _normal;\n    float pad_11;\n    float3 _viewDir;\n    float pad_12;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__GeometricContext\n{\n    float3 _position;\n    float pad_13;\n    float3 _normal;\n    float pad_14;\n    float3 _viewDir;\n    float pad_15;\n};\n#pragma pack_matrix(column_major)\nstruct _DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__DirectionalLight\n{\n    float3 _direction;\n    float3 _color;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_16;\n    float3 _color;\n    float pad_17;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__DirectionalLight\n{\n    float3 _direction;\n    float pad_18;\n    float3 _color;\n    float pad_19;\n};\n#pragma pack_matrix(column_major)\nstruct _HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__HemisphereLight\n{\n    float3 _direction;\n    float3 _skyColor;\n    float3 _groundColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_20;\n    float3 _skyColor;\n    float pad_21;\n    float3 _groundColor;\n    float pad_22;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__HemisphereLight\n{\n    float3 _direction;\n    float pad_23;\n    float3 _skyColor;\n    float pad_24;\n    float3 _groundColor;\n    float pad_25;\n};\n#pragma pack_matrix(column_major)\nstruct _PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(row_major)\nstruct rm__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(column_major)\nstruct std__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n};\n#pragma pack_matrix(column_major)\nstruct std_fp__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n    float pad_26;\n};\n#pragma pack_matrix(row_major)\nstruct std_rm_fp__PhysicalMaterial\n{\n    float3 _diffuseColor;\n    float _roughness;\n    float3 _specularColor;\n    float _specularF90;\n    float _transmission;\n    float _transmissionAlpha;\n    float _thickness;\n    float _attenuationDistance;\n    float3 _attenuationColor;\n    float pad_27;\n};\n#pragma pack_matrix(column_major)\nfloat float_ctor(bool x0)\n{\n    return float(x0);\n}\nfloat2 vec2_ctor(float x0, float x1)\n{\n    return float2(x0, x1);\n}\nfloat2 vec2_ctor_int2(int2 x0)\n{\n    return float2(x0);\n}\nfloat3 vec3_ctor(float x0)\n{\n    return float3(x0, x0, x0);\n}\nfloat3 vec3_ctor(float x0, float x1, float x2)\n{\n    return float3(x0, x1, x2);\n}\nfloat3 vec3_ctor(float3 x0)\n{\n    return float3(x0);\n}\nfloat4 vec4_ctor(float2 x0, float2 x1)\n{\n    return float4(x0, x1);\n}\nfloat4 vec4_ctor(float3 x0, float x1)\n{\n    return float4(x0, x1);\n}\nint int_ctor(float x0)\n{\n    return int(x0);\n}\n// Uniforms\n\nuniform float4x4 _viewMatrix : register(c0);\nuniform float3 _cameraPosition : register(c4);\nuniform bool _isOrthographic : register(c5);\nuniform float2 _resolution : register(c6);\nuniform bool _aoEnabled : register(c7);\nuniform float3 _ambientLightColor : register(c8);\nuniform float3 _lightProbe[9] : register(c9);\nuniform _DirectionalLight _directionalLights[1] : register(c18);\nuniform _HemisphereLight _hemisphereLights[1] : register(c20);\nuniform float4x4 _modelMatrix : register(c23);\nuniform float4x4 _projectionMatrix : register(c27);\nuniform float _nodeU0 : register(c31);\nuniform float _nodeU1 : register(c32);\nuniform float _nodeU2 : register(c33);\nuniform float2 _nodeU3 : register(c34);\nuniform float2 _nodeU6 : register(c35);\nuniform float _nodeU7 : register(c36);\nuniform float _nodeU8 : register(c37);\nuniform float _nodeU9 : register(c38);\nuniform float3 _nodeU10 : register(c39);\nuniform float3 _nodeU11 : register(c40);\nuniform bool _nodeU12 : register(c41);\nuniform float _nodeU13 : register(c42);\nuniform int _nodeU14 : register(c43);\nuniform float3 _nodeU15 : register(c44);\nuniform float _nodeU16 : register(c45);\nuniform float _nodeU17 : register(c46);\nuniform float _nodeU18 : register(c47);\nuniform float _nodeU19 : register(c48);\nuniform bool _nodeU20 : register(c49);\nuniform float _nodeU21 : register(c50);\nuniform int _nodeU22 : register(c51);\nuniform float3 _nodeU23 : register(c52);\nuniform float _nodeU24 : register(c53);\nuniform float _nodeU25 : register(c54);\nuniform float _nodeU26 : register(c55);\nuniform float _nodeU27 : register(c56);\nuniform bool _nodeU28 : register(c57);\nuniform float _nodeU29 : register(c58);\nuniform int _nodeU30 : register(c59);\nuniform float _nodeU31 : register(c60);\nuniform float _nodeU32 : register(c61);\nuniform bool _nodeU33 : register(c62);\nuniform float _nodeU34 : register(c63);\nuniform int _nodeU35 : register(c64);\nuniform float _nodeU36 : register(c65);\nuniform float _nodeU37 : register(c66);\nuniform float _nodeU38 : register(c67);\nuniform float4 _nodeUA0[4] : register(c68);\nuniform float _nodeUA1[4] : register(c72);\nstatic const uint _aoMap = 0;\nstatic const uint _nodeU4 = 1;\nstatic const uint _nodeU5 = 2;\nuniform Texture2D<float4> textures2D[3] : register(t0);\nuniform SamplerState samplers2D[3] : register(s0);\n#ifdef ANGLE_ENABLE_LOOP_FLATTEN\n#define LOOP [loop]\n#define FLATTEN [flatten]\n#else\n#define LOOP\n#define FLATTEN\n#endif\n\n#define ATOMIC_COUNTER_ARRAY_STRIDE 4\n\n// Varyings\nstatic  float3 _vViewPosition = {0, 0, 0};\nstatic  float3 _vWPosition = {0, 0, 0};\nstatic  float3 _vNormal = {0, 0, 0};\nstatic  float3 _vPosition = {0, 0, 0};\nstatic  float3 _vWNormal = {0, 0, 0};\nstatic  float3 _vWorldViewDir = {0, 0, 0};\n\nstatic float4 out_pc_fragColor = {0, 0, 0, 0};\nstatic float4 gl_FragCoord = float4(0, 0, 0, 0);\n\ncbuffer DriverConstants : register(b1)\n{\n    float4 dx_ViewCoords : packoffset(c1);\n    float2 dx_FragCoordOffset : packoffset(c3);\n    float3 dx_DepthFront : packoffset(c2);\n    float2 dx_ViewScale : packoffset(c3.z);\n    uint dx_Misc : packoffset(c2.w);\n    struct SamplerMetadata\n    {\n        int baseLevel;\n        int wrapModes;\n        int2 padding;\n        int4 intBorderColor;\n    };\n    SamplerMetadata samplerMetadata[3] : packoffset(c4);\n};\n\nint2 gl_texture2DSize(uint samplerIndex, int lod)\n{\n    int baseLevel = 0;\n    uint width; uint height; uint numberOfLevels;\n    textures2D[samplerIndex].GetDimensions(baseLevel, width, height, numberOfLevels);\n    width = max(width >> lod, 1);\n    height = max(height >> lod, 1);\n    return int2(width, height);\n}\n\nfloat4 gl_texture2D(uint samplerIndex, float2 t)\n{\n    return textures2D[samplerIndex].Sample(samplers2D[samplerIndex], float2(t.x, t.y));\n}\n\nfloat4 gl_texture2DLod(uint samplerIndex, float2 t, float lod)\n{\n    return textures2D[samplerIndex].SampleLevel(samplers2D[samplerIndex], float2(t.x, t.y), lod);\n}\n\n#define GL_USES_FRAG_COORD\nfloat mod_emu(float x, float y)\n{\n    return x - y * floor(x / y);\n}\n\n\nfloat4 f_LinearToLinear_float4(in float4 _value)\n{\nreturn _value;\n}\nfloat4 f_linearToOutputTexel_float4(in float4 _value)\n{\nreturn f_LinearToLinear_float4(_value);\n}\nfloat3 f_spe_normalBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, _b, _alpha);\n}\nfloat3 f_spe_multiplyBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nreturn lerp(_a, (_a * _b), _alpha);\n}\nfloat3 f_spe_screenBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2579 = (1.0 - ((1.0 - _a) * (1.0 - _b)));\nreturn lerp(_a, _tmp2579, _alpha);\n}\nfloat3 f_spe_overlayBlend(in float3 _a, in float3 _b, in float _alpha)\n{\nfloat3 _tmp2584 = lerp((1.0 - ((2.0 * (1.0 - _a)) * (1.0 - _b))), ((2.0 * _a) * _b), step(_a, float3(0.5, 0.5, 0.5)));\nreturn clamp(lerp(_a, _tmp2584, _alpha), 0.0, 1.0);\n}\nfloat3 f_spe_blend_int(in float3 _a, in float3 _b, in float _alpha, in int _mode)\n{\nif ((_mode == 0))\n{\nreturn f_spe_normalBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 1))\n{\nreturn f_spe_multiplyBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 2))\n{\nreturn f_spe_screenBlend(_a, _b, _alpha);\n}\nelse\n{\nif ((_mode == 3))\n{\nreturn f_spe_overlayBlend(_a, _b, _alpha);\n}\n}\n}\n}\nreturn float3(1.0, 1.0, 1.0);\n}\nfloat f_pow2(const float _x)\n{\nreturn (_x * _x);\n}\nfloat f_rand(const float2 _uv)\n{\nfloat _dt2647 = dot(_uv.xy, float2(12.9898, 78.233002));\nfloat _sn2648 = mod_emu(_dt2647, 3.1415927);\nreturn frac((sin(_sn2648) * 43758.547));\n}\n;\n;\n;\nfloat3 f_inverseTransformDirection(in float3 _dir, in float4x4 _matrix)\n{\nreturn normalize(mul(vec4_ctor(_dir, 0.0), transpose(_matrix)).xyz);\n}\nstatic float _accumAlpha = {0.0};\nfloat3 f_dithering(in float3 _color)\n{\nfloat _grid_position2704 = f_rand(gl_FragCoord.xy);\nfloat3 _dither_shift_RGB2705 = {0.00098039221, -0.00098039221, 0.00098039221};\n(_dither_shift_RGB2705 = lerp((2.0 * _dither_shift_RGB2705), (-2.0 * _dither_shift_RGB2705), _grid_position2704));\nreturn (_color + _dither_shift_RGB2705);\n}\nfloat3 f_BRDF_Lambert(const float3 _diffuseColor)\n{\nreturn (0.31830987 * _diffuseColor);\n}\nfloat3 f_F_Schlick(const float3 _f0, const float _f90, const float _dotVH)\n{\nfloat _fresnel2712 = exp2((((-5.5547299 * _dotVH) - 6.98316) * _dotVH));\nreturn ((_f0 * (1.0 - _fresnel2712)) + (_f90 * _fresnel2712));\n}\nfloat f_V_GGX_SmithCorrelated(const float _alpha, const float _dotNL, const float _dotNV)\n{\nfloat _a22729 = f_pow2(_alpha);\nfloat _gv2730 = (_dotNL * sqrt((_a22729 + ((1.0 - _a22729) * f_pow2(_dotNV)))));\nfloat _gl2731 = (_dotNV * sqrt((_a22729 + ((1.0 - _a22729) * f_pow2(_dotNL)))));\nreturn (0.5 / max((_gv2730 + _gl2731), 1e-06));\n}\nfloat f_D_GGX(const float _alpha, const float _dotNH)\n{\nfloat _a22735 = f_pow2(_alpha);\nfloat _denom2736 = ((f_pow2(_dotNH) * (_a22735 - 1.0)) + 1.0);\nreturn ((0.31830987 * _a22735) / f_pow2(_denom2736));\n}\nfloat3 f_BRDF_GGX(const float3 _lightDir, const float3 _viewDir, const float3 _normal, const float3 _f0, const float _f90, const float _roughness)\n{\nfloat _alpha2744 = f_pow2(_roughness);\nfloat3 _halfDir2745 = normalize((_lightDir + _viewDir));\nfloat _dotNL2746 = clamp(dot(_normal, _lightDir), 0.0, 1.0);\nfloat _dotNV2747 = clamp(dot(_normal, _viewDir), 0.0, 1.0);\nfloat _dotNH2748 = clamp(dot(_normal, _halfDir2745), 0.0, 1.0);\nfloat _dotVH2749 = clamp(dot(_viewDir, _halfDir2745), 0.0, 1.0);\nfloat3 _F2750 = f_F_Schlick(_f0, _f90, _dotVH2749);\nfloat _V2751 = f_V_GGX_SmithCorrelated(_alpha2744, _dotNL2746, _dotNV2747);\nfloat _D2752 = f_D_GGX(_alpha2744, _dotNH2748);\nreturn (_F2750 * (_V2751 * _D2752));\n}\nfloat3 f_shGetIrradianceAt(in float3 _normal, in float3 _shCoefficients[9])\n{\nfloat _x2811 = _normal.x;\nfloat _y2812 = _normal.y;\nfloat _z2813 = _normal.z;\nfloat3 _result2814 = (_shCoefficients[0] * 0.88622701);\n(_result2814 += (((_shCoefficients[1] * 2.0) * 0.51166397) * _y2812));\n(_result2814 += (((_shCoefficients[2] * 2.0) * 0.51166397) * _z2813));\n(_result2814 += (((_shCoefficients[3] * 2.0) * 0.51166397) * _x2811));\n(_result2814 += ((((_shCoefficients[4] * 2.0) * 0.42904299) * _x2811) * _y2812));\n(_result2814 += ((((_shCoefficients[5] * 2.0) * 0.42904299) * _y2812) * _z2813));\n(_result2814 += (_shCoefficients[6] * (((0.74312502 * _z2813) * _z2813) - 0.24770799)));\n(_result2814 += ((((_shCoefficients[7] * 2.0) * 0.42904299) * _x2811) * _z2813));\n(_result2814 += ((_shCoefficients[8] * 0.42904299) * ((_x2811 * _x2811) - (_y2812 * _y2812))));\nreturn _result2814;\n}\nfloat3 f_getLightProbeIrradiance(const float3 _lightProbe[9], const float3 _normal)\n{\nfloat3 _worldNormal2818 = f_inverseTransformDirection(_normal, _viewMatrix);\nfloat3 _irradiance2819 = f_shGetIrradianceAt(_worldNormal2818, _lightProbe);\nreturn _irradiance2819;\n}\nfloat3 f_getAmbientLightIrradiance(const float3 _ambientLightColor)\n{\nfloat3 _irradiance2822 = _ambientLightColor;\nreturn _irradiance2822;\n}\n;\nvoid f_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(const _DirectionalLight _directionalLight, const _GeometricContext _geometry, inout _IncidentLight _light)\n{\n(_light._color = _directionalLight._color);\n(_light._direction = _directionalLight._direction);\n(_light._visible = true);\n}\n;\nfloat3 f_getHemisphereLightIrradiance__HemisphereLight(const _HemisphereLight _hemiLight, const float3 _normal)\n{\nfloat _dotNL2844 = dot(_normal, _hemiLight._direction);\nfloat _hemiDiffuseWeight2845 = ((0.5 * _dotNL2844) + 0.5);\nfloat3 _irradiance2846 = lerp(_hemiLight._groundColor, _hemiLight._skyColor, _hemiDiffuseWeight2845);\nreturn _irradiance2846;\n}\n;\nfloat2 f_DFGApprox(const float3 _normal, const float3 _viewDir, const float _roughness)\n{\nfloat _dotNV2864 = clamp(dot(_normal, _viewDir), 0.0, 1.0);\nfloat4 _r2867 = ((_roughness * float4(-1.0, -0.0275, -0.57200003, 0.022)) + float4(1.0, 0.0425, 1.04, -0.039999999));\nfloat _a0042868 = ((min((_r2867.x * _r2867.x), exp2((-9.2799997 * _dotNV2864))) * _r2867.x) + _r2867.y);\nfloat2 _fab2869 = ((float2(-1.04, 1.04) * _a0042868) + _r2867.zw);\nreturn _fab2869;\n}\nvoid f_computeMultiscattering(const float3 _normal, const float3 _viewDir, const float3 _specularColor, const float _specularF90, const float _roughness, inout float3 _singleScatter, inout float3 _multiScatter)\n{\nfloat2 _fab2885 = f_DFGApprox(_normal, _viewDir, _roughness);\nfloat3 _Fr2886 = _specularColor;\nfloat3 _FssEss2887 = ((_Fr2886 * _fab2885.x) + (_specularF90 * _fab2885.y));\nfloat _Ess2888 = (_fab2885.x + _fab2885.y);\nfloat _Ems2889 = (1.0 - _Ess2888);\nfloat3 _Favg2890 = (_Fr2886 + ((1.0 - _Fr2886) * 0.047619));\nfloat3 _Fms2891 = ((_FssEss2887 * _Favg2890) / (1.0 - (_Ems2889 * _Favg2890)));\n(_singleScatter += _FssEss2887);\n(_multiScatter += (_Fms2891 * _Ems2889));\n}\nvoid f_RE_Direct_Physical__IncidentLight__GeometricContext__PhysicalMaterial__ReflectedLight(const _IncidentLight _directLight, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat _dotNL2897 = clamp(dot(_geometry._normal, _directLight._direction), 0.0, 1.0);\nfloat3 _irradiance2898 = (_dotNL2897 * _directLight._color);\n(_reflectedLight._directSpecular += (_irradiance2898 * f_BRDF_GGX(_directLight._direction, _geometry._viewDir, _geometry._normal, _material._specularColor, _material._specularF90, _material._roughness)));\n(_reflectedLight._directDiffuse += (_irradiance2898 * f_BRDF_Lambert(_material._diffuseColor)));\n}\nvoid f_RE_IndirectDiffuse_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(const float3 _irradiance, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\n(_reflectedLight._indirectDiffuse += (_irradiance * f_BRDF_Lambert(_material._diffuseColor)));\n}\nvoid f_RE_IndirectSpecular_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(const float3 _radiance, const float3 _irradiance, const float3 _clearcoatRadiance, const _GeometricContext _geometry, const _PhysicalMaterial _material, inout _ReflectedLight _reflectedLight)\n{\nfloat3 _singleScattering2911 = {0.0, 0.0, 0.0};\nfloat3 _multiScattering2912 = {0.0, 0.0, 0.0};\nfloat3 _cosineWeightedIrradiance2913 = (_irradiance * 0.31830987);\nf_computeMultiscattering(_geometry._normal, _geometry._viewDir, _material._specularColor, _material._specularF90, _material._roughness, _singleScattering2911, _multiScattering2912);\nfloat3 _totalScattering2914 = (_singleScattering2911 + _multiScattering2912);\nfloat3 _diffuse2915 = (_material._diffuseColor * (1.0 - max(max(_totalScattering2914.x, _totalScattering2914.y), _totalScattering2914.z)));\n(_reflectedLight._indirectSpecular += (_radiance * _singleScattering2911));\n(_reflectedLight._indirectSpecular += (_multiScattering2912 * _cosineWeightedIrradiance2913));\n(_reflectedLight._indirectDiffuse += (_diffuse2915 * _cosineWeightedIrradiance2913));\n}\nfloat f_w0(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-_a) + 3.0)) - 3.0)) + 1.0));\n}\nfloat f_w1(in float _a)\n{\nreturn (0.16666667 * (((_a * _a) * ((3.0 * _a) - 6.0)) + 4.0));\n}\nfloat f_w2(in float _a)\n{\nreturn (0.16666667 * ((_a * ((_a * ((-3.0 * _a) + 3.0)) + 3.0)) + 1.0));\n}\nfloat f_w3(in float _a)\n{\nreturn (0.16666667 * ((_a * _a) * _a));\n}\nfloat f_g0(in float _a)\n{\nreturn (f_w0(_a) + f_w1(_a));\n}\nfloat f_g1(in float _a)\n{\nreturn (f_w2(_a) + f_w3(_a));\n}\nfloat f_h0(in float _a)\n{\nreturn (-1.0 + (f_w1(_a) / (f_w0(_a) + f_w1(_a))));\n}\nfloat f_h1(in float _a)\n{\nreturn (1.0 + (f_w3(_a) / (f_w2(_a) + f_w3(_a))));\n}\nfloat4 f_bicubic_float4(const uint _tex, in float2 _vUv, in float4 _texelSize, in float _lod)\n{\n(_vUv = ((_vUv * _texelSize.zw) + 0.5));\nfloat2 _iuv2992 = floor(_vUv);\nfloat2 _fuv2993 = frac(_vUv);\nfloat _g0x2994 = f_g0(_fuv2993.x);\nfloat _g1x2995 = f_g1(_fuv2993.x);\nfloat _h0x2996 = f_h0(_fuv2993.x);\nfloat _h1x2997 = f_h1(_fuv2993.x);\nfloat _h0y2998 = f_h0(_fuv2993.y);\nfloat _h1y2999 = f_h1(_fuv2993.y);\nfloat2 _p03000 = ((vec2_ctor((_iuv2992.x + _h0x2996), (_iuv2992.y + _h0y2998)) - 0.5) * _texelSize.xy);\nfloat2 _p13001 = ((vec2_ctor((_iuv2992.x + _h1x2997), (_iuv2992.y + _h0y2998)) - 0.5) * _texelSize.xy);\nfloat2 _p23002 = ((vec2_ctor((_iuv2992.x + _h0x2996), (_iuv2992.y + _h1y2999)) - 0.5) * _texelSize.xy);\nfloat2 _p33003 = ((vec2_ctor((_iuv2992.x + _h1x2997), (_iuv2992.y + _h1y2999)) - 0.5) * _texelSize.xy);\nreturn ((f_g0(_fuv2993.y) * ((_g0x2994 * gl_texture2DLod(_tex, _p03000, _lod)) + (_g1x2995 * gl_texture2DLod(_tex, _p13001, _lod)))) + (f_g1(_fuv2993.y) * ((_g0x2994 * gl_texture2DLod(_tex, _p23002, _lod)) + (_g1x2995 * gl_texture2DLod(_tex, _p33003, _lod)))));\n}\nfloat4 f_textureBicubic(const uint _sampler, in float2 _vUv, in float _lod)\n{\nfloat2 _fLodSize3008 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor(_lod)));\nfloat2 _cLodSize3009 = vec2_ctor_int2(gl_texture2DSize(_sampler, int_ctor((_lod + 1.0))));\nfloat2 _fLodSizeInv3010 = (1.0 / _fLodSize3008);\nfloat2 _cLodSizeInv3011 = (1.0 / _cLodSize3009);\nfloat4 _fSample3012 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_fLodSizeInv3010, _fLodSize3008), floor(_lod));\nfloat4 _cSample3013 = f_bicubic_float4(_sampler, _vUv, vec4_ctor(_cLodSizeInv3011, _cLodSize3009), ceil(_lod));\nreturn lerp(_fSample3012, _cSample3013, frac(_lod));\n}\nfloat f_applyIorToRoughness(in float _roughness, in float _ior)\n{\nreturn (_roughness * clamp(((_ior * 2.0) - 2.0), 0.0, 1.0));\n}\nfloat3 f_getVolumeTransmissionRay(in float3 _n, in float3 _v, in float _thickness, in float _ior, in float4x4 _modelMatrix)\n{\nfloat3 _refractionVector3041 = refract((-_v), _n, (1.0 / _ior));\nfloat3 _modelScale3042 = {0, 0, 0};\n(_modelScale3042.x = length(vec3_ctor(_modelMatrix[0].xyz)));\n(_modelScale3042.y = length(vec3_ctor(_modelMatrix[1].xyz)));\n(_modelScale3042.z = length(vec3_ctor(_modelMatrix[2].xyz)));\nreturn ((normalize(_refractionVector3041) * _thickness) * _modelScale3042);\n}\nfloat f_vectorSphericalObjectSpaceDepth(in float3 _origin, in float _near, in float _far)\n{\nfloat _dist3061 = length((_vPosition - _origin));\nreturn ((_dist3061 - _near) / (_far - _near));\n}\nfloat3 f_fresnel_int(in float3 _color, in float _bias, in float _scale, in float _intensity, in float _factor, in bool _isMask, in float _mask, in float _alpha, in int _mode, inout float _calpha)\n{\nfloat _fresnel3078 = (_bias + (_scale * pow(abs((_factor + dot(normalize(_vWorldViewDir), normalize(_vWNormal)))), _intensity)));\nfloat _lalpha3079 = ((clamp(_fresnel3078, 0.0, 1.0) * _alpha) * _mask);\n(_calpha = lerp((_lalpha3079 / clamp((_lalpha3079 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3079, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3079) * (1.0 - float_ctor(_isMask))));\nreturn _color;\n}\nfloat3 f_getTransmissionSample(in float2 _fragCoord, in float _roughness, in float _ior, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _unrefractedCoords, in float2 _aspectRatio)\n{\nfloat _lod3089 = (log2(_transmissionSamplerSize.x) * f_applyIorToRoughness((_roughness / 5.0), _ior));\nreturn f_textureBicubic(_transmissionSamplerMap, _fragCoord.xy, _lod3089).xyz;\n}\nfloat3 f_gb60bf13d71894171a2af79dd1d344da3_sdepth_float(in float _near, in float _far, in float3 _origin, in float3 _direction, in float4 _colors[4], in float _steps[4], in bool _isMask, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat4 _color3101 = _colors[0];\nfloat _depth3102 = f_vectorSphericalObjectSpaceDepth(_origin, _near, _far);\nfloat _p3103 = {0};\n{ for(int _i3104 = {1}; (_i3104 < 4); (_i3104++))\n{\n(_p3103 = clamp(((_depth3102 - _steps[(_i3104 - 1)]) / (_steps[_i3104] - _steps[(_i3104 - 1)])), 0.0, 1.0));\n(_color3101 = lerp(_color3101, _colors[_i3104], _p3103));\n}\n}\nfloat _lalpha3105 = ((_alpha * _color3101.w) * _mask);\n(_calpha = lerp((_lalpha3105 / clamp((_lalpha3105 + _accumAlpha), 9.9999997e-06, 1.0)), _lalpha3105, float_ctor(_isMask)));\n(_accumAlpha += (((1.0 - _accumAlpha) * _lalpha3105) * (1.0 - float_ctor(_isMask))));\nreturn _color3101.xyz;\n}\nfloat3 f_getIBLVolumeRefraction(in float3 _n, in float3 _v, in float _roughness, in float3 _position, in float4x4 _modelMatrix, in float4x4 _viewMatrix, in float4x4 _projMatrix, in float _ior, in float _thickness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio)\n{\nfloat3 _transmissionRay3120 = f_getVolumeTransmissionRay(_n, _v, _thickness, _ior, _modelMatrix);\nfloat3 _refractedRayExit3121 = (_position + _transmissionRay3120);\nfloat4 _ndcPos3122 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_refractedRayExit3121, 1.0));\nfloat2 _refractionCoords3123 = (_ndcPos3122.xy / _ndcPos3122.w);\n(_refractionCoords3123 += 1.0);\n(_refractionCoords3123 /= 2.0);\nfloat4 _ndcPosUnrefracted3124 = mul(transpose(transpose(mul(transpose(_projMatrix), transpose(_viewMatrix)))), vec4_ctor(_position, 1.0));\nfloat2 _unrefractedCoords3125 = (_ndcPosUnrefracted3124.xy / _ndcPosUnrefracted3124.w);\n(_unrefractedCoords3125 += 1.0);\n(_unrefractedCoords3125 /= 2.0);\nreturn f_getTransmissionSample(_refractionCoords3123, _roughness, _ior, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _unrefractedCoords3125, _aspectRatio);\n}\nfloat3 f_transmission(in float _thickness, in float _ior, in float _roughness, in float2 _transmissionSamplerSize, const uint _transmissionSamplerMap, const uint _transmissionDepthMap, in float2 _aspectRatio, in float3 _normal, in float _mask, in float _alpha, inout float _calpha)\n{\nfloat3 _v3138 = {0.0, 0.0, 0.0};\nif (_isOrthographic)\n{\n(_v3138 = normalize(vec3_ctor((-_viewMatrix[0][2]), (-_viewMatrix[1][2]), (-_viewMatrix[2][2]))));\n}\nelse\n{\n(_v3138 = normalize((_vWPosition - _cameraPosition)));\n}\nfloat3 _transmission3139 = f_getIBLVolumeRefraction(_vWNormal, (-_v3138), _roughness, _vWPosition, _modelMatrix, _viewMatrix, _projectionMatrix, _ior, _thickness, _transmissionSamplerSize, _transmissionSamplerMap, _transmissionDepthMap, _aspectRatio);\nfloat _lalpha3140 = (_alpha * _mask);\n(_calpha = (_lalpha3140 / clamp((_lalpha3140 + _accumAlpha), 9.9999997e-06, 1.0)));\n(_accumAlpha += ((1.0 - _accumAlpha) * _alpha));\nreturn _transmission3139;\n}\nstruct PS_OUTPUT\n{\n    float4 out_pc_fragColor : SV_TARGET0;\n};\n\nPS_OUTPUT generateOutput()\n{\n    PS_OUTPUT output;\n    output.out_pc_fragColor = out_pc_fragColor;\n    return output;\n}\n\n\nPS_OUTPUT main(PS_INPUT input){\n    float rhw = 1.0 / input.gl_FragCoord.w;\n    gl_FragCoord.x = input.dx_Position.x - dx_FragCoordOffset.x;\n    gl_FragCoord.y = input.dx_Position.y - dx_FragCoordOffset.y;\n    gl_FragCoord.z = input.dx_Position.z;\n    gl_FragCoord.w = rhw;\n    _vViewPosition = input.v0.xyz;\n    _vWPosition = input.v1.xyz;\n    _vNormal = input.v2.xyz;\n    _vPosition = input.v3.xyz;\n    _vWNormal = input.v4.xyz;\n    _vWorldViewDir = input.v5.xyz;\n\nfloat _g5bfaadd2eca34fa3b71f09ed96a7f085_calpha3142 = {0};\nfloat _gb60bf13d71894171a2af79dd1d344da3_calpha3143 = {0};\nfloat _gee38695320d24f1c8e9eb0283839cba8_calpha3144 = {0};\nfloat _g354ff6fd46474004b7bb3125dc58a54f_calpha3145 = {0};\nfloat3 _normal3147 = normalize(_vNormal);\nfloat3 _geometryNormal3148 = _normal3147;\nfloat3 _viewdx3149 = ddx(_vViewPosition);\nfloat3 _viewdy3150 = ddy(_vViewPosition);\nfloat3 _faceNormal3151 = normalize(cross(_viewdx3149, _viewdy3150));\nif ((dot(_normal3147, _faceNormal3151) < 0.0))\n{\n(_normal3147 *= -1.0);\n}\n_PhysicalMaterial _material3152 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_material3152._diffuseColor = float3(1.0, 1.0, 1.0));\nfloat3 _diffuseColor3153 = f_spe_blend_int(f_spe_blend_int(f_spe_blend_int(f_transmission(_nodeU0, _nodeU1, _nodeU2, _nodeU3, _nodeU4, _nodeU5, _nodeU6, _normal3147, 1.0, _nodeU7, _g5bfaadd2eca34fa3b71f09ed96a7f085_calpha3142), f_gb60bf13d71894171a2af79dd1d344da3_sdepth_float(_nodeU8, _nodeU9, _nodeU10, _nodeU11, _nodeUA0, _nodeUA1, _nodeU12, 1.0, _nodeU13, _gb60bf13d71894171a2af79dd1d344da3_calpha3143), _gb60bf13d71894171a2af79dd1d344da3_calpha3143, _nodeU14), f_fresnel_int(_nodeU15, _nodeU16, _nodeU17, _nodeU18, _nodeU19, _nodeU20, 1.0, _nodeU21, _nodeU22, _gee38695320d24f1c8e9eb0283839cba8_calpha3144), _gee38695320d24f1c8e9eb0283839cba8_calpha3144, _nodeU22), f_fresnel_int(_nodeU23, _nodeU24, _nodeU25, _nodeU26, _nodeU27, _nodeU28, 1.0, _nodeU29, _nodeU30, _g354ff6fd46474004b7bb3125dc58a54f_calpha3145), _g354ff6fd46474004b7bb3125dc58a54f_calpha3145, _nodeU30);\n_ReflectedLight _reflectedLight3154 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\nfloat _metalnessFactor3155 = _nodeU32;\nfloat _roughnessFactor3156 = _nodeU31;\nfloat3 _dxy3157 = max(abs(ddx(_geometryNormal3148)), abs(ddy(_geometryNormal3148)));\nfloat _geometryRoughness3158 = max(max(_dxy3157.x, _dxy3157.y), _dxy3157.z);\n(_material3152._diffuseColor = (_diffuseColor3153 * (1.0 - _metalnessFactor3155)));\n(_material3152._roughness = max(_roughnessFactor3156, 0.052499998));\n(_material3152._roughness += _geometryRoughness3158);\n(_material3152._roughness = min(_material3152._roughness, 1.0));\n(_material3152._roughness = clamp(_roughnessFactor3156, 0.039999999, 1.0));\n(_material3152._specularColor = lerp(vec3_ctor((0.16 * f_pow2(_nodeU37))), _diffuseColor3153, _metalnessFactor3155));\n_GeometricContext _geometry3159 = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n(_geometry3159._position = (-_vViewPosition));\n(_geometry3159._normal = _normal3147);\nfloat3 sc61 = {0, 0, 0};\nif (_isOrthographic)\n{\n(sc61 = float3(0.0, 0.0, 1.0));\n}\nelse\n{\n(sc61 = normalize(_vViewPosition));\n}\n(_geometry3159._viewDir = sc61);\n_IncidentLight _directLight3160 = {0, 0, 0, 0, 0, 0, 0};\n_DirectionalLight _directionalLight3161 = {0, 0, 0, 0, 0, 0};\n(_directionalLight3161 = _directionalLights[0]);\nf_getDirectionalLightInfo__DirectionalLight__GeometricContext__IncidentLight(_directionalLight3161, _geometry3159, _directLight3160);\nf_RE_Direct_Physical__IncidentLight__GeometricContext__PhysicalMaterial__ReflectedLight(_directLight3160, _geometry3159, _material3152, _reflectedLight3154);\nfloat3 _iblIrradiance3162 = {0.0, 0.0, 0.0};\nfloat3 _irradiance3163 = f_getAmbientLightIrradiance(_ambientLightColor);\n(_irradiance3163 += f_getLightProbeIrradiance(_lightProbe, _geometry3159._normal));\n(_irradiance3163 += f_getHemisphereLightIrradiance__HemisphereLight(_hemisphereLights[0], _geometry3159._normal));\nfloat3 _radiance3164 = {0.0, 0.0, 0.0};\nfloat3 _clearcoatRadiance3165 = {0.0, 0.0, 0.0};\nf_RE_IndirectDiffuse_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(_irradiance3163, _geometry3159, _material3152, _reflectedLight3154);\nf_RE_IndirectSpecular_Physical__GeometricContext__PhysicalMaterial__ReflectedLight(_radiance3164, _iblIrradiance3162, _clearcoatRadiance3165, _geometry3159, _material3152, _reflectedLight3154);\nfloat3 sc62 = {0, 0, 0};\nif ((_aoEnabled && _nodeU33))\n{\n(sc62 = gl_texture2D(_aoMap, (gl_FragCoord.xy / _resolution)).xyz);\n}\nelse\n{\n(sc62 = float3(1.0, 1.0, 1.0));\n}\nfloat3 _ao3166 = sc62;\nfloat3 _outgoingLight3167 = (((_reflectedLight3154._directDiffuse + _reflectedLight3154._indirectDiffuse) + _reflectedLight3154._directSpecular) + _reflectedLight3154._indirectSpecular);\nif (!all(_outgoingLight3167 == _diffuseColor3153))\n{\nfloat _lightAccu3168 = clamp(length((_reflectedLight3154._directSpecular + _reflectedLight3154._indirectSpecular)), 0.0, 1.0);\n(_accumAlpha += ((((1.0 - _accumAlpha) * _nodeU34) * 1.0) * _lightAccu3168));\n(_outgoingLight3167 = f_spe_blend_int(_diffuseColor3153, _outgoingLight3167, (_nodeU34 * 1.0), _nodeU35));\n(_outgoingLight3167 *= _ao3166);\n}\n(out_pc_fragColor = vec4_ctor(_outgoingLight3167, (_accumAlpha * _nodeU36)));\n(out_pc_fragColor.w *= _nodeU38);\n(out_pc_fragColor = f_linearToOutputTexel_float4(out_pc_fragColor));\n(out_pc_fragColor.xyz = f_dithering(out_pc_fragColor.xyz));\nreturn generateOutput();\n}\n\n// COMPILER INPUT HLSL END\n\n// FRAGMENT SHADER END\n\u0000"
                    }
                ],
                "uniformBlocks": [],
                "uniforms": [
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 367",
                                "id": 367,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.1925085335969925,
                            -5.946269989013672,
                            -1.479448676109314,
                            0,
                            1.5082927942276,
                            1.480620265007019,
                            -5.7547173500061035,
                            0,
                            5.939019203186035,
                            -0.1832796186208725,
                            1.5094420909881592,
                            0,
                            -1270.114990234375,
                            -934.184326171875,
                            561.032958984375,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 368",
                                "id": 368,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "modelViewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.19756315648555756,
                            -5.928686618804932,
                            -1.5477728843688965,
                            0,
                            1.5279496908187866,
                            1.5473250150680542,
                            -5.731937885284424,
                            0,
                            5.933826446533203,
                            -0.20104138553142548,
                            1.5274958610534668,
                            0,
                            -1272.02490234375,
                            -940.5895385742188,
                            -14455.302734375,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 369",
                                "id": 369,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "projectionMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.0007603672565892339,
                            0,
                            0,
                            0,
                            0,
                            0.0015251043951138854,
                            0,
                            0,
                            0,
                            0,
                            -0.000009999999747378752,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 370",
                                "id": 370,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "viewMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT4",
                        "value": [
                            0.999994158744812,
                            -0.00003970626858063042,
                            0.0034170825965702534,
                            0,
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598,
                            0,
                            -0.0034173133317381144,
                            -0.011619079858064651,
                            0.9999266862869263,
                            0,
                            -3.0878077872387166e-15,
                            0,
                            -15001.1005859375,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 371",
                                "id": 371,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "normalMatrix",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_MAT3",
                        "value": [
                            0.0052565825171768665,
                            -0.1577451378107071,
                            -0.04118174687027931,
                            0.04065430909395218,
                            0.04116982966661453,
                            -0.15251022577285767,
                            0.15788190066814423,
                            -0.005349128041416407,
                            0.040642235428094864
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 372",
                                "id": 372,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "cameraPosition",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            51.2599983215332,
                            174.3000030517578,
                            15000
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 373",
                                "id": 373,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "isOrthographic",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": true
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 374",
                                "id": 374,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "resolution",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC2",
                        "value": [
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 375",
                                "id": 375,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "aoEnabled",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": false
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 376",
                                "id": 376,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "ambientLightColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            0,
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 377",
                                "id": 377,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "lightProbe",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 9,
                        "type": "FLOAT_VEC3",
                        "values": [
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 378",
                                "id": 378,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "directionalLights[0].direction",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            -0.440809041261673,
                            0.8562363386154175,
                            -0.26934507489204407
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 379",
                                "id": 379,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "directionalLights[0].color",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            2.880840539932251,
                            2.880840539932251,
                            2.880840539932251
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 380",
                                "id": 380,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].direction",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            6.776263578034403e-21,
                            0.9999324679374695,
                            0.011619147844612598
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 381",
                                "id": 381,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].skyColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            2.092608690261841,
                            2.092608690261841,
                            2.092608690261841
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 382",
                                "id": 382,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "hemisphereLights[0].groundColor",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1.2892849445343018,
                            1.2892849445343018,
                            1.2892849445343018
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 383",
                                "id": 383,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU0",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 5
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 384",
                                "id": 384,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU1",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1.5
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 385",
                                "id": 385,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU2",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 3
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 386",
                                "id": 386,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU3",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC2",
                        "value": [
                            1745,
                            870
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 387",
                                "id": 387,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU6",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC2",
                        "value": [
                            0.4985673427581787,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 388",
                                "id": 388,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU7",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 389",
                                "id": 389,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU8",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 27.86949920654297
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 390",
                                "id": 390,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU9",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 175.14022827148438
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 391",
                                "id": 391,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU10",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            -140.86349487304688,
                            102.71446228027344,
                            33.25956726074219
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 392",
                                "id": 392,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU11",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            0,
                            0
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 393",
                                "id": 393,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU12",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": false
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 394",
                                "id": 394,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU13",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 395",
                                "id": 395,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU14",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "INT",
                        "value": 2
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 396",
                                "id": 396,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU15",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            1,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 397",
                                "id": 397,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU16",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 0.10000000149011612
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 398",
                                "id": 398,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU17",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 399",
                                "id": 399,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU18",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 2
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 400",
                                "id": 400,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU19",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 401",
                                "id": 401,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU20",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": false
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 402",
                                "id": 402,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU21",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 403",
                                "id": 403,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU22",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "INT",
                        "value": 3
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 404",
                                "id": 404,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU23",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT_VEC3",
                        "value": [
                            1,
                            1,
                            1
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 405",
                                "id": 405,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU24",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 0.10000000149011612
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 406",
                                "id": 406,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU25",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 407",
                                "id": 407,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU26",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 2
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 408",
                                "id": 408,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU27",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 409",
                                "id": 409,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU28",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": false
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 410",
                                "id": 410,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU29",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 411",
                                "id": 411,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU30",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "INT",
                        "value": 3
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 412",
                                "id": 412,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU31",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 0.8999999761581421
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 413",
                                "id": 413,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU32",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 0.6000000238418579
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 414",
                                "id": 414,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU33",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "BOOL",
                        "value": true
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 415",
                                "id": 415,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU34",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 0.5
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 416",
                                "id": 416,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU35",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "INT",
                        "value": 3
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 417",
                                "id": 417,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU36",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 418",
                                "id": 418,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU37",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 0.6000000238418579
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 419",
                                "id": 419,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU38",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "type": "FLOAT",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 420",
                                "id": 420,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeUA0",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 4,
                        "type": "FLOAT_VEC4",
                        "values": [
                            {
                                "value": [
                                    0.008213827386498451,
                                    0.23190057277679443,
                                    0.5212568044662476,
                                    1
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0.10698281973600388,
                                    0.18638122081756592,
                                    1
                                ]
                            },
                            {
                                "value": [
                                    0,
                                    0.10698281973600388,
                                    0.18638122081756592,
                                    1
                                ]
                            },
                            {
                                "value": [
                                    0.024416930973529816,
                                    0.03410720452666283,
                                    0.06075546145439148,
                                    1
                                ]
                            }
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 421",
                                "id": 421,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeUA1",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 4,
                        "type": "FLOAT",
                        "values": [
                            {
                                "value": 0
                            },
                            {
                                "value": 0.26302361488342285
                            },
                            {
                                "value": 0.5431194305419922
                            },
                            {
                                "value": 0.9511203765869141
                            }
                        ]
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 422",
                                "id": 422,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "aoMap",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "texture": {
                            "anisotropy": 1,
                            "baseLevel": 0,
                            "compareFunc": "LEQUAL",
                            "compareMode": "NONE",
                            "format": "RGBA",
                            "height": 1,
                            "immutable": false,
                            "immutableLevels": 0,
                            "internalFormat": "RGBA",
                            "magFilter": "NEAREST",
                            "maxLevel": 1000,
                            "maxLod": 1000,
                            "minFilter": "NEAREST",
                            "minLod": -1000,
                            "textureType": "UNSIGNED_BYTE",
                            "visual": {
                                "TEXTURE_2D": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAABkhJREFUeF7t1AERAAAIAjHpX9ogPxswPHaOAIGswLLJBSdA4AyAJyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedwAOf2gEBwEDqbgAAAABJRU5ErkJggg=="
                            },
                            "width": 1,
                            "wrapR": "REPEAT",
                            "wrapS": "REPEAT",
                            "wrapT": "REPEAT"
                        },
                        "type": "SAMPLER_2D",
                        "value": 0
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 423",
                                "id": 423,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU4",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "texture": {
                            "anisotropy": 1,
                            "baseLevel": 0,
                            "compareFunc": "LEQUAL",
                            "compareMode": "NONE",
                            "format": "RGBA",
                            "height": 870,
                            "immutable": false,
                            "immutableLevels": 0,
                            "internalFormat": "RGBA16F",
                            "magFilter": "LINEAR",
                            "maxLevel": 1000,
                            "maxLod": 1000,
                            "minFilter": "LINEAR_MIPMAP_LINEAR",
                            "minLod": -1000,
                            "textureType": "HALF_FLOAT",
                            "visual": {
                                "TEXTURE_2D": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAABb1JREFUeF7t2M2rp2MYB/D7nO2UOgs1NkZJkvfMDKGE2GhMNClLLKyIQSOmTqeYTBhiZSFLpYnGZGNCysbMyHuSTubYmN35Dw7N4ixGk87cXc/vd1/3/VEWdJ7r+V6f6+nbmVnYdsml/xT/zEXgxQPPldcOvzmXd3spgXMCCwrAh0BgXAEFMOfbf3z0w/LwvkfnnMLrRxVQAKNe3t4E/BGgjW/gj99/KlddfUMbYaQYSsBvAEOd27IEzhdQAI18EWdWfytXXHlNI2nEGEVAAYxyaXsSuICAAmjoszh+7GjZs3dfQ4lE6V1AAfR+YfsR+B8BBdDY53Ho1ZXy0svLjaUSp1cBBdDrZe1FYAsCCmALSLP+kQf3PFA+Pf7ZrF/rfQMKKIABj25lApsCCqDRb+H6664tP//ya6PpxOpFQAH0ckl7EKgQUAAVaB4h0IuAAujlkvYgUCGgACrQPEKgFwEF0Msl7UGgQkABVKB5hEAvAgqgl0vag0CFgAKoQPMIgV4EFEAvl7QHgQoBBVCB5hECvQgogF4uaQ8CFQIKoALNIwR6EVAACS952fbt5e+zZxMmF7k1AQXQ2kXkITBDAQUwQ+zIV91/373l8xNfRI40a0ABBTDg0a1MYFNAAST+Fg68sL8cfv1I4g1En7eAApj3BbyfwBwFFMAc8SNe/cH775XHnngyYpQZAwoogAGPbmUC/g6go2/g9LfflJ233tnRRlaZlYDfAGYl7T0EGhRQAA0epSbSO2+/UZ5+5vmaRz0zsIACGPj4ViegADr6Bo598lHZ+9AjHW1klakFFMDUwuYTaFhAATR8nJpoO3ZcXtbW/qp51DMDCiiAAY9uZQKbAgqgw29h165byqlT33W4mZWiBRRAtKh5BBIJKIBEx7qYqDffdGP5/ocfL+YRPzuggAIY8OhWJuDvAAb4BhYXF8vGxsYAm1qxVsBvALVyniPQgYAC6OCIViBQK6AAauU8R6ADAQXQwRGtQKBWQAHUyiV7bmlpqayvrydLLe7UAgpgamHzCTQsoAAaPo5oBKYWUABTC5tPoGEBBdDwcaaItv/Zp8qRt96dYrSZCQUUQMKjiUwgSkABREkmmnPP3XeVL7/6OlFiUacSUABTyZpLIIGAAkhwpCki7t69s5w8eXqK0WYmElAAiY4lKoFoAQUQLZpo3srywbK88kqixKJGCyiAaNFE8+64/bby+NpqWf3zTCkL5fx/z+3x3/93of9u/efOZd5qxqCfPXRiW5qvQAGkOZWgBOIFFEC8qYkE0ggogDSnEpRAvIACiDc1kUAaAQWQ5lSCEogXUADxpiYSSCOgANKcSlAC8QIKIN7URAJpBBRAmlMJSiBeQAHEm5pIII2AAkhzKkEJxAsogHhTEwmkEVAAaU4lKIF4AQUQb2oigTQCCiDNqQQlEC+gAOJNTSSQRkABpDmVoATiBRRAvKmJBNIIKIA0pxKUQLyAAog3NZFAGgEFkOZUghKIF1AA8aYmEkgjoADSnEpQAvECCiDe1EQCaQQUQJpTCUogXkABxJuaSCCNgAJIcypBCcQLKIB4UxMJpBFQAGlOJSiBeAEFEG9qIoE0AgogzakEJRAvoADiTU0kkEZAAaQ5laAE4gUUQLypiQTSCCiANKcSlEC8gAKINzWRQBoBBZDmVIISiBdQAPGmJhJII6AA0pxKUALxAgog3tREAmkEFECaUwlKIF5AAcSbmkggjYACSHMqQQnECyiAeFMTCaQRUABpTiUogXgBBRBvaiKBNAIKIM2pBCUQL6AA4k1NJJBGQAGkOZWgBOIFFEC8qYkE0ggogDSnEpRAvIACiDc1kUAaAQWQ5lSCEogXUADxpiYSSCOgANKcSlAC8QIKIN7URAJpBBRAmlMJSiBeQAHEm5pIII2AAkhzKkEJxAsogHhTEwmkEVAAaU4lKIF4AQUQb2oigTQCCiDNqQQlEC/wLzkw5NMX6PehAAAAAElFTkSuQmCC"
                            },
                            "width": 1745,
                            "wrapR": "REPEAT",
                            "wrapS": "CLAMP_TO_EDGE",
                            "wrapT": "CLAMP_TO_EDGE"
                        },
                        "type": "SAMPLER_2D",
                        "value": 1
                    },
                    {
                        "arrayStride": -1,
                        "blockIndice": -1,
                        "location": {
                            "__SPECTOR_Object_TAG": {
                                "displayText": "WebGLUniformLocation - ID: 424",
                                "id": 424,
                                "typeName": "WebGLUniformLocation"
                            }
                        },
                        "matrixStride": -1,
                        "name": "nodeU5",
                        "offset": -1,
                        "rowMajor": false,
                        "size": 1,
                        "texture": {
                            "anisotropy": 1,
                            "baseLevel": 0,
                            "compareFunc": "LEQUAL",
                            "compareMode": "NONE",
                            "format": "RGBA",
                            "height": 1,
                            "immutable": false,
                            "immutableLevels": 0,
                            "internalFormat": "RGBA",
                            "magFilter": "NEAREST",
                            "maxLevel": 1000,
                            "maxLod": 1000,
                            "minFilter": "NEAREST",
                            "minLod": -1000,
                            "textureType": "UNSIGNED_BYTE",
                            "visual": {
                                "TEXTURE_2D": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAABkhJREFUeF7t1AERAAAIAjHpX9ogPxswPHaOAIGswLLJBSdA4AyAJyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedgAHwAwTCAgYgXL7oBAyAHyAQFjAA4fJFJ2AA/ACBsIABCJcvOgED4AcIhAUMQLh80QkYAD9AICxgAMLli07AAPgBAmEBAxAuX3QCBsAPEAgLGIBw+aITMAB+gEBYwACEyxedwAOf2gEBwEDqbgAAAABJRU5ErkJggg=="
                            },
                            "width": 1,
                            "wrapR": "REPEAT",
                            "wrapS": "REPEAT",
                            "wrapT": "REPEAT"
                        },
                        "type": "SAMPLER_2D",
                        "value": 2
                    }
                ]
            },
            "DrawState": {
                "DITHER": true,
                "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
                "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
                "FRONT_FACE": "CCW",
                "RASTERIZER_DISCARD": false,
                "VIEWPORT": [
                    0,
                    0,
                    1745,
                    870
                ]
            },
            "PolygonOffsetState": {
                "POLYGON_OFFSET_FACTOR": 0,
                "POLYGON_OFFSET_FILL": false,
                "POLYGON_OFFSET_UNITS": 0
            },
            "ScissorState": {
                "SCISSOR_BOX": [
                    0,
                    0,
                    300,
                    150
                ],
                "SCISSOR_TEST": false
            },
            "StencilState": {
                "STENCIL_BACK_FAIL": "KEEP",
                "STENCIL_BACK_FUNC": "ALWAYS",
                "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_BACK_REF": 0,
                "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_BITS": "8",
                "STENCIL_FAIL": "KEEP",
                "STENCIL_FUNC": "ALWAYS",
                "STENCIL_PASS_DEPTH_FAIL": "KEEP",
                "STENCIL_PASS_DEPTH_PASS": "KEEP",
                "STENCIL_REF": 0,
                "STENCIL_TEST": false,
                "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
                "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
            },
            "VisualState": {
                "Attachments": [
                    {
                        "attachmentName": "Canvas COLOR_ATTACHMENT",
                        "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAAIABJREFUeF7tfQmQHWeR5vf/Ve9+r+9DUuuyJCxbtiyfYGC83AzrCTA3wzK7G5hZjh1mGFiuBRYMAV4C7wwQy05MBGNgITaAwbCMJwCvGQaYtYcBbLCNAZ+ybCRL1tX3u6tqNzP/v+p/TzKWTMtWd//tkLv7db16f2VV5p/55ZeZqjo4kcB/PSkSeO+7/xM+/om/eFI+23/o45NA4U0/RuOGv0PcOQqVxADoH6lQDJXQ9yj9WfHr9HsEldD3rhyj6PcYin+3x8u5Ej6HqGRCvyOBiun/8jn0H/+ZPztBQt+TBImi7/ZnIMyPImrPIolb8nd5kxzP55DflTcAj+9B8O9avRIY/vpuHPnzzwDdOSSs3GIA7D+VGoPEGAmj6CoCSOEVGQsxAqkxYCV1FF6RfhpjkMjrmSKToouB4GPSvzvKrXPQ+Qqi1gwQR86xmTGhc3gD8CQ/x9+47st4+Stf+ySvwn/8yUhg9D0fQrf2Usx89stI2gdZqe3OLkor3gAZAvEAyAA4ys6KSx5AtvuLgpOi03us8sueL0pujQzt4sYY8K6feQFydGYEdK6KJGohjtuZd+A9gJO51f5YL4HjS2Dys/dg/vrdaPzyJsT1B4xLbsIA4+KzISAlZ2UXY2ANQY+RMLu/3fElDKBwwBgDx+1PXfl09zdKz1FD5ilInKCgwiKSuI0k6iAh7yMNMSSU8B7AafCE33PX7TjzrF2nwUr8Ek5GAsWLPo/82Vsw971rgbgpysXK72IBUab8qREwXoKN6Z1dPvUEGBsQJCB1/Y2hUKn736f0ThhhYgQ2AOxZRC0kSdcYAHNejwGczO32x3oJHCuB0vl/jfLvbcSRr30u2+E5BBBMIHXzHXc/Aw1FEXvi+z5Qj22JCQ8sMJhhAw4OwB6BCRnScELWq4ICewNxZ8EAjAIycpjiQcDT47F+4L5f4YxtO06PxfhVnJQEhq64DvM/+x7i1j7Z7U18T/G4AILG/TdIfAoaMnpvEH83zndCghQDsPG9cfUlUZCh+tlxDkAIRXoPIOBvMWcEXIzBG4CTutH+YC+B40ngwr+9C/tu3ItD138aitxss9tnGIAFBOm7AfFS156MhGJgjw1Gj/JngJ5rCFLld85hgUJJB1qvgbZ5BaUCdv8FAzCZA/YAYu8BnE6P9PXf/Bpe8tJXnU5L8ms5AQls/5ObUbt0DD9/57uAuG6yADYEMAg+p/6yfLwoqc37u7G+C+TZNJ/7PkPbSYA4zf33YQEObqCUZg+AXIAkakuqMk0veg/gBG6vP8RL4LdLYOOr34vqllfivv/1GUTNPbzLSxhAPABDwOlJ72VEnIz4k5F8Mk/AZgMsOcgCgq7ByFKENj1omEI2EQAVFIVWFDWh4izV6DGA0/DJvvqjV+F9H7jqNFyZX9Jvk8DGl/8tjtzxc7RmbhID4MT7lr3n5ugtSp+CgA47LwPzjLIyPmAAP9b97Pyu0mdgInkbcmaK/XW+JpkE4gRETQcI9B6Af6q9BJZEApd88UFM/2Q3HvrKBw078FEU1k35sZYaaq+l6vanBB3DkDL/HCMgfkPmUdiUoRtuKBWy0uv8EOLuHNBpCXXYpwGX5N4v+Ule8uI/wPV//60lP68/4amTwJrnvgLn/oeP4paPfB31g98WdN8g7qmbnyL9/VhArxLzzs0MP+IVOESflMXnpvsk/k+9hp6QI6srIMOgdI49AgsGEtHIpwFP3TPhz7zKJHD2n/0L9t5wPZpHvi+cf1G3nmIcl9TDym2Lcpwcvuz0x4vz+88lx/SmCo3hse+3XgY0GxPe9VUOiCkr0PUG4HR9Rneeew5+cecvT9fl+XUdRwJjl12DQG3C7H1fRtTc5xTggD0CG5dbpU3ddEfZM0zAxPBcCdhXFJS6/MYTsNRh53UXY2CllwRkmmYkb4CMgPcA/KPsJbBEEqie9S6MXvJiJI1Z7P/B1Sbt5uT9zabeC/zZF+U4MQri1huKUAr62RqBtGagT+GzUt/snHJpxvik3oB5TQXeACzRvfen8RLA0760F3N3T+PQ927H/ANfRkSVguRqpzu4ddmzaj8bv7uufP/xwvhzkf/emn6bZZByZDdLYFsLCJaQhhXGINCh3gPwD66XwBJJID+2DRtfdx1mb70XCw9ej27jPsRdKhIy5B5B6tKGH8eL3yVMt16AuP/sFRiGXxrvW8age04pHEhBwVTpe8KPzCPwWYAluvH+NF4CVgITL7oBQRBg7q4bsfaK12LPF95kKvEyRN7m5/tJQClG0NMVyO0HYEhFKaPQAQv7vAyXDCRQpMURDDZpvADvAfhn10tgCSVQ2PQ6bHvLVZi759dYuP0wuosPof7I9VyTn/L1TVwue3Gf22528Z7cvnHrMyXupwY7yu2QkPq9Df7deAP2kr0BWMKb70/lJVDY+Dqc/c734ldXvxcTz/8AwoE89n/zanQW703xgP5sgAnc+9KFRpYOb98aANcQ9Mb8AvbZ/T7FBPq8Az6GqwQ9BuCfWC+BJZVAcfO/A1QeCkXE7YNY8+L3oHNoHo98/51Iug0h4Thxewbg2XjfdddF1W0FYVrp19fVJ3X32a1XKV7QGwZYr8HQASgoIG/A9wNY0vvvT+YlgMLm10OH44hbB1BZ/2KUNq3D4j33Ym73p5AQKGhbdzG6n4Fywh40GGE/6GfChWMrCnvZfgL8WTDQVg5mv2c1Asa4eAPgn1gvgaWVQHHrG9E+cgsKo89BkB9FWDsD+ZEJzP36K2hP/0h69NkmnykDUAxB5tKTHtv0XV/Mn7L8LAgomQMB+8xrPWk/e+5jU4HeA1jae+/P5iWA8T+4AUf++b8gHDwLQX4NimM7MX/vtRh99vtw5AdXI2ofRUJVeVyaezwAzzL8MqOQGowUQHSU2TEUKZ5ggEObAUixAWMY7O/eAPgH1ktgiSVwzmf24b6/+AA6c3dDh1Wsf/U12POFP2Q67tDOT2DxwS+hs/BrJJHBBJxmnzLkw4YC1nV3cAGj2OIt9LYQt3UH3Amspz+g4AgZPJiFDd4ALPHN96fzEiAJlM56O6cApR9fgPb0LemOnx88Dzo3ivbcrewJJHGHh3ccwwZ0wT7j4DPI5/T+d3P8PUpvmn6y2psioJ60oAkZvAFYhs/r2jVrsP/AgWW48tWz5PKOq9BZ+BW6c/dCBSVEzUeA2O7aCcLaFuSq56M9+yMMXfIRHL35bVxBmHCVngwMsWO/UmwgzR5IR18JH6wX4MT5LpZgJgyxcXAYgZwF9F2BV88D6a/0iZVA4Yw3QOlBNA/dAKULiNpzUKTcKTgH6NIIt+iiGX6s/EmMgbM/hMU9/wPoNhFH1MVXXudGo4lJ3jvVgWnMb5B/UfReo2AaD2d4g00t+oYgT+xDsZSf9oLnPxff/Yd/XMpT+nMtoQQK2/4jOrN3MPknpmac3UWpC7Dz/+izdMC1+dyxl44xYJ5CiLA8gbhLDUaBuLMoYYLd7Y0n0IP6p/lDt9BIYn3LDZDwwb4mHoMPAZbwpvtTeQlYCYy97FYc+cEbofNjULkhdKZ/JvF+mqZTUJpadVHbbo2428h69vNrHLwDQR7U0ivuLjCGIF/y3Y35e352uIBSSGTCg7QQyTIGPRNwWT+x737X2/GJaz65rK9hRS9+aBfv6vnRy9A88C2O7wWpNwpM9fgqZAVV0GIg0nmAZodWIVSQE+4AeQFOoZDl9tN36T5smogYD0GGjhxbgcjHm05C3gNY0U+gv7gnUwKDT/sqZn/9ERRGn4HGge9KQZBVSIsFaAWt8oDW/Cea3qOiyAB2ZBkyT0Em+8jMwAxKsCk9UXRpSW5NgT3QNQSO8vvhoE/m47E0n/35a/8ar3/Dm5fmZP4sSy+BgR3IDV2AztGfIepMO267cctFnVnRdVCUECGymQBp5QUa7qG0IP+xmfJrqgRcgyJGoXei8PHYgelrvhho6e+3P6OXQI8EyAAM7EBn/m5EjUM9zUCMz55W5tHvQViR/v1mkq9AAWQGNBDmGSyUCT9ufT9D/+lrGd/fOBw8lciGBxkeQNkCHwKsgOf1pz/+v7jkaZetgCtZgZcQVqAHz+HYvbOw16TzjBJanU0vOzGTfGMksYwZZ3zApviCAnRQ4KwApwiNBUkxPhvzcxggbUDlRykQslyANNvgQ4AV+MD5SzrtJBCMPA1BZRMaB/9JYvgUjXeXamJ3gf+h6Ht/VR+9rkPosIJu6ygUdQy22m/dCcYBso4AljB0TE2AmRrkPYDT7nF5fAv69Cevwdve/q7H92b/rlMqgXDsmYy5t+fvd6bzGrfdsnTYKci4/2nDjtS7t3iAAQWTGLHtMuS8V8yH2flTboCct58q7HkAp/S2+5N7CYgE1r7iG9h/w7sRd+bTBqH9jD3q0y9kn8wIuBV8ROKxYKEhCUj9ADEF01Cgn+jjgII2jHDoxN4ArLAn9Jvf+Cpe+vLXrLCrWhmXkxQ3IIlbhuef7dKZkivJ93fb4sL3NPYQGUhGwBgCSyhi3oAtK7aTiLJUn9gGp2mIOyPAZwFWxsPlr+L0l4CqnYVu86C7wRtXPdvxg7BkioEoDZil89IogTOCIRJTVGQbh2ZpPTt9yBgY4xukGQDLD3CahXgM4PR/dk5qhZs2bsSDD1EZqv863SQQhyNZlx/az23hjgHuQMxAUnAq/CGAz/QPtFkA9gICog/LgE87SchSAnjYpwMckr674F+vVyHGwhuA0+0p8etZsRKIciOMAWQ5+Sxmt6E/of88t4/IPzRQxAB9MktAMWOQCENUO2BHgWXVfr0kII7xLT04TQfa8EC8BG8AVuDjdsnFF+Gnt9y6Aq9seV9SOHQBWvMP9JF4THxvpgGlCqs0dK7MFYRUQ5CFAQr52nq0F/YxCGiHjFjJEBMwQ/ttKGCU3e0SZN7gDcDyfqb86peZBJL8BHcGtsh9unxu1uHk/i3WRxWDRA1mxRYQMF+dQqd+UOoGaNO3Mb0T26cEIAv6SeAg2cW0OYjyHsAye35OeLnnn38ebrvtjhM+3h/4xEkgyY1yjwCXsMPxvW0KbF139vgpPSjpPruf6yDk+J89g3STz1p/yzxBk0noLxumd2TggDcAT9xt95/kJSASGDnvYzjyy2ukEUhf3t/9XbJ+WvoAWFowIQE6RLG2EY1ZIhZlg0QlTSgAofAGzLCRtExYMAdpECLffQiwgp9KrTXitInECr7QZXhphdELUZ++m1fuxuy26ZdxD+TvKkCcEElIuABUD0CeQbezcGy60DYSoTSi2wfQuApiGOTLTwZahg+OX/LKkEBY3QIVFtFZ2I8oavXG5s4lkreulTblAxblB8JcFRG1FefwgF7PRoulsUKKDViNzxqDci7AjwZbGQ+Tv4rlKYHS2EVozD7ASmxLfKU7EH1ppwegeZHy9lwkBAS5CtcCcH8ANgL97r4p/zU7vnQHIm/DDg2QEMGHAMvz2fGrXgESqE39PqqTl2P/Lz6MuNPo7RXgUn7Z8Teuu9bmZ6EOc6NRMiAOczB18VMeQCasntojsgV+NuAKeJL8JSxbCeRqZ6BYOxtzB35oegY6l8Ibf5DWD3BmUIemmSg5CZprB5gxSAxAM2HIFYYF/Xpes/MBvAFYts/NSS98eHgI09MzJ/0+/4ZTL4GhDVdg/tCP0Wke7UPppRuQZQXy7s2tw/KGMmwbjBJtOEZCvQS5OtAwAE0zEX6bLSvuuxzvAZz6++s/wUvgt0pgw66rMXvoRswdpL6BjSy3b/11ogeneX0JB3RY5EwA8Qk47acCwf6SSOYQMHooE4Yz5N82EHFCAh8C+KfTS+DJl8DoplehVd+N+cN38k6efTHyJ/+MB2DxAJ0rQqsQETELjRHgWQNJhG636WQSnYYgLgboy4Gf/BvvV+AlYCVQHd2F+uwedLv1FNSzrrvtBUDNQZVpIU4kIaoXYIVvLwhLgEDCoMDAIBmGtDuQi/7ZbIDPAqy+h+8df/6n+MtP/ffVd+HL5IqLg9vQXDhgxohlvf1o+dwZmJ0BGigircIJDwiCAqJOHd1ug0MFHeYlQxB1EHepeSg1DJEUYE860HsAy+Sp8MtcVRIoDZ2Fbmse7cYhxIbkYwVg5wRQ/E+7PfEBbPzfaU5LQxFOENDfA/ECCCA09QFpD3IlFGIPAq6qR0su9jnPeRa+//0frsIrXz6XPLz+X6PTPIzFmXuy2n9bxMPuABGFJLavDG2VEEAl6DSmOXywHgKFAjGPJBMvgN/KP5juwx4EXD4PhV/p6pJAoboRpYFtiKM65g7dbhRZXPmYyoMdcUxu+yPM7v8HfoXCAc4OmGIiyizYiUFuIRCbAW8AVtdDZa/2qZdcjJ/89JbVefHL7KqrYxegUNuB2YdvRKc9JxWETPyhC5F+YjRkdHDiQjTnHzJThcgQLJpqwxhxl6YJufMCZJiQNwDL7GHwy12dEghLa1Ed2YnZAz9CTPx/0/nH+vUE7mmdR3V4G+rzv0G+MIRW8whnA6jZaKc5m44mt0Cg9wBW57OUXvVVH3o/rvrwx1a5FJbP5VdGdyLITWD+8C2mezDxBawnIPt7eXgrFHJo1R9GmKug05wRliCXByeImTZsm4v4YqDlc/dPwUqf+YxL8foH78f9D+zJBlTaVlSP9d3iSI91nA1UV8JxJ3gt//W7lVNwt+SUpYGzUaitx9yhW02KzzQXM73/i+VJhMVBFCpbMXfwnzlL0KpTO3KZDZDEZAwyw+FDgFN2q/yJvQROnQTy1Y0oVKakqYjSwhsgZ0ArlKvr0Vx4GLnSGGIiFREpqFPnEEC8ATEATBP2IOCpu0n+zF4Cp0oCueJkmtbTNFGIlZwahHRRGd2OxZn7kMsNcNuxMD+INjcR7fA/5gWY6kFvAE7VHfLn9RI4xRLYeNF/w947PsrgH5UGk2IT8YeIQUPrno2Zfd9HsbYOrcWD3EgkotRg1GYcgLgAnEr0HsApvkv+9F4Cp1ACOjfCXYGI9RfwHAHTH0BrhGEZcRwhDIsoDW7D7MGfyt+ZLSipRG8ATuHN8af2EngiJECEIcU1AQMIC4NozN2HiCYHxZHpHRAgXxxFc3E/1weQF8BYgPcAnojb4z/DS+DUS0DnhhDmayhUJlGonMng3/zhnyCKmtA6RGlwE6J2HY2FfakBoHbj3gM49ffGf4KXwBMmAZUbZBd/bP1LuCy4PvsLNBceQm3iArQXH0Zzfq8AgZwOjKGGX/bVpHr5M6HGx9E91EDcpP7jki8sPX0Uh18w9YQt3n+Ql4CXwNJJYPyMK9Fp7UGhcjZa9bsRtWdRn3uAU4YWCFRDL/p0gjgA8iNQpXGocgHBuvVAQKBihO6DB6BLFdT+9Dy0H1hkArEqB1h4x/MQ7929dKv1Z/IS8BJYcglMnvlWzB68EdWhi9BtP4LF6bs49uc6AcoGDFz2nkQFFaj8GFAYRdyaJTYBoAuIZu9HMH4hQAjj+CSCTWMIN9WQ215FvBAhbkYIRnOYedEmwzRa8vX7E3oJeAn8jhKY2PLvMXf4ZgxPvRSN+V9i/uBPOG3I3QVrF/7bBNRUIDcMFMahi2vECOgCoAqALtJoEkCFULk81MAQgvEh6Kka9FQF4doCECigS9MKgPjAHsxf+azfccn+7V4CXgJLKYHS0NkIciVUhp6K5sKdmDt4G0CdhSrnviyhHCKCAlRuACo3AuRHxQCE5BmMSOcQAg3M8EEEOeiBYeixQajBIlAIEW6pIdhQhC4EQA5QeY35P34xur/wc+qX8kb6c3kJPC4JKI3axCWIWnMoDe1Ea+FetJtHoMrnXpFIrzGp1lBBCQir7BGoMmEBZSAsQ4E8ApouSs1FIsStGaigCD2xGapaRtJq8/dgagDhUwYQrC1A1QLoikaIh3Dowksf17r9m7wEvASWRgKjm1+F+swvWI9L1TOxcPTnUJWdr0ik5XA2ZABhEUqXJSwgcDAvXoHOVbmJAJcWRl0kURcqXxLjoQOoYhmqXALKRahyHnr9AHJnVKAGQ6iSRvt/fgTNL352aa7Gn8VLwEvgpCVAFOH67P1cNzA89UKo6vl/KN0BSZFN51Bd24S4NUd+PMifV2EVKIyBcowqX0USUO/xGMjR33JAEAgX2f4rhFCFPFAMgU4EPVBEuGMYuhZCj4XofPtzqH/igye9eP8GLwEvgd9NAhsu+Dhm9l2HxuxDvHGrkZd+gSeKdR76Rx43pGubkXQWZKgAeQWqJEAgGYE8GYAhqFwVCEMgn4POF5AUclD8j14LkXS7SJoRknaXDUDSalHlAVShAD1Rg95YQ7ihjKBwH2Zf/sLf7Yr8u70EvAROSgLj296AhcM3cQNRNfqarydJpwlETSRRh1356Og9vSfkTEAJCKpAbgA6P4QkLPPOr4IQKp8HCnk2AvQaKX7SbgPtLuJ2CyCDQKwjwhrKZQS1GtTUgGQR1pTQeN9zEe1+4KQuwh/sJeAl8DgloDS7//OHfwZV3HBxoouDUIVBhGM7TbsgmiGmudEgTyDlcCAnWQFdQULfCRwMihwiJBT/mx6lCbkVBBaSXxF1qTMhkm4HoHllOg9VqkIVq9ADA9Br6F8FwboS8jvLmL7Ysw4f5y31b/MSOCkJ1MZ/j/Z6qOL6XWZCgDQZDYe2QJVGoPMDnCfk/uM0gaQwAlUcRDT9kKQIafwQQnDyX4VI+OccFxoQf0CZpgPxwoMms1AWoDA/AFUcgCrVoCo16HHKGAxAjxYRnlmB2nMDZv/kTSd1Mf5gLwEvgZOXQHloJ2UBXpnEiweQUCOBfBWIu+wN6NKwgIKa3PoCgoEt/HswsBFxax6d/T8CKGVIoQEpPJOGSlC5Mepchu7BbyNReaiwBoQD7E0kRDwggxES56ACVRqFGhiBHhqEHihBjZaRP28E4fo8Wl/5NOp/dc3JX5V/h5eAl8AJS0DVLn5DomjAYL7GbnrcmhaXn764asg0DyB3Pshx3TH906VJ3vnjNh1LWYAyFBmD3Ch0cSva+74EhINQivCDnMwqJm8ioWNDwzLMQReGoMpj0NURoFCErlUQbh9H/uIRXsLCW5+H6MH7TviC/IFeAl4CJy4BVd31moQUkjIACc0To/5irVkk7UUxAE5LYQ4SKNXHwwkD6PIokqgl2YJY5hap/HqEw89At7EbSWsaiKkNUYP/lg4ojFuSRqQaBGIeBgXoXA0qX8vCg2oN4dZx5HaNIhjLY+byjSd+Vf5ILwEvgROSgKpe8LokiZqswLo8jqSzCJBSx22uGaYe4lRfLCXCXTNzTPL+PKW0MADQfHLa4UnNA1LkNQjXPQvR/D4k7Vk+Z9Jd4NZF4C6l9HkEChaYcAQKE3RRsILCEHR1gg2RKlSgS2XoNcMItxMRCZj/sx0ndGH+IC8BL4HHloCqPfOtSfmiK9HZeye6B29D0l0EuoTc15FQl9GkCxVHXDrIBkBGjwpAaI1AWGR6MKOJbBTGmVhIAwr00DlI2vOSDSDDwh5DF6DPofOFVU4p6oEzoQs1CRWo+MgMMFT5MhufYN06YKHFOEHrWl9s9Ni31h/hJfDYElDVXa9OeGslZc4PIqiSq60Q1/cj6cyJR0A7fJcUVyaK2KmkQXUtcwdol+cwgnjCuRJUcdykDimNWISq0rQSyhIoxJ15JN0GKz9bCWIVEnhIu3/cBbEQqcaAjQS9o1iT5oVJguKLLkK0bx7R3qMIR/ah/jd//NhX6I/wEvASeFQJqNLWZ0stgA6gcxXo2jpoovzSzkxKmHQ5lo87c0C3xUAe4wN2JJGd+ELGgUqGCeijWoJchbkDCSj1NwxFJCLiEnCxURkJTSvReTYGFB7YtCHjAeUNCGpTzBeI5w5BlQaN3UlQuvxidHcfRbR/Bkmzgc53Xu5vr5eAl8DjlIAqbX56IqQfJalA4vYnCrnJC5nyK8Qeyu832CMgFiDo9frDiBYPAFHEfQLYOOicFAoxFpADcmXmBSjuLZCDLq0VDgFCwQWIH9xZEJCQu5SSLQrZ+KjiWiT1/VClKajyGsEF0oGoMfLnnQW0uujuP4Lojs8j2v21xykC/zYvgdUrAVVYf16iaCeO2+LCk/LmK4zwU1NB4gaoAu3gVCxE7L6G7PRUIkwpPEoftuuI5vcgbh0y3gHNMAen9+h9DP6ZOSbh+PmIF44gbs8LQBgTLtA2/QbIeJAx0kB+ALmJy9E58G3xIMpTCIa3QSWB6WkeIbdlG7p7CGicQfdH7wDIS/FfXgJeAicsAVWc2iXTBdNBQ6SDARS78YTQEzqf55+JxUfxOAODxOwvTfBuHUychXBoA9r334Tu9O2IG0f5fHy8PTfxCMg7CPPsRahwgA1DTJ4FTzClc2rBGehf1JE6AzqOzkH041wNQWECqiKeBKUuw6mz0d17N8J1m5E7cwpzH95+whfvD/QSWO0SUAWmAnOvH6RzwxnBV1z7z7o3sJHBOkXlwaEYA04RklEIK4wdUF2Arq5BbuMutO78DrpH70DSmOFzsmJHDZCnocISGNkPiuLqM+DXRtyYRpJ0OLXIBKOFvWwwqEsRhwa0QsNXQH4YurSOP5u9lOIYuof/Bbq6HuGaXdBhDo2vv2y131t//V4CjykBVZg616i7aLtVNqH1MBwAHVCjj1HecYUaLIxA6iXIoCBNHo1bHL8zs6+yFuVLX4v6TV9APL+Hd/iYsgmcNqT3FcQQkPJSjQEZgfaMhArMFaCswwKzBbm2gCaZ0BQTFXA2glqYEf9AVzfzKksXvQntu29Ed+Y2qOIo05UJzGx968rHFIA/wEtgNUtAFdeRAaAv2fHZDCT0s9l1abcnhiABhfSzrRKk9B3t4pQl4JSegH+8S1OZMDH7iqMoP/VKdH5zB9p7vsupQZ5jRjG+GWhojQz7HFR9yOeREcZkbJIWgYTUT6ArGQMz1IANUb6M3MTTEdcfRDjxVOSmdqHz8M8RL+yHLlN4UkYwvg1nr+ZoAAAQ/klEQVSN6165mu+xv3YvgUeVgCquO4c9AGsEjP4bkyDIANfxU6EQ8wAUNLH/uErQ5AApn0+zRhtHoCsTcjzt0txghOaWFZHf8jzO6XceugXdQ7ey18AdSWhXtx/PbEJhHxKxiI0JlyTTv4BTh1SIlJKOkCA3ej6SmMA/BV2chCqNMZWZfRmiIueqCGqb0Ln5Kv8YeAl4CfRJQBXXnpPIzm8afpqfJRywpsGEB6Sw/AdxGqSO2IQKvPmXuC6AMwimjJj/TgqcryAor0e47lLoYgXdQ3cjbh6W8IFYgdSQhJiBtq8A1yF0DeOQvAoKG6g5aYjO9F3GSJC3kCAY3AwkdDxFDdK1iHsP6Byi+QdM2FJEbkChdfMX/EPgJeAlYLf84rodPR6AYeBKYY81AiYkcKUmBoMYetY4SA6fmX30bir3pbJfbiWuTfcgAv6oYegUwuEzGeyL6vvMOWjnp6KiGHFnBkl7ThiD9Bp5E3zuHPclDEfPRkyTTrt14QY0jiBJqL5A5p0Ftc3sdYgHESBqHBQzlRCWkKDwlMvR+fEnET3sW5Z7TVjdElDFtTuECWj2cskEKFFK87IBCXrDgj6jwG+jLwL4ePQ4MQPN9JHSEGcAEq1lXDEZAeovWF7Lu7oNLTgkMJkCIhlJIZG499kaiV08LjUHTGEOkTSJqTgjRUycRkwQVNazERKSEx0X8N9Tg0PGISwhGN6O/NaLUb/udYhn96/up8Ff/aqTgAkBzE6exuJZOJA5+Jmzn+36RPgRwLA/YLD2gJSUUHu2J5xSoJ4AgKrQFKJhrj0gReQOQ+QxUBowLHA2gfQ+rh9lPgAVKHWO3C4gIacHq9xchJmKeepTOIC4OY2keQQJFRO1F6BLY4YvkJfBJzpEXH8EceeoCRHIIyFqclHKkQs1BINTUMEc6l9/y6p7GPwFrz4JiAdgddvW7KcvOO69peHyS2lwIEdaKhFlDqznQMenToQ9D3nxFaELUxqRjEOujKC6DrqyTpQ6T9OIqqyYujYGXSHvQSNukYtPFYUdNG//EtOLuRehASrIK9CVScRcxkxzCw8D7XnhGhCTMVcy5QuRhAzdulQjkuHJSSkyrUX6IERQlQkUz30O5v/qGavvqfBXvGokoIprzzaDQUSxLSDo7uhWGrKLG8W20D1X7qasAeMRZEaB3puCjCmISOyiPGcLCLTjUWMl6iQ0LOlBChGIJ0A/c1Yghi5PIly3g3GFhOoPAo3u/rsQzRDPYFrwCDIolUkE1TWSOaDraU5z8RE3JWVgkTCFEKCaBzIgVLNA/wg/IOXvNBEvHpTiJ6URDm5FOLUTuQ2b0d39d1j82vtXzcPhL3TlSyDzAOyub7ZUgwT8Fgmk8YKTxnNBwcxY2JNwZsCSjawiktJSJ6CwCCovJs+AwwCK2alAiFqVG6+DvunqRoQT50IViEUYMuYQzx2AKg0hadJkY4ovqCLRti+jISVlxPV5oNMy048VVNGAlDmDDxAOQram3WKyUTz/CGJqaEIcBPrc8hiC0a0IxjcgqA4iaTbR+M670X3w5pX/lPgrXLES6DMA1gswJKAsNngUAWSuvXuA9RL6X+PZgjyGzFYMUltxagcwajoOERMwRjiyDdHCw/J28hoofmejQDs3UZFrCEd3IhhaL/0CiEvQaQDtBlOKabpxUj/EGIAenIKujSMYHIEeHkEwPITOQ3sQHaHMQFYGwS3Mux2o8gDC8XU87bh74Dfo7PuJpCnJI8mV2UtRlWEEQ5PQg8NI6nUsXvv8FfuA+Atb2RJQpbU7mAfg1gKlgF22yadSSDMCpJhp7G90tSczcBycwLxkowdSfC45JnYgjyY08wPIQCgi9gwagyGZSi4VNlRk7htQHIPmUuE10OUh8Qpo7kA+j6TTQdJaRNyY5TmG6LaFScidiSgcaCOcPBdBdRTBxCS6hx9BsjCTkZvo8yuDCNdNQVcoUxEjoRTl/ALio9MCNFI9BH1Ouwm0m2h8+83ihfgvL4FlIgHBAFJQTzyAjBnYg/BlxQFpmCCeQor4p8NBjAfhAIHSEFTwAN71a+uhuSFI0+TpDW5A8bhdDw8TCaGLQ6YvATEMpYEpx/emazGl+4IqTTIuANSlmH4f3c5eQTC0Ebo0iM7+O9PWZjTfIJ7dY9qWSVDC3ZAGppBQJsKEHtwSzdYndBqIu4sIiiM8NyE3tQPRUeqHQF5LxOcORjciOXoLFr/7sWVy+/0yV7sEjAFws3jOtp8R9R30r8ex70n/9QrT1BP0gIWmT0CJ0n/r0Jm+N6shMB2GFPUedE5kmYEMCJYGhWZMBUiWKUi7MOX6KXVYHjegoQkdCiNm6nGbKxO5CtEyFKmsmTwCqjmIE8Rxk1OJ5FXw7EOCFalK0jZI5fVFpp2Z5TgkDFaG4xea8uhhzjosfuf1q/258te/TCSgimsoC9CTszNL7/P/XWNgSodT2u5xFNaGEVxUxKGBsSFBgHB0B6IjROcV/oAlFlPfP676S9mFbooxK1RCQGCi8VQIE2BwkdiCmnsSappgTN4DGwvmInNjUjYihP5T9oG8CEorEupPTU6oApE8huokswiZRGRIRWmhE4UmNsXIwCAZHCl3ZqwiSZAb3IXiOf8Gs1+9bJk8An6Zq1kCqrhme+K68RZxz4TSG8sLMGdye/Zn8aJZCdLafXOCtNDH/F2HFVF5UlAm9diIQ5SfSUJ9d8TNSMj5peqQD6b0HfGLTKWieANEAw5kVgG58+05LmCSAaVkiQKhJlPtQqeOuDWTxibMD6BMYWkYmnoXkkEyIQl/crfJ3Yy4WKkPByGjUhg/H6UtV2Lu/1yxmp8rf+3LRAKqNHmW0SgXBzQqaHftVNGPRQUfDTA8ppCIzkH5fu4b6BgAtgApuUDEZoyFvJwuz9gKuwaTzydFdL6sp8FLpqpFIgbxOZVwCOh8bBgiCQniLqLmnHQe5g7FOckoGLuXXjH9jdbN/yjscKwfvddWRyqNgZ3vx8JNb14mj4Bf5mqWgCpObjca5hT/WDDPbMfWhU/9+FRi/QahDz/okaySYh6aEWjYeikKl1mLnmxEPzZpgcTMRTBhgAwh6E1l9KzRISqF1JRUlJdCBTIEcWvBTEAynZHIEyEvwUEjeq6UYxaDVPASpOCJiU06xPBl12Lm731qcDUr1nK5dlWa3M6RuPXqU2W3bbiYHejAck6RUGYQMj6AHOr+bvnApqUXTxgyTUKdrMAxH+EigZZN2Pea6DHF/4anbI2AuaBeLyTLWUrbMapYJLZhiMjMQkyzFBQq0Cm1KYpyNnvRe7sQ8wl0HGEQ3Fq9jIELP4LZG1+zXJ4Bv85VLAFjAHqJPy5w58qmBytwd9jj8AXcSD7tLkQ5fEvHPWY7P56RcV2DHkff7UKQxeiZBvdlJ4x3Y/qKMwBIa9YBAhp5vnAkPTnbN8IVuEW5MBcN6JAZGjY45HWYTAFHI9SvgBqeVlCYfAEad3xqFT9W/tKXiwRUafJM096Di4CdxqD0m5PKM9O6MkhQAL9ezkB22S5wlyoRKR53B3b4Bfyj+VxrA5wwP3X3My++vxbJAHsSDnDqjrIJtqzZLMmuhxWbuAbGbSfFjakpSSTNSBi0tLgCs4ol7Wj7H4i3YXELa2diaGqKmitCF2uID94rxUb+y0vgNJeAKk2cmaQ7tBv1Okh/XwawJ02XXZ9bKWRPZNx/UiTWz8BMG3KkYi0K77SZmy5H9JoRmT3YG+rL3k7hRUZISqnGpmmJmDY5m+bd37Qz4+/E/2+kqUj5WEtwMsCgsULiQFhWImEEBCFQNoOmq1H6sYywshadB//pNL/tfnleAsa5LU5u4zSgaEBvE5CebN+j5OblXY7ypdu9VVabUTAqaHf/1OPv02j3/ce5S5kHkpkITseZ6cRiNkyD0r73axp9blN31FCEsgJMD5ampuLR2Lpny0wkRafehYI1SGgQsMtPLcxiHpNGRYwVBPkKSlMvw+JtH/fPl5fAspCAKk085TjQWjYToNcbz0KCLN3W+9qxZcSZglviUG8BsbFEzsaeKrlJAx4ryQx04J/MTm6ziZT/z0BNY9eIG2Bdd3opV2QF5mpDmmxMjEIH3JO+BqaBCRkAamnOxotKmCscZnTrR015sUZQqCIo1BAduHNZ3Hi/SC8BVp3SxLY+A2Bc6mMqfazAyG3mWSJmi5SiIJf5l6l0v3LLRx3rMfSxBU00wbu5WUcWg/feOMvCy14lb0RQfN6ZC2UkFNNz/l78A67/Jy8hkpHnrmGw3ANeJ2MAFDKQASCOALVGL4I8ic78I0I0Qub+l9dfgcXb/9I/WV4Cy0YCqjSxlRCzY+l3PXw8sxuS4ru8uKyfN1+wBd7s1T9ataBbFJS1FOsrN3Abj7huiFiQzNFI+xnKH3SxysQee96Aho4Yt15GjlN5cYik22a3PjZ0396uRvYKxIpQbM/eS1hAQGh/voj2zH4kUVPsSWmQPYCB7f8Z0z/8o2Vz8/1CvQRUaXxrRr51NVZ862wL5zr+LDOQ5cNNzt9SdC3wZnsAHkfGNs2YqlmKHxrQz8kGiI3JSo8z1bTtxxyegekKJHUAQtCh1BzXAnTlNdrJ+Wd2dMwgUkNJZm/g2NwGx/c0PZlShkQh7syaKkA6RVhAfnCtdCHuBGjvv8k/VV4Cy0YCqjSxJfMA0lSb4xGY4R82Rcbf08Shu1PKtuxm8jLAzUbX4oZnEXyG86cIv0kL2ty7xPI2O2AW2MMhyNZKwFxENN40OqEhJjK+jME6cvn5w8mPoQYjtohHIY5aPeuSowRLCKhHoQ6RG97ChUSN/Vk7ccoqFMeegqC0CfW7v7JsbrxfqJdA/PQ3QpXGtxjtylJllueesuFsr0DK15tmHY8qPkbkTecfLtU1R1pev9N9xPIIUnDQdvi02QgXnUizB45XYvAE8dOphZhMLhaSDlF9SfkVotYCg3b9XykfgK6L6MkWJzCEIbt2cu/D8gjyQxdj/oH/bTAPyQYURjcjLG9DfvhSzP74Hf6p8hI4rSUQ/6u3IVk4Ysb0RVDlsS3SEcj9cuNqTn8Z48CtvNy0nuyTmZZTukxAxDQVR0BZ//kfTUSWedfz90xxM7yg74Qm3KDy3Ww1tPsT1z9B3F7gM6YIRnoQ4QFEChLyD2cFUu9BQIiACoZ0gOrm16K+9xvoLByWbGkChLVxFIfP4w7FUDks3vXF0/rm+8WtZgkoRE+7EsnM3kwXaH9mA2BxtVSvZBdnpXlU5e3diYWMQ226TRhgPQU7NNSeLN3l+/J+7Lebc/b0KHMBAWH4WSPDbzEcBjf3L4quocM85/i5rt8p7JHHQD6LDACdIzaEnuwRMQAgof65EsLyKNqze5F0WmmgU1l7AQ9IzVfPQ9w5goVffW41P2H+2k9TCcQv/CDih38upfP8nJs+GdQWvzx2hk2OpVRY3ml1b5MQfo01pnfHT5WJEwVa8AHrQgv3Luv6c1xj8tvcAxv7W2PjFP0wocfSka1+Z94Cue0U13N+n5F+x8rZa+A1U2GQAQntup1LJA+gOHEhWkfvRFSfSbmJ+YG1yNU2ICisRxzNIlfbhdlbP3SaPgJ+WatVAtEz3oL46G4oam9nOS/0nf51mpkBcHfFtI+/3ShdnXd3z9S376sYtMxCRcrnKLhVvFRP+70IWx54bLzecwP7bYah6DooBnRQEN6eQfatA5DVO9hcosn107HECDTzDum95EEExQHE1Ca8RdOMrUECKusu4XmEucq5WNz7LaAxi5j6EfovL4HTQQL5ErpPfwuSg78CGtTwJoZS0oOTvQDyjP//hO7/B5+Yz9qqp53jAAAAAElFTkSuQmCC",
                        "textureCubeMapFace": null,
                        "textureLayer": 0
                    }
                ],
                "FrameBuffer": null
            },
            "commandArguments": [
                4,
                59994,
                5125,
                0
            ],
            "commandEndTime": 1732773587879.8,
            "endTime": 1732773587977.7,
            "id": 44,
            "name": "drawElements",
            "stackTrace": [
                "WebGLIndexedBufferRenderer.render (https://unpkg.com/three@0.149.0/build/three.module.js:16593:6)",
                "WebGLRenderer.renderBufferDirect (https://unpkg.com/three@0.149.0/build/three.module.js:27764:13)",
                "renderObject (https://unpkg.com/three@0.149.0/build/three.module.js:28274:10)",
                "renderObjects (https://unpkg.com/three@0.149.0/build/three.module.js:28243:5)"
            ],
            "startTime": 1732773587879.8,
            "status": 0,
            "text": "drawElements: TRIANGLES, 59994 indices, UNSIGNED_INT, 0"
        }
    ],
    "context": {
        "capabilities": {
            "ALIASED_LINE_WIDTH_RANGE": [
                1,
                1
            ],
            "ALIASED_POINT_SIZE_RANGE": [
                1,
                1024
            ],
            "ALPHA_BITS": 8,
            "BLUE_BITS": 8,
            "DEPTH_BITS": 24,
            "GREEN_BITS": 8,
            "IMPLEMENTATION_COLOR_READ_FORMAT": "RGBA",
            "IMPLEMENTATION_COLOR_READ_TYPE": "UNSIGNED_BYTE",
            "LINE_WIDTH": 1,
            "MAX_3D_TEXTURE_SIZE": 2048,
            "MAX_ARRAY_TEXTURE_LAYERS": 2048,
            "MAX_CLIENT_WAIT_TIMEOUT_WEBGL": 0,
            "MAX_COLOR_ATTACHMENTS": 8,
            "MAX_COLOR_ATTACHMENTS_WEBGL": "Extension WEBGL_draw_buffers is unavailable.",
            "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS": 200704,
            "MAX_COMBINED_TEXTURE_IMAGE_UNITS": 32,
            "MAX_COMBINED_UNIFORM_BLOCKS": 24,
            "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS": 212992,
            "MAX_CUBE_MAP_TEXTURE_SIZE": 16384,
            "MAX_DRAW_BUFFERS": 8,
            "MAX_DRAW_BUFFERS_WEBGL": "Extension WEBGL_draw_buffers is unavailable.",
            "MAX_ELEMENTS_INDICES": 2147483647,
            "MAX_ELEMENTS_VERTICES": 2147483647,
            "MAX_ELEMENT_INDEX": 4294967294,
            "MAX_FRAGMENT_INPUT_COMPONENTS": 120,
            "MAX_FRAGMENT_UNIFORM_BLOCKS": 12,
            "MAX_FRAGMENT_UNIFORM_COMPONENTS": 4096,
            "MAX_FRAGMENT_UNIFORM_VECTORS": 1024,
            "MAX_PROGRAM_TEXEL_OFFSET": 7,
            "MAX_RENDERBUFFER_SIZE": 16384,
            "MAX_SAMPLES": 16,
            "MAX_SERVER_WAIT_TIMEOUT": 0,
            "MAX_TEXTURE_IMAGE_UNITS": 16,
            "MAX_TEXTURE_LOD_BIAS": 2,
            "MAX_TEXTURE_MAX_ANISOTROPY_EXT": 16,
            "MAX_TEXTURE_SIZE": 16384,
            "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS": 120,
            "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS": 4,
            "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS": 4,
            "MAX_UNIFORM_BLOCK_SIZE": 65536,
            "MAX_UNIFORM_BUFFER_BINDINGS": 24,
            "MAX_VARYING_COMPONENTS": 120,
            "MAX_VARYING_VECTORS": 30,
            "MAX_VERTEX_ATTRIBS": 16,
            "MAX_VERTEX_OUTPUT_COMPONENTS": 120,
            "MAX_VERTEX_TEXTURE_IMAGE_UNITS": 16,
            "MAX_VERTEX_UNIFORM_BLOCKS": 12,
            "MAX_VERTEX_UNIFORM_COMPONENTS": 16384,
            "MAX_VERTEX_UNIFORM_VECTORS": 4096,
            "MAX_VIEWPORT_DIMS": [
                32767,
                32767
            ],
            "MIN_PROGRAM_TEXEL_OFFSET": -8,
            "RED_BITS": 8,
            "RENDERER": "WebKit WebGL",
            "SAMPLES": 0,
            "SAMPLE_BUFFERS": 0,
            "SHADING_LANGUAGE_VERSION": "WebGL GLSL ES 3.00 (OpenGL ES GLSL ES 3.0 Chromium)",
            "STENCIL_BITS": 8,
            "SUBPIXEL_BITS": 4,
            "VENDOR": "WebKit",
            "VERSION": "WebGL 2.0 (OpenGL ES 3.0 Chromium)"
        },
        "compressedTextures": {
            "COMPRESSED_TEXTURE_FORMATS": [
                "COMPRESSED_RGB_S3TC_DXT1_EXT",
                "COMPRESSED_RGBA_S3TC_DXT1_EXT",
                "COMPRESSED_RGBA_S3TC_DXT3_EXT",
                "COMPRESSED_RGBA_S3TC_DXT5_EXT"
            ]
        },
        "contextAttributes": {
            "alpha": true,
            "antialias": false,
            "depth": true,
            "desynchronized": false,
            "failIfMajorPerformanceCaveat": false,
            "powerPreference": "default",
            "premultipliedAlpha": true,
            "preserveDrawingBuffer": false,
            "stencil": true,
            "xrCompatible": false
        },
        "extensions": {
            "EXT_color_buffer_float": true,
            "EXT_disjoint_timer_query": false,
            "EXT_disjoint_timer_query_webgl2": true,
            "EXT_texture_filter_anisotropic": true,
            "OES_texture_float_linear": true,
            "WEBGL_compressed_texture_astc": false,
            "WEBGL_compressed_texture_atc": false,
            "WEBGL_compressed_texture_etc": false,
            "WEBGL_compressed_texture_etc1": false,
            "WEBGL_compressed_texture_pvrtc": false,
            "WEBGL_compressed_texture_s3tc": true,
            "WEBGL_draw_instanced_base_vertex_base_instance": false,
            "WEBGL_multi_draw": true,
            "WEBGL_multi_draw_instanced_base_vertex_base_instance": false
        },
        "version": 2
    },
    "endState": {
        "AlignmentState": {
            "PACK_ALIGNMENT": 4,
            "PACK_ROW_LENGTH": 0,
            "PACK_SKIP_PIXELS": 0,
            "PACK_SKIP_ROWS": 0,
            "UNPACK_ALIGNMENT": 4,
            "UNPACK_COLORSPACE_CONVERSION_WEBGL": "BROWSER_DEFAULT_WEBGL",
            "UNPACK_FLIP_Y_WEBGL": false,
            "UNPACK_IMAGE_HEIGHT": 0,
            "UNPACK_PREMULTIPLY_ALPHA_WEBGL": false,
            "UNPACK_SKIP_IMAGES": 0,
            "UNPACK_SKIP_PIXELS": 0,
            "UNPACK_SKIP_ROWS": 0
        },
        "BlendState": {
            "BLEND": false,
            "BLEND_COLOR": [
                0,
                0,
                0,
                0
            ],
            "BLEND_DST_ALPHA": "ZERO",
            "BLEND_DST_RGB": "ZERO",
            "BLEND_EQUATION_ALPHA": "FUNC_ADD",
            "BLEND_EQUATION_RGB": "FUNC_ADD",
            "BLEND_SRC_ALPHA": "ONE",
            "BLEND_SRC_RGB": "ONE"
        },
        "ClearState": {
            "COLOR_CLEAR_VALUE": [
                0.0470588244497776,
                0.05882352963089943,
                0.08627451211214066,
                1
            ],
            "DEPTH_CLEAR_VALUE": 1,
            "STENCIL_CLEAR_VALUE": 0
        },
        "ColorState": {
            "COLOR_WRITEMASK": [
                true,
                true,
                true,
                true
            ]
        },
        "CoverageState": {
            "SAMPLE_ALPHA_TO_COVERAGE": false,
            "SAMPLE_COVERAGE": false,
            "SAMPLE_COVERAGE_INVERT": false,
            "SAMPLE_COVERAGE_VALUE": 1
        },
        "CullState": {
            "CULL_FACE": true,
            "CULL_FACE_MODE": "BACK"
        },
        "DepthState": {
            "DEPTH_FUNC": "LEQUAL",
            "DEPTH_RANGE": [
                0,
                1
            ],
            "DEPTH_TEST": true,
            "DEPTH_WRITEMASK": true
        },
        "DrawState": {
            "DITHER": true,
            "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
            "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
            "FRONT_FACE": "CCW",
            "RASTERIZER_DISCARD": false,
            "VIEWPORT": [
                0,
                0,
                1745,
                870
            ]
        },
        "MipmapHintState": {
            "GENERATE_MIPMAP_HINT": 4352
        },
        "PolygonOffsetState": {
            "POLYGON_OFFSET_FACTOR": 0,
            "POLYGON_OFFSET_FILL": false,
            "POLYGON_OFFSET_UNITS": 0
        },
        "ScissorState": {
            "SCISSOR_BOX": [
                0,
                0,
                300,
                150
            ],
            "SCISSOR_TEST": false
        },
        "StencilState": {
            "STENCIL_BACK_FAIL": "KEEP",
            "STENCIL_BACK_FUNC": "ALWAYS",
            "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
            "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
            "STENCIL_BACK_REF": 0,
            "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
            "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
            "STENCIL_BITS": "8",
            "STENCIL_FAIL": "KEEP",
            "STENCIL_FUNC": "ALWAYS",
            "STENCIL_PASS_DEPTH_FAIL": "KEEP",
            "STENCIL_PASS_DEPTH_PASS": "KEEP",
            "STENCIL_REF": 0,
            "STENCIL_TEST": false,
            "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
            "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
        },
        "VisualState": {
            "Attachments": [
                {
                    "attachmentName": "Canvas COLOR_ATTACHMENT",
                    "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAAIABJREFUeF7tfQmQHWeR5vf/Ve9+r+9DUuuyJCxbtiyfYGC83AzrCTA3wzK7G5hZjh1mGFiuBRYMAV4C7wwQy05MBGNgITaAwbCMJwCvGQaYtYcBbLCNAZ+ybCRL1tX3u6tqNzP/v+p/TzKWTMtWd//tkLv7db16f2VV5p/55ZeZqjo4kcB/PSkSeO+7/xM+/om/eFI+23/o45NA4U0/RuOGv0PcOQqVxADoH6lQDJXQ9yj9WfHr9HsEldD3rhyj6PcYin+3x8u5Ej6HqGRCvyOBiun/8jn0H/+ZPztBQt+TBImi7/ZnIMyPImrPIolb8nd5kxzP55DflTcAj+9B8O9avRIY/vpuHPnzzwDdOSSs3GIA7D+VGoPEGAmj6CoCSOEVGQsxAqkxYCV1FF6RfhpjkMjrmSKToouB4GPSvzvKrXPQ+Qqi1gwQR86xmTGhc3gD8CQ/x9+47st4+Stf+ySvwn/8yUhg9D0fQrf2Usx89stI2gdZqe3OLkor3gAZAvEAyAA4ys6KSx5AtvuLgpOi03us8sueL0pujQzt4sYY8K6feQFydGYEdK6KJGohjtuZd+A9gJO51f5YL4HjS2Dys/dg/vrdaPzyJsT1B4xLbsIA4+KzISAlZ2UXY2ANQY+RMLu/3fElDKBwwBgDx+1PXfl09zdKz1FD5ilInKCgwiKSuI0k6iAh7yMNMSSU8B7AafCE33PX7TjzrF2nwUr8Ek5GAsWLPo/82Vsw971rgbgpysXK72IBUab8qREwXoKN6Z1dPvUEGBsQJCB1/Y2hUKn736f0ThhhYgQ2AOxZRC0kSdcYAHNejwGczO32x3oJHCuB0vl/jfLvbcSRr30u2+E5BBBMIHXzHXc/Aw1FEXvi+z5Qj22JCQ8sMJhhAw4OwB6BCRnScELWq4ICewNxZ8EAjAIycpjiQcDT47F+4L5f4YxtO06PxfhVnJQEhq64DvM/+x7i1j7Z7U18T/G4AILG/TdIfAoaMnpvEH83zndCghQDsPG9cfUlUZCh+tlxDkAIRXoPIOBvMWcEXIzBG4CTutH+YC+B40ngwr+9C/tu3ItD138aitxss9tnGIAFBOm7AfFS156MhGJgjw1Gj/JngJ5rCFLld85hgUJJB1qvgbZ5BaUCdv8FAzCZA/YAYu8BnE6P9PXf/Bpe8tJXnU5L8ms5AQls/5ObUbt0DD9/57uAuG6yADYEMAg+p/6yfLwoqc37u7G+C+TZNJ/7PkPbSYA4zf33YQEObqCUZg+AXIAkakuqMk0veg/gBG6vP8RL4LdLYOOr34vqllfivv/1GUTNPbzLSxhAPABDwOlJ72VEnIz4k5F8Mk/AZgMsOcgCgq7ByFKENj1omEI2EQAVFIVWFDWh4izV6DGA0/DJvvqjV+F9H7jqNFyZX9Jvk8DGl/8tjtzxc7RmbhID4MT7lr3n5ugtSp+CgA47LwPzjLIyPmAAP9b97Pyu0mdgInkbcmaK/XW+JpkE4gRETQcI9B6Af6q9BJZEApd88UFM/2Q3HvrKBw078FEU1k35sZYaaq+l6vanBB3DkDL/HCMgfkPmUdiUoRtuKBWy0uv8EOLuHNBpCXXYpwGX5N4v+Ule8uI/wPV//60lP68/4amTwJrnvgLn/oeP4paPfB31g98WdN8g7qmbnyL9/VhArxLzzs0MP+IVOESflMXnpvsk/k+9hp6QI6srIMOgdI49AgsGEtHIpwFP3TPhz7zKJHD2n/0L9t5wPZpHvi+cf1G3nmIcl9TDym2Lcpwcvuz0x4vz+88lx/SmCo3hse+3XgY0GxPe9VUOiCkr0PUG4HR9Rneeew5+cecvT9fl+XUdRwJjl12DQG3C7H1fRtTc5xTggD0CG5dbpU3ddEfZM0zAxPBcCdhXFJS6/MYTsNRh53UXY2CllwRkmmYkb4CMgPcA/KPsJbBEEqie9S6MXvJiJI1Z7P/B1Sbt5uT9zabeC/zZF+U4MQri1huKUAr62RqBtGagT+GzUt/snHJpxvik3oB5TQXeACzRvfen8RLA0760F3N3T+PQ927H/ANfRkSVguRqpzu4ddmzaj8bv7uufP/xwvhzkf/emn6bZZByZDdLYFsLCJaQhhXGINCh3gPwD66XwBJJID+2DRtfdx1mb70XCw9ej27jPsRdKhIy5B5B6tKGH8eL3yVMt16AuP/sFRiGXxrvW8age04pHEhBwVTpe8KPzCPwWYAluvH+NF4CVgITL7oBQRBg7q4bsfaK12LPF95kKvEyRN7m5/tJQClG0NMVyO0HYEhFKaPQAQv7vAyXDCRQpMURDDZpvADvAfhn10tgCSVQ2PQ6bHvLVZi759dYuP0wuosPof7I9VyTn/L1TVwue3Gf22528Z7cvnHrMyXupwY7yu2QkPq9Df7deAP2kr0BWMKb70/lJVDY+Dqc/c734ldXvxcTz/8AwoE89n/zanQW703xgP5sgAnc+9KFRpYOb98aANcQ9Mb8AvbZ/T7FBPq8Az6GqwQ9BuCfWC+BJZVAcfO/A1QeCkXE7YNY8+L3oHNoHo98/51Iug0h4Thxewbg2XjfdddF1W0FYVrp19fVJ3X32a1XKV7QGwZYr8HQASgoIG/A9wNY0vvvT+YlgMLm10OH44hbB1BZ/2KUNq3D4j33Ym73p5AQKGhbdzG6n4Fywh40GGE/6GfChWMrCnvZfgL8WTDQVg5mv2c1Asa4eAPgn1gvgaWVQHHrG9E+cgsKo89BkB9FWDsD+ZEJzP36K2hP/0h69NkmnykDUAxB5tKTHtv0XV/Mn7L8LAgomQMB+8xrPWk/e+5jU4HeA1jae+/P5iWA8T+4AUf++b8gHDwLQX4NimM7MX/vtRh99vtw5AdXI2ofRUJVeVyaezwAzzL8MqOQGowUQHSU2TEUKZ5ggEObAUixAWMY7O/eAPgH1ktgiSVwzmf24b6/+AA6c3dDh1Wsf/U12POFP2Q67tDOT2DxwS+hs/BrJJHBBJxmnzLkw4YC1nV3cAGj2OIt9LYQt3UH3Amspz+g4AgZPJiFDd4ALPHN96fzEiAJlM56O6cApR9fgPb0LemOnx88Dzo3ivbcrewJJHGHh3ccwwZ0wT7j4DPI5/T+d3P8PUpvmn6y2psioJ60oAkZvAFYhs/r2jVrsP/AgWW48tWz5PKOq9BZ+BW6c/dCBSVEzUeA2O7aCcLaFuSq56M9+yMMXfIRHL35bVxBmHCVngwMsWO/UmwgzR5IR18JH6wX4MT5LpZgJgyxcXAYgZwF9F2BV88D6a/0iZVA4Yw3QOlBNA/dAKULiNpzUKTcKTgH6NIIt+iiGX6s/EmMgbM/hMU9/wPoNhFH1MVXXudGo4lJ3jvVgWnMb5B/UfReo2AaD2d4g00t+oYgT+xDsZSf9oLnPxff/Yd/XMpT+nMtoQQK2/4jOrN3MPknpmac3UWpC7Dz/+izdMC1+dyxl44xYJ5CiLA8gbhLDUaBuLMoYYLd7Y0n0IP6p/lDt9BIYn3LDZDwwb4mHoMPAZbwpvtTeQlYCYy97FYc+cEbofNjULkhdKZ/JvF+mqZTUJpadVHbbo2428h69vNrHLwDQR7U0ivuLjCGIF/y3Y35e352uIBSSGTCg7QQyTIGPRNwWT+x737X2/GJaz65rK9hRS9+aBfv6vnRy9A88C2O7wWpNwpM9fgqZAVV0GIg0nmAZodWIVSQE+4AeQFOoZDl9tN36T5smogYD0GGjhxbgcjHm05C3gNY0U+gv7gnUwKDT/sqZn/9ERRGn4HGge9KQZBVSIsFaAWt8oDW/Cea3qOiyAB2ZBkyT0Em+8jMwAxKsCk9UXRpSW5NgT3QNQSO8vvhoE/m47E0n/35a/8ar3/Dm5fmZP4sSy+BgR3IDV2AztGfIepMO267cctFnVnRdVCUECGymQBp5QUa7qG0IP+xmfJrqgRcgyJGoXei8PHYgelrvhho6e+3P6OXQI8EyAAM7EBn/m5EjUM9zUCMz55W5tHvQViR/v1mkq9AAWQGNBDmGSyUCT9ufT9D/+lrGd/fOBw8lciGBxkeQNkCHwKsgOf1pz/+v7jkaZetgCtZgZcQVqAHz+HYvbOw16TzjBJanU0vOzGTfGMksYwZZ3zApviCAnRQ4KwApwiNBUkxPhvzcxggbUDlRykQslyANNvgQ4AV+MD5SzrtJBCMPA1BZRMaB/9JYvgUjXeXamJ3gf+h6Ht/VR+9rkPosIJu6ygUdQy22m/dCcYBso4AljB0TE2AmRrkPYDT7nF5fAv69Cevwdve/q7H92b/rlMqgXDsmYy5t+fvd6bzGrfdsnTYKci4/2nDjtS7t3iAAQWTGLHtMuS8V8yH2flTboCct58q7HkAp/S2+5N7CYgE1r7iG9h/w7sRd+bTBqH9jD3q0y9kn8wIuBV8ROKxYKEhCUj9ADEF01Cgn+jjgII2jHDoxN4ArLAn9Jvf+Cpe+vLXrLCrWhmXkxQ3IIlbhuef7dKZkivJ93fb4sL3NPYQGUhGwBgCSyhi3oAtK7aTiLJUn9gGp2mIOyPAZwFWxsPlr+L0l4CqnYVu86C7wRtXPdvxg7BkioEoDZil89IogTOCIRJTVGQbh2ZpPTt9yBgY4xukGQDLD3CahXgM4PR/dk5qhZs2bsSDD1EZqv863SQQhyNZlx/az23hjgHuQMxAUnAq/CGAz/QPtFkA9gICog/LgE87SchSAnjYpwMckr674F+vVyHGwhuA0+0p8etZsRKIciOMAWQ5+Sxmt6E/of88t4/IPzRQxAB9MktAMWOQCENUO2BHgWXVfr0kII7xLT04TQfa8EC8BG8AVuDjdsnFF+Gnt9y6Aq9seV9SOHQBWvMP9JF4THxvpgGlCqs0dK7MFYRUQ5CFAQr52nq0F/YxCGiHjFjJEBMwQ/ttKGCU3e0SZN7gDcDyfqb86peZBJL8BHcGtsh9unxu1uHk/i3WRxWDRA1mxRYQMF+dQqd+UOoGaNO3Mb0T26cEIAv6SeAg2cW0OYjyHsAye35OeLnnn38ebrvtjhM+3h/4xEkgyY1yjwCXsMPxvW0KbF139vgpPSjpPruf6yDk+J89g3STz1p/yzxBk0noLxumd2TggDcAT9xt95/kJSASGDnvYzjyy2ukEUhf3t/9XbJ+WvoAWFowIQE6RLG2EY1ZIhZlg0QlTSgAofAGzLCRtExYMAdpECLffQiwgp9KrTXitInECr7QZXhphdELUZ++m1fuxuy26ZdxD+TvKkCcEElIuABUD0CeQbezcGy60DYSoTSi2wfQuApiGOTLTwZahg+OX/LKkEBY3QIVFtFZ2I8oavXG5s4lkreulTblAxblB8JcFRG1FefwgF7PRoulsUKKDViNzxqDci7AjwZbGQ+Tv4rlKYHS2EVozD7ASmxLfKU7EH1ppwegeZHy9lwkBAS5CtcCcH8ANgL97r4p/zU7vnQHIm/DDg2QEMGHAMvz2fGrXgESqE39PqqTl2P/Lz6MuNPo7RXgUn7Z8Teuu9bmZ6EOc6NRMiAOczB18VMeQCasntojsgV+NuAKeJL8JSxbCeRqZ6BYOxtzB35oegY6l8Ibf5DWD3BmUIemmSg5CZprB5gxSAxAM2HIFYYF/Xpes/MBvAFYts/NSS98eHgI09MzJ/0+/4ZTL4GhDVdg/tCP0Wke7UPppRuQZQXy7s2tw/KGMmwbjBJtOEZCvQS5OtAwAE0zEX6bLSvuuxzvAZz6++s/wUvgt0pgw66rMXvoRswdpL6BjSy3b/11ogeneX0JB3RY5EwA8Qk47acCwf6SSOYQMHooE4Yz5N82EHFCAh8C+KfTS+DJl8DoplehVd+N+cN38k6efTHyJ/+MB2DxAJ0rQqsQETELjRHgWQNJhG636WQSnYYgLgboy4Gf/BvvV+AlYCVQHd2F+uwedLv1FNSzrrvtBUDNQZVpIU4kIaoXYIVvLwhLgEDCoMDAIBmGtDuQi/7ZbIDPAqy+h+8df/6n+MtP/ffVd+HL5IqLg9vQXDhgxohlvf1o+dwZmJ0BGigircIJDwiCAqJOHd1ug0MFHeYlQxB1EHepeSg1DJEUYE860HsAy+Sp8MtcVRIoDZ2Fbmse7cYhxIbkYwVg5wRQ/E+7PfEBbPzfaU5LQxFOENDfA/ECCCA09QFpD3IlFGIPAq6qR0su9jnPeRa+//0frsIrXz6XPLz+X6PTPIzFmXuy2n9bxMPuABGFJLavDG2VEEAl6DSmOXywHgKFAjGPJBMvgN/KP5juwx4EXD4PhV/p6pJAoboRpYFtiKM65g7dbhRZXPmYyoMdcUxu+yPM7v8HfoXCAc4OmGIiyizYiUFuIRCbAW8AVtdDZa/2qZdcjJ/89JbVefHL7KqrYxegUNuB2YdvRKc9JxWETPyhC5F+YjRkdHDiQjTnHzJThcgQLJpqwxhxl6YJufMCZJiQNwDL7GHwy12dEghLa1Ed2YnZAz9CTPx/0/nH+vUE7mmdR3V4G+rzv0G+MIRW8whnA6jZaKc5m44mt0Cg9wBW57OUXvVVH3o/rvrwx1a5FJbP5VdGdyLITWD+8C2mezDxBawnIPt7eXgrFHJo1R9GmKug05wRliCXByeImTZsm4v4YqDlc/dPwUqf+YxL8foH78f9D+zJBlTaVlSP9d3iSI91nA1UV8JxJ3gt//W7lVNwt+SUpYGzUaitx9yhW02KzzQXM73/i+VJhMVBFCpbMXfwnzlL0KpTO3KZDZDEZAwyw+FDgFN2q/yJvQROnQTy1Y0oVKakqYjSwhsgZ0ArlKvr0Vx4GLnSGGIiFREpqFPnEEC8ATEATBP2IOCpu0n+zF4Cp0oCueJkmtbTNFGIlZwahHRRGd2OxZn7kMsNcNuxMD+INjcR7fA/5gWY6kFvAE7VHfLn9RI4xRLYeNF/w947PsrgH5UGk2IT8YeIQUPrno2Zfd9HsbYOrcWD3EgkotRg1GYcgLgAnEr0HsApvkv+9F4Cp1ACOjfCXYGI9RfwHAHTH0BrhGEZcRwhDIsoDW7D7MGfyt+ZLSipRG8ATuHN8af2EngiJECEIcU1AQMIC4NozN2HiCYHxZHpHRAgXxxFc3E/1weQF8BYgPcAnojb4z/DS+DUS0DnhhDmayhUJlGonMng3/zhnyCKmtA6RGlwE6J2HY2FfakBoHbj3gM49ffGf4KXwBMmAZUbZBd/bP1LuCy4PvsLNBceQm3iArQXH0Zzfq8AgZwOjKGGX/bVpHr5M6HGx9E91EDcpP7jki8sPX0Uh18w9YQt3n+Ql4CXwNJJYPyMK9Fp7UGhcjZa9bsRtWdRn3uAU4YWCFRDL/p0gjgA8iNQpXGocgHBuvVAQKBihO6DB6BLFdT+9Dy0H1hkArEqB1h4x/MQ7929dKv1Z/IS8BJYcglMnvlWzB68EdWhi9BtP4LF6bs49uc6AcoGDFz2nkQFFaj8GFAYRdyaJTYBoAuIZu9HMH4hQAjj+CSCTWMIN9WQ215FvBAhbkYIRnOYedEmwzRa8vX7E3oJeAn8jhKY2PLvMXf4ZgxPvRSN+V9i/uBPOG3I3QVrF/7bBNRUIDcMFMahi2vECOgCoAqALtJoEkCFULk81MAQgvEh6Kka9FQF4doCECigS9MKgPjAHsxf+azfccn+7V4CXgJLKYHS0NkIciVUhp6K5sKdmDt4G0CdhSrnviyhHCKCAlRuACo3AuRHxQCE5BmMSOcQAg3M8EEEOeiBYeixQajBIlAIEW6pIdhQhC4EQA5QeY35P34xur/wc+qX8kb6c3kJPC4JKI3axCWIWnMoDe1Ea+FetJtHoMrnXpFIrzGp1lBBCQir7BGoMmEBZSAsQ4E8ApouSs1FIsStGaigCD2xGapaRtJq8/dgagDhUwYQrC1A1QLoikaIh3Dowksf17r9m7wEvASWRgKjm1+F+swvWI9L1TOxcPTnUJWdr0ik5XA2ZABhEUqXJSwgcDAvXoHOVbmJAJcWRl0kURcqXxLjoQOoYhmqXALKRahyHnr9AHJnVKAGQ6iSRvt/fgTNL352aa7Gn8VLwEvgpCVAFOH67P1cNzA89UKo6vl/KN0BSZFN51Bd24S4NUd+PMifV2EVKIyBcowqX0USUO/xGMjR33JAEAgX2f4rhFCFPFAMgU4EPVBEuGMYuhZCj4XofPtzqH/igye9eP8GLwEvgd9NAhsu+Dhm9l2HxuxDvHGrkZd+gSeKdR76Rx43pGubkXQWZKgAeQWqJEAgGYE8GYAhqFwVCEMgn4POF5AUclD8j14LkXS7SJoRknaXDUDSalHlAVShAD1Rg95YQ7ihjKBwH2Zf/sLf7Yr8u70EvAROSgLj296AhcM3cQNRNfqarydJpwlETSRRh1356Og9vSfkTEAJCKpAbgA6P4QkLPPOr4IQKp8HCnk2AvQaKX7SbgPtLuJ2CyCDQKwjwhrKZQS1GtTUgGQR1pTQeN9zEe1+4KQuwh/sJeAl8DgloDS7//OHfwZV3HBxoouDUIVBhGM7TbsgmiGmudEgTyDlcCAnWQFdQULfCRwMihwiJBT/mx6lCbkVBBaSXxF1qTMhkm4HoHllOg9VqkIVq9ADA9Br6F8FwboS8jvLmL7Ysw4f5y31b/MSOCkJ1MZ/j/Z6qOL6XWZCgDQZDYe2QJVGoPMDnCfk/uM0gaQwAlUcRDT9kKQIafwQQnDyX4VI+OccFxoQf0CZpgPxwoMms1AWoDA/AFUcgCrVoCo16HHKGAxAjxYRnlmB2nMDZv/kTSd1Mf5gLwEvgZOXQHloJ2UBXpnEiweQUCOBfBWIu+wN6NKwgIKa3PoCgoEt/HswsBFxax6d/T8CKGVIoQEpPJOGSlC5Mepchu7BbyNReaiwBoQD7E0kRDwggxES56ACVRqFGhiBHhqEHihBjZaRP28E4fo8Wl/5NOp/dc3JX5V/h5eAl8AJS0DVLn5DomjAYL7GbnrcmhaXn764asg0DyB3Pshx3TH906VJ3vnjNh1LWYAyFBmD3Ch0cSva+74EhINQivCDnMwqJm8ioWNDwzLMQReGoMpj0NURoFCErlUQbh9H/uIRXsLCW5+H6MH7TviC/IFeAl4CJy4BVd31moQUkjIACc0To/5irVkk7UUxAE5LYQ4SKNXHwwkD6PIokqgl2YJY5hap/HqEw89At7EbSWsaiKkNUYP/lg4ojFuSRqQaBGIeBgXoXA0qX8vCg2oN4dZx5HaNIhjLY+byjSd+Vf5ILwEvgROSgKpe8LokiZqswLo8jqSzCJBSx22uGaYe4lRfLCXCXTNzTPL+PKW0MADQfHLa4UnNA1LkNQjXPQvR/D4k7Vk+Z9Jd4NZF4C6l9HkEChaYcAQKE3RRsILCEHR1gg2RKlSgS2XoNcMItxMRCZj/sx0ndGH+IC8BL4HHloCqPfOtSfmiK9HZeye6B29D0l0EuoTc15FQl9GkCxVHXDrIBkBGjwpAaI1AWGR6MKOJbBTGmVhIAwr00DlI2vOSDSDDwh5DF6DPofOFVU4p6oEzoQs1CRWo+MgMMFT5MhufYN06YKHFOEHrWl9s9Ni31h/hJfDYElDVXa9OeGslZc4PIqiSq60Q1/cj6cyJR0A7fJcUVyaK2KmkQXUtcwdol+cwgnjCuRJUcdykDimNWISq0rQSyhIoxJ15JN0GKz9bCWIVEnhIu3/cBbEQqcaAjQS9o1iT5oVJguKLLkK0bx7R3qMIR/ah/jd//NhX6I/wEvASeFQJqNLWZ0stgA6gcxXo2jpoovzSzkxKmHQ5lo87c0C3xUAe4wN2JJGd+ELGgUqGCeijWoJchbkDCSj1NwxFJCLiEnCxURkJTSvReTYGFB7YtCHjAeUNCGpTzBeI5w5BlQaN3UlQuvxidHcfRbR/Bkmzgc53Xu5vr5eAl8DjlIAqbX56IqQfJalA4vYnCrnJC5nyK8Qeyu832CMgFiDo9frDiBYPAFHEfQLYOOicFAoxFpADcmXmBSjuLZCDLq0VDgFCwQWIH9xZEJCQu5SSLQrZ+KjiWiT1/VClKajyGsEF0oGoMfLnnQW0uujuP4Lojs8j2v21xykC/zYvgdUrAVVYf16iaCeO2+LCk/LmK4zwU1NB4gaoAu3gVCxE7L6G7PRUIkwpPEoftuuI5vcgbh0y3gHNMAen9+h9DP6ZOSbh+PmIF44gbs8LQBgTLtA2/QbIeJAx0kB+ALmJy9E58G3xIMpTCIa3QSWB6WkeIbdlG7p7CGicQfdH7wDIS/FfXgJeAicsAVWc2iXTBdNBQ6SDARS78YTQEzqf55+JxUfxOAODxOwvTfBuHUychXBoA9r334Tu9O2IG0f5fHy8PTfxCMg7CPPsRahwgA1DTJ4FTzClc2rBGehf1JE6AzqOzkH041wNQWECqiKeBKUuw6mz0d17N8J1m5E7cwpzH95+whfvD/QSWO0SUAWmAnOvH6RzwxnBV1z7z7o3sJHBOkXlwaEYA04RklEIK4wdUF2Arq5BbuMutO78DrpH70DSmOFzsmJHDZCnocISGNkPiuLqM+DXRtyYRpJ0OLXIBKOFvWwwqEsRhwa0QsNXQH4YurSOP5u9lOIYuof/Bbq6HuGaXdBhDo2vv2y131t//V4CjykBVZg616i7aLtVNqH1MBwAHVCjj1HecYUaLIxA6iXIoCBNHo1bHL8zs6+yFuVLX4v6TV9APL+Hd/iYsgmcNqT3FcQQkPJSjQEZgfaMhArMFaCswwKzBbm2gCaZ0BQTFXA2glqYEf9AVzfzKksXvQntu29Ed+Y2qOIo05UJzGx968rHFIA/wEtgNUtAFdeRAaAv2fHZDCT0s9l1abcnhiABhfSzrRKk9B3t4pQl4JSegH+8S1OZMDH7iqMoP/VKdH5zB9p7vsupQZ5jRjG+GWhojQz7HFR9yOeREcZkbJIWgYTUT6ArGQMz1IANUb6M3MTTEdcfRDjxVOSmdqHz8M8RL+yHLlN4UkYwvg1nr+ZoAAAQ/klEQVSN6165mu+xv3YvgUeVgCquO4c9AGsEjP4bkyDIANfxU6EQ8wAUNLH/uErQ5AApn0+zRhtHoCsTcjzt0txghOaWFZHf8jzO6XceugXdQ7ey18AdSWhXtx/PbEJhHxKxiI0JlyTTv4BTh1SIlJKOkCA3ej6SmMA/BV2chCqNMZWZfRmiIueqCGqb0Ln5Kv8YeAl4CfRJQBXXnpPIzm8afpqfJRywpsGEB6Sw/AdxGqSO2IQKvPmXuC6AMwimjJj/TgqcryAor0e47lLoYgXdQ3cjbh6W8IFYgdSQhJiBtq8A1yF0DeOQvAoKG6g5aYjO9F3GSJC3kCAY3AwkdDxFDdK1iHsP6Byi+QdM2FJEbkChdfMX/EPgJeAlYLf84rodPR6AYeBKYY81AiYkcKUmBoMYetY4SA6fmX30bir3pbJfbiWuTfcgAv6oYegUwuEzGeyL6vvMOWjnp6KiGHFnBkl7ThiD9Bp5E3zuHPclDEfPRkyTTrt14QY0jiBJqL5A5p0Ftc3sdYgHESBqHBQzlRCWkKDwlMvR+fEnET3sW5Z7TVjdElDFtTuECWj2cskEKFFK87IBCXrDgj6jwG+jLwL4ePQ4MQPN9JHSEGcAEq1lXDEZAeovWF7Lu7oNLTgkMJkCIhlJIZG499kaiV08LjUHTGEOkTSJqTgjRUycRkwQVNazERKSEx0X8N9Tg0PGISwhGN6O/NaLUb/udYhn96/up8Ff/aqTgAkBzE6exuJZOJA5+Jmzn+36RPgRwLA/YLD2gJSUUHu2J5xSoJ4AgKrQFKJhrj0gReQOQ+QxUBowLHA2gfQ+rh9lPgAVKHWO3C4gIacHq9xchJmKeepTOIC4OY2keQQJFRO1F6BLY4YvkJfBJzpEXH8EceeoCRHIIyFqclHKkQs1BINTUMEc6l9/y6p7GPwFrz4JiAdgddvW7KcvOO69peHyS2lwIEdaKhFlDqznQMenToQ9D3nxFaELUxqRjEOujKC6DrqyTpQ6T9OIqqyYujYGXSHvQSNukYtPFYUdNG//EtOLuRehASrIK9CVScRcxkxzCw8D7XnhGhCTMVcy5QuRhAzdulQjkuHJSSkyrUX6IERQlQkUz30O5v/qGavvqfBXvGokoIprzzaDQUSxLSDo7uhWGrKLG8W20D1X7qasAeMRZEaB3puCjCmISOyiPGcLCLTjUWMl6iQ0LOlBChGIJ0A/c1Yghi5PIly3g3GFhOoPAo3u/rsQzRDPYFrwCDIolUkE1TWSOaDraU5z8RE3JWVgkTCFEKCaBzIgVLNA/wg/IOXvNBEvHpTiJ6URDm5FOLUTuQ2b0d39d1j82vtXzcPhL3TlSyDzAOyub7ZUgwT8Fgmk8YKTxnNBwcxY2JNwZsCSjawiktJSJ6CwCCovJs+AwwCK2alAiFqVG6+DvunqRoQT50IViEUYMuYQzx2AKg0hadJkY4ovqCLRti+jISVlxPV5oNMy048VVNGAlDmDDxAOQram3WKyUTz/CGJqaEIcBPrc8hiC0a0IxjcgqA4iaTbR+M670X3w5pX/lPgrXLES6DMA1gswJKAsNngUAWSuvXuA9RL6X+PZgjyGzFYMUltxagcwajoOERMwRjiyDdHCw/J28hoofmejQDs3UZFrCEd3IhhaL/0CiEvQaQDtBlOKabpxUj/EGIAenIKujSMYHIEeHkEwPITOQ3sQHaHMQFYGwS3Mux2o8gDC8XU87bh74Dfo7PuJpCnJI8mV2UtRlWEEQ5PQg8NI6nUsXvv8FfuA+Atb2RJQpbU7mAfg1gKlgF22yadSSDMCpJhp7G90tSczcBycwLxkowdSfC45JnYgjyY08wPIQCgi9gwagyGZSi4VNlRk7htQHIPmUuE10OUh8Qpo7kA+j6TTQdJaRNyY5TmG6LaFScidiSgcaCOcPBdBdRTBxCS6hx9BsjCTkZvo8yuDCNdNQVcoUxEjoRTl/ALio9MCNFI9BH1Ouwm0m2h8+83ihfgvL4FlIgHBAFJQTzyAjBnYg/BlxQFpmCCeQor4p8NBjAfhAIHSEFTwAN71a+uhuSFI0+TpDW5A8bhdDw8TCaGLQ6YvATEMpYEpx/emazGl+4IqTTIuANSlmH4f3c5eQTC0Ebo0iM7+O9PWZjTfIJ7dY9qWSVDC3ZAGppBQJsKEHtwSzdYndBqIu4sIiiM8NyE3tQPRUeqHQF5LxOcORjciOXoLFr/7sWVy+/0yV7sEjAFws3jOtp8R9R30r8ex70n/9QrT1BP0gIWmT0CJ0n/r0Jm+N6shMB2GFPUedE5kmYEMCJYGhWZMBUiWKUi7MOX6KXVYHjegoQkdCiNm6nGbKxO5CtEyFKmsmTwCqjmIE8Rxk1OJ5FXw7EOCFalK0jZI5fVFpp2Z5TgkDFaG4xea8uhhzjosfuf1q/258te/TCSgimsoC9CTszNL7/P/XWNgSodT2u5xFNaGEVxUxKGBsSFBgHB0B6IjROcV/oAlFlPfP676S9mFbooxK1RCQGCi8VQIE2BwkdiCmnsSappgTN4DGwvmInNjUjYihP5T9oG8CEorEupPTU6oApE8huokswiZRGRIRWmhE4UmNsXIwCAZHCl3ZqwiSZAb3IXiOf8Gs1+9bJk8An6Zq1kCqrhme+K68RZxz4TSG8sLMGdye/Zn8aJZCdLafXOCtNDH/F2HFVF5UlAm9diIQ5SfSUJ9d8TNSMj5peqQD6b0HfGLTKWieANEAw5kVgG58+05LmCSAaVkiQKhJlPtQqeOuDWTxibMD6BMYWkYmnoXkkEyIQl/crfJ3Yy4WKkPByGjUhg/H6UtV2Lu/1yxmp8rf+3LRAKqNHmW0SgXBzQqaHftVNGPRQUfDTA8ppCIzkH5fu4b6BgAtgApuUDEZoyFvJwuz9gKuwaTzydFdL6sp8FLpqpFIgbxOZVwCOh8bBgiCQniLqLmnHQe5g7FOckoGLuXXjH9jdbN/yjscKwfvddWRyqNgZ3vx8JNb14mj4Bf5mqWgCpObjca5hT/WDDPbMfWhU/9+FRi/QahDz/okaySYh6aEWjYeikKl1mLnmxEPzZpgcTMRTBhgAwh6E1l9KzRISqF1JRUlJdCBTIEcWvBTEAynZHIEyEvwUEjeq6UYxaDVPASpOCJiU06xPBl12Lm731qcDUr1nK5dlWa3M6RuPXqU2W3bbiYHejAck6RUGYQMj6AHOr+bvnApqUXTxgyTUKdrMAxH+EigZZN2Pea6DHF/4anbI2AuaBeLyTLWUrbMapYJLZhiMjMQkyzFBQq0Cm1KYpyNnvRe7sQ8wl0HGEQ3Fq9jIELP4LZG1+zXJ4Bv85VLAFjAHqJPy5w58qmBytwd9jj8AXcSD7tLkQ5fEvHPWY7P56RcV2DHkff7UKQxeiZBvdlJ4x3Y/qKMwBIa9YBAhp5vnAkPTnbN8IVuEW5MBcN6JAZGjY45HWYTAFHI9SvgBqeVlCYfAEad3xqFT9W/tKXiwRUafJM096Di4CdxqD0m5PKM9O6MkhQAL9ezkB22S5wlyoRKR53B3b4Bfyj+VxrA5wwP3X3My++vxbJAHsSDnDqjrIJtqzZLMmuhxWbuAbGbSfFjakpSSTNSBi0tLgCs4ol7Wj7H4i3YXELa2diaGqKmitCF2uID94rxUb+y0vgNJeAKk2cmaQ7tBv1Okh/XwawJ02XXZ9bKWRPZNx/UiTWz8BMG3KkYi0K77SZmy5H9JoRmT3YG+rL3k7hRUZISqnGpmmJmDY5m+bd37Qz4+/E/2+kqUj5WEtwMsCgsULiQFhWImEEBCFQNoOmq1H6sYywshadB//pNL/tfnleAsa5LU5u4zSgaEBvE5CebN+j5OblXY7ypdu9VVabUTAqaHf/1OPv02j3/ce5S5kHkpkITseZ6cRiNkyD0r73axp9blN31FCEsgJMD5ampuLR2Lpny0wkRafehYI1SGgQsMtPLcxiHpNGRYwVBPkKSlMvw+JtH/fPl5fAspCAKk085TjQWjYToNcbz0KCLN3W+9qxZcSZglviUG8BsbFEzsaeKrlJAx4ryQx04J/MTm6ziZT/z0BNY9eIG2Bdd3opV2QF5mpDmmxMjEIH3JO+BqaBCRkAamnOxotKmCscZnTrR015sUZQqCIo1BAduHNZ3Hi/SC8BVp3SxLY+A2Bc6mMqfazAyG3mWSJmi5SiIJf5l6l0v3LLRx3rMfSxBU00wbu5WUcWg/feOMvCy14lb0RQfN6ZC2UkFNNz/l78A67/Jy8hkpHnrmGw3ANeJ2MAFDKQASCOALVGL4I8ic78I0I0Qub+l9dfgcXb/9I/WV4Cy0YCqjSxlRCzY+l3PXw8sxuS4ru8uKyfN1+wBd7s1T9ataBbFJS1FOsrN3Abj7huiFiQzNFI+xnKH3SxysQee96Aho4Yt15GjlN5cYik22a3PjZ0396uRvYKxIpQbM/eS1hAQGh/voj2zH4kUVPsSWmQPYCB7f8Z0z/8o2Vz8/1CvQRUaXxrRr51NVZ862wL5zr+LDOQ5cNNzt9SdC3wZnsAHkfGNs2YqlmKHxrQz8kGiI3JSo8z1bTtxxyegekKJHUAQtCh1BzXAnTlNdrJ+Wd2dMwgUkNJZm/g2NwGx/c0PZlShkQh7syaKkA6RVhAfnCtdCHuBGjvv8k/VV4Cy0YCqjSxJfMA0lSb4xGY4R82Rcbf08Shu1PKtuxm8jLAzUbX4oZnEXyG86cIv0kL2ty7xPI2O2AW2MMhyNZKwFxENN40OqEhJjK+jME6cvn5w8mPoQYjtohHIY5aPeuSowRLCKhHoQ6RG97ChUSN/Vk7ccoqFMeegqC0CfW7v7JsbrxfqJdA/PQ3QpXGtxjtylJllueesuFsr0DK15tmHY8qPkbkTecfLtU1R1pev9N9xPIIUnDQdvi02QgXnUizB45XYvAE8dOphZhMLhaSDlF9SfkVotYCg3b9XykfgK6L6MkWJzCEIbt2cu/D8gjyQxdj/oH/bTAPyQYURjcjLG9DfvhSzP74Hf6p8hI4rSUQ/6u3IVk4Ysb0RVDlsS3SEcj9cuNqTn8Z48CtvNy0nuyTmZZTukxAxDQVR0BZ//kfTUSWedfz90xxM7yg74Qm3KDy3Ww1tPsT1z9B3F7gM6YIRnoQ4QFEChLyD2cFUu9BQIiACoZ0gOrm16K+9xvoLByWbGkChLVxFIfP4w7FUDks3vXF0/rm+8WtZgkoRE+7EsnM3kwXaH9mA2BxtVSvZBdnpXlU5e3diYWMQ226TRhgPQU7NNSeLN3l+/J+7Lebc/b0KHMBAWH4WSPDbzEcBjf3L4quocM85/i5rt8p7JHHQD6LDACdIzaEnuwRMQAgof65EsLyKNqze5F0WmmgU1l7AQ9IzVfPQ9w5goVffW41P2H+2k9TCcQv/CDih38upfP8nJs+GdQWvzx2hk2OpVRY3ml1b5MQfo01pnfHT5WJEwVa8AHrQgv3Luv6c1xj8tvcAxv7W2PjFP0wocfSka1+Z94Cue0U13N+n5F+x8rZa+A1U2GQAQntup1LJA+gOHEhWkfvRFSfSbmJ+YG1yNU2ICisRxzNIlfbhdlbP3SaPgJ+WatVAtEz3oL46G4oam9nOS/0nf51mpkBcHfFtI+/3ShdnXd3z9S376sYtMxCRcrnKLhVvFRP+70IWx54bLzecwP7bYah6DooBnRQEN6eQfatA5DVO9hcosn107HECDTzDum95EEExQHE1Ca8RdOMrUECKusu4XmEucq5WNz7LaAxi5j6EfovL4HTQQL5ErpPfwuSg78CGtTwJoZS0oOTvQDyjP//hO7/B5+Yz9qqp53jAAAAAElFTkSuQmCC",
                    "textureCubeMapFace": null,
                    "textureLayer": 0
                }
            ],
            "FrameBuffer": null
        }
    },
    "endTime": 1732773587996.6,
    "frameMemory": {
        "Buffer": 0,
        "Program": 0,
        "Renderbuffer": 0,
        "Texture2d": 0,
        "Texture3d": 0
    },
    "initState": {
        "AlignmentState": {
            "PACK_ALIGNMENT": 4,
            "PACK_ROW_LENGTH": 0,
            "PACK_SKIP_PIXELS": 0,
            "PACK_SKIP_ROWS": 0,
            "UNPACK_ALIGNMENT": 4,
            "UNPACK_COLORSPACE_CONVERSION_WEBGL": "BROWSER_DEFAULT_WEBGL",
            "UNPACK_FLIP_Y_WEBGL": false,
            "UNPACK_IMAGE_HEIGHT": 0,
            "UNPACK_PREMULTIPLY_ALPHA_WEBGL": false,
            "UNPACK_SKIP_IMAGES": 0,
            "UNPACK_SKIP_PIXELS": 0,
            "UNPACK_SKIP_ROWS": 0
        },
        "BlendState": {
            "BLEND": false,
            "BLEND_COLOR": [
                0,
                0,
                0,
                0
            ],
            "BLEND_DST_ALPHA": "ZERO",
            "BLEND_DST_RGB": "ZERO",
            "BLEND_EQUATION_ALPHA": "FUNC_ADD",
            "BLEND_EQUATION_RGB": "FUNC_ADD",
            "BLEND_SRC_ALPHA": "ONE",
            "BLEND_SRC_RGB": "ONE"
        },
        "ClearState": {
            "COLOR_CLEAR_VALUE": [
                0.0470588244497776,
                0.05882352963089943,
                0.08627451211214066,
                1
            ],
            "DEPTH_CLEAR_VALUE": 1,
            "STENCIL_CLEAR_VALUE": 0
        },
        "ColorState": {
            "COLOR_WRITEMASK": [
                true,
                true,
                true,
                true
            ]
        },
        "CoverageState": {
            "SAMPLE_ALPHA_TO_COVERAGE": false,
            "SAMPLE_COVERAGE": false,
            "SAMPLE_COVERAGE_INVERT": false,
            "SAMPLE_COVERAGE_VALUE": 1
        },
        "CullState": {
            "CULL_FACE": true,
            "CULL_FACE_MODE": "BACK"
        },
        "DepthState": {
            "DEPTH_FUNC": "LEQUAL",
            "DEPTH_RANGE": [
                0,
                1
            ],
            "DEPTH_TEST": true,
            "DEPTH_WRITEMASK": true
        },
        "DrawState": {
            "DITHER": true,
            "FRAGMENT_SHADER_DERIVATIVE_HINT": 4352,
            "FRAGMENT_SHADER_DERIVATIVE_HINT_OES": "Extension OES_standard_derivatives is unavailable.",
            "FRONT_FACE": "CCW",
            "RASTERIZER_DISCARD": false,
            "VIEWPORT": [
                0,
                0,
                1745,
                870
            ]
        },
        "MipmapHintState": {
            "GENERATE_MIPMAP_HINT": 4352
        },
        "PolygonOffsetState": {
            "POLYGON_OFFSET_FACTOR": 0,
            "POLYGON_OFFSET_FILL": false,
            "POLYGON_OFFSET_UNITS": 0
        },
        "ScissorState": {
            "SCISSOR_BOX": [
                0,
                0,
                300,
                150
            ],
            "SCISSOR_TEST": false
        },
        "StencilState": {
            "STENCIL_BACK_FAIL": "KEEP",
            "STENCIL_BACK_FUNC": "ALWAYS",
            "STENCIL_BACK_PASS_DEPTH_FAIL": "KEEP",
            "STENCIL_BACK_PASS_DEPTH_PASS": "KEEP",
            "STENCIL_BACK_REF": 0,
            "STENCIL_BACK_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
            "STENCIL_BACK_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)",
            "STENCIL_BITS": "8",
            "STENCIL_FAIL": "KEEP",
            "STENCIL_FUNC": "ALWAYS",
            "STENCIL_PASS_DEPTH_FAIL": "KEEP",
            "STENCIL_PASS_DEPTH_PASS": "KEEP",
            "STENCIL_REF": 0,
            "STENCIL_TEST": false,
            "STENCIL_VALUE_MASK": "2147483647 (0b1111111111111111111111111111111)",
            "STENCIL_WRITEMASK": "2147483647 (0b1111111111111111111111111111111)"
        },
        "VisualState": {
            "Attachments": [
                {
                    "attachmentName": "Canvas COLOR_ATTACHMENT",
                    "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAB/CAYAAAAAcRzGAAAAAXNSR0IArs4c6QAAAylJREFUeF7t1AERAAAIAjHpX9ogPxswOXaOAIGswLLJBSdA4AyAEhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAsYADCzxedgAHQAQJhAQMQfr7oBAyADhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAsYADCzxedgAHQAQJhAQMQfr7oBAyADhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAsYADCzxedgAHQAQJhAQMQfr7oBAyADhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAsYADCzxedgAHQAQJhAQMQfr7oBAyADhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAsYADCzxedgAHQAQJhAQMQfr7oBAyADhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAsYADCzxedgAHQAQJhAQMQfr7oBAyADhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAsYADCzxedgAHQAQJhAQMQfr7oBAyADhAICxiA8PNFJ2AAdIBAWMAAhJ8vOgEDoAMEwgIGIPx80QkYAB0gEBYwAOHni07AAOgAgbCAAQg/X3QCBkAHCIQFDED4+aITMAA6QCAs8CPOAIDeEgbfAAAAAElFTkSuQmCC",
                    "textureCubeMapFace": null,
                    "textureLayer": 0
                }
            ],
            "FrameBuffer": null
        }
    },
    "listenCommandsEndTime": 1732773587977.8,
    "listenCommandsStartTime": 1732773587338.9,
    "memory": {
        "Buffer": {
            "0": 144,
            "1": 1674064,
            "2": 1914040,
            "3": 2870400
        },
        "Program": {
            "0": 20849,
            "1": 127897,
            "2": 264241,
            "3": 337424
        },
        "Renderbuffer": {
            "1": 6072600
        },
        "Texture2d": {
            "0": 28,
            "1": 12145228
        },
        "Texture3d": {}
    },
    "startTime": 1732773587298.3
}